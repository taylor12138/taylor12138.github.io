{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://taylor12138.github.io","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-05-04T06:35:25.450Z","comments":true,"path":"about/index.html","permalink":"https://taylor12138.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-03T17:17:32.000Z","updated":"2020-05-04T06:33:28.454Z","comments":true,"path":"tags/index.html","permalink":"https://taylor12138.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-03T17:20:07.000Z","updated":"2020-05-04T06:33:11.259Z","comments":true,"path":"categories/index.html","permalink":"https://taylor12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-05-03T17:22:42.000Z","updated":"2020-05-04T06:34:25.403Z","comments":true,"path":"friends/index.html","permalink":"https://taylor12138.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-05-03T17:21:52.000Z","updated":"2020-05-04T06:33:52.664Z","comments":true,"path":"contact/index.html","permalink":"https://taylor12138.github.io/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"personnel note","slug":"personnel note","date":"2020-05-14T11:30:26.797Z","updated":"2020-05-14T15:14:30.559Z","comments":true,"path":"2020/05/14/personnel-note/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/personnel-note/","excerpt":"","text":"小基础floor[x] 小于等于x的最大值整数（向下取整） ceil[x] 大于等于x的最小整数（向上取整） int 32位二进制 第一个是符号位正数为0，负数为1，后面是数值位 -2^31——2^31-1 long long 64位二进制 double 64位二进制 （float别用了，太垃圾了） ~ 取反 &gt;&gt;右移 &lt;&lt;左移 枚举一一举例，不重复 先列举出（求第x数到第y数的和，先求数组所有和，直接减），（求四个点的位置，并且四个点组成正方形，先求四个点中的两个点，），（求一排树数量，部份树被整段移走（可能重叠），直接标记1，移走的树部分-1） 取尺法分L，R两个指针，求数组区域&lt;=s的连续数组的个数，&lt;s R右移， &gt;=s L右移 使用前提： 1.能够维护一个区间，保证这个区间能够获得答案。 2.维护的具体操作可以左边移动一位、右边移动一位。 3.区间的变化是连续的而不是跳跃的。问题1就是比较跳跃的，双指针比较好，问题2不能跳跃。 贪心算法局部最优解，然后发现局部最优=整体最优解 桶排序列出数组，讲数据对比，有则让数组对应的数据+1，然后依次输出， 这里有位大佬我觉得写得很好，可以看一下 https://www.cnblogs.com/bqwzx/p/11029264.html","categories":[],"tags":[],"author":"Hello"},{"title":"字典排序","slug":"字典排序","date":"2020-05-14T11:30:26.797Z","updated":"2020-05-14T14:35:31.248Z","comments":true,"path":"2020/05/14/zi-dian-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/zi-dian-pai-xu/","excerpt":"","text":"字典排序实现“ 1 2 3 ， 1 3 2 ， 2 1 3 ， 2 3 1 ， 3 1 2 ， 3 2 1 ”的序列排序方法 代码实现如下 #include #define swap(a,b) {int temp=a;a=b;b=temp;} //交换a，b值 void sort(int arr[],int start,int end)//冒泡排序，从start到end的排序，使用时注意是数组的下标，如数组下标0-3排序，sort（arr,0,3） { int i,j; for(i=0;iarr[a]) //这是字典排序第二步，获取arr[b]的值 { b=j1; break; } } swap(arr[a],arr[b]); //这是第三步 sort(arr,a+1,n-1); //这是第四步 } } int main() { int arr[]={1,2,4,3}; permutation(arr,4); return 0; } 总结得出字典排序算法四步法： 字典排序：第一步：从右至左找第一个左邻小于右邻的数，记下位置i，值list[a]第二部：从右边往左找第一个右边大于list[a]的第一个值，记下位置j，值list[b]第三步：交换list[a]和list[b]的值第四步：将i以后的元素重新按从小到大的顺序排列 举例：125643的下一个字典序列第一步：右边值大于左边的3&lt;4,4&lt;6,6&gt;5,则i=2，list[a]=5第二步：从右往左找出第一个右边大于list[a]=5的值，找到6&gt;5,j=3;list[b]=6;第三步：交换list[a]和list[b]的值，序列125643-&gt;126543第四步：将位置2以后的元素重新排序,126543-&gt;126345;结束： 126345即125643的下一个序列————————————————版权声明：本文为CSDN博主「Hi,Mr.Wang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_34672688/article/details/79557380","categories":[],"tags":[],"author":"Hello"},{"title":"C++string转换int，double","slug":"C++string转换int，double","date":"2020-05-13T09:10:17.923Z","updated":"2020-05-13T09:16:21.549Z","comments":true,"path":"2020/05/13/c-string-zhuan-huan-int-double/","link":"","permalink":"https://taylor12138.github.io/2020/05/13/c-string-zhuan-huan-int-double/","excerpt":"","text":"头文件#include &quot;iostream&quot; #include &quot;stdlib.h&quot; #include &quot;cstdlib&quot; #include &quot;string&quot;使用cstdlib中c_str()使其转换成char，再转int和float/double C 库函数 int atoi(const char *str) 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。 C 库函数 double atof(const char *str) 把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 double price=atof(new_str[2].c_str()); int count=atoi(new_str[3].c_str());;","categories":[],"tags":[],"author":"Hello"},{"title":"emmet语法","slug":"emmet语法","date":"2020-05-09T16:00:00.000Z","updated":"2020-05-10T10:19:56.809Z","comments":true,"path":"2020/05/10/emmet-yu-fa/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/emmet-yu-fa/","excerpt":"","text":"Emmet语法插件于市面上大多前端编译软件，如VScode所带有的，便于快速写html和CSSh5想要生成多个标签：div*10，再回车（或者tab），即可生成10个div标签。 生成父子关系标签：div&gt;span,再回车（或者tab），即可生成包含span标签的div标签。 生成兄弟关系标签：div+span,再回车（或者tab）。 输入：.nav 直接生成一个class=“nav”的div标签。(默认div) 输入：#nav 直接生成一个id=“nav”的div标签。 输入：p.nav 直接生成一个class=“nav”的p标签。 输入：.nav$*5 直接生成5个class=“nav1”,class=“nav2”…..的div标签。($是自增符号) 输入：div{前端真好玩}*5 直接生成5个&lt;div&gt; 前端真好玩 &lt;/div&gt; CSS样式内输入：tac 直接生成text-align: center; 其他语法缩写同样类似，诸如w100—&gt;width: 100 格式化直接鼠标右键，格式化文档，即可直接让文档变整齐。 （或者想要每次保存后自动格式化，需要在首页—首选项—设置—搜索emmet.include,在setting.json下的用户，添加 “editor.formatOnType”: true, “editor.formatOnSave”: true 即可）","categories":[],"tags":[],"author":"Hello"},{"title":"CSS样式","slug":"CSS样式","date":"2020-05-09T16:00:00.000Z","updated":"2020-05-13T17:14:35.692Z","comments":true,"path":"2020/05/10/css-yang-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/css-yang-shi/","excerpt":"","text":"声明：可以使用chrome的F12浏览学习别人的样式并且调试你的代码引入CSS&lt;link rel=\"stylesheet\" href=\"css文件路径\"> 1.主要定义//是类型选择,标签选择器 元素（标签） { } //选择所有元素 * { } //类的选择 选择多个类可以 &lt;div class=\"类1 类2\">&lt;/div> .class(类名) { } //id的选择,有点类似class，只能调用一次，别人切勿使用 #(id名) { } //复合，后代选择器 元素1（可以是类名） 元素2（可以是类名） { } //只选择亲儿子，孙子不选 元素1（可以是类名）>元素2（可以是类名） { } //并集选择器，多个统一 元素1, 元素2{ } 文字font-size: 12px //12像素大小文字 谷歌默认16px font-weight: xxx //字体加粗 text-align: center //文字水平居中对齐 text-indent: 10px //文本首行缩进,最好使用em，如text-indent: 2em,em是相对单位，当前1个文字元素的大小 text-decoration: none//取消下划线 line-height: 26px //行间距，用QQ截图可以偷偷测量 背景background-color //背景颜色 background: rgba(red（数值）,green(数值),blue（数值），透明度（0-1）) //背景颜色 透明化 background-image: url(地址)//背景图片，常见于标志，logo或者超大背景图片，有点是便于控制位置 baackground-repeat: no-repeat//背景平铺，默认为平铺，可以改成取消平铺 background-position: x y//背景图片的位置 ，可以使用方位名词，前后顺序可可以不一样top，center ，botton，left等（只写一个另外一个默认居中）。也可以使用精确单位x轴长度，y轴长度，（只写一个另外一个默认居中） background-attachment: scroll||fixed//背景图像随对象内容滚动||背景图像固定 复合：background: 颜色 图片地址 平铺 图像滚动 图片位置 2.伪类选择器//a超链接类 a:link 选择所有未访问的链接 a:visited 选择所有已被访问的链接 a:hover 常用，选择鼠标指向的链接 a:ative 鼠标按下未弹起的链接 //如果全部都写，请按照LVHA的顺序写 //input类，把获得光标的inut选取出来改写CSS input:focus 3.行块转换（块元素和行元素相互转换）display:block //转块元素 display:inline //转行内元素 display: inline-block //转行内块 //使文字垂直居中 让文字行高=盒子的行高 行高&gt;盒子高度偏下，&lt;偏上 line-height: 盒子高度","categories":[],"tags":[],"author":"Hello"},{"title":"循环队列","slug":"循环队列","date":"2020-05-09T11:51:20.811Z","updated":"2020-05-09T12:26:39.350Z","comments":true,"path":"2020/05/09/xun-huan-dui-lie/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/xun-huan-dui-lie/","excerpt":"","text":"循环队列顺序定义typedef struct { QElemType *base;//初始化时动态分配存储空间 int front;//头指针 int rear;//尾指针 } SqQueue; 初始化//算法3.11 循环队列的初始化 Status InitQueue(SqQueue &Q) {//构造一个空队列Q Q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间 if (!Q.base) exit(OVERFLOW); //存储分配失败 Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空 return OK; } 求队列长度//算法3.12 求循环队列的长度 int QueueLength(SqQueue Q) {//返回Q的元素个数，即队列的长度 return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE; } 入队和出队（防止假溢出）（出头front，入尾rear）（rear无元素，front有元素）//算法3.13 循环队列的入队 Status EnQueue(SqQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满 return ERROR; Q.base[Q.rear] = e; //新元素插入队尾 Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1 return OK; } //算法3.14 循环队列的出队 Status DeQueue(SqQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 if (Q.front == Q.rear) return ERROR; //队空 e = Q.base[Q.front]; //保存队头元素 Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1 return OK; } 链队定义（还是像极了单链表，可知X链的形式一般都是单链表拓展）typedef struct QNode { QElemType data; struct QNode *next; } QNode, *QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 } LinkQueue; 链队的初始化Status InitQueue(LinkQueue &Q) {//构造一个空队列Q Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点 Q.front->next = NULL; //头结点的指针域置空 return OK; } 入队和出队（队头front无元素）//算法3.17 链队的入队 Status EnQueue(LinkQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 QueuePtr p; p = new QNode; //为入队元素分配结点空间，用指针p指向 p->data = e; //将新结点数据域置为e p->next = NULL; Q.rear->next = p; //将新结点插入到队尾 Q.rear = p; //修改队尾指针 return OK; } //算法3.18 链队的出队 Status DeQueue(LinkQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 QueuePtr p; if (Q.front == Q.rear) return ERROR; //若队列空，则返回ERROR p = Q.front->next; //p指向队头元素 e = p->data; //e保存队头元素的值 Q.front->next = p->next; //修改头指针 if (Q.rear == p) Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点 delete p; //释放原队头元素的空间 return OK; } 取队头元素//算法3.19 取链队的队头元素 SElemType GetHead(LinkQueue Q) {//返回Q的队头元素，不修改队头指针 if (Q.front != Q.rear) //队列非空 return Q.front->next->data; //返回队头元素的值，队头指针不变 }","categories":[],"tags":[],"author":"Hello"},{"title":"栈","slug":"栈","date":"2020-05-09T11:14:09.081Z","updated":"2020-05-09T12:32:24.263Z","comments":true,"path":"2020/05/09/zhan/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/zhan/","excerpt":"","text":"顺序栈定义typedef struct { SElemType *base;//栈底指针 SElemType *top;//栈顶指针 int stacksize;//栈可用的最大容量 } SqStack; 初始化Status InitStack(SqStack &S) { //构造一个空栈S S.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间 if (!S.base) exit(OVERFLOW); //存储分配失败 S.top = S.base; //top初始为base，空栈 S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE return OK; } 入栈和出栈（top无元素）//算法3.2 顺序栈的入栈 Status Push(SqStack &S, SElemType e) { // 插入元素e为新的栈顶元素 if (S.top - S.base == S.stacksize) return ERROR; //栈满 *(S.top++) = e; //元素e压入栈顶，栈顶指针加1 return OK; } //算法3.3 顺序栈的出栈 Status Pop(SqStack &S, SElemType &e) { //删除S的栈顶元素，用e返回其值 if (S.base == S.top) return ERROR;//栈空 e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e return OK; } 链栈定义，有点像链表typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack;初始化，无需链表的”头结点“Status InitStack(LinkStack &amp;S) { // 构造一个空栈 S，栈顶指针置空 S = NULL; return OK; }入栈和出栈//算法3.6 链栈的入栈 Status Push(LinkStack &S, SElemType e) {//在栈顶插入元素e LinkStack p; p = new StackNode; //生成新结点 p->data = e; //将新结点数据域置为e p->next = S; //将新结点插入栈顶 S = p; //修改栈顶指针为p return OK; } //算法3.7 链栈的出栈 Status Pop(LinkStack &S, SElemType &e) {//删除S的栈顶元素，用e返回其值 LinkStack p; if (S == NULL) return ERROR; //栈空 e = S->data; //将栈顶元素赋给e p = S; //用p临时保存栈顶元素空间，以备释放 S = S->next; //修改栈顶指针 delete p; //释放原栈顶元素的空间 return OK; }","categories":[],"tags":[],"author":"Hello"},{"title":"双向链表","slug":"双向链表","date":"2020-05-07T11:15:31.827Z","updated":"2020-05-07T11:20:50.855Z","comments":true,"path":"2020/05/07/shuang-xiang-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shuang-xiang-lian-biao/","excerpt":"","text":"双向链表的定义typedef struct DuLNode{ ElemType data; struct DuLNode *prior; struct DuLNode *next; //前驱和后继 }DuLNode，*DuLinkList 插入顺序 s=data; s->prior=p->prior; p->prior->next=s; s->next=p; p->prior=s;","categories":[],"tags":[],"author":"Hello"},{"title":"单链表","slug":"单链表","date":"2020-05-07T10:10:22.778Z","updated":"2020-05-09T11:52:19.429Z","comments":true,"path":"2020/05/07/dan-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/dan-lian-biao/","excerpt":"","text":"如定义单链表结构体，注意引用单链表元素用” -&gt; “,因为是*LinkList，使用单链表用的是LinkListtypedef struct LNode { ElemType data; //结点的数据域 struct LNode *next; //结点的指针域 }LNode,*LinkList; //LinkList为指向结构体LNode的指针类型 前插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头 } }后插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p,r; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 r=L; //尾指针r指向头结点 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=NULL; r-&gt;next=p; r=p; } }单链表的初始化，它的头节点（为了处理方便，在第一个节点之前增加的结点）没有赋值Status InitList_L(LinkList &L){ //功能1---算法2.5 单链表的初始化 //构造一个空的单链表L L=new LNode; //生成新结点作为头结点，用头指针L指向头结点 L->next=NULL; //头结点的指针域置空 return OK; } 它不能像顺序表一样随机取值，所以需要一一查找ElemType FindList(LinkList &amp;L,int i,ElemType &amp;x){ LinkList p=L; for(int j=0;j&lt;i;j++){ if(!(p-&gt;next))return ERROR; p=p-&gt;next; } x=p-&gt;data; return OK; }查找，按值查找int GetElem(LinkList &L,int &i,ElemType e) { LinkList p=L; int j=1; while(p->next) { p=p->next; if(p->data==e){ //查找成功 i=j; return OK; } j++; } return ERROR; //循环至查找失败 } 单链表的插入Status ListInsert_L(LinkList &amp;L,int i,ElemType &amp;e){ //功能3---算法2.8 单链表的插入 //在带头结点的单链表L中第i个位置之前插入元素e int j; LinkList p,s; p=L;j=0; while(p &amp;&amp; j&lt;i-1){p=p-&gt;next;++j;} //寻找第i-1个结点 if(!p||j&gt;i-1) return ERROR; //i大于表长+1或者小于1 s=new LNode; //生成新结点s s-&gt;data=e; //将结点s的数据域置为e s-&gt;next=p-&gt;next; //将结点s插入L中 p-&gt;next=s; return OK; }删除指定序号数据元素Status ListDelete(LinkList &L,int i){ LinkList p=L; int j=1; while(p->next&&jnext; j++; } if(!(p->next)||j>i)return ERROR; LinkList q=p->next; p->next=q->next; delete q; return OK; }","categories":[],"tags":[],"author":"Hello"},{"title":"顺序表","slug":"顺序表","date":"2020-05-07T09:31:08.736Z","updated":"2020-05-10T07:06:27.805Z","comments":true,"path":"2020/05/07/shun-xu-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shun-xu-biao/","excerpt":"","text":"如定义s顺序表结构体，注意引用顺序表元素用” . “,因为是SqList不是*S’q’Listtypedef struct{ ElemType *elem; //存储空间的基地址 int length; //当前长度 }SqList; 顺序表的初始化Status InitList_Sq(SqList &L){ //功能1--算法2.1 顺序表的初始化 //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) return OVERFLOW; //存储分配失败，overflow为-2 L.length=0; //空表长度为0 return OK; } 查找Status LocateElem(SqList *L, ElemType e) //按元素值查找 { int i=0; while (ilength && L->elem[i]!=e) i++; //查找元素e if (i>=L->length) //未找到时返回0 return 0; else return i+1; //找到后返回其逻辑序号 顺序表的插入Status ListInsert_Sq(SqList &amp;L,int i,ElemType e){ //功能3--算法2.3 顺序表的插入 //在顺序表L中第i个位置之前插入新的元素e //i值的合法范围是1&lt;=i&lt;=L.length+1 if(i&lt;1 || i&gt;L.length+1) return ERROR; //i值不合法,error为0 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length; //表长增1 return OK; }删除数据元素bool ListDelete(SqList &L,int i) //删除数据元素 { int j; if (iL.length) //参数错误时返回false return false; for (j=i-1;j","categories":[],"tags":[],"author":"Hello"},{"title":"C++结构体初始化","slug":"C++结构体初始化","date":"2020-05-07T09:16:02.980Z","updated":"2020-05-07T09:31:02.136Z","comments":true,"path":"2020/05/07/c-jie-gou-ti-chu-shi-hua/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/c-jie-gou-ti-chu-shi-hua/","excerpt":"","text":"如定义药品结构体 typedef struct node{ //定义结构体 string name; float price; int count; float sale; int next; }Medicine; typedef struct{ //定义顺序表 Medicine r[MAX_Size+1]; int length; }SqList; 使用new的初始化 SqList *list_med=new SqList;","categories":[],"tags":[],"author":"Hello"},{"title":"C++求string数组元素个数","slug":"C++求String数组的元素个数","date":"2020-05-06T11:04:31.177Z","updated":"2020-05-06T11:44:46.247Z","comments":true,"path":"2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","link":"","permalink":"https://taylor12138.github.io/2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","excerpt":"","text":"不能使用str.length,这个求的是单个字符串的大小，可以使用以下求得到长度 sizeof(str)/sizeof(str[0])","categories":[],"tags":[],"author":"Hello"},{"title":"搞定了gitee了！！","slug":"搞定了gitee了！！","date":"2020-05-04T17:01:10.659Z","updated":"2020-05-05T17:02:45.166Z","comments":true,"path":"2020/05/05/gao-ding-liao-gitee-liao/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/gao-ding-liao-gitee-liao/","excerpt":"","text":"原来是个人邮箱的设置必须得是公开的，我一直是设置为private，搞得一直错，终于搞出来了，单独发一条blog来庆祝一下！！！！ 但是发现了gitee的一个缺点，每次部署完后都要去码云更新一次。。。","categories":[],"tags":[],"author":"Hello"},{"title":"HTML5的基本属性","slug":"HTML5的基本属性","date":"2020-05-04T16:25:58.368Z","updated":"2020-05-12T13:34:56.350Z","comments":true,"path":"2020/05/05/html5-de-ji-ben-shu-xing/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/html5-de-ji-ben-shu-xing/","excerpt":"","text":"1.基本标签介绍&lt;html&gt;&lt;/html&gt;``根标签 &lt;head&gt; &lt;/head&gt; 文档头部 &lt; title&gt; &lt;/title&gt; 文档标题 &lt;body&gt;&lt;/body&gt; 文档主体 2.在vscode里使用英文“！”可以直接生成基本结构ctrl+“+”可以放大（写代码）页面 &lt;!DOCTYPE html&gt; （） &lt;html lang=&quot;zh-CN&quot;&gt; (中文) &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;h1&gt;&lt;/h1&gt;---&lt;h6&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; &lt;br /&gt;&lt;strong&gt;&lt;/strong&gt;(字体加粗)&lt;del&gt;&lt;/del&gt;（字体删除线） 3.盒子：类似于view，用于布局&lt;div&gt;&lt;/div&gt; //大盒子，独占一整行 &lt;span&gt;&lt;/span&gt; //小盒子 4.img&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; height=&quot;&quot; width=&quot;&quot;&gt; //微信小程序是image alt为图片无法加载时显示的文字，title为鼠标移到图片上显示的文字提示, 但是对于height和width,一般只修改其中一个，另外一个就会跟着改变 src种绝对路径 \\ 相对路径 / 5.超链接&lt; a&gt;&lt;a href=&quot;&quot; target=&quot;&quot; &gt;文本或者图像&lt;/a&gt; 类似于微信小程序中的navigator, href用于指定目标的url，可打开内部，外部链接 target用于来链接打开方式，默认_self _blank为在新窗口打开 锚点链接：设置href=#名字，如&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;可以快速跳转到第二集的页面位置 ​ 在于目标位置标签里添加id=”two” 6.特殊字符空格：&amp;nbsp (因无法识别大于号和小于号) 小于号：&amp;lt 大于号：&amp;gt 7.表格（用于数据）&lt;table&gt; ​ &lt;tr&gt; ​ &lt;td&gt;单元格文字&lt;/td&gt;或者&lt;th&gt;&lt;/th&gt; ​ &lt;/tr&gt; &lt;/table&gt; table是表格，tr是行，td是单元格（th可充当表头单元格）。还可以加入&lt;thead&gt;和 &lt;tbody&gt;来帮助CSS区分表格结构 单元格合并使用colspan=”（列）想要合并的单元个数”或者rowspan=”（行）想要合并的单元个数”，再删除多余的td（或th） 8.列表（用于布局）无序列表（ul里只能放li标签，所以其他容器放li里面就可以）&lt;ul&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ul&gt; 有序列表(规则同无序)&lt;ol&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ol&gt; 自定义列表(同上)&lt;dl&gt; ​ &lt;dt&gt;名词1&lt;/dt&gt; ​ &lt;dd&gt;名词1解释1&lt;/dd ​ &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 9.表单（用于填写信息，用户注册）&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot; maxlength=&quot;&quot;&gt;&lt;/form&gt;表单域 url地址为处理表单数据的地址，method有get，post 表单元素&lt;input&gt;&lt;input type=&quot;属性值&quot; name=&quot;&quot; value=&quot;&quot; check=&quot;&quot;&gt;输入 type可以为text，password，button，reset（重置）submit（用于提交），radio（单选框，必须添加name才能使用），checkbox（复选框）等 科普：submit是button的一个特例，用于处理大量表单数据 value为输入框内的提示语||充当提交给后台的数据||显示的文字 check用于单选和复选的默认值 check=”checked” maxlength=“最大值” &lt;label for=&quot;sex&quot;&gt;男 &lt;/label&gt; label用于增加用户体验，点击范围内即可选中某input &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; label中的for对应input里的id 或者把input标签放在label里面也能达到同样的效果，此时不需要for和id 表单元素&lt;select&gt; 下拉列表&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;选项3&lt;/option&gt; //默认选中选项3 ... &lt;select&gt;表单元素&lt;textarea&gt; 文本域，可以写大量文字（个人介绍，评论）&lt;textarea&gt; 文字 &lt;/textarea&gt;10 元素分类块元素，独占一行，是一个容器或者盒子如 &lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt;等 但&lt;p&gt; &lt;h&gt; 不能内置块级元素，只能放文字行元素，不能设置宽高，只能容纳文本或者其他行内元素 &lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;span&gt;等 但是&lt;a&gt;不能再放&lt;a&gt; 特殊情况&lt;a&gt;可以转块级行内块元素，能在同一行，也能设置宽高 &lt;input/&gt; &lt;img/&gt; &lt;td&gt;行块的转换详情请看CSS里的《行块转换》h5标签推荐网址： http://www.w3school.com.cn/ http://developer.mozilla.org/zh-CN/","categories":[],"tags":[],"author":"Hello"},{"title":"主题与2d人物","slug":"主题与2d人物","date":"2020-05-03T16:50:47.307Z","updated":"2020-05-05T17:03:19.452Z","comments":true,"path":"2020/05/04/zhu-ti-yu-2d-ren-wu/","link":"","permalink":"https://taylor12138.github.io/2020/05/04/zhu-ti-yu-2d-ren-wu/","excerpt":"","text":"Start人物使用命令安装npm：npm uninstall hexo-helper-live2d npm install –save hexo-helper-live2d此时在blog/node_modeles下多出了一个“live2d-widget”下载动画model：这里是套用别人（大佬）的仓库https://github.com/xiazeyu/live2d-widget-models.git下载好后将packages里的所有文件拷贝到blog/node_modeles最后在win使用padnote _config.yml，把以下：live2d: enable: true pluginModelPath: assets/ model: use: live2d-widget-model-epsilon2_1 #模板目录，在node_modules里 display: position: right width: 150 height: 300 mobile: show: false #是否在手机进行显示 复制进去 再使用hexo clean g d进行部署 主题下载好了之后放入blog/themes里面（整个文件）再在win使用padnote _config.yml把theme: xx改成theme: (你要的主题名)最后部署","categories":[],"tags":[],"author":"Hello"},{"title":"困难的一天","slug":"困难的一天","date":"2020-05-03T15:00:48.806Z","updated":"2020-05-05T17:03:02.641Z","comments":true,"path":"2020/05/03/kun-nan-de-yi-tian/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/kun-nan-de-yi-tian/","excerpt":"","text":"difficult daynothing搞了一天，荒废了一天的宝贵五一假期时间，竟然还搞不好gitee的部署，我太菜了 但是至少弄好了ssh和主题，安慰一下把","categories":[],"tags":[],"author":"Hello"},{"title":"My First Blog","slug":"My First Blog","date":"2020-05-02T17:33:53.947Z","updated":"2020-05-05T17:02:29.455Z","comments":true,"path":"2020/05/03/my-first-blog/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/my-first-blog/","excerpt":"","text":"Quick Start打开win+R进入cmd，然后在正确目录下进入：cd source_post(指定blog下) 基本操作用typora修改完毕后，1.使用“hexo clean”进行清理（1.5.若是发生主题等修改后，要接上hexo g 来建立）2.接上“hexo s”即可进入网站查看（退出键位：control+C，y）（本地浏览）3.再次部署到远端：hexo d 关于主题1.可以使用git clone 网址.git themes\\新建目录名（或者使用码云gitee进行下载，然后复制到themes目录下）2.cd.. (回到blog目录下)notepad _config.yml把记事本里面的theme：xx修改成theme：主题目录名3.重新执行”基本操作” 参考文献 https://hexo.io/docs/one-command-deployment.html)","categories":[],"tags":[],"author":"Hello"},{"title":"hello-world","slug":"hello-world","date":"2020-04-30T16:00:00.000Z","updated":"2020-05-10T07:57:29.668Z","comments":true,"path":"2020/05/01/hello-world/","link":"","permalink":"https://taylor12138.github.io/2020/05/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"author":"Hello"}],"categories":[],"tags":[]}