{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://taylor12138.github.io","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-05-04T06:35:25.450Z","comments":true,"path":"about/index.html","permalink":"https://taylor12138.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-05-03T17:21:52.000Z","updated":"2020-05-04T06:33:52.664Z","comments":true,"path":"contact/index.html","permalink":"https://taylor12138.github.io/contact/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-03T17:20:07.000Z","updated":"2020-05-04T06:33:11.259Z","comments":true,"path":"categories/index.html","permalink":"https://taylor12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-03T17:17:32.000Z","updated":"2020-05-04T06:33:28.454Z","comments":true,"path":"tags/index.html","permalink":"https://taylor12138.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-05-03T17:22:42.000Z","updated":"2020-05-04T06:34:25.403Z","comments":true,"path":"friends/index.html","permalink":"https://taylor12138.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"循环队列","slug":"循环队列","date":"2020-05-09T11:51:20.811Z","updated":"2020-05-09T12:26:39.350Z","comments":true,"path":"2020/05/09/xun-huan-dui-lie/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/xun-huan-dui-lie/","excerpt":"","text":"循环队列顺序定义typedef struct { QElemType *base;//初始化时动态分配存储空间 int front;//头指针 int rear;//尾指针 } SqQueue; 初始化//算法3.11 循环队列的初始化 Status InitQueue(SqQueue &Q) {//构造一个空队列Q Q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间 if (!Q.base) exit(OVERFLOW); //存储分配失败 Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空 return OK; } 求队列长度//算法3.12 求循环队列的长度 int QueueLength(SqQueue Q) {//返回Q的元素个数，即队列的长度 return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE; } 入队和出队（防止假溢出）（出头front，入尾rear）（rear无元素，front有元素）//算法3.13 循环队列的入队 Status EnQueue(SqQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满 return ERROR; Q.base[Q.rear] = e; //新元素插入队尾 Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1 return OK; } //算法3.14 循环队列的出队 Status DeQueue(SqQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 if (Q.front == Q.rear) return ERROR; //队空 e = Q.base[Q.front]; //保存队头元素 Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1 return OK; } 链队定义（还是像极了单链表，可知X链的形式一般都是单链表拓展）typedef struct QNode { QElemType data; struct QNode *next; } QNode, *QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 } LinkQueue; 链队的初始化Status InitQueue(LinkQueue &Q) {//构造一个空队列Q Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点 Q.front->next = NULL; //头结点的指针域置空 return OK; } 入队和出队（队头front无元素）//算法3.17 链队的入队 Status EnQueue(LinkQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 QueuePtr p; p = new QNode; //为入队元素分配结点空间，用指针p指向 p->data = e; //将新结点数据域置为e p->next = NULL; Q.rear->next = p; //将新结点插入到队尾 Q.rear = p; //修改队尾指针 return OK; } //算法3.18 链队的出队 Status DeQueue(LinkQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 QueuePtr p; if (Q.front == Q.rear) return ERROR; //若队列空，则返回ERROR p = Q.front->next; //p指向队头元素 e = p->data; //e保存队头元素的值 Q.front->next = p->next; //修改头指针 if (Q.rear == p) Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点 delete p; //释放原队头元素的空间 return OK; } 取队头元素//算法3.19 取链队的队头元素 SElemType GetHead(LinkQueue Q) {//返回Q的队头元素，不修改队头指针 if (Q.front != Q.rear) //队列非空 return Q.front->next->data; //返回队头元素的值，队头指针不变 }","categories":[],"tags":[],"author":"Hello"},{"title":"栈","slug":"栈","date":"2020-05-09T11:14:09.081Z","updated":"2020-05-09T12:32:24.263Z","comments":true,"path":"2020/05/09/zhan/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/zhan/","excerpt":"","text":"顺序栈定义typedef struct { SElemType *base;//栈底指针 SElemType *top;//栈顶指针 int stacksize;//栈可用的最大容量 } SqStack; 初始化Status InitStack(SqStack &S) { //构造一个空栈S S.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间 if (!S.base) exit(OVERFLOW); //存储分配失败 S.top = S.base; //top初始为base，空栈 S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE return OK; } 入栈和出栈（top无元素）//算法3.2 顺序栈的入栈 Status Push(SqStack &S, SElemType e) { // 插入元素e为新的栈顶元素 if (S.top - S.base == S.stacksize) return ERROR; //栈满 *(S.top++) = e; //元素e压入栈顶，栈顶指针加1 return OK; } //算法3.3 顺序栈的出栈 Status Pop(SqStack &S, SElemType &e) { //删除S的栈顶元素，用e返回其值 if (S.base == S.top) return ERROR;//栈空 e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e return OK; } 链栈定义，有点像链表typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack;初始化，无需链表的”头结点“Status InitStack(LinkStack &amp;S) { // 构造一个空栈 S，栈顶指针置空 S = NULL; return OK; }入栈和出栈//算法3.6 链栈的入栈 Status Push(LinkStack &S, SElemType e) {//在栈顶插入元素e LinkStack p; p = new StackNode; //生成新结点 p->data = e; //将新结点数据域置为e p->next = S; //将新结点插入栈顶 S = p; //修改栈顶指针为p return OK; } //算法3.7 链栈的出栈 Status Pop(LinkStack &S, SElemType &e) {//删除S的栈顶元素，用e返回其值 LinkStack p; if (S == NULL) return ERROR; //栈空 e = S->data; //将栈顶元素赋给e p = S; //用p临时保存栈顶元素空间，以备释放 S = S->next; //修改栈顶指针 delete p; //释放原栈顶元素的空间 return OK; }","categories":[],"tags":[],"author":"Hello"},{"title":"CSS样式","slug":"CSS样式","date":"2020-05-07T16:51:50.598Z","updated":"2020-05-09T17:33:21.122Z","comments":true,"path":"2020/05/08/css-yang-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/08/css-yang-shi/","excerpt":"","text":"主要定义a { //是类型选择,标签选择器 } * { //选择所有元素 } .class(类名) { //类的选择 } 选择多个类可以 &lt;div class=&quot;类1 类2&quot;&gt;&lt;/div&gt; #(id名) { //id的选择,有点类似class，只能调用一次，别人切勿使用 }font-size: 12px //12像素大小文字 谷歌默认16px font-weight: xxx //字体加粗 background-color //背景颜色","categories":[],"tags":[],"author":"Hello"},{"title":"双向链表","slug":"双向链表","date":"2020-05-07T11:15:31.827Z","updated":"2020-05-07T11:20:50.855Z","comments":true,"path":"2020/05/07/shuang-xiang-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shuang-xiang-lian-biao/","excerpt":"","text":"双向链表的定义typedef struct DuLNode{ ElemType data; struct DuLNode *prior; struct DuLNode *next; //前驱和后继 }DuLNode，*DuLinkList 插入顺序 s=data; s->prior=p->prior; p->prior->next=s; s->next=p; p->prior=s;","categories":[],"tags":[],"author":"Hello"},{"title":"单链表","slug":"单链表","date":"2020-05-07T10:10:22.778Z","updated":"2020-05-09T11:52:19.429Z","comments":true,"path":"2020/05/07/dan-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/dan-lian-biao/","excerpt":"","text":"如定义单链表结构体，注意引用单链表元素用” -&gt; “,因为是*LinkList，使用单链表用的是LinkListtypedef struct LNode { ElemType data; //结点的数据域 struct LNode *next; //结点的指针域 }LNode,*LinkList; //LinkList为指向结构体LNode的指针类型 前插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头 } }后插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p,r; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 r=L; //尾指针r指向头结点 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=NULL; r-&gt;next=p; r=p; } }单链表的初始化，它的头节点（为了处理方便，在第一个节点之前增加的结点）没有赋值Status InitList_L(LinkList &L){ //功能1---算法2.5 单链表的初始化 //构造一个空的单链表L L=new LNode; //生成新结点作为头结点，用头指针L指向头结点 L->next=NULL; //头结点的指针域置空 return OK; } 它不能像顺序表一样随机取值，所以需要一一查找ElemType FindList(LinkList &amp;L,int i,ElemType &amp;x){ LinkList p=L; for(int j=0;j&lt;i;j++){ if(!(p-&gt;next))return ERROR; p=p-&gt;next; } x=p-&gt;data; return OK; }查找，按值查找int GetElem(LinkList &L,int &i,ElemType e) { LinkList p=L; int j=1; while(p->next) { p=p->next; if(p->data==e){ //查找成功 i=j; return OK; } j++; } return ERROR; //循环至查找失败 } 单链表的插入Status ListInsert_L(LinkList &amp;L,int i,ElemType &amp;e){ //功能3---算法2.8 单链表的插入 //在带头结点的单链表L中第i个位置之前插入元素e int j; LinkList p,s; p=L;j=0; while(p &amp;&amp; j&lt;i-1){p=p-&gt;next;++j;} //寻找第i-1个结点 if(!p||j&gt;i-1) return ERROR; //i大于表长+1或者小于1 s=new LNode; //生成新结点s s-&gt;data=e; //将结点s的数据域置为e s-&gt;next=p-&gt;next; //将结点s插入L中 p-&gt;next=s; return OK; }删除指定序号数据元素Status ListDelete(LinkList &L,int i){ LinkList p=L; int j=1; while(p->next&&jnext; j++; } if(!(p->next)||j>i)return ERROR; LinkList q=p->next; p->next=q->next; delete q; return OK; }","categories":[],"tags":[],"author":"Hello"},{"title":"顺序表","slug":"顺序表","date":"2020-05-07T09:31:08.736Z","updated":"2020-05-09T11:52:34.516Z","comments":true,"path":"2020/05/07/shun-xu-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shun-xu-biao/","excerpt":"","text":"如定义s顺序表结构体，注意引用顺序表元素用” . “,因为是SqList不是*S’q’Listtypedef struct{ ElemType *elem; //存储空间的基地址 int length; //当前长度 }SqList; 顺序表的初始化Status InitList_Sq(SqList &L){ //功能1--算法2.1 顺序表的初始化 //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) return OVERFLOW; //存储分配失败，overflow为-2 L.length=0; //空表长度为0 return OK; } 查找Status LocateElem(SqList *L, ElemType e) //按元素值查找 { int i=0; while (ilength && L->elem[i]!=e) i++; //查找元素e if (i>=L->length) //未找到时返回0 return 0; else return i+1; //找到后返回其逻辑序号 顺序表的插入Status ListInsert_Sq(SqList &amp;L,int i,ElemType e){ //功能3--算法2.3 顺序表的插入 //在顺序表L中第i个位置之前插入新的元素e //i值的合法范围是1&lt;=i&lt;=L.length+1 if(i&lt;1 || i&gt;L.length+1) return ERROR; //i值不合法,error为0 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length; //表长增1 return OK; }删除数据元素bool ListDelete(SqList &L,int i) //删除数据元素 { int j; if (iL.length) //参数错误时返回false return false; for (j=i-1;j","categories":[],"tags":[],"author":"Hello"},{"title":"C++结构体初始化","slug":"C++结构体初始化","date":"2020-05-07T09:16:02.980Z","updated":"2020-05-07T09:31:02.136Z","comments":true,"path":"2020/05/07/c-jie-gou-ti-chu-shi-hua/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/c-jie-gou-ti-chu-shi-hua/","excerpt":"","text":"如定义药品结构体 typedef struct node{ //定义结构体 string name; float price; int count; float sale; int next; }Medicine; typedef struct{ //定义顺序表 Medicine r[MAX_Size+1]; int length; }SqList; 使用new的初始化 SqList *list_med=new SqList;","categories":[],"tags":[],"author":"Hello"},{"title":"C++求string数组元素个数","slug":"C++求String数组的元素个数","date":"2020-05-06T11:04:31.177Z","updated":"2020-05-06T11:44:46.247Z","comments":true,"path":"2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","link":"","permalink":"https://taylor12138.github.io/2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","excerpt":"","text":"不能使用str.length,这个求的是单个字符串的大小，可以使用以下求得到长度 sizeof(str)/sizeof(str[0])","categories":[],"tags":[],"author":"Hello"},{"title":"搞定了gitee了！！","slug":"搞定了gitee了！！","date":"2020-05-04T17:01:10.659Z","updated":"2020-05-05T17:02:45.166Z","comments":true,"path":"2020/05/05/gao-ding-liao-gitee-liao/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/gao-ding-liao-gitee-liao/","excerpt":"","text":"原来是个人邮箱的设置必须得是公开的，我一直是设置为private，搞得一直错，终于搞出来了，单独发一条blog来庆祝一下！！！！ 但是发现了gitee的一个缺点，每次部署完后都要去码云更新一次。。。","categories":[],"tags":[],"author":"Hello"},{"title":"HTML5的基本属性","slug":"HTML5的基本属性","date":"2020-05-04T16:25:58.368Z","updated":"2020-05-07T16:49:24.002Z","comments":true,"path":"2020/05/05/html5-de-ji-ben-shu-xing/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/html5-de-ji-ben-shu-xing/","excerpt":"","text":"1.基本标签介绍&lt;html&gt;&lt;/html&gt;``根标签 &lt;head&gt; &lt;/head&gt; 文档头部 &lt; title&gt; &lt;/title&gt; 文档标题 &lt;body&gt;&lt;/body&gt; 文档主体 2.在vscode里使用英文“！”可以直接生成基本结构ctrl+“+”可以放大（写代码）页面 &lt;!DOCTYPE html&gt; （） &lt;html lang=&quot;zh-CN&quot;&gt; (中文) &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;h1&gt;&lt;/h1&gt;---&lt;h6&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; &lt;br /&gt;&lt;strong&gt;&lt;/strong&gt;(字体加粗)&lt;del&gt;&lt;/del&gt;（字体删除线） 3.盒子：类似于view，用于布局&lt;div&gt;&lt;/div&gt; //大盒子，独占一整行 &lt;span&gt;&lt;/span&gt; //小盒子 4.img&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; height=&quot;&quot; width=&quot;&quot;&gt; //微信小程序是image alt为图片无法加载时显示的文字，title为鼠标移到图片上显示的文字提示, 但是对于height和width,一般只修改其中一个，另外一个就会跟着改变 src种绝对路径 \\ 相对路径 / 5.超链接&lt; a&gt;&lt;a href=&quot;&quot; target=&quot;&quot; &gt;文本或者图像&lt;/a&gt; 类似于微信小程序中的navigator, href用于指定目标的url，可打开内部，外部链接 target用于来链接打开方式，默认_self _blank为在新窗口打开 锚点链接：设置href=#名字，如&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;可以快速跳转到第二集的页面位置 ​ 在于目标位置标签里添加id=”two” 6.特殊字符空格：&amp;nbsp (因无法识别大于号和小于号) 小于号：&amp;lt 大于号：&amp;gt 7.表格（用于数据）&lt;table&gt; ​ &lt;tr&gt; ​ &lt;td&gt;单元格文字&lt;/td&gt;或者&lt;th&gt;&lt;/th&gt; ​ &lt;/tr&gt; &lt;/table&gt; table是表格，tr是行，td是单元格（th可充当表头单元格）。还可以加入&lt;thead&gt;和 &lt;tbody&gt;来帮助CSS区分表格结构 单元格合并使用colspan=”（列）想要合并的单元个数”或者rowspan=”（行）想要合并的单元个数”，再删除多余的td（或th） 8.列表（用于布局）无序列表（ul里只能放li标签，所以其他容器放li里面就可以）&lt;ul&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ul&gt; 有序列表(规则同无序)&lt;ol&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ol&gt; 自定义列表(同上)&lt;dl&gt; ​ &lt;dt&gt;名词1&lt;/dt&gt; ​ &lt;dd&gt;名词1解释1&lt;/dd ​ &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 9.表单（用于填写信息，用户注册）&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot; maxlength=&quot;&quot;&gt;&lt;/form&gt;表单域 url地址为处理表单数据的地址，method有get，post 表单元素&lt;input&gt;&lt;input type=&quot;属性值&quot; name=&quot;&quot; value=&quot;&quot; check=&quot;&quot;&gt;输入 type可以为text，password，button，reset（重置）submit（用于提交），radio（单选框，必须添加name才能使用），checkbox（复选框）等 value为输入框内的提示语||充当提交给后台的数据||显示的文字 check用于单选和复选的默认值 check=”checked” maxlength=“最大值” &lt;label for=&quot;sex&quot;&gt;男 &lt;/label&gt; label用于增加用户体验，点击范围内即可选中某input &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; label中的for对应input里的id 或者把input标签放在label里面也能达到同样的效果，此时不需要for和id 表单元素&lt;select&gt; 下拉列表&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;选项3&lt;/option&gt; //默认选中选项3 ... &lt;select&gt;表单元素&lt;textarea&gt; 文本域，可以写大量文字（个人介绍，评论）&lt;textarea&gt; 文字 &lt;/textarea&gt;h5标签推荐网址： http://www.w3school.com.cn/ http://developer.mozilla.org/zh-CN/","categories":[],"tags":[],"author":"Hello"},{"title":"主题与2d人物","slug":"主题与2d人物","date":"2020-05-03T16:50:47.307Z","updated":"2020-05-05T17:03:19.452Z","comments":true,"path":"2020/05/04/zhu-ti-yu-2d-ren-wu/","link":"","permalink":"https://taylor12138.github.io/2020/05/04/zhu-ti-yu-2d-ren-wu/","excerpt":"","text":"Start人物使用命令安装npm：npm uninstall hexo-helper-live2d npm install –save hexo-helper-live2d此时在blog/node_modeles下多出了一个“live2d-widget”下载动画model：这里是套用别人（大佬）的仓库https://github.com/xiazeyu/live2d-widget-models.git下载好后将packages里的所有文件拷贝到blog/node_modeles最后在win使用padnote _config.yml，把以下：live2d: enable: true pluginModelPath: assets/ model: use: live2d-widget-model-epsilon2_1 #模板目录，在node_modules里 display: position: right width: 150 height: 300 mobile: show: false #是否在手机进行显示 复制进去 再使用hexo clean g d进行部署 主题下载好了之后放入blog/themes里面（整个文件）再在win使用padnote _config.yml把theme: xx改成theme: (你要的主题名)最后部署","categories":[],"tags":[],"author":"Hello"},{"title":"困难的一天","slug":"困难的一天","date":"2020-05-03T15:00:48.806Z","updated":"2020-05-05T17:03:02.641Z","comments":true,"path":"2020/05/03/kun-nan-de-yi-tian/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/kun-nan-de-yi-tian/","excerpt":"","text":"difficult daynothing搞了一天，荒废了一天的宝贵五一假期时间，竟然还搞不好gitee的部署，我太菜了 但是至少弄好了ssh和主题，安慰一下把","categories":[],"tags":[],"author":"Hello"},{"title":"My First Blog","slug":"My First Blog","date":"2020-05-02T17:33:53.947Z","updated":"2020-05-05T17:02:29.455Z","comments":true,"path":"2020/05/03/my-first-blog/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/my-first-blog/","excerpt":"","text":"Quick Start打开win+R进入cmd，然后在正确目录下进入：cd source_post(指定blog下) 基本操作用typora修改完毕后，1.使用“hexo clean”进行清理（1.5.若是发生主题等修改后，要接上hexo g 来建立）2.接上“hexo s”即可进入网站查看（退出键位：control+C，y）（本地浏览）3.再次部署到远端：hexo d 关于主题1.可以使用git clone 网址.git themes\\新建目录名（或者使用码云gitee进行下载，然后复制到themes目录下）2.cd.. (回到blog目录下)notepad _config.yml把记事本里面的theme：xx修改成theme：主题目录名3.重新执行”基本操作” 参考文献 https://hexo.io/docs/one-command-deployment.html)","categories":[],"tags":[],"author":"Hello"},{"title":"hello-world","slug":"hello-world","date":"2020-05-02T16:45:45.799Z","updated":"2020-05-09T11:14:05.056Z","comments":true,"path":"2020/05/03/hello-world/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"author":"Hello"}],"categories":[],"tags":[]}