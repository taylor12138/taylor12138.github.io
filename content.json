{"meta":{"title":"Hexo","subtitle":"Books are the ladder of human progress","description":"","author":"Hello","url":"https://taylor12138.github.io","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-05-04T06:35:25.450Z","comments":true,"path":"about/index.html","permalink":"https://taylor12138.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-05-03T17:21:52.000Z","updated":"2020-05-04T06:33:52.664Z","comments":true,"path":"contact/index.html","permalink":"https://taylor12138.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-05-03T17:22:42.000Z","updated":"2020-05-04T06:34:25.403Z","comments":true,"path":"friends/index.html","permalink":"https://taylor12138.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-03T17:20:07.000Z","updated":"2020-05-04T06:33:11.259Z","comments":true,"path":"categories/index.html","permalink":"https://taylor12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-03T17:17:32.000Z","updated":"2020-05-04T06:33:28.454Z","comments":true,"path":"tags/index.html","permalink":"https://taylor12138.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WebGL","slug":"WebGL","date":"2023-06-11T16:00:00.000Z","updated":"2023-06-12T16:12:20.942Z","comments":true,"path":"2023/06/12/webgl/","link":"","permalink":"https://taylor12138.github.io/2023/06/12/webgl/","excerpt":"","text":"WebGL简介WebGL是一种JavaScript API，用于在不使用外挂程式的情况下在任何相容的网页浏览器中呈现交互式2D和3D图形[3]。WebGL完全整合到浏览器的所有网页标准中，可将影像处理和效果的GPU加速使用方式当做网页Canvas的一部分。WebGL元素可以加入其他HTML元素之中并与网页或网页背景的其他部分混合[4]。WebGL程序由JavaScript编写的控制代码和OpenGL Shading Language（GLSL）编写的著色器代码组成，该语言类似于C或C++，并在电脑的图形处理器（GPU）上执行。WebGL由非营利Khronos Group设计和维护[5]。 兼容性：（截止2023年6月） GLSLGLSL - OpenGL Shading Language 也称作 GLslang，是一个以C语言为基础的高阶着色语言。它是由 OpenGL ARB 所建立，提供开发者对绘图管线更多的直接控制，而无需使用汇编语言或硬件规格语言。 想要使用WebGL作图就必须要使用到着色器（shader）。着色器包括： 顶点着色器（Vertex shader）用来描述顶点的特征（位置、颜色、大小等），顶点指的就是空间中的某一个点。 片元着色器（Fragment shader）处理每一个片元，片元可以理解成像素点。 比如说我们想画一个三角形首先要知道三角形的三个点在哪，这就需要我们通过顶点着色器来描述点的位置，然后如果要把这个三角形画出来就需要填充颜色，三角形上每个像素点需要什么颜色就可以使用片元着色器来决定。 所以，我们一般利用JavaScript中创建字符串的方式创建GLSL字符串：用串联的方式（concatenating）(用得最多)， 用AJAX下载，用多行模板数据。 gl_FragColor是一个片段着色器主要设置的变量、gl_Position 是一个顶点着色器主要设置的变量 // 顶点着色器glsl代码 const vsSource = ` attribute vec4 aVertexPosition; attribute vec4 aVertexColor; varying lowp vec4 vColor; void main() { gl_Position = aVertexPosition; vColor = aVertexColor; } `; // 片段着色器glsl代码 const fsSource = ` varying lowp vec4 vColor; void main() { gl_FragColor = vColor; } `; 或者在这个例子里，我们可以将它们放在非JavaScript类型的标签中。 &lt;script id=\"vertex-shader-2d\" type=\"notjs\"> //xxxxxx &lt;/script> 然后，我们通过对GLSL数据的上传，然后编译成。顶点/片元 着色器。 // 创建着色器，gl为上下文，type指明是顶点着色器还是片段着色器，source即为源码 function createShader(gl, type, source) { const shader = gl.createShader(type); // 创建着色器对象 gl.shaderSource(shader, source); // 提供数据源 gl.compileShader(shader); var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS); if (success) { return shader; } else { //一些处理 } return shader; } function initShaderProgram(gl, vsSource, fsSource) { const vshader = createShader(gl, gl.VERTEX_SHADER, vsSource); const fshader = createShader(gl, gl.FRAGMENT_SHADER, fsSource); const shaderProgram = gl.createProgram(); // 创建着色器程序 gl.attachShader(shaderProgram, vshader); // 链接着色器到对应的着色器程序中 gl.attachShader(shaderProgram, fshader); gl.linkProgram(shaderProgram); // 关联着色器程序到整个绘制对象中 var success = gl.getProgramParameter(program, gl.LINK_STATUS); if (success) { return shaderProgram; } else { //一些处理 } } Basic 语法（1）变量类型 属性（Attributes）和缓冲 缓冲是发送到GPU的一些二进制数据序列，通常情况下缓冲数据包括位置，法向量，纹理坐标，顶点颜色值等。 你可以存储任何数据。我们可以理解为和threejs 的 attribute 类似 全局变量（Uniforms） 全局变量在着色程序运行前赋值，在运行过程中全局有效。 纹理（Textures） 纹理是一个数据序列，可以在着色程序运行中随意读取其中的数据。 大多数情况存放的是图像数据，但是纹理仅仅是数据序列， 你也可以随意存放除了颜色数据以外的其它数据。 可变量（Varyings） 可变量是一种顶点着色器给片段着色器传值的方式，依照渲染的图元是点， 线还是三角形，顶点着色器中设置的可变量会在片段着色器运行中获取不同的插值。 （2）基本类型void空类型,即不返回任何值 bool布尔类型 true,false int带符号的整数 signed integer float带符号的浮点数 floating scalar vec2, vec3, vec4n维浮点数向量 n-component floating point vector bvec2, bvec3, bvec4n维布尔向量 Boolean vector ivec2, ivec3, ivec4n维整数向量 signed integer vector mat2, mat3, mat42x2, 3x3, 4x4 浮点数矩阵 float matrix sampler2D2D纹理 a 2D texture samplerCube盒纹理 cube mapped texture 精度限定符 精度范围 浮点数范围 highp (-2的62次方, 2的62次方); mediump (-2的14次方, 2的14次方); lowp (-2,2); 整数范围 highp (-2的16次方, 2的16次方); mediump (-2的10次方, 2的10次方); lowp (-2的8次方, 2的8次方); 指定默认精度 precision 顶点着色器预定义，预定义即为默认值 precision highp float; // 浮点数高精度 precision highp int; // 整型高精度 precision lowp sampler2D; precision lowp samplerCube; 片段着色器预定义 precision mediump int; // 整型中精度 precision lowp sampler2D; precision lowp samplerCube; 兼容性var gl = canvas.getContext(\"webgl\"); if (!gl) { // 你不能使用WebGL！ ... 参考WebGL 基础概念 webgl从0到写一个简易滤镜","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"h5动画相关","slug":"h5动画相关","date":"2023-05-07T16:00:00.000Z","updated":"2023-06-12T06:59:21.625Z","comments":true,"path":"2023/05/08/h5-dong-hua-xiang-guan/","link":"","permalink":"https://taylor12138.github.io/2023/05/08/h5-dong-hua-xiang-guan/","excerpt":"","text":"动画原理这里把动画方案的实现原理分为三种。 第一种是纯面向过程的动画记录方式，目前市面上主流的有Airbnb 的Lottie和腾讯最近开源的PAG，原理是通过记录动画设计师制作动画的每个元素，还有每个元素的运动过程，然后开发者再还原这些元素的运动。这个方案的优点是文件体积小，能实现大部分基础特效和变换下的动画。缺点是不支持比较复杂的特效（如3D效果等），播放性能也比较差，因为记录过程就必然有一个还原动画的计算过程，在渲染的同时还需要计算每个元素的变化过程，对比其他方案就多了一项计算的性能损耗。 第二种是半面向过程半结果的动画记录方式 目前市面上主流的方案有YY的SVGA和Y2A方案，原理是记录动画设计师制作动画时用到的每一个元素，然后记录元素在每一帧的特征（形状，大小，位置，alpha等）。SVGA的优点是能支持更复杂的动画，同时播放性能也比第一种方案好许多。缺点是体积会大一些，同时也不支持复杂的特效（如3D效果等）。为什么第二种方案相比第一种方案性能上比较好，也能够支持更复杂的动画呢，这是牺牲了一部分文件体积，从而减少了计算这一环节的因素。SVGA的文件经过zlib压缩和base64编码后，压缩率能达到85%~90% 第三种是记录结果方式，目前主要有PNG序列图和带透明通道的MP4方案。原理是记录每一帧每个像素点的像素值来渲染，优点是所见即所得，充分解放设计师的思想，能够支持所有设计师能设计出来的动画，包括3D动效等 总结： 第一种方案 支持一般的动效，比如UI动画，场景切换动效和一些进场、得分等动效。 第二种方案能支持第一种能支持的所有动效，且能够支持更复杂的动效，例如复杂的礼物动效，酷炫的坐骑动画等。 第三种方案能支持所有的动效，只要设计师能设计出来的动效都支持。在体积上，也是依次递增的，第一种方案体积最小。但是在性能上刚好反过来，第一种方案性能最差，CPU和GPU占用较高。 LottieLottie是Airbnb开源的一个支持 Android、iOS 以及 ReactNative，利用json文件的方式快速实现动画效果的库。 设计师可以使用 Adobe After Effects 设计出漂亮的动画之后，使用 Lottic 提供的 Bodymovin 插件将设计好的动画导出成 JSON 格式，就可以直接运用在 iOS、Android、Web 和 React Native之上，无需其他额外操作。 Lottie-webLottie-web是爱彼迎提供的针对html的lottie播放器版本 usage npm i lottie-web --save import lottie from 'lottie-web/build/player/lottie_light_canvas'; import JSONL from './ani/dataModal.json'; const modalRef = useRef(); modalRef.current = lottie.loadAnimation({ container: modalRef?.current, renderer: 'canvas', animationData: JSONL, autoplay: true, loop: false, }); &lt;div className=\"rock-lottie\" ref={modalRef} /> lottie的json文件{ \"v\": \"5.6.10\", // 使用bodymovie插件的版本 \"fr\": 32, // 帧速率 \"ip\": 0, // 合成开始时间 \"op\": 64, // 合成持续时间 \"w\": 750, // 合成宽度 \"h\": 1334, // 合成高度 \"nm\": \"合成 1\", // 合成名 \"ddd\": 0, // 是否3d图层 \"assets\": [ // 使用的资源 { \"id\": \"image_0\", // 使用的资源id \"w\": 750, // 当前图片资源的宽 \"h\": 1334, // 当前图片资源的高 \"u\": \"images/\", // 当前图片导出后在使用bodymovie导出后的文件夹 \"p\": \"img_0.jpg\", // 当前图片资源路径 \"e\": 0 // e=0 后将拼接u+p作为图片路径，e=1 不使用u，直接使用p的路径。 } ], \"layers\": [ // 图层 { \"ddd\": 0, // 是否是3d图层 \"ind\": 1, // 当前图层所在的索引 \"ty\": 2, // 2代表图片图层 \"nm\": \"img_0.jpg\", // 源名称 \"cl\": \"jpg\", // 后缀 \"refId\": \"image_0\", // 使用assets中的id \"sr\": 1, // 图层 =>时间=>时间伸缩 \"ks\": { // 图层 => 变换 \"o\": { // 透明度 \"a\": 1, // 是否是关键帧 \"k\": [ // 如果是关键帧时是数组 { // 每一个关键帧位置的配置信息 \"i\": { \"x\": [0.833], \"y\": [0.833] }, // 当前贝塞尔曲线的入值，这个是在lottie中写死的值 \"o\": { \"x\": [0.167], \"y\": [0.167] }, // 当前贝塞尔曲线的出值，这个是在lottie中写死的值 \"t\": 0, // 当前关键帧开始时间 \"s\": [60] // 开始的opacity }, { // 第二个关键帧的配置信息 \"i\": { \"x\": [0.833], \"y\": [0.833] }, \"o\": { \"x\": [0.167], \"y\": [0.167] }, \"t\": 25, \"s\": [100] }, // 第三个关键帧的配置信息 { \"i\": { \"x\": [0.833], \"y\": [0.833] }, \"o\": { \"x\": [0.167], \"y\": [0.167] }, \"t\": 30, \"s\": [100] }, // 第四个关键帧的配置信息 { \"t\": 50, \"s\": [50] } ], \"ix\": 11 // Property Index. Used for expressions。表达式标记。还没研究到这个怎么用 }, \"r\": { // 旋转 \"a\": 0, // 是否是关键帧， 0代表不是关键帧 \"k\": 0, // 不是关键帧时为number，旋转角度为0 \"ix\": 10 // Property Index. Used for expressions。表达式标记 }, \"p\": { // 位置 \"a\": 1, // 是关键帧 \"k\": [ { \"i\": { \"x\": 0.833, \"y\": 0.833 }, // 当前贝塞尔曲线的入值，这个是在lottie中写死的值 \"o\": { \"x\": 0.167, \"y\": 0.167 }, // 当前贝塞尔曲线的出值，这个是在lottie中写死的值 \"t\": 0, // 开始时间 \"s\": [-375, 675, 0], // 当前关键帧位置，横坐标-375，纵坐标675， 不是3d图层，z方向为0 \"to\": [125, 0, 0], // In Spatial Tangent. Only for spatial properties. Array of numbers. 入值 还不知道空间切线在AE中是个什么鬼 \"ti\": [-125, 0, 0] // Out Spatial Tangent. Only for spatial properties. Array of numbers. 出值 还不知道空间切线在AE中是个什么鬼 }, { \"i\": { \"x\": 0.833, \"y\": 0.833 }, \"o\": { \"x\": 0.167, \"y\": 0.167 }, \"t\": 25, \"s\": [375, 675, 0], \"to\": [0, 0, 0], \"ti\": [0, 0, 0] }, { \"i\": { \"x\": 0.833, \"y\": 0.833 }, \"o\": { \"x\": 0.167, \"y\": 0.167 }, \"t\": 30, \"s\": [375, 675, 0], \"to\": [125.167, 0, 0] \"ti\": [-125.167, 0, 0] }, { \"t\": 50, \"s\": [1126, 675, 0] } ], \"ix\": 2 // Property Index. Used for expressions. }, \"a\": { // 锚点 \"a\": 0, // 不是关键帧 \"k\": [375, 667, 0], // 锚点值 \"ix\": 1 // Property Index. Used for expressions. }, \"s\": { // 缩放比例 \"a\": 0, // 不是关键帧 \"k\": [100, 100, 100], // // 缩放比例值 \"ix\": 6 // Property Index. Used for expressions. } }, \"ao\": 0, // 是否自动跟踪 \"ip\": 0, // 开始帧 \"op\": 64, // 持续帧长 \"st\": 0, // 开始时间 \"bm\": 0 // 混合模式 } ], \"markers\": [] } 然后我们可以通过修改json文件，来修改我们的lottie资源 import JSONL from './ani/dataModal.json'; JSONL.assets[9].p = 'xxxurl'; JSONL.assets[8].p = 'xxxurl'; JSONL.assets[5].p = 'xxxurl'; JSONL.assets[4].p = 'xxxurl'; JSONL.assets[7].p = 'xxxurl'; JSONL.assets[6].p = 'xxxurl'; modalRef.current = lottie.loadAnimation({ container: modalRef?.current, renderer: 'canvas', animationData: JSONL, autoplay: true, loop: false, }); 参考 第一篇:直播间礼物动效 - 实现方案","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"SSR","slug":"SSR","date":"2023-04-11T16:00:00.000Z","updated":"2023-05-24T11:33:42.095Z","comments":true,"path":"2023/04/12/ssr/","link":"","permalink":"https://taylor12138.github.io/2023/04/12/ssr/","excerpt":"","text":"SSR渲染SSR简介SSR：server side render 当前端为vue、react这种spa应用时，非常不利于SEO，各种路由的跳转也变得复杂，并且在首屏渲染时间上也花费了大量时间。在整体架构部署上，还需要利用各种web服务（如ngxin），这点很麻烦 服务端将我们需要的HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中。这个服务端组装HTML的过程，叫做服务端渲染。 SSR优势 更利于SEO。 更利于首屏渲染，即白屏时长更短 SSR劣势 相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源。 一些常用的浏览器API可能无法正常使用，比如window、docment和alert等，如果使用的话需要对运行的环境加以判断。 开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂。 可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致。 FID性能可能会有问题：这里有介绍说明 也可以看这里 https://github.com/reactwg/react-18/discussions/37 所以一般来说为了解决浏览器API交互问题，因此需要在浏览器中执行 CSR 的 JS 脚本，完成事件绑定，让页面拥有交互的能力，这个过程被称作hydrate(翻译为注水或者激活)。同时，像这样服务端渲染 + 客户端 hydrate 的应用也被称为同构应用。 遥望历史之重新认识服务端渲染现在的服务端渲染和过去的服务端渲染完全是两码事 Web1.0时期，在没有AJAX的时候，也就是web1.0时代，几乎所有应用都是服务端渲染，浏览器接收请求后，到数据库查询数据，将数据丢到后端的组件模板（php、asp、jsp等）中，并渲染成HTML片段，然后浏览器拿到的是一个完整的HTML，然后渲染页面，过程没有任何JavaScript代码的参与。。 这样做的缺点是：每一次更新都要请求后，让服务端查一次数据库，重新组装html返回 代码混杂，难以维护（jsp、php） 前后端分离时代，SPA模式出现，前端团队接管页面渲染，后端团队仅负责数据查询和API 随着SPA的发展，弊端也逐渐暴露：JS脚本的臃肿，SEO的退化 此时后端渲染再次出现，但不同的是连接口导向 浏览器 &lt;-&gt; 前端服务器 &lt;-&gt; 后端服务器 其实也可以看作加入了nodejs中间件，这个中间件作为伪“服务端”，由这个前端服务器组装一个携带了具体数据的HTML文本，并且返回给浏览器。 但是！值得一提的是，浏览器加载并执行 JavaScript 脚本，（这个是之前服务端渲染不会的做）给页面上的元素绑定事件，让页面变得可交互，当用户与浏览器页面进行交互，如跳转到下一个页面时，浏览器会执行 JavaScript 脚本，向后端服务器请求数据，获取完数据之后再次执行 JavaScript 代码动态渲染页面。 使用了服务端渲染之后，你还要实现同构！即一份代码，既可以客户端渲染，也可以服务端渲染。 因为这时你要用到两种页面渲染： 前端服务器通过请求后端服务器获取数据并组装HTML返回给浏览器，浏览器直接解析HTML后渲染页面（首屏渲染） 浏览器完成事件绑定，在交互过程中，请求新的数据并动态更新渲染页面（交互渲染） 2大步此时我们可以分为2大步 1.构建时 将代码生成commonjs格式产物，让前端服务器（node）可以正常加载（随着nodejs对esm的支持成熟程度增加，也在不断变得友好） 移除代码样式引入 依赖外部化(external)。对于某些第三方依赖我们并不需要使用构建后的版本，而是直接从 node_modules 中读取，比如 react-dom，这样在 SSR 构建的过程中将不会构建这些依赖，从而极大程度上加速 SSR 的构建。 2.运行时 从SSR入口记载模块 将数据收屏需要渲染的数据提前请求（内网请求） 渲染组件 -&gt; html 拼接html 字符串 SSG但是一般来说，首屏一般不会对内容产生什么修改，但是数以万计的访客打开网站时候，都要进行数据库查询吗？这无疑会导致数据库后端的重复开销，而解决问题的方法是： （SSG）将后端渲染的HTML缓存，这份缓存作为静态内容，也更容易被推送至CDN，实现全国甚至全球加速；即使需要修改内容，也可以重新生成静态内容，再更新cdn内容的方式轻松应对 你可以理解为构建时请求数据 + 填入 缺点：所有用户看到的都是同一个页面，无法生成用户相关内容，并且对于百万级、千万级、亿级页面的大型网站而言，一旦有数据改动，要进行一次全部页面的渲染，需要的时间可能是按小时甚至按天计的，这是不可接受的。 IslandSSR 的页面会第一时间呈现给用户，但是只有当 js 加载完毕，执行完毕后，功能才是真正可用的： 功能方面：用户看到了但是不能操作 性能方面：大量 js 在页面加载完成后集中的解析、执行，FID 必然受到影响 这就是 Progressive Hydration 和 Islands Architecture 要解决的问题。但实际上，某些场景下 SSG + CSR 才是更好的选择。 明白了SSR、CSR两者的优势劣势之后，Islands Architecture 框架的概念在于 与客户端渲染（CSR）相当的交互性 与服务端渲染（SSR）相媲美的 SEO 优势 你可以理解为客户端负责交互JS（降低 后的JS 体积），服务端负责SSR静态相关的进行渲染，二者结合 Island优点： 性能：降低客户端 JS 代码的体积。加载的代码，仅包含交互式组件所需的 JS，这比为整个页面重新创建 Virtual DOM，并重新 hydrate 页面上的所有元素所需的 JS 要少得多。较小的 JS 会带来更快的页面加载和交互时间 (TTI)。 Astro 与使用 Next.js 和 Nuxt.js 创建的文档网站相比，JS 代码减少了 83%。其他用户也反馈了使用 Astro 的性能改进。 （图片来自 https://divriots.com/blog/our-experience-with-astro/） SEO：由于所有静态内容经过服务端渲染，所以页面对 SEO 场景是友好的 关键内容优先：用户几乎可以立即获得关键内容（尤其是博客、新闻文章和产品类的页面）。在关键内容逐渐可用后，可交互的次要功能也是必须的。 可访问性：使用标准静态 HTML 链接导航，有助于提高网站的可访问性（Accessibility）。 基于组件：该架构具有基于组件的架构的所有优点，如：可重用、可维护。 IsLand缺点： 尽管有这些优势，但该概念仍处于初期阶段。“有限的支持”导致了一些缺点： 开发人员实现 Islands 的唯一选择，是使用少数可用的框架之一，或自己实现架构。将现有站点迁移到 Astro 或 Marko 需要额外的工作量。 除了 Jason 最初的文章外，几乎没有更多的信息。 有一些新框架声称支持 Islands Architecture，因此筛选出适合你的架构会更难。 该架构不适合复杂交互页面，例如可能需要数千个 Islands 的社交应用。 参考 Islands Architecture Islands Architecture续 更好的 React SSR 彻底理解服务端渲染 - SSR原理 Next.js 的三种渲染方式（BSR、SSG、SSR） 深入浅出vite","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"SWC","slug":"SWC","date":"2023-03-27T03:22:26.044Z","updated":"2023-03-29T15:20:13.554Z","comments":true,"path":"2023/03/27/swc/","link":"","permalink":"https://taylor12138.github.io/2023/03/27/swc/","excerpt":"","text":"SWCSWC 是一个可扩展的基于 Rust 的平台，用于下一代快速开发工具 SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器都支持的有效代码，类似于 babel。 虽然目前SWC 也提供了 Bundle 能力，但是其生态和稳定性上来说稍微逊色 官方：SWC在单线程上比 Babel 快 20 倍，在四核上**快 70 倍**。 快的原因网上看了大概是因为支持并行的特性 SWC 的编译旨在支持所有 ECMAScript 特性。SWC CLI 旨在成为 Babel 的直接替代品： $ npx babel # old $ npx swc # new SWC 支持所有 stage 3 proposals和 preset-env，包括 bugfix 转换。 特性 Compilation （编译） Bundling (swcpack, under development) （打包，正在开发中） Minification （压缩） Transforming with WebAssembly （使用WebAssembly进行转换） Usage inside webpack (swc-loader) （在webpack中使用） Improving Jest performance (@swc/jest) （提高jest单测性能） Custom Plugins （个性化插件定制） 使用pnpm i -D @swc/cli @swc/core 或者 npm i -D @swc/cli @swc/core 或者 yarn add -D @swc/cli @swc/core 然后 npx swc ./file.js 参考文章SWC官网 swc-node, 最快的 TypeScript/JavaScript compiler","categories":[],"tags":[]},{"title":"Monorepo","slug":"Monorepo","date":"2023-03-27T02:19:46.585Z","updated":"2023-03-27T03:07:29.212Z","comments":true,"path":"2023/03/27/monorepo/","link":"","permalink":"https://taylor12138.github.io/2023/03/27/monorepo/","excerpt":"","text":"monorepo一个 monorepo 是一个代码库中许多不同应用程序和包的集合。 用于替代polyrepo方案，你可以理解为 monorepo 就是将制定的都项目移动到一个存储库中，这些项目可以相互依赖，因此它们可以共享代码。并且几乎不需要包管理器，毕竟所有模块都托管在同一个存储库中 在polyrepo中假设您拥有三个独立的存储库 - app、docs和shared-utils。和app都docs依赖于shared-utils，它作为一个包发布在 npm 上。 此时 shared-utils 出现严重问题，但是你的 app、docs 都依赖了 shared-utils ，此时你需要： 提交shared-utils修复错误 运行一个publish任务shared-utils发布到 npm 升级 app 的依赖版本 升级 docs 的依赖版本 重新部署 docs、app 项目 感觉流程是不是比较长. 在monorepo中遇到以上问题，你只需 提交shared-utils修复错误 重新部署 docs、app 项目 优点 可见性：每个人都可以看到其他人的代码。此属性可以带来更好的协作和跨团队的贡献——不同团队中的开发人员可以修复代码中你甚至不知道存在的错误。 更简单的依赖管理：共享依赖是微不足道的。几乎不需要包管理器，因为所有模块都托管在同一个存储库中。 单一事实来源：每个依赖的一个版本意味着没有版本冲突，也没有依赖地狱。 一致性：当您将所有代码库放在一个地方时，执行代码质量标准和统一风格会更容易。 共享时间表：API 或共享库中的重大更改会立即公开，迫使不同的团队提前沟通并联合起来。每个人都投入精力跟上变化。 原子提交：原子提交使大规模重构更容易。开发人员可以在一次提交中更新多个包或项目。 隐式 CI：持续集成得到保证，因为所有代码都已经统一在一个地方。 统一 CI/CD：您可以对存储库中的每个项目使用相同的CI/CD部署过程。 统一构建过程：我们可以为 repo 中的每个应用程序使用共享构建过程。 缺点 性能不佳：monorepos 难以扩展。像这样的命令git blame可能会花费不合理的长时间，IDE 开始滞后并且生产力受到影响，并且在每次提交时测试整个 repo 变得不可行。 损坏的 main/master：损坏的 master 会影响在 monorepo 中工作的每个人。这可以被视为灾难性的，也可以被视为保持测试清洁和最新的良好动机。 学习曲线：如果存储库跨越许多紧密耦合的项目，新开发人员的学习曲线会更陡峭。 大量数据：monorepos 可以达到庞大的数据量和每天的提交量。 所有权：维护文件的所有权更具挑战性，因为像 Git 或 Mercurial 这样的系统没有内置的目录权限。（但是有解决方式） 代码审查：通知会变得非常嘈杂。例如，GitHub 的通知设置有限，不适合大量的拉取请求和代码审查。 更多的考虑：迁移到 monorepo 需要您重新考虑如何进行持续集成。毕竟，您不再构建单个应用程序。您只是在构建受您的更改影响的东西。 运作模式monorepo 的主要构建块是workspace。您构建的每个应用程序和包都将位于自己的工作区中，并带有自己的package.json. 正如您将从我们的指南中了解到的，工作空间可以相互依赖，这意味着您的docs工作空间可以依赖于shared-utils： npm： { \"dependencies\": { \"shared-utils\": \"*\" } } yarn： { \"dependencies\": { \"shared-utils\": \"*\" } } pnpm { \"dependencies\": { \"shared-utils\": \"workspace:*\" } } 参考： what is monorepo What is monorepo? (and should you use it?) Misconceptions about Monorepos: Monorepo != Monolith","categories":[],"tags":[]},{"title":"Vite","slug":"Vite","date":"2023-02-28T16:00:00.000Z","updated":"2023-04-15T09:09:00.272Z","comments":true,"path":"2023/03/01/vite/","link":"","permalink":"https://taylor12138.github.io/2023/03/01/vite/","excerpt":"","text":"Vite概述Webpack是前端使用最多的构建工具，但是除了webpack还有一些其他的构建工具，比如rollup、parcel、gulp、vite Vite 是 vue 的作者尤雨溪在开发 vue3.0 的时候开发的一个基于原生 ES-Module 的前端构建工具 Vite官方的定位：下一代前端开发和构建工具 他主要由两部分组成 一个开发服务器，它基于原生ES模块提供了丰富的内建功能，并且借助 Esbuild 超快的编译速度来做第三方库构建和 TS/JSX 语法编译，这使得HMR速度非常快 一套构建指令，它使用rollup打包我们的代码（使用rollup打包功能），并且它是预配置的，输出生成环境优化过的静态资源 所以构建过程中 Vite 中仍然使用 Esbuild 进行编译和压缩，但打包留给 Rollup。所以 esbuild 用于构建过程的一部分。 图片源自神三元的《深入浅出vite》 Vite初衷就是依赖浏览器本身就识别的依赖关系直接将js解析呈现，而不考虑其他 Vite 所倡导的no-bundle理念的真正含义: 利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载，而不是先整体打包再进行加载 优点： 快，构建快、冷启动快、热更新快。快在哪？ 开发阶段： 使用esbuild进行了预构建 esbuild本身的打包速度快 本身的no-bundle，懒加载 使用@vitejs/plugin-react-swc，在开发阶段，将 Babel 替换为 SWC，冷启动和模块热替换（HMR）将会有显著提升 生产环境： 预构建阶段，编译能力依然用到了esbuild（Transformer），对 TS(X)/JS(X) 进行编译，所以快（但是vite的一些默认React 预设使用 Babel 来转换 React HMR 和 JSX。） 从vite2.6开始，自动启用esbuild对代码压缩（esbuild的压缩速度是要比webpack的terser快的） 但是缺点就是： 如果包依赖太多，会发送过多的网络请求（import 语句即代表一个 HTTP 请求） 一些兼容性问题，在官网的issue可以看到 写自己插件有需要的话，也要同时兼容 rollup 和 esbuild Vite将基于原生浏览器的特点，解决以上缺点 还有尤大怼人的相关链接：尤雨溪：Turbopack 真的比 Vite 快 10 倍吗？ Esbuildesbuild 是一个用 Go 语言编写的用于打包，（自带压缩）压缩 Javascript 代码的工具库（类似webpack的构建工具） 优点：编译、构建速度快 为什么这么快？ 它是用 Go 语言编写的，该语言可以编译为本地代码 解析，生成最终打包文件和生成 source maps 的操作全部完全并行化 无需昂贵的数据转换，没有使用第三方依赖，只需很少的几步即可完成所有操作 在 Webpack、Rollup 这类工具中，我们不得不使用很多额外的第三方插件来解决各种工程需求，比如： 使用 babel 实现 ES 版本转译 使用 eslint 实现代码检查 使用 TSC 实现 ts 代码转译与代码检查 使用 less、stylus、sass 等 css 预处理工具 但是Esbuild 完全重写整套编译流程所需要用到的所有工具 该库以提高编译速度为编写代码时的第一原则，并尽量避免不必要的内存分配（go的能力） 缺点： babel插件问题 为了保证 esbuild 的编译效率，esbuild 没有提供 AST 的操作能力。所以一些通过 AST 处理代码的 babel-plugin 没有很好的方法过渡到 esbuild 中（比如 babel-plugin-import） 作为打包工具的话，代码分割和 CSS处理方面 较差 虽然自带（捆绑）了压缩功能，但是在 esbuild 命令中使用“ minify ”和“ bundle ”选项不会创建与Rollup / Terser管道一样小的包。这是因为 esbuild 牺牲了一些包大小优化以尽可能少地通过您的代码。但是，差异可能可以忽略不计，并且对于提高捆绑速度来说是值得的，具体取决于您的项目。 在生产环境下使用 esbuild 是可行的。像 snowpack , vite 等构建工具都已经是用了 esbuild 作为代码处理工具（稳定性已经足够）。如果你一定要使用，可以看看是否符合下面标准 没有使用一些自定义的 babel-plugin (如 babel-plugin-import) 不需要兼容一些低版本浏览器（esbuild 只能将代码转成 es6） 那你就可以大胆使用 esbuild-loader 为你的项目提效了 rollupRollup 也是前端模块化的一个打包工具，它的开发本意，是打造一款简单易用的 ES 模块打包（和esbuild天然配合）工具，不必配置，直接使用 优点： 不必配置，直接食用，对 tree shaking 有着良好的支持，产物非常干净，支持多种输出格式，适合做库的开发 rollup插件思路很棒，Vite的插件写法就是模仿rollup的，甚至有不少 Rollup 插件可以直接复用到 Vite 。 工具库打包后体积更小一点 缺点： 介绍是这么介绍，但是我个人用下来， webapck5之后配置项上来看，webpack是比rollup少的， 而且webpack5还自带terser各种代码压缩，都不用配置了，但是rollup还需要配置，截止2023.4.14为止，rollup已经更新至3.20版本，部分插件还不兼容rollup3.0（官方文档未更新，比如文档推荐用rollup-plugin-terser压缩，但是实际上有兼容问题，要用 原terser进行替代） 而且rollup官方文档也比webpack逊色，而且rollup打包还需要更高版本的node支持，webpack5兼容node更好 注意：如果你想用rollup打包commonjs，比如项目中用了lodash，那要走和webpack一样麻烦的配置流程，那还不如用webpack 如果你需要 code-splitting，有很多 static assets，需要使用很多 CommonJS 依赖，使用 Webpack 如果你的 codebase 是ES Module，写一些给其他人使用的代码或库，那么使用 Rollup webpack优点： 兼容性无敌 生态强大，插件、loader强大，灵活 所以适合大型项目 缺点： 上手麻烦，冷启动，热更新慢 性能测试(该数据测试截止于2022.4)打包工具特性对比总览 打包速度测试打包 antd + lodash + react + react-dom + three.js 的速度。为了控制变量，统一采用 esbuild 作为 minifier（spack 不支持除外）。 测试数据来源 webpack rollup parcel esbuild spack ThinkPad T480 5.347s 14.548s 6.069s 0.249s 1.082s MacBook 16, 2019 4.229s 12.790s 5.225s 0.227s 1.012s 打包速度上首当其冲的就是esbuild，毋庸置疑，，spack（swcpack）也挺快的，但令人意外的是， webpack 居然比 parcel 和 rollup 更快。尤其是 rollup 的性能，令人意外地差。有可能是因为 lodash 和 react 都是 CJS 模块，rollup 需要将其转化成 ESM 才能使用，这才降低了rollup的速度 包体积测试数据来源 no-minify terser esbuild swc 产物尺寸 4.7MB 1.8MB 1.9MB 1.9MB 运行时间 ThinkPad T480 4.677s 17.046s 5.615s 8.997s 运行时间 MacBook 16, 2019 3.556s 13.834s 4.052s 6.892s webpack v5 开箱即带有最新版本的 terser-webpack-plugin，这次对比的是 terser、esbuild和swc的压缩能力，terser是用node.js、esbuild使用go、swc使用rust， 对于这类高计算量任务，node.js的性能比原生程序差得多。但是从压缩结果来没什么差距 编译特性对比 babel esbuild swc ES Next ✅ ✅ ✅ ES5, IE11 ✅ ❌ ✅ JS 修饰器语法 ✅ ❌ ❌ Flow 语言 ✅ ❌ ❌ TypeScript 语言 ✅ ✅ ✅ TS 修饰器语法 ✅ ✅ ✅ JSX ✅ ✅ ✅ 运行时间在ThinkPad T480编译速度 10.133s 0.464s 0.549s 从特性上来看，babel 依旧是最全面的，而esbuild 和 swc 则注重对最新 ES 标准的支持，并且esbuild对旧版本兼容性一般，这也是为什么vite生产环境用rollup的原因吧 小总结： webpack 仍然是最全面的 Bundler 选择，支持特性最丰富，生态最为庞大。而且它的性能并不差，某些打包场景要优于 rollup 和 parcel；而esbuild、SWC等潜力也很大，vite有意在esbuild生态完善后全面使用，而不是参合着rollup，同时也用SWC取代babel的位置 CRA和Vite在业界，使用CRA已经成为了创建React应用约定俗成的惯例。它确实是个好办法，多年来也一直在迭代升级。 npx create-react-app my-app cd my-app npm start 然而，CRA也有自身的痛点（也是Vite力主提升的方向）：当项目体积变大，开发时间和构建时间也会大幅增加。原因是，无论进行任何更改，CRA都会全量的重新构建应用。 而vite不同 不同于CRA的全量构建，Vite是按需构建的。Vite将一个应用分为两个部分：依赖和源码。 依赖依赖在开发过程中，基本不会变动。Vite使用esbuild（基于Go语言，比传统JS要快10-100倍）预打包了依赖，而且由于依赖变动极少，所以会被缓存起来以节省大量时间。 源码源码采用了ESM（ECMAScript modules）作为模块体系。好处是无需打包，按需加载，从图中我们可以看到那种按需的感觉 Vite的预构建Vite预构建主要是为了 CommonJS 和 UMD 兼容性：本地开发依赖于esbuild，所以需要代码转换成esm才能正常编译 + 构建，但是目前一些模块并不是esm，比如react、lodash，所以此时预构建起到一个转换的作用 性能：：由于vite的no-bundle性质，每一个import都对应一个请求，对于像lodash这种依赖层级深、涉及模块数量多的依赖包，直接回引发瀑布流请求，而预构建会帮忙直接把这种依赖层级深的包打包成一个文件，直接引入，这样会减少请求次数 vite默认自动开启，在项目启动成功后，你可以在根目录下的node_modules中发现.vite目录，这就是预构建产物文件存放的目录 当然，我们也可以自定义预构建配置，通过在vite.config.js里面进行更改optimizeDeps选项，可以自定义添加预构建入口entries、以来添加include、手动取消exclude，详情可查看：这里 Vite安装和使用startNode版本 &gt;= 12版本 安装一个完整的项目(直接上脚手架) npm init @vitejs/app 相当于 npm i @vuejs/create-app create-app 或者入门的话老师推荐先安装vite工具 npm install vite -g or npm i vite -D 开启vite服务器使用： npx vite vite打包 npx vite build 配置我们可以直接用vite.config.ts作为配置文件 为避免类型报错，你需要通过 pnpm i @types/node -D 安装类型 tsconfig.node.json 中设置 allowSyntheticDefaultImports: true，以允许下面的 default 导入方式 // vite.config.ts import { defineConfig } from 'vite' import path from 'path' import react from '@vitejs/plugin-react' export default defineConfig({ // 手动指定项目根目录位置(html的根目录) root: path.join(__dirname, 'src'), //配置了官方的 react 插件 plugins: [react()] }) 配置别名 // vite.config.ts import path from 'path'; { resolve: { // 别名配置 alias: { '@assets': path.join(__dirname, 'src/assets') } } } Vite的拆包策略为什么要拆包？ 传统打包模式下，会直接把整个项目一次性打包，它会 无法按需加载，最经典的就是路由组件 线上缓存复用率低，改动一行代码替换整个 bundle 产物，导致url改变，接而缓存失效。 所以我们进行拆包之后，加入入口文件有 5个文件，其中一个文件变动了，则变动的chunk只有那一份，此时达到拆包的效果 vite默认拆包策略： ├── assets │ ├── Dynamic.xxx.js // Async Chunk, 放动态导入的代码 │ ├── Dynamic.xxx.css // Async CSS Chunk │ ├── favicon.xxx.svg // 静态资源 │ ├── index.xxx.css // Initial CSS Chunk │ ├── index.xxx.js // Initial Chunk，放本地代码 │ └── vendor.xxx.js // 放第三方包产物 └── index.html当然我们可以通过manualChunks自定义拆包策略，但是可能会有循环引用的问题，所以还是推荐用一个 vite-plugin-chunk-split 插件去做自定义拆包 其他没有像webpack一样的loader，比如要使用less文件，直接 npm install less -D 重新跑vite即可 vite默认支持TS vite服务器内部Connect会对我们的请求做转发，完成less -&gt; js、ts -&gt; js，然后浏览器得到编译后的js代码 Vite1搭建的服务器为koa，而Vite2搭建的服务器为connect Vite对Vue的支持Vue3单文件组件支持： @vitejs/plugin-vue Vue3 JSX支持： @vite/plugin-vue-jsx Vue 2支持：underfin/vite-plugin-vue2 比如加入vue3的支持(@vue/complier-sfc负责编译vue文件) npm i @vitejs/plugin-vue -D npm i @vue/complier-sfc -D vite的配置 在目录下新建vite.config.js文件，并将配置文件导出 const vue = require('@vitejs/plugin-vue'); module.exports = { plugins: [ vue() ] } 用esbuild起一个服务（类似 webpack-dev-server） 首先在根目录下创建build.js // build.js const { build, buildSync, serve } = require(\"esbuild\"); function runBuild() { serve( { port: 8000, // 静态资源目录 servedir: './dist' }, { absWorkingDir: process.cwd(), entryPoints: [\"./src/index.jsx\"], bundle: true, format: \"esm\", splitting: true, sourcemap: true, ignoreAnnotations: true, metafile: true, } ).then((server) => { console.log(\"HTTP Server starts at port\", server.port); }); } runBuild(); 直接调vite的服务进行启动 createServer Api，这就意味着无论在什么类型的项目中，只要提供给这个 API 准确的入参，就能启动 vite 服务。 vite插件 钩子通用钩子 在开发中，Vite 开发服务器会创建一个插件容器来调用 Rollup 构建钩子，与 Rollup 如出一辙。 以下钩子在服务器启动时被调用： options buildStart 以下钩子会在每个传入模块请求时被调用： resolveId load transform 它们还有一个扩展的 options 参数，包含其他特定于 Vite 的属性。你可以在 SSR 文档 中查阅更多内容。 以下钩子在服务器关闭时被调用： buildEnd closeBundle 请注意 moduleParsed 钩子在开发中是 不会 被调用的，因为 Vite 为了性能会避免完整的 AST 解析。 Output Generation Hooks（除了 closeBundle) 在开发中是 不会 被调用的。你可以认为 Vite 的开发服务器只调用了 rollup.rollup() 而没有调用 bundle.generate()。 特有钩子 config 在读取完vite.config.ts后执行该钩子 configResolved 使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用，但是不建议再修改配置 configureServer 是用于配置开发服务器的钩子。最常见的用例是在内部 connect 应用程序中添加自定义中间件: configurePreviewServer 与 configureServer 相同但是作为预览服务器。它提供了一个 connect 服务器实例及其底层的 http server。与 configureServer 类似，configurePreviewServer 这个钩子也是在其他中间件安装前被调用的。如果你想要在其他中间件 之后 安装一个插件，你可以从 configurePreviewServer 返回一个函数，它将会在内部中间件被安装之后再调用 const myPlugin = () => ({ name: 'configure-preview-server', configurePreviewServer(server) { // 返回一个钩子，会在其他中间件安装完成后调用 return () => { server.middlewares.use((req, res, next) => { // 自定义处理请求 ... }) } }, }) transformIndexHtml 这个钩子用来灵活控制 HTML 的内容，你可以拿到原始的 html 内容后进行任意的转换 handleHotUpdate 这个钩子会在 Vite 服务端处理热更新时被调用，你可以在这个钩子中拿到热更新相关的上下文信息，进行热更模块的过滤，或者进行自定义的热更处理 普通用户插件钩子执行顺序 export default function testHookPlugin () { return { name: 'test-hooks-plugin', // 独有 config(config) { console.log('config'); }, // 独有 configResolved(resolvedCofnig) { console.log('configResolved'); }, // 通用钩子 options(opts) { console.log('options'); return opts; }, // 独有 configureServer(server) { console.log('configureServer'); setTimeout(() => { // 手动退出进程 process.kill(process.pid, 'SIGTERM'); }, 3000) }, // 通用钩子 buildStart() { console.log('buildStart'); }, // 通用钩子 buildEnd() { console.log('buildEnd'); }, // 通用钩子 closeBundle() { console.log('closeBundle'); } } } 下图源自神三元的《深入浅出Vite》 插件顺序 如果是直接看全部插件种类的顺序则为 参考文章： 【译文】Vite是什么？为何推荐使用Vite代替Create React App？ ESbuild 介绍 深入浅出 Vite Comparing the New Generation of Build Tools 前端构建工具测评","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React的一些工具","slug":"React的一些工具","date":"2023-01-04T16:00:00.000Z","updated":"2023-01-06T07:39:11.271Z","comments":true,"path":"2023/01/05/react-de-yi-xie-gong-ju/","link":"","permalink":"https://taylor12138.github.io/2023/01/05/react-de-yi-xie-gong-ju/","excerpt":"","text":"普通动画用 transition 只能做一些简单的动画，稍微复杂的动画可以使用keyframes： .show{ animation:show-item 2s ease-in forwards; } .hide{ animation:hide-item 2s ease-in forwards; } @keyframes hide-item{ 0% { opacity:1; color:yellow; } 50%{ opacity: 0.5 ; color:red; } 100%{ opacity:0; color: green; } } @keyframes show-item{ 0% { opacity:0; color:yellow; } 50%{ opacity: 0.5 ; color:red; } 100%{ opacity:1; color: green; } } 当然，React也有它好的套件：就叫做 react-transition-group npm install react-transition-group --save 官方文档 它有三个核心套件： Transition CSSTransition TransitionGroup CSSTransitionimport { CSSTransition } from 'react-transition-group' render() { return ( &lt;> &lt;CSSTransition in={this.state.isShow} // 用户判断是否出现的状态 timeout={2000} // 动画持续时间 classNames=\"boss-text\" // 防止重复，可以理解成 namespace > &lt;div>BOSS - king&lt;/div> &lt;/CSSTransition> &lt;div> &lt;button onClick={this.toToggle}>召喚「風魚」 &lt;/button> &lt;/div> &lt;/> ); } 再看看官方文件說明可以知道，我们接下来就可以编写css属性了 在组件出现、进入、退出或完成过渡时应用于组件的动画类名。可以提供单个名称，每个阶段都将添加后缀，例如classNames=&quot;fade&quot;applys： fade-appear, fade-appear-active,fade-appear-done fade-enter, fade-enter-active,fade-enter-done fade-exit, fade-exit-active,fade-exit-done 举个例子： namespace-enter: 进入前的样式 / 初始值 namespace-enter-active：动画开始直到完成的css namespace-enter-done：完成时css namespace-exit：退出之前CSS namespace-exit-active：退出动画直到完成時之前的的 CSS 。 namespace-exit-done：退出完成時的 CSS 。 现在我们不用自己编写 / 管理classname啦🥵～ .boss-text-enter{ opacity: 0; } .boss-text-enter-active{ opacity: 1; transition: opacity 2000ms; } .boss-text-enter-done{ opacity: 1; } .boss-text-exit{ opacity: 1; } .boss-text-exit-active{ opacity: 0; transition: opacity 2000ms; } .boss-text-exit-done{ opacity: 0; } 几个回调onEnter组件的回调函数，当组件enter或appear时会立即调用。 type: Function(node: HtmlElement, isAppearing: bool) onEntering也是一个过渡组件的回调函数，当组件enter-active或appear-active时，立即调用此函数 type: Function(node: HtmlElement, isAppearing: bool) onEntered同样是回调函数，当组件的enter,appearclassName被移除时，意即调用此函数 type: Function(node: HtmlElement, isAppearing: bool) onExit当组件应用exit类名时，调用此函数 type: Function(node: HtmlElement) onExiting当组件应用exit-active类名时，调用此函数 type: Function(node: HtmlElement) onExited当组件exit类名被移除，且添加了exit-done类名时，调用此函数 type: Function(node: HtmlElement) 其他mountOnEnter：&lt;bool = false&gt;，默认情况子组件与transtion组件一起加载(也就是说即使in属性为false，组件也会先以隐藏状态(exited)正常加载)，当mountOnEnter 为true时，会在第一次in属性为true时加载子组件 unmountOnExit：&lt;bool = false&gt;，在元素退场时，自动把DOM也删除，这是以前用CSS动画没办法做到的。在过渡结束后卸载组件, 测试发现这里确实卸载了子组件生成的dom节点，但是并不会触发componentWillUnmount钩子，在子组件重新进入entered状态时也不会重新触发componentDidMount等创建阶段钩子 react-canvas-draw一个canvas绘画组件 import CanvasDraw from 'react-canvas-draw'; &lt;CanvasDraw brushRadius={5} brushColor=\"#fad54b\" ref={saveableCanvas} onChange={onChange} backgroundColor=\"transparent\" className=\"draw-canvas-wrap\" hideInterface hideGrid /> static defaultProps = { onChange: null loadTimeOffset: 5, lazyRadius: 30, //拖拽点距离鼠标的距离 brushRadius: 12, //线条粗度 brushColor: \"#444\", //线条颜色 catenaryColor: \"#0a0302\", gridColor: \"rgba(150,150,150,0.17)\", hideGrid: false, canvasWidth: 400, canvasHeight: 400, disabled: false, imgSrc: \"\", saveData: null, immediateLoading: false, hideInterface: false, gridSizeX: 25, gridSizeY: 25, gridLineWidth: 0.5, hideGridX: false, hideGridY: false enablePanAndZoom: false, mouseZoomFactor: 0.01, zoomExtents: { min: 0.33, max: 3 }, };","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"qiankun实战","slug":"qiankun实战","date":"2022-09-21T16:00:00.000Z","updated":"2022-12-07T11:13:20.133Z","comments":true,"path":"2022/09/22/qiankun-shi-zhan/","link":"","permalink":"https://taylor12138.github.io/2022/09/22/qiankun-shi-zhan/","excerpt":"","text":"1.qiankun快速上手快速上手：https://qiankun.umijs.org/zh/guide/getting-started 主应用in 主应用，要完成对微应用的注册： yarn add qiankun # 或者 npm i qiankun -S import { registerMicroApps, start } from 'qiankun'; registerMicroApps([ { name: 'react app', // app name registered entry: '//localhost:7100', container: '#yourContainer', activeRule: '/yourActiveRule', }, { name: 'vue app', entry: { scripts: ['//localhost:7100/main.js'] }, container: '#yourContainer2', activeRule: '/yourActiveRule2', }, ]); start(); 当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。 registerMicroApps(apps, lifeCycles?)：https://qiankun.umijs.org/zh/api#registermicroappsapps-lifecycles 如果不想要用url控制子应用的加载，可以选择手动加载完毕 import { loadMicroApp } from 'qiankun'; loadMicroApp({ name: 'app', entry: '//localhost:7100', container: '#yourContainer', }); 子应用in 子应用，不需要npm装啥东西，但是需要做两个配置 配置一微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用。 bootstrap：类似于special mount，仅在第一次 mount： 每次挂载子应用就会调用 unmount： 每次卸载子应用调用 update：可选，仅使用 loadMicroApp 方式加载微应用时生效 /** * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。 */ export async function bootstrap() { console.log('react app bootstraped'); } /** * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法 */ export async function mount(props) { ReactDOM.render(&lt;App />, props.container ? props.container.querySelector('#root') : document.getElementById('root')); } /** * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例 */ export async function unmount(props) { ReactDOM.unmountComponentAtNode( props.container ? props.container.querySelector('#root') : document.getElementById('root'), ); } /** * 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效 */ export async function update(props) { console.log('update props', props); } 配置二配置微应用的打包工具 除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要增加如下配置： webpack: const packageName = require('./package.json').name; module.exports = { output: { library: `${packageName}-[name]`, libraryTarget: 'umd', jsonpFunction: `webpackJsonp_${packageName}`, //webpack5不用配置 }, }; jsonpFunction： 在 webpack 4 中，多个 webpack 运行时可能在同一个 HTML 页面上发生冲突，因为它们使用相同的全局变量来加载块。要解决此问题，需要为output.jsonpFunction配置提供自定义名称。 Webpack 5 会自动推断构建的唯一名称，package.json name并将其用作output.uniqueName. 2.qiankun基本项目上手对于主应用，一般来说和快速上手主应用的配置一样即可 对于子应用，微应用分为有 webpack 构建和无 webpack 构建项目，有 webpack 的微应用（主要是指 Vue、React、Angular）需要做的事情有： 新增 public-path.js 文件，用于修改运行时的 publicPath。 注意：运行时的 publicPath 和构建时的 publicPath 是不同的，两者不能等价替代。 微应用建议使用 history 模式的路由，需要设置路由 base，值和它的 activeRule 是一样的。（路由不带 # 号） 在入口文件最顶部引入 public-path.js，修改并导出三个生命周期函数。 修改 webpack 打包，允许开发环境跨域和 umd 打包。 对于1，我们先来了解一个概念：webpack的公共路径 publicPath 配置选项在各种场景中都非常有用。你可以通过它来指定应用程序中所有资源的基础路径。 你可以理解为我们常用的在脚手架中config配置的全局路径前缀”@”、”$”等 但是在微前端中，这个公共路径可能会随着主应用改变，需要一个子应用运行时的公共路径配置（运行时改变） webpack 暴露了一个名为 __webpack_public_path__ 的全局变量。所以在应用程序的 entry point 中，可以直接如下设置： __webpack_public_path__ = process.env.ASSET_PATH; 对于无 webpack 构建的子应用项目，直接将 lifecycles 挂载到 window 上即可。 window.__POWERED_BY_QIANKUN__在qiankun环境中，我们可以得到 window.__POWERED_BY_QIANKUN__)这个值，为true，通常用来判断子应用是否为乾坤环境 展开说说React微应用项目 以 create react app 生成的 react 16 项目为例，搭配 react-router-dom 5.x。 在 src 目录新增 public-path.js： if (window.__POWERED_BY_QIANKUN__) { __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__; } 设置 history 模式路由的 base： &lt;BrowserRouter basename={window.__POWERED_BY_QIANKUN__ ? '/app-react' : '/'}> 入口文件 index.js 修改，为了避免根 id #root 与其他的 DOM 冲突，需要限制查找范围。 并且在入口文件导出生命周期函数 import './public-path'; import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; function render(props) { const { container } = props; ReactDOM.render(, container ? container.querySelector(‘#root’) : document.querySelector(‘#root’)); } if (!window.POWERED_BY_QIANKUN) { render({}); } export async function bootstrap() { console.log(‘[react16] react app bootstraped’); } export async function mount(props) { console.log(‘[react16] props from main framework’, props); render(props); } export async function unmount(props) { const { container } = props; ReactDOM.unmountComponentAtNode(container ? container.querySelector(‘#root’) : document.querySelector(‘#root’)); } 4. 修改 `webpack` 配置 安装插件 `@rescripts/cli`，当然也可以选择其他的插件，例如 `react-app-rewired`。 ```dash npm i -D @rescripts/cli 根目录新增 .rescriptsrc.js： const { name } = require('./package'); module.exports = { webpack: (config) => { config.output.library = `${name}-[name]`; config.output.libraryTarget = 'umd'; config.output.jsonpFunction = `webpackJsonp_${name}`; config.output.globalObject = 'window'; return config; }, devServer: (_) => { const config = _; config.headers = { 'Access-Control-Allow-Origin': '*', }; config.historyApiFallback = true; config.hot = false; config.watchContentBase = false; config.liveReload = false; return config; }, }; 修改 package.json： - \"start\": \"react-scripts start\", + \"start\": \"rescripts start\", - \"build\": \"react-scripts build\", + \"build\": \"rescripts build\", - \"test\": \"react-scripts test\", + \"test\": \"rescripts test\", - \"eject\": \"react-scripts eject\" 其他项目（vue、angular）也可查看qiankun官网的项目实践：qiankun官网项目实践 3.全局状态主应用： // main/src/main.js import { initGlobalState } from 'qiankun'; // 初始化 state const initialState = { user: {} // 用户信息 }; const actions = initGlobalState(initialState); actions.onGlobalStateChange((state, prev) => { // state: 变更后的状态; prev 变更前的状态 console.log(state, prev); }); actions.setGlobalState(state); actions.offGlobalStateChange(); 子应用： // 从生命周期 mount 中获取通信方法，props默认会有onGlobalStateChange和setGlobalState两个api export function mount(props) { props.onGlobalStateChange((state, prev) => { // state: 变更后的状态; prev 变更前的状态 console.log(state, prev); }); props.setGlobalState(state); 形成了一个父子应用的发布订阅模式 4.注册子应用我从qiankun源代码直接看到的流程为：registerMicroApps -&gt; loadApp -&gt; const { template, execScripts, assetPublicPath } = await importEntry(entry, importEntryOpts); 然后初始化html模版（加上各种qiankun-head） const appContent = getDefaultTplWrapper(appInstanceId)(template); let initialAppWrapperElement: HTMLElement | null = createElement( appContent, strictStyleIsolation, scopedCSS, appInstanceId, ); 其实 createElement 也就是在做一些 document.createElement(&#39;div&#39;); containerElement.innerHTML = appContent; shadow = appElement.attachShadow({ mode: &#39;open&#39; }); 的一些操作 在加载script的时候执行子应用生命周期 const scriptExports: any = await execScripts(global, sandbox &amp;&amp; !useLooseSandbox); const { bootstrap, mount, unmount, update } = getLifecyclesFromExports( scriptExports, appName, global, sandboxContainer?.instance?.latestSetProp, ); 5.import-html-entryimport-html-entry 是 qiankun 中一个举足轻重的依赖，用于获取子应用的 HTML 和 JS，它允许以html文件为应用入口，然后通过一个html解析器从文件中提取js和css依赖，并通过fetch下载依赖，同时对 HTML 和 JS 进行了各自的处理，以便于子应用在父应用中加载 该方案的主要思路是允许以html文件为应用入口，然后通过一个html解析器从文件中提取js和css依赖，并通过fetch下载依赖 export default function importHTML(url, opts = {}) { // 1. 通过 fetch 获取到 url 对应的 html return embedHTMLCache[url] || (embedHTMLCache[url] = fetch(url) .then(html => { // 2. 从返回的结果中解析出以下内容a.经过初步处理后的 html, b.由所有 \"script\" 组成的数组, c.由所有 \"style\" 组成的数组 const { template, scripts, entry, styles } = processTpl(getTemplate(html), assetPublicPath, postProcessTemplate); // 3. 将所有的 css 嵌入到上述经过初步处理后的 html 中 return getEmbedHTML(template, styles, { fetch }).then(embedHTML => (...)); })); } 于是在qiankun中你可以这样配置入口： const MicroApps = [{ name: 'app1', entry: 'http://localhost:8080', container: '#app', activeRule: '/app1' }] qiankun会通过import-html-entry请求http://localhost:8080，得到对应的html文件，解析内部的所有script和style标签，依次下载和执行它们，这使得应用加载变得更易用。 三个apiimport-html-entry，有 importHTML：将索引 html 视为清单并加载资产（css，js），从入口脚本获取导出。 导出 //解析模板的核心函数_processTpl2 var _processTpl = (0, _processTpl2[\"default\"])(getTemplate(html), assetPublicPath, postProcessTemplate), template = _processTpl.template, scripts = _processTpl.scripts, entry = _processTpl.entry, styles = _processTpl.styles; return getEmbedHTML(template, styles, { fetch: fetch }).then(function (embedHTML) { return { template: embedHTML, assetPublicPath: assetPublicPath, getExternalScripts: function getExternalScripts() { return _getExternalScripts(scripts, fetch); }, getExternalStyleSheets: function getExternalStyleSheets() { return _getExternalStyleSheets(styles, fetch); }, execScripts: function execScripts(proxy, strictGlobal) { var opts = arguments.length > 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : {}; if (!scripts.length) { return Promise.resolve(); } return _execScripts(entry, scripts, proxy, _objectSpread({ fetch: fetch, strictGlobal: strictGlobal }, opts)); } }; }); importEntry：加载资产（css，js）并嵌入到 HTML 模板中，从入口脚本获取导出。（实际上如果 type of 参数 === string，就会返回importHTML） 为对象的时候，传入的是脚本和样式的资源列表。 { html:\"http://xxx.com/static/tpl.html\", scripts:[ { src:\"http://xxx.com/static/xx.js\", async:true }, ... ], styles:[ { href:\"http://xxx.com/static/style.css\" }, ... ] } execScripts：在自定义沙箱上通过 URL 加载脚本，从入口脚本获取导出。 暴露出的核心接口是importHTML，而 importHTML 的具体流程： 检查是否有缓存，如果有，直接从缓存中返回 如果没有，则通过fetch下载，并字符串化 基于正则表达式对模板字符串基于正则表达式对模板字符串 进行一次模板解析，主要任务是扫描出外联脚本和外联样式，保存在scripts和styles中 调用getEmbedHTML，将外联样式下载下来，并替换到模板内，使其变成内部样式 返回一个对象，该对象包含处理后的模板，以及getExternalScripts、getExternalStyleSheets、execScripts等几个核心方法。 getExternalStyleSheets：prefetch下载styles样式表，isInlineCode判断是否为内联代码，返回css的代码 function _getExternalStyleSheets(styles) { var fetch = arguments.length > 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : defaultFetch; return Promise.all(styles.map(function (styleLink) { if (isInlineCode(styleLink)) { // if it is inline style return (0, _utils.getInlineCode)(styleLink); } else { // external styles return styleCache[styleLink] || (styleCache[styleLink] = fetch(styleLink).then(function (response) { return response.text(); })); } })); } getExternalScripts：prefetch下载script表，isInlineCode判断是否为内联代码，是的话直接截取script里面的代码，返回js的代码 // for prefetch function _getExternalScripts(scripts) { var fetch = arguments.length > 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : defaultFetch; var errorCallback = arguments.length > 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : function () {}; var fetchScript = function fetchScript(scriptUrl) { return scriptCache[scriptUrl] || (scriptCache[scriptUrl] = fetch(scriptUrl).then(function (response) { // usually browser treats 4xx and 5xx response of script loading as an error and will fire a script error event // https://stackoverflow.com/questions/5625420/what-http-headers-responses-trigger-the-onerror-handler-on-a-script-tag/5625603 if (response.status >= 400) { errorCallback(); throw new Error(\"\".concat(scriptUrl, \" load failed with status \").concat(response.status)); } return response.text(); })[\"catch\"](function (e) { errorCallback(); throw e; })); }; return Promise.all(scripts.map(function (script) { if (typeof script === 'string') { if (isInlineCode(script)) { // if it is inline script return (0, _utils.getInlineCode)(script); } else { // external script return fetchScript(script); } } else { // use idle time to load async script var src = script.src, async = script.async; if (async) { return { src: src, async: true, content: new Promise(function (resolve, reject) { return (0, _utils.requestIdleCallback)(function () { return fetchScript(src).then(resolve, reject); }); }) }; } return fetchScript(src); } })); } execScripts：执行脚本，返回_getExternalScripts.then() + 获取代码（getExecutableScript,改变脚本执行时候的window/self/this 的指向。） + schedule 函数调度中按序执行 exec function getExecutableScript(scriptSrc, scriptText) { var opts = arguments.length > 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : {}; var proxy = opts.proxy, strictGlobal = opts.strictGlobal, _opts$scopedGlobalVar = opts.scopedGlobalVariables, scopedGlobalVariables = _opts$scopedGlobalVar === void 0 ? [] : _opts$scopedGlobalVar; var sourceUrl = isInlineCode(scriptSrc) ? '' : \"//# sourceURL=\".concat(scriptSrc, \"\\n\"); // 将 scopedGlobalVariables 拼接成函数声明，用于缓存全局变量，避免每次使用时都走一遍代理 var scopedGlobalVariableFnParameters = scopedGlobalVariables.length ? scopedGlobalVariables.join(',') : ''; // 通过这种方式获取全局 window，因为 script 也是在全局作用域下运行的，所以我们通过 window.proxy 绑定时也必须确保绑定到全局 window 上 // 否则在嵌套场景下， window.proxy 设置的是内层应用的 window，而代码其实是在全局作用域运行的，会导致闭包里的 window.proxy 取的是最外层的微应用的 proxy var globalWindow = (0, eval)('window'); globalWindow.proxy = proxy; // TODO 通过 strictGlobal 方式切换 with 闭包，待 with 方式坑趟平后再合并 return strictGlobal ? scopedGlobalVariableFnParameters ? \";(function(){with(window.proxy){(function(\".concat(scopedGlobalVariableFnParameters, \"){;\").concat(scriptText, \"\\n\").concat(sourceUrl, \"}).bind(window.proxy)(\").concat(scopedGlobalVariableFnParameters, \")}})();\") : \";(function(window, self, globalThis){with(window){;\".concat(scriptText, \"\\n\").concat(sourceUrl, \"}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);\") : \";(function(window, self, globalThis){;\".concat(scriptText, \"\\n\").concat(sourceUrl, \"}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);\"); } 参考： qiankun官网项目实践","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"一些好用的网站","slug":"一些好用的网站","date":"2022-08-22T16:00:00.000Z","updated":"2023-04-26T07:00:09.597Z","comments":true,"path":"2022/08/23/yi-xie-hao-yong-de-wang-zhan/","link":"","permalink":"https://taylor12138.github.io/2022/08/23/yi-xie-hao-yong-de-wang-zhan/","excerpt":"","text":"Example以下部分网站分享均来源于老陈打码的网站推荐： 图标 动画图标库 https://loading.io/ css 动画css代码在线演示（可以直接cv动画代码） https://xsgames.co/animatiss/ css flex布局游戏练习网站 and css一些新的功能尝试网站 http://www.flexboxdefense.com/ https://css-tricks.com/ CSS-doodle 是一个基于 Web-Component 的库。允许我们快速的创建基于 CSS Grid 布局的页面，以实现各种 CSS 效果（或许可以称之为 CSS 艺术）。 https://css-doodle.com/ https://www.cnblogs.com/coco1s/p/15178959.html react中使用：https://github.com/css-doodle/css-doodle/issues/35 3D Web3D编辑器 https://techbrood.com/ 动画 扁平化的3d效果图案：zdog，类似于吧一些logo、svg进行3d展现 体积28k，不需要像threejs那种一样需要一大堆的支持 https://zzz.dog/ 对于vue、react可以在github上搜索vue-zdog、react-zdog来玩一玩 PPT ppt模板网站 https://www.youyedoc.com/ppt/ 绘制流程图网站 https://app.diagrams.net/ 画图网站 https://app.diagrams.net/ Gif生成网站 diagrams：https://www.qtool.net/gif 备注：该挂件配置和我们正常运营平台的挂件配置并无二致，只是该cms整顿了一半所有直播业务的cms独立出来，并且可以在新业务的开发运营后台未开发挂件配置时，可以直接作为子应用插拔到运用后台主应用当中去 颜色网站： 让你的网站找到属于自己的主色调 https://www.palettable.io/FDF903 渐变色 https://www.joshwcomeau.com/gradient-generator/ 中国红 http://zhongguose.com/ 自选色调，会自动帮你搭配应有的色调 https://m2.material.io/resources/color/#!/?view.left=0&amp;view.right=0 adobe color https://color.adobe.com/zh/create/color-wheel colors https://coolors.co/ logo自动生成网站https://www.logosc.cn/make 在线脑图绘制https://gitmind.cn/ JS库 Polyfill是一个js库，主要抚平不同浏览器之间对js实现的差异。 ECMAScript 的迅速成长以及浏览器的频繁更新换代，每年会出现新的 api ，举个例子 es6 时期诞生的 ‘Promise’ ，’Set’ 或者是 ‘es7’ 数组新提供的方法 ‘includes’ ,这些新加入的 ‘api’ ，就引出一个词 “polyfill” ‘polyfill(垫片/补丁)’ 就是用社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性 lodash，这个无需多言 Ramda.js：https://www.ruanyifeng.com/blog/2017/03/ramda.html，阮一峰老师的教程 core-js：也适用于polyfill的库","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"文件上传功能","slug":"文件上传功能","date":"2022-07-27T16:00:00.000Z","updated":"2023-05-08T09:24:08.306Z","comments":true,"path":"2022/07/28/wen-jian-shang-chuan-gong-neng/","link":"","permalink":"https://taylor12138.github.io/2022/07/28/wen-jian-shang-chuan-gong-neng/","excerpt":"","text":"1.Blobblob数据类型以随机存取块的形式存储任何种类的二进制数据；二进制数据通常由已保存的电子表格、程序装入模块和数字化声音模式等等组成，也就是说它通常用于存储大文件，通常用来读写文件，比如一个图片文件的内容就可以通过Blob 对象读写 在Web中，Blob类型的对象表示不可变的类似文件对象的原始数据，通俗点说，就是Blob对象是二进制数据，但它是类似文件对象的二进制数据，因此可以像操作File对象一样操作Blob对象，实际上，File继承自Blob（文件对象）。 构造函数 array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings 会被编码为 UTF-8。 options（可选） 它可能会指定如下两个属性： type，默认值为 &quot;&quot;，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。 endings，默认值为&quot;transparent&quot;，用于指定包含行结束符\\n的字符串如何被写入。它是以下两个值中的一个：&quot;native&quot;，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 &quot;transparent&quot;，代表会保持 blob 中保存的结束符不变 非标准 let blob = new Blob([typedArray.buffer], {type: 'application/octet-stream'}); // 传入一个合适的 MIME 类型 let blob2 = new Blob([\"image/jpeg\"],{type:\"application/json\"}) 使用字符串构造一个blob对象 var debug = {hello: \"world\"}; var blob = new Blob([JSON.stringify(debug)], {type : 'application/json'}); 第一个参数是数组，数组元素可以是字符串或二进制文件，用来表示Blob实例对象的数据内容。 第二个参数是配置对象，但是目前该对象只有一个type属性可提供配置，它的值是一个字符串，表示数据的MIME类型，默认是空字符串，关于MIME类型分类，可以参照以下这张表： blob2url此时前端可以将Blob数据转换为url下载地址 export function downBlob(blobData: Blob, fileName: string) { // 下载地址 const downUrl = window.URL.createObjectURL(blobData); const a = document.createElement('a'); a.style.display = 'none'; a.href = downUrl; a.target = '_blank'; if (fileName) { a.download = fileName; } document.body.appendChild(a); a.click(); a.remove(); window.URL.revokeObjectURL(downUrl); // 释放掉blob对象 } url2blob对于canvas生成的base64 url，也就是Data URL 格式的图片数据，为了进一步减少传输的数据量，我们可以把它转换为 Blob 对象，再传给服务端 function dataUrlToBlob(base64, mimeType) { let bytes = window.atob(base64.split(\",\")[1]); let ab = new ArrayBuffer(bytes.length); let ia = new Uint8Array(ab); for (let i = 0; i &lt; bytes.length; i++) { ia[i] = bytes.charCodeAt(i); } return new Blob([ab], { type: mimeType }); } URL.createObjectURLURL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。 createObjectURL返回一段带hash的url，并且一直存储在内存中，直到document触发了unload事件（例如：document close）或者执行revokeObjectURL来释放。 File文件（File）接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。 通常情况下， File 对象是来自用户在一个 input 元素上选择文件后返回的 FileList 对象，也可以是来自由拖放操作生成的 DataTransfer 对象，或者来自 HTMLCanvasElement 上的 mozGetAsFile() API。 File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中。 File() FormDataFormData 接口提供了一种表示表单数据的键值对 key/value 的构造方式，并且可以轻松的将数据通过XMLHttpRequest.send() 方法发送出去，本接口和此方法都相当简单直接。如果送出时的编码类型被设为 &quot;multipart/form-data&quot;，它会使用和表单一样的格式。 它的用法和 map 有点像 构造函数 FormData() 创建一个新的 FormData 对象。 方法 FormData.append() 向 FormData 中添加新的属性值，FormData 对应的属性值存在也不会覆盖原值，而是新增一个值，如果属性不存在则新增一项属性值。 FormData.delete() 从 FormData 对象里面删除一个键值对。 FormData.entries() 返回一个包含所有键值对的iterator对象。 FormData.get() 返回在 FormData 对象中与给定键关联的第一个值。 FormData.getAll() 返回一个包含 FormData 对象中与给定键关联的所有值的数组。 FormData.has() 返回一个布尔值表明 FormData 对象是否包含某些键。 FormData.keys() 返回一个包含所有键的iterator对象。 FormData.set() 给 FormData 设置属性值，如果FormData 对应的属性值存在则覆盖原值，否则新增一项属性值。 FormData.values() 返回一个包含所有值的iterator对象。 2.选择图片上传在元素方面，我们可以选择 input &lt;input type=\"file\" /> &lt;input type=\"file\" accept=\"image/*\"> &lt;input type=\"file\" accept=\"image/gif,image/jpeg,image/jpg,image/png\" multiple /> 通过设置其 multiple 属性和 accept 属性可以使得 input 标签支持多选和仅支持选择 gif、jpg/jpeg 和 png 类型的文件 然后可以对input读取到的数据，采用 2种方式 URL.createObjectURL(file)，得到图片的url，由于可以获取到每张图片的 File 对象，则可以使用 URL.createObjectURL() 创建一个对象 URL，可以作为 img 标签的 src 值进行传入，则能实现本地图片的预览功能。 需要注意的是，当不再需要这些使用 URL.createObjectURL() 创建的 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法来释放 const localUrl = URL.createObjectURL(flieList[0]) // localUrl 可作为图片的源 &lt;img src={localUrl} alt='' /> // 无需使用时释放内存 window.URL.revokeObjectURL(localUrl); 创建一个FileReader对象，监听它的load事件 $inputFile.addEventListener('change', function() { const file = this.files[0]; const reader = new FileReader(); reader.addEventListener('load', function() { $previewImage.src = reader.result; }, false); if(file) { reader.readAsDataURL(file); } } 上传前端要实现图片上传的原理就是通过构建FormData对象，把文件对象append()到该对象，然后挂载在XMLHttpRequest对象上 send() 到服务端。（如果是得到本地url可以通过 fetch(data.url).then((resp) => { console.log(resp); return resp.blob(); }).then((b) => { console.log('---- bb', b); const fd = new FormData(); fd.append('file', b); console.log(fd, 'fd'); }); 得到blob数据格式) function uploadFile() { //这里是用cropperjs对图片进行裁剪 cropperInstance.getCroppedCanvas().toBlob(function(blob) { const formData = new FormData(); formData.append('avatar', blob); fetch('xxxx', { method: 'POST', body: formData }); }); } 3.文件上传文件上传实质上和图片上传差不多，都是使用input获取文件 &lt;div> &lt;input onChange={(v)=>this.handleChange(v)} type=\"file\" size={this.state.size} name=\"fileSelect\" accept=\"image/*\" multiple={this.state.multiple} /> &lt;span ref=\"dragBox\" onDragOver={(e)=>this.handleDragHover(e)} onDragLeave={(e)=>this.handleDragHover(e)} onDrop={(e)=>this.handleDrop(e)} className=\"upload-drag-area\"> 或者将图片拖到此处 &lt;/span> &lt;/div> 处理图片上传的函数handleChange e.preventDefault() let target = event.target let files = target.files let count = this.state.multiple ? files.length : 1 for (let i = 0; i &lt; count; i++) { files[i].thumb = URL.createObjectURL(files[i]) } // 转换为真正的数组 files = Array.prototype.slice.call(files, 0) // 过滤非图片类型的文件 files = files.filter(function (file) { return /image/i.test(file.type) }) 处理拖拽进来的文件： handleDrop(e) { this.setState({progress:[]}) this.handleDragHover(e) // 获取文件列表对象 let files = e.target.files || e.dataTransfer.files let count = this.state.multiple ? files.length : 1 for (let i = 0; i &lt; count; i++) { files[i].thumb = URL.createObjectURL(files[i]) } // 转换为真正的数组 files = Array.prototype.slice.call(files, 0) // 过滤非图片类型的文件 files = files.filter(function (file) { return /image/i.test(file.type) }) this.setState({files: this.state.files.concat(files)}) } 上传函数 upload(file, idx) { return new Promise((resolve, reject) => { let xhr = new XMLHttpRequest() if (xhr.upload) { // 上传中 xhr.upload.addEventListener(\"progress\", (e) => { // 处理上传进度 this.handleProgress(file, e.loaded, e.total, idx); }, false) // 文件上传成功或是失败 xhr.onreadystatechange = (e) => { if (xhr.readyState === 4) { if (xhr.status === 200) { // 上传成功操作 this.handleSuccess(file, xhr.responseText) // 把该文件从上传队列中删除 this.handleDeleteFile(file) resolve(xhr.responseText); } else { // 上传出错处理 this.handleFailure(file, xhr.responseText) reject(xhr.responseText); } } } // 开始上传 xhr.open(\"POST\", this.state.uri, true) let form = new FormData() form.append(\"filedata\", file) xhr.send(form) }) } 只是上看了好多篇文章，他们对于上传图片的请求好多都是直接用原生xhr来写，而且原声xhr也有自带的上传终止功能（abort） 修改请求头在上传的时候如果请求的数据格式有点问题，可以调整一下请求头再发请求，比如： let config = { headers:{'Content-Type':'multipart/form-data'} }; //添加请求头 this.axios.post('http://upload.qiniu.com/',param,config) .then(response=>{ console.log(response.data); }) 参考： 前端图片上传那些事儿 React 实现图片上传和展示功能 基于Node的React图片上传组件实现","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React(下)","slug":"React(下)","date":"2022-07-02T15:33:04.139Z","updated":"2022-10-28T02:34:34.017Z","comments":true,"path":"2022/07/02/react-xia/","link":"","permalink":"https://taylor12138.github.io/2022/07/02/react-xia/","excerpt":"","text":"11.HooksReact的Hook 是 16.8版本新增的特性/语法，可以让我们在函数式组件中使用state和其他React特性 函数式组件最主要没有上述功能的原因是没有实例对象，没有this（现在函数式组件是主流了） Hook主要是践行代数效应的思想（比如不使用async处理正常的函数（因为回将该函数变成一个promise），而是自定义语法以try、catch的理念将函数内部执行的无论同步、异步操作剥离出函数本身），长此以往，可能可以形成服务即组件的结果，从不同数据库，即不同的源获取，对应不同的单独组件 三个常用的Hook State Hook：React.useState()，让我们是使用state const [xxx, setXxx] = React.useState(initValue) 参数: 第一次初始化指定的值在内部作缓存 返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数 Effect Hook：React.useEffect()，让我们使用生命周期函数 useEffect(fn, [stateValue]) 根据stateValue数组的范围，可划分 componentDidMount()、componentDidUpdate()两种生命周期函数，stateValue为监听的state fn是作为以上两种生命周期函数进入该周期执行的回调函数。 fn可以再返回一个函数fn2，fn是作为componentWillUnmount()这个生命周期函数 综上所述，可以把 useEffect Hook 看做如下三个函数的组合`componentDidMount()` `componentDidUpdate()` `componentWillUnmount()` Ref Hook：React.useRef() const refContainer = useRef() State Hook使用示范 import React from 'react' // 这个demo函数调用次数 = render次数 function Demo() { // 保存状态和更新状态的方法，都自定义名字 const [count, setCount] = React.useState(0); const [NewArr, setArr] = React.useState([0]); function add() { // 第一种写法，适用于改变一次的情况 setCount(count + 1); // 第二种写法，适用于不断改变的情况，比如定时器，此时count总能获取到上次状态设置好的count // setCount(count => count+1) // setCount(preState => preState+1) 更容易理解 } function addArr() { setArr([NewArr.length, ...NewArr]) } return ( &lt;div> &lt;h2>当前的Count为：{count}&lt;/h2> &lt;button onClick={add}>+1&lt;/button> &lt;button onClick={addArr}>为数组添加数据&lt;/button> 当前数组：&lt;ul>{ NewArr.map((item, index) => { return ( &lt;li key={index}>{item}&lt;/li> ) }) } &lt;/ul> &lt;/div> ) } export default Demo; Ref Hook 示范 function Demo() { // 感觉和类式组件的createRef差不多 const myRef = React.useRef(); function show() { alert(myRef.current.value); } return ( &lt;div> &lt;input type=\"text\" ref={myRef} /> &lt;button onClick={show}>tip&lt;/button> &lt;/div> ) } ref可以看成fiber中非链表形式，而是单纯作为一个个体存储的hook对象 const hook = workInProgressHook(); //workInProgress可以理解成当前fiber的暂存区 hook.memoizedState = {current: initialValue} useEffectEffect Hook 示范 // 总觉得有点像vue里的watch //第一个参数相当于两个钩子，一个是DidMount、一个是DidUpdate React.useEffect(() => { let timer = setInterval(() => { setCount(count => count + 1); }, 1000); return () => { //组件卸载前执行，相当于componentWillUnmount，可以执行比如清除定时器，取消订阅等操作 clearInterval(timer); } }, []) //这里传入空数组，可以当作componentDidMount来使用 // React.useEffect(() => { // // do something // }, [count]) 只监测count的变化，有点像隶属于count的watcher，如果第二个参数不传入，则全部state都监听 第一个参数返回值是一个清除函数，为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除 其中第二个参数为依赖数组，每次都会进行“浅比较”（Object.js()），判断是否重新渲染 对于Hook的理解不能只停留在这种桌面上对于周期函数 -&gt; useEffect，更要心领神会，忘记之前所学的“生命周期”，他们还是有很多不同之处的， 比如 useEffect 直接使用state、props，会捕获到 “初始的 props和state”（当前渲染状态/ 次数下的props和state），而在useEffect中使用useRef可以获取到最新的数据之类的。 下面这篇文章可以帮助大家加深React Hook的印象https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/ 在render阶段进入到commit阶段的时候，会通过一种被称为Effect（Flags）的数据结构 插入DOM -&gt; fiber节点上增加Placement的effect 更新DOM -&gt; fiber节点上增加Update的effect 删除DOM -&gt; fiber节点上增加Deletion的effect 更新Ref -&gt; fiber节点上增加Ref的effect useEffect回调执行 -&gt; fiber节点上增加Passive的effect 然后在render阶段 -&gt; commit阶段的时候，会传递一条effect链表，里面可能包含了Placement、Passive等 commit阶段处理链表上的每个effect commit阶段有三个小段： 1.beforeMutation阶段 2.mutation阶段 3.layout阶段 useEffect和生命周期函数的区别 Placement -&gt; （mutation阶段）新增DOM节点，使用appendChild方法，然后再layout阶段调用componentDidmount（同步） Passive -&gt; 在以上三个子阶段都执行完毕后，异步调用我们的useEffect回调 此时我们可以是用useLayoutEffect(fn, [])，那效果就和生命周期函数一样了，都在layout阶段调用（useLayoutEffect 内部的更新计划将被同步刷新。） 摘录自React文档effect 的执行时机 (opens new window)： 与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。 可见，useEffect异步执行的原因主要是防止同步执行时阻塞浏览器渲染。 useLayoutEffect官方的推荐使用时机： 如果你正在将代码从 class 组件迁移到使用 Hook 的函数组件，则需要注意 useLayoutEffect 与 componentDidMount、componentDidUpdate 的调用阶段是一样的。但是，我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。 所以我们可以看到useEffect 并不等价于 componentDidMout，而useLayoutEffect 才是与 componentDidMount 等价 useEffect 和 useLayoutEffect的差异 useEffect 是异步执行的，而useLayoutEffect是同步执行的。（所以设计到渲染操作放到useLayoutEffect里面去） useEffect 的执行时机是浏览器完成渲染之后，而 useLayoutEffect 的执行时机是浏览器把内容真正渲染到界面之前，和 componentDidMount 等价。 如果使用服务端渲染，使用 useLayoutEffect 可能会导致实际渲染效果和服务端渲染初衷不一致 参考链接 https://zhuanlan.zhihu.com/p/348701319 React Hook书写习惯（Borrowed by Robin Wieruch，who is famous in GitHub） 在useEffect中调用异步请求时，顺便在useEffect中定义异步请求，如下（使用 try/catch 块进行错误处理） useEffect(() => { const fetchData = async () => { try{ const result = await axios( 'https://hn.algolia.com/api/v1/search?query=redux', ); setData(result.data); } catch { //.... } fetchData(); }, []); 由于挂钩不应返回任何内容或清理函数，而async 函数返回一个AsyncFunction对象，所以以下写法为错误的 × //错误示范 × useEffect(async () => { const result = await axios( 'https://hn.algolia.com/api/v1/search?query=redux', ); setData(result.data); }, []); 一般建议把不依赖props和state的函数提到你的组件外面，并且把那些仅被effect使用的函数放到effect里面。 如果effect要用到外面的函数（不在effect中定义的函数） 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在effects中使用 也可以在定义这些函数的地方用useCallback包一层 出现无限重复请求的问题： 没有设置effect依赖参数（你至少也设置一个空数组[] ，如果没有的话个人感觉有点像进入到类式组件的redner中） 无限循环的发生也可能是因为你设置的依赖总是会改变 不要对依赖项进行撒谎，effect中用到的所有组件内的值都要包含在依赖中。这包括props，state，函数 — 组件内的任何东西。（虽然有时可能导致死循环，但是解决方法不是移除依赖项！——前端大师 Dan说到） function SearchResults() { async function fetchData() { // ... } useEffect(() => { fetchData(); }, []); // Is this okay? Not always -- and there's a better way to write it. // ... } 如果导致死循环，也就是依赖项在Effect中被改动，该如何是好？ 让Effect减少依赖项，仔细思考一下，我们真的需要在Effect中时用到这个依赖项吗？减少“错误依赖”的产生，巧用 setCount(c =&gt; c+1)，也就是这种函数的形式，减少依赖项 处理state中出现相互依赖的关系时，比如 setCount(c =&gt; c + step);（step是一种状态），此时依赖项要添加上step，消除这个依赖项我们可以使用useReducer！ 技术参考：https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/ 自定义hook自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook（实质上自定义hook也我们平时使用函数复用相同逻辑的代码是一样的，只是自定义hook这个函数里面我们可以调用其他的hook，比如State Hook、Effect Hook等） React官方示例 import { useState, useEffect } from 'react'; function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); useEffect(() => { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () => { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; } 它就像一个正常的函数。但是它的名字应该始终以 use 开头，这样可以一眼看出其符合 Hook 的规则。 在React 函数中使用（分别在两个组件中使用相同的逻辑代码） function FriendStatus(props) { const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) { return 'Loading...'; } return isOnline ? 'Online' : 'Offline'; } function FriendListItem(props) { const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style={{ color: isOnline ? 'green' : 'black' }}> {props.friend.name} &lt;/li> ); } 官方的问题回答： 在两个组件中使用相同的 Hook 会共享 state 吗？不会。自定义 Hook 是一种重用状态逻辑的机制，他们的state是相互隔离的 useReduceruseReducer是useState的替代方案 const [state, dispatch] = useReducer(reducer, initialArg, init); 在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。所以当你写类似setSomething(something =&gt; ...)这种代码的时候，也许就是考虑使用reducer的契机 当你想更新一个状态，并且这个状态更新依赖于另一个状态（非自身状态）的值时，你可能需要用useReducer去替换它们。 官网的使用示例 const initialState = {count: 0}; function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1}; case 'decrement': return {count: state.count - 1}; default: throw new Error(); } } function Counter() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;> Count: {state.count} &lt;button onClick={() => dispatch({type: 'decrement'})}>-&lt;/button> &lt;button onClick={() => dispatch({type: 'increment'})}>+&lt;/button> &lt;/> ); } 从此中我们可以看到，是有点类似于redux的模式 为什么用dispatch替换依赖项会更好？React会保证dispatch在组件的声明周期内保持不变。 这就是dispatch的好处之一， dispatch 不会随着 re-render 而重新分配记忆位置（他会暂时记忆），在作为 props 传入到 child component 的时候也可以不用担心没有 useMemo 而造成 re-render 的问题。 在下面的例子中我们不再重新订阅定时器（id） （正常情况下使用useEffect订阅定时器，当step依赖项发生改变时，定时器将会被重新订阅；反观使用dispatch，在定时器开启后，如果step发生改变，定时器不会被重新渲染，而是采用之前的step） import React, { useReducer, useEffect } from \"react\"; import ReactDOM from \"react-dom\"; function Counter() { const [state, dispatch] = useReducer(reducer, initialState); const { count, step } = state; useEffect(() => { const id = setInterval(() => { dispatch({ type: 'tick' }); }, 1000); return () => clearInterval(id); }, [dispatch]); return ( &lt;> &lt;h1>{count}&lt;/h1> &lt;input value={step} onChange={e => { dispatch({ type: 'step', step: Number(e.target.value) }); }} /> &lt;/> ); } const initialState = { count: 0, step: 1, }; function reducer(state, action) { const { count, step } = state; if (action.type === 'tick') { return { count: count + step, step }; } else if (action.type === 'step') { return { count, step: action.step }; } else { throw new Error(); } } （你可以从依赖中去除dispatch, setState, 和useRef包裹的值因为React会确保它们是静态的。不过你设置了它们作为依赖也没什么问题。） 小知识：useState底层也是使用useReducer实现的 export function useState&lt;S>( initialState: (() => S) | S, ): [S, Dispatch&lt;BasicStateAction&lt;S>>] { return useReducer( basicStateReducer, // useReducer has a special case to support lazy useState initializers (initialState: any), ); } function basicStateReducer&lt;S>(state: S, action: BasicStateAction&lt;S>): S { return typeof action === 'function' ? action(state) : action; } useState小Demo源自魔术师卡颂） let isMount = true; let workInProgressHook = null; const fiber = { stateNode: App, memoizedState: null //保存App里面的state } function schedule() { workInProgressHook = fiber.memoizedState; //初始化，得到state的表头 const app = fiber.stateNode(); isMount = false; return app; } function useState(initialState) { let hook; //hook作为一个链表 if (isMount) { hook = { memoizedState: initialState, next: null, queue: { pending: null } } if (!fiber.memoizedState) { fiber.memoizedState = hook } else { workInProgressHook.next = hook; } workInProgressHook = hook; } else { hook = workInProgressHook; workInProgressHook = workInProgressHook.next; } let baseState = hook.memoizedState; if (hook.queue.pending) { let firstUpdate = hook.queue.pending.next; do { const action = firstUpdate.action; baseState = action(baseState); firstUpdate = firstUpdate.next; } while (firstUpdate !== hook.queue.pending.next) hook.queue.pending = null; } hook.memoizedState = baseState; return [baseState, dispatchAction.bind(null, hook.queue)]; } function dispatchAction(queue, action) { const update = { //作为一个环状链表 action, next: null } if (queue.pending === null) { update.next = update } else { update.next = queue.pending.next; //让update.next指向队头 queue.pending.next = update; //让当前update成为队头 } queue.pending = update; schedule(); } function App() { const [num, setNum] = useState(0); return { onClick() { setNum(num => num + 1); } } } window.app = schedule(); react依赖项对于react那些hooks的依赖项，要切实地填写（关乎到当前地hook会不会重新渲染），对于react的依赖尽可能写详细，比如我 currentDay.index写成了currentDay，重新渲染多了一次，useEffect，导致请求多发了一次 12.React拓展setState使用方法方法一：传统的对象式setState（class） setState(stateChange, [callback]) stateChange为状态改变对象（原state的key: 新的值） callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用 （实际上，setState是一个同步的方法，但是异步执行，也就是改动state的数据是异步的，为了提高性能，会将收集到多个state一次性整合更新。这里其实和Vue的异步渲染原因是一致的） something = () => { const {a} = this.state; //1 this.setState({a:a+1}, () => { //2 console.log(this.state.a) //2 }); console.log(this.state.a); //1 } 方法二：函数式的setState（class） setState(updater, [callback]) updater是一个返回stateChange对象（（原state的key: 新的值）的一个对象）的函数。 updater可以接收到state和props。 callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。 something = () => { this.setState((state, props) => { return {a:state.a+1} },() => { console.log(this.state.a) }); } something2 = () => { this.setState(state => {a:state.a-1}); //不再需要 const {a} = this.state; 这个语句，一行解决 } 对象式的setState是函数式setState的语法糖 方法三：hook的setState setCount(c => c + 1); 如果您将 State Hook 更新为与当前状态相同的值，React 将退出而不渲染子级或触发效果。（React 使用Object.is比较算法。） setState同步、异步问题React的三个模式： //- legancy模式： ReactDOM.render(&lt;App />, rootNode) //- blocking模式： ReactDOM.createBlockingRoot(root).render(&lt;App />) //- Concurrent模式： ReactDOM.createRoot(rootNode).render(&lt;App />) 针对legancy模式： 异步渲染。根据batchedUpdates函数进行优化，进行批处理，将多次setState转化为一次。其实也是batchedUpdates函数中，有一个 executionContext全局变量，如果当前更新，包含了 BatchedContext，则会认为这是一次批处理（因为是 |=， 所以可能包含，可能不包含），批处理中的 setState都会被合并为一次 executionContext |= BatchedContext 所以此时如果将 setState()方法放入setTimeout中（进行异步执行），比如下面这种情况 function handleClick() { console.log(\"=== click ===\"); fetchSomething().then(() => { setCount((c) => c + 1); // Causes a re-render setFlag((f) => !f); // Causes a re-render }); } 使得 executionContext |= BatchedContext不能同步得到 BatchedContext这个值，则此时 executionContext啥也没有，源码中有： if(executionContext === NoContext) { resetRenderTimer(); flushSyncCallbackQueue(); //同步执行本次渲染setState } 针对Concurrent模式： 即使将 setState()方法放入setTimeout中（进行异步执行），也不会同步渲染，因为进入以上判断条件之前，还要进入一个判断，即是否为同步的优先级（ReactDOM.render），由于此时是ConCurrent模式，则不会进入这个逻辑判断，继续往下走命中 flushSyncCallbackQueue()函数。 在Concurrent模式出现之前，是通过 包裹unstable_batchedupdates实现异步任务中批处理 实际上，Concurrent还处于实验阶段，在稳定版本中尚不可用。它面向的人群是早期使用者以及好奇心较强的人。 setTimeout(() => { // 模拟异步 ReactDOM.unstable_batchedUpdates(() => { // 仅仅加了unstable_batchedUpdates // 这里的两个setState会合并执行一次。 setNum(2); setStr('c'); }); }, 1000); 补充： 在react18以后，不再有这三种模式，而是以“是否使用并发特性”作为“是否开启并发更新”的依据 并且从 React 18 开始createRoot，所有更新都将自动批处理，无论它们来自何处。这意味着超时、承诺、本机事件处理程序或任何其他事件内部的更新将以与 React 事件内部的更新相同的方式进行批处理： 追溯异步回调中批处理问题为什么之前异步回调中的setState不能批处理？ React 的更新是基于 Transaction（事务）的，Transacation 就是给目标执行的函数包裹一下，加上前置和后置的 hook （有点类似 koa 的 middleware），在开始执行之前先执行 initialize hook，结束之后再执行 close hook，这样搭配上 isBatchingUpdates 这样的布尔标志位就可以实现一整个函数调用栈内的多次 setState 全部入 pending 队列，结束后统一 apply 了。 但是 setTimeout 这样的方法执行是脱离了事务的，react 管控不到，所以就没法 batch 了。 （但是18.x以后都可以batch了） 为什么Vue没有这个限制？ 是因为 vue 采用了 nexttick 的方式，利用 EventLoop，将一个同步事件循环过程中所有修改合并，它本质上属于延迟的批量更新 LazyLoad-React的懒加载懒加载组件 如果有多个所有路由组件，所有的路由组件都会在第一次就全部给你加载完毕。我们可以借助react里面的 Lazy 函数 // lazy为路由懒加载函数，Suspence为如果当前路由组件没能即使请求出来，给用户展示的页面信息 import React, { Component, lazy, Suspense } from 'react' 引入路由组件是写的方式有所变化 （在Vue中是直接 const Home = () =&gt; import(&#39;../components/home&#39;);） // import Home from './pages/Home' // import About from './pages/About' const Home = lazy(() => import('./pages/Home')) const About = lazy(() => import('./pages/About')) 但是注册路由部分需要使用 从React 引入的 Suspense 组件进行包裹，为的是当前路由组件没能及时加载出来，给用户展示的页面信息 {/* 注册路由部分都给我用Suspence包裹起来,fallback部分可以放置一个组件 */} {/* 但是这个放置的加载组件，不能使用路由懒加载 */} &lt;Suspense fallback={&lt;h2>Loading...&lt;/h2>}> {/* 注册路由 */} &lt;Route path=\"/about\" component={About}>&lt;/Route> &lt;Route path=\"/home\" component={Home}>&lt;/Route> &lt;Redirect to=\"/about\" /> &lt;/Suspense> 如果不是以 react-router-dom 进行路由分配，而是通过本组件的state决定是否渲染子组件的简易版动态路由，则也可以用以上类似写法 const Home = lazy(() => import('./pages/Home')) const About = lazy(() => import('./pages/About')) {/* 注册路由部分都给我用Suspence包裹起来,fallback部分可以放置一个组件 */} {/* 但是这个放置的加载组件，不能使用路由懒加载 */} &lt;Suspense fallback={&lt;h2>Loading...&lt;/h2>}> { isShow ? &lt;Home /> : &lt;About/> } &lt;/Suspense> 实现原理 当Webpack解析该语法时，他会自动开始进行代码分割，分割成一个文件（Code Spliting），当使用到这个文件时这段代码会被异步加载 当然除了异步懒加载组件，还可以异步懒加载方法，详情可以看《PC&amp;移动端网页特效(JS)》篇章 Fragment正常情况下，我们使用jsx语法们都需要在外层包裹一层div，但其实有另外一个选择，就是在外层包一层Fragment（隶属于源码干净强迫症患者） &lt;Fragment> .... &lt;/Fragment> 最终Fragment会被React解析，丢弃，撰写Fragment实际上是为了骗过jsx语法（类似Vue的template），由此可以得到没有太多曾div包裹的干净html代码 0.0 实际上我们可以写空标签，它也可以实现fragment的效果 &lt;> ..... &lt;/> 只不过如果使用fragment标签，可以给它添加key属性： &lt;Fragment key={1}&gt;，所以使用fragment标签可以进行遍历，二空标签不行 Context一种组件间通信方式（生产消费者模式），常用于祖组件和后代组件的通信（祖孙），在应用开发中一般不用context, 一般都用它的封装react插件 （回忆：父传子直接props，子传父用回调，兄弟等跨父子可用订阅发布机制或者redux） 1.创建Context容器对象：const XxxContext = React.createContext() 2.渲染子组时，外面包裹xxxContext.Provider标签, 通过value属性给后代组件传递数据 3.哪个子组件要使用，则 如果是类式子组件，需要 static contextType = XxxContext;进行声明接收；然后 this.context.username 就可以使用祖组件传过来的数据了 如果是函数式组件，则需要通过 XxxContext.Consumer标签进行声明接收，并且由回调函数得到祖组件传来的数据 import React, { Component } from 'react' //记住这里赋值变量名首字母大写，因为现在要把MyContext作为组件去使用 const MyContext = React.createContext(); export default class App extends Component { state = { username: 'Allen', age: 18 } render() { const { username, age } = this.state return ( &lt;div> I am grandFather &lt;MyContext.Provider value={{ username, age }}> &lt;Son /> &lt;/MyContext.Provider> &lt;/div> ) } } class Son extends Component { render() { return ( &lt;div> &lt;Grand /> &lt;/div> ) } } // class Grand extends Component { // // 举手示意我要使用(必须要声明才能接收到) // static contextType = MyContext; // render() { // return ( // &lt;div> // {this.context.username} // &lt;/div> // ) // } // } // 函数式组件写法 function Grand() { return ( &lt;div> &lt;MyContext.Consumer> { value => { return `My name is ${value.username}, my age is ${value.age}` } } &lt;/MyContext.Consumer> &lt;/div> ) } useContext函数式组件除了可以使用 Consumer 接收Context的数据，还可以使用useContext进行接收（特别是在多个context的时候，更能体现出useContext的优势）（结合上面的案例来看） import { useContext } from 'react' function Grand() { const value = useContext(MyContext); return ( &lt;div> &lt;MyContext.Consumer> {`My name is ${value.username}, my age is ${value.age}`} &lt;/MyContext.Consumer> &lt;/div> ) } 一般context系列和useReducer使用起来会很爽 import React, { useReducer, useContext } from 'react'; const initialState = { count: 0 } function reducer(state, action) { const { count } = state; switch (action.type) { case 'increment': return { count: count + 1 }; case 'decrement': return { count: count - 1 } default: return state } } const MyContext = React.createContext(); function App() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;> &lt;div>{state.count}&lt;/div> &lt;MyContext.Provider value={ { state, dispatch } }> &lt;Child>&lt;/Child> &lt;Child>&lt;/Child> &lt;Child>&lt;/Child> &lt;/MyContext.Provider> &lt;/> ) } function Child() { const {dispatch, state} = useContext(MyContext) return ( &lt;div> &lt;div>{state.count}&lt;/div> &lt;button onClick={() => dispatch({type: 'increment'})}>+++&lt;/button> &lt;button onClick={() => dispatch({type: 'decrement'})}>---&lt;/button> &lt;/div> ) } export default App; React的插槽技术在我们封装自定义的 Link 标签时（React（中）路由篇章部分），我们直接在自定义路由组件标签内写入文字，从而在子组件里面可以使用 children属性进行接收（this.props.children） 插槽技术的实用性在于：预留位置，随时改变整个组件 由此，我们可以看到React在处理组件插槽时的策略 class App extends Component { render() { return ( &lt;div> &lt;A> &lt;B /> &lt;/A> &lt;/div> ); } } class A extends Component { render() { return ( &lt;div> I am A {this.props.children} &lt;/div> ); } } class B extends Component { render() { return ( &lt;div> I am B &lt;/div> ); } } 此时B要算作A的子组件，可是此时B如何获取到A的state呢？以上的 children props只能实现传递结构，无法传递数据 我们要使用render props（实际上也有点像利用正常的子传父闭包特性实现） class App extends Component { render() { return ( &lt;div> {/* render是自定义的属性名，但是我们一般都定义为render */} &lt;A render={(name) => &lt;B name={name} />} /> &lt;/div> ); } } class A extends Component { state = { name: 'Allen' } render() { return ( &lt;div> I am A {this.props.render(this.state.name)} &lt;/div> ); } } class B extends Component { render() { return ( &lt;div> I am B &lt;br /> {this.props.name} &lt;/div> ); } } 由此，我们也可以是实现作为插槽的父子组件数据传递了 在Vue中，以上被称为slot技术。 错误边界（react16以上） 由于某些不可控因素，代码错误、后端数据问题、服务器崩溃、返回数据undefined等 而ErrorBoundary，不要让一个子组件的错误，影响到整个组件都无法呈现 我们之前学习过 getDerivedStateFromProps钩子（新钩子），这一次是 我们使用 getDerivedStateFromError处理错误边界 getDerivedStateFromError： 如果该组件的子组件出现任何的报错，都会调用这个钩子，并携带错误信息作为参数 它必须返回一个状态对象，只能捕获后代组件生命周期产生的错误（包括render） getDerivedStateFromError 经常搭配另外一个不太常用的 钩子 componentDidCatch 一起使用 class App extends Component { state = { hasError: '' //用于表示子组件是否产生错误 } // 在出错组件的父组件进行处理 getDerivedStateFromError static getDerivedStateFromError(err) { return { hasError: err } } // 统计子组件错误次数，反馈给服务器，用于通知编码人员bug的解决： componentDidCatch() { console.log(); } render() { return ( &lt;div> I am App {/* 不过在dev环境下其实还是会出现网页整体报错，但是打包后就不会了 0.0 */} {this.hasError ? &lt;h2>当前网络不稳定，请稍后重试&lt;/h2> : &lt;A />} &lt;/div> ); } } Server Component官方提出草案的目的是解决接口请求分散在各个组件中带来的子组建的数据请求，需要等待父组件请求完成渲染子组件时才能开始请求的数据请求队列问题 方案大概是将React拆分为Server组件和Client的组件，然而和SSR不同的地方在于Server Component返回的是序列化的组件数据（JSX），而SSR返回的是html 与此同时，仍然会带来一些问题（取自魔法师卡颂，卡老师） 1.接口返回，会额外多出冗余的组件结构 2.服务器成本问题，在目前行业大势观看，服务器的成本还是比较昂贵的，很多为了节约服务器成本，将逻辑计算下移至客户端处理 3.心智负担，ServerComponent无法使用useState、useEffect等hooks forwardRef有时候父组件需要拿到子组件的ref组件，进行直接操作（虽然我们要尽量避免这种情况），此时通过父子组件通信的方式，可能会比较麻烦（虽然可以实现，比如用props穿回调函数），从事我们可以使用forwardRef import React, { forwardRef, useRef } from 'react' const Child = forwardRef((props, ref) => { return ( child ) }) export default function Index() { const text = useRef(null) return ( father { console.log(text); }}>click ) } 判断是否为React组件import React, { isValidElement } from 'react'; console.log(isValidElement(xxxx)); // true 13.React优化PureComponent &amp; memo问题一：执行setState的时候，即使state未发生改变，也会重新render（不过类式组件中redux的更新也由此得益） 问题二：React中使用父子组件嵌套时，父组件使用props传入state的状态，发生 setState 时state改变，setState触发 render()，而传入的props也随之改变，子组件也发生 render()；但是如果没有传入props，父组件发生 render()更新时，因为子组件也放在 render()里面，所以子组件即使没什么要改的地方，也不得不随着父组件一起 render()更新 造成原因： Component中的shouldComponentUpdate()总是返回true（拉闸开门） 在我们研究中，可以判断： shouldComponentUpdate(nextProps, nextState) { console.log(this.props, this.state); //当前组件的props、state console.log(nextProps, nextState); //发生更新后的props、更新后的state return !this.props.属性 === nextProps.属性 &amp;&amp; !this.state.属性 === nextState.属性 } 在开发中解决： 对于类式组件 我们可以使用React带的 PureComponent，它能帮我们自动重写阀门这个逻辑 import React, { PureComponent } from 'react' 然后定义类式组件时，原本继承Component -&gt; 继承PureComponent export default class App extends PureComponent { //xxx } 但实际上 PureComponent 有些许小瑕疵（类似于redux小bug）,它在底层也是做一个浅比较（Object.is()），如果只是数据对象内部数据变了，shouldComponentUpdate()返回false changeSomething = () => { let obj = this.state; obj.username = 'Bruce'; this.setState(obj); //地址没有改变，不发生变化 // this.setState({ username: 'Bruce' }) 这个也不顶用了 // 之前不推荐使用push、unshift const { student } = this.state; student.push('Olivia'); this.setState({ student: student }); ////地址没有改变，不发生变化 } 正确写法： this.setState({ username:'Bruce', student: ['Olivia', ...student] }); 亦或是需要深层比较的时候，自行实现 shouldComponentUpdate 对于函数式组件 我们此时无法使用到PureComponent，我们可以使用 React.memo 他接收一个组件作为参数返回一个新组件，新组件仅检查props变更，会将当前props和上一次props进行浅层比较，相同则阻止渲染 所以对于函数式组件来说，React.memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState，useReducer 或 useContext 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。 const ChildComponent = React.memo(function MyComponent(props) { /* 使用 props 渲染 */ }); React.memo 为高阶组件。 如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。 默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。 function MyComponent(props) { /* 使用 props 渲染 */ } function areEqual(prevProps, nextProps) { /* 如果把 nextProps 传入 render 方法的返回结果与 将 prevProps 传入 render 方法的返回结果一致则返回 true， 否则返回 false */ } export default React.memo(MyComponent, areEqual); 此方法仅作为性能优化的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。 注意 与 class 组件中 shouldComponentUpdate() 方法不同的是，如果 props 相等，areEqual 会返回 true；如果 props 不相等，则返回 false。这与 shouldComponentUpdate 方法的返回值相反。 高阶组件是参数为组件，返回值为新组件的函数。 useCallback官方： 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。 这里引入一个例子 function Foo() { const [count, setCount] = useState(0); const handleClick() { console.log(`Click happened with dependency: ${count}`) } return &lt;Button onClick={handleClick}>Click Me&lt;/Button>; } 这里每次渲染，都会造成handleClick重新创建，给Button是不同的引用，然后Button也跟着渲染。 function Foo() { const [count, setCount] = useState(0); const memoizedHandleClick = useCallback( () => console.log(`Click happened with dependency: ${count}`), [count], ); return &lt;Button onClick={memoizedHandleClick}>Click Me&lt;/Button>; } 此时在依赖项count不变的情况下，他会返回相同的引用，避免Button无意义的重复渲染。 源码赏析 function mountCallback&lt;T>(callback: T, deps: Array&lt;mixed> | void | null): T { const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; hook.memoizedState = [callback, nextDeps]; return callback; } function updateCallback&lt;T>(callback: T, deps: Array&lt;mixed> | void | null): T { const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const prevState = hook.memoizedState; if (prevState !== null) { if (nextDeps !== null) { const prevDeps: Array&lt;mixed> | null = prevState[1]; if (areHookInputsEqual(nextDeps, prevDeps)) { return prevState[0]; } } } hook.memoizedState = [callback, nextDeps]; return callback; } useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。 useMemoconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]); 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。 关于useCallback和useMemo更深一侧的了解（利弊关系）可以查看https://jancat.github.io/post/2019/translation-usememo-and-usecallback/，实质上可以当成对时间、空间的分配置换关系来看就行了 使用场景： 一、应该使用 useMemo 的场景 保持引用相等 对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo。 自定义 Hook 中暴露出来的 object、array、函数等，都应该使用 useMemo 。以确保当值相同时，引用不发生变化。 使用 Context 时，如果 Provider 的 value 中定义的值（第一层）发生了变化，即便用了 Pure Component 或者 React.memo，仍然会导致子组件 re-render。这种情况下，仍然建议使用 useMemo 保持引用的一致性。 成本很高的计算 比如 cloneDeep 一个很大并且层级很深的数据 二、无需使用 useMemo 的场景 如果返回的值是原始值： string, boolean, null, undefined, number, symbol（不包括动态声明的 Symbol），一般不需要使用 useMemo。 仅在组件内部用到的 object、array、函数等（没有作为 props 传递给子组件），且没有用到其他 Hook 的依赖数组中，一般不需要使用 useMemo。 源码赏析 function mountMemo&lt;T>( nextCreate: () => T, deps: Array&lt;mixed> | void | null, ): T { const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const nextValue = nextCreate(); hook.memoizedState = [nextValue, nextDeps]; return nextValue; } function updateMemo&lt;T>( nextCreate: () => T, deps: Array&lt;mixed> | void | null, ): T { const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const prevState = hook.memoizedState; if (prevState !== null) { // Assume these are defined. If they're not, areHookInputsEqual will warn. if (nextDeps !== null) { const prevDeps: Array&lt;mixed> | null = prevState[1]; if (areHookInputsEqual(nextDeps, prevDeps)) { return prevState[0]; } } } const nextValue = nextCreate(); hook.memoizedState = [nextValue, nextDeps]; return nextValue; } useCallback使用场景 + 死循环https://segmentfault.com/a/1190000020108840 死循环的出现（链接里面的两个例子）： 子组件的渲染依赖父组件传递的函数，而函数被在被调用的时候会触发父组件的渲染，会导致父组件内，该函数的引用发生改变 -&gt; 传入子组件函数发生改变，函数再次调用 -&gt; 死循环 函数依赖自身自家组件的state（加上usecallback，但依赖列表也要添加自身的state），state发生改变，引用再次改变 -&gt; 再调用，再改变，再调用，再改变。 解决方法： 将方法传递给子组件的时候包一层useCallback 自定义hook 14.React 17 | 18新增特性一览（主要的，也可以说是我所关注的） （1）在React 16和更早的版本中，React将对大多数事件执行document.addEventListener()。 React 17将在后调用rootNode.addEventListener()。（也就是将事件委托从 document 切换为 root） 一张图明示两者的差异 )（2) React 17支持新的JSX转换。我们还将对它支持到React 16.14.0，React 15.7.0和0.14.10。需要注意的是，这是完全选择启用的，您也不必使用它。之前的JSX转换的方式将继续存在，并且没有计划停止对其支持。 更多：https://juejin.cn/post/6885881513741647886 React18： 从带有 createRoot 的 React 18 开始，所有更新都将自动批处理，无论它们来自何处。（也就是说不用我们自己） 这意味着timeouts、promises、native events处理程序或任何其他事件内的更新将以与 React 事件内的更新相同的方式进行批处理。我们希望这会导致更少的渲染工作，从而在您的应用程序中获得更好的性能 ReactDOM.createRoot(rootElement).render(&lt;App />); 通常，批处理是安全的，但某些代码可能依赖于在状态更改后立即从 DOM 中读取某些内容。对于这些用例，您可以使用 ReactDOM.flushSync() 选择退出批处理： import { flushSync } from 'react-dom'; // Note: react-dom, not react function handleClick() { flushSync(() => { setCounter(c => c + 1); }); // React 现在已经更新了 DOM flushSync(() => { setFlag(f => !f); }); // React 现在已经更新了 DOM } 对于之前用于异步批处理的 unstable_batchedUpdates： 这个 API 在 18 中仍然存在，但不再需要它了，因为批处理是自动发生的。我们不会在 18 中删除它，尽管在流行的库不再依赖于它的存在之后，它可能会在未来的主要版本中被删除。 https://juejin.cn/post/6998763055685304356 15.React其他PortalPortal提供了一个最好的在父组件包含DOM结构层次外的DOM节点渲染组件的方法（说人话就是，把组件渲染到root之外），这里的container是指挂载的位置 ReactDOM.createPortal(child, container) 应用场景：组件想要作为提示窗口覆盖整个窗口（fixed），但是可能因为父盒子使用了定位+z-index，导致了组件本身定位的z-index再大，也无法覆盖到全局 此时在写组件时，我们将其写为Portal组件 import { createPortal } from 'react-dom' export default function Dialog() { return createPortal( Dialog, document.body ) } 虽然通过Portal渲染的组件在父组件盒子之外，但是渲染的dom节点仍然在React元素树上，在那个dom元素上的点击事件仍然能在dom树中监听到（仍然会冒泡冒到父节点上） React.StrictModeStrictMode 是一个用以标记出应用中潜在问题的工具。就像 Fragment ，StrictMode 不会渲染任何真实的UI。它为其后代元素触发额外的检查和警告。 但是有个小坑：React.StrictMode 多次调用问题，导致这个函数组件被调用了两次。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Nextjs","slug":"Nextjs","date":"2022-06-26T16:02:27.806Z","updated":"2022-07-17T12:34:09.159Z","comments":true,"path":"2022/06/27/nextjs/","link":"","permalink":"https://taylor12138.github.io/2022/06/27/nextjs/","excerpt":"","text":"1.Next.js开端英文官网：https://nextjs.org/ 中文官网：https://www.nextjs.cn/docs/getting-started 搭建项目 yarn create next-app 或者 npx create-next-app@latest 使用Nextjs搭建SSR优点： 搭建轻松 自带数据同步 SSR 丰富插件 灵活配置 2.路由next.js是约定式路由直接在pages文件夹下对应的路由页面 比如我要新建一个detail页面（localhost:3000/detial） 路由跳转Link方式 import Link from \"next/link\"; export default function Home() { return ( &lt;Link href=\"/detail/1\"> &lt;a>Go to pages/detail/1&lt;/a> &lt;/Link> &lt;/div> ); } 连接到动态路径： //方法一 &lt;Link href={`/blog/${encodeURIComponent(post.slug)}`}> &lt;a>{post.title}&lt;/a> &lt;/Link> //方法二 &lt;Link href={{ pathname: '/blog/[slug]', query: { slug: post.slug }, }} > &lt;a>{post.title}&lt;/a> &lt;/Link> 客户端导航 该Link组件支持在同一个 Next.js 应用程序中的两个页面之间进行客户端导航。 客户端导航意味着使用 JavaScript进行页面转换，这比浏览器完成的默认导航要快。 这是您可以验证的简单方法： 使用浏览器的开发者工具将backgroundCSS 属性更改&lt;html&gt;为yellow。 单击链接可在两个页面之间来回切换。 您会看到黄色背景在页面转换之间持续存在。 编程式导航 使用一个useRouter，和React中的useHistory用起来差不多 要访问 React 组件中的router对象，您可以使用useRouter或withRouter。 一般来说，我们建议使用useRouter. import React from \"react\"; import { useRouter } from \"next/router\"; export default function Detial() { const router = useRouter(); const linkToHome = () => { router.push(\"/\"); }; return ( &lt;div> &lt;button onClick={linkToHome}>点击跳转到首页&lt;/button> &lt;/div> ); } 嵌套路由对于多级嵌套路由，可以直接在该路由文件夹下 （二级路由）：直接写路由名 + js文件 （嵌套多级路由）：新建文件夹，文件夹名为路由名，再新建index.js文件 pages/blog/first-post.js→/blog/first-post pages/dashboard/settings/username.js→/dashboard/settings/username 动态路由要匹配动态段，您可以使用括号语法。这允许您匹配命名参数。 pages/blog/[slug].js → /blog/:slug (/blog/hello-world) pages/[username]/settings.js → /:username/settings (/foo/settings) pages/post/[...all].js → /post/* (/post/2020/id/title) 路由传参nextjs传参方式一共两种： 动态路由传参 对于params传参方式，新建文件 [自定义参数名].js（可见上图），此时通过url路由地址导向，就可以获取对应的params参数（依然是通过useRouter的hook） const id = 1 // Link as内是参数 import Link from 'next/link'; &lt;Link href={`/details/${id}`>&lt;a>跳转&lt;/a>&lt;/Link> // router import { useRouter } from 'next/router'; const router = useRouter(); router.push(`/details/${id}`); // details接收参数ID import { useRouter } from 'next/router'; export default function details() { const router = useRouter(); const { id }: any = router.query; console.log(id); } query传参 // Link import Link from 'next/link'; &lt;Link href={{ pathname: '/b', query: { name: '张三', age: '18', work: '前端开发' } }}>&lt;a>跳转&lt;/a>&lt;/Link> // router import { useRouter } from 'next/router'; const router = useRouter(); router.push('/first?name=张思学&amp;age=18&amp;work=前端开发'); // 页面接收参数 import { useRouter } from 'next/router'; const router = useRouter(); const { name, age, work }: any = router.query; console.log(name, age, work); 接收后端服务对于后端数据接收，要在pages/api文件夹下进行对后端接口的数据获取（作为node中间件） 官方：pages/api 目录下的任何文件都将作为 API 端点映射到 /api/*，而不是 page。这些文件只会增加服务端文件包的体积，而不会增加客户端文件包的大小。 此时最好设定与pages页面一一对应的文件命名格式进行获取，比如对于 detail/[id].js页面对应的就是 api文件夹下 detail/[id].js的api //api/detail/[id].js const fn = (req, res) => { res.status(200).json({ name: \"Allen\" }); }; export default fn; //detail/[id].js import React, { useEffect } from \"react\"; import { useRouter } from \"next/router\"; export default function Detial() { const router = useRouter(); const { id } = router.query; useEffect(() => { id &amp;&amp; fetch(`/api/detail/${id}`) .then((res) => res.json()) .then((json) => { console.log(json); }); }, [id]); return &lt;div>Detialid: {id}&lt;/div>; } 当然，我们也可以尝试在http://localhost:3000/api/hello访问它。你应该看到`{&quot;text&quot;:&quot;Hello&quot;}`。注意： req是http.IncomingMessage的一个实例，以及一些您可以在此处看到的预构建中间件。 res是http.ServerResponse的一个实例，以及一些您可以在此处看到的帮助函数。 捕获所有后端服务API 的路由通过在方括号内添加三个英文句点 (...) 即可将 API 路由扩展为能够捕获所有路径的路由。例如： pages/api/post/[...slug].js 匹配 /api/post/a，也匹配 /api/post/a/b、/api/post/a/b/c 等。 注意：slug 并不是必须使用的，你也可以使用 [...param] 路由捕获顺序和规则 预定义的 API 路由优先于动态 API 路由，而动态 API 路由优先于捕获所有 API 的路由。看下面的例子： pages/api/post/create.js - 将匹配 /api/post/create pages/api/post/[pid].js - 将匹配 /api/post/1, /api/post/abc 等，但不匹配 /api/post/create pages/api/post/[...slug].js - 将匹配 /api/post/1/2, /api/post/a/b/c 等，但不匹配 /api/post/create、/api/post/abc 浅路由浅路由允许您更改 URL 而无需再次运行数据获取方法，包括getServerSideProps、getStaticProps和getInitialProps. 您将收到更新pathname的和query通过router对象（由useRouteror添加withRouter），而不会丢失状态。 要启用浅层路由，请将shallow选项设置为true。 可以看官方文档，写的够明白了：https://www.nextjs.cn/docs/routing/shallow-routing 路由事件可以看成vue的路由守卫（路由生命周期函数） routeChangeStart 路由开始发生变化 routeChangeComplete 路由发生变化之后 beforeHistoryChange history模式下路由发生变化 routeChangeError 路有变化发生错误的时候 hashChangeStart hash开始发生变化 hashChangeStart hash开始发生变化 注意：这里需要把路由事件监听放在useEffect里，每次卸载页面的时候把监听也卸载掉，否则每次页面跳转都会创建新的事件监听，会越来越多 import React, { useEffect } from \"react\"; import { Router } from \"next/dist/client/router\"; useEffect(() => { Router.events.on(\"routeChangeStart\", (...args) => { console.log(\"routeChangeStart参数\", ...args); }); }, []); return &lt;div>DEtial&lt;/div>; } 3.服务端渲染getInitialPropsgetInitialProps在页面中启用服务器端渲染并允许您进行初始数据填充，这意味着发送页面时已从服务器填充了数据。这对SEO尤其有用；所以getInitialProps用于异步获取一些数据，然后填充props. 个人感觉有点react-redux中使用connect方法传入ui组件第一个参数mapDispatchToProps的味道在里面 推荐： getStaticProps 或 getServerSideProps。 如果你使用的是 Next.js 9.3 或更高版本，我们建议你使用 getStaticProps 或 getServerSideProps 来替代 getInitialProps。 function Page({ stars }) { return &lt;div>Next stars: {stars}&lt;/div> } Page.getInitialProps = async (ctx) => { const res = await fetch('https://api.github.com/repos/vercel/next.js') const json = await res.json() return { stars: json.stargazers_count } } export default Page SSG（getStaticProps）对于每个用户基本一致的静态页面，可以使用SSG（构建build时渲染页面） 优点：这种方式可以解决白屏问题、SEO 问题 缺点：所有用户看到的都是同一个页面，无法生成用户相关内容 效果：如果动态内容与用户无关，那么可以提前静态化，通过 getStaticProps 可以获取数据静态内容+数据(本地获取) 就得到了完整的页面，代替了之前的 静态内容+动态内容(AJAX 获取) 实际用例： 营销页面 博客文章和个人简历 电商产品列表 帮助和文档 实现：通过getStaticProps 获取 数据 import {getPosts} from '../../lib/posts'; export default function Home(props) { console.log(props); return ( &lt;div className={styles.container} /> ); } export const getStaticProps = async (context) => { const posts = await getPosts(); return { props: { posts: [{ name: \"allen\" }, { name: \"mikasa\" }, { name: \"armin\" }], }, }; }; /*typescript export const getStaticProps: GetStaticProps = async (context) => { // ... } */ 静态化的时机 环境 在 开发环境 ，每次请求都会运行一次 getStaticProps 这是为了方便你修改代码重新运行 在 生产环境，getStaticProps 只在 build 是运行一次，这样可以提供一份 HTML 给所有的用户下载 注意：您不应该使用fetch()在getStaticProps. 相反，直接导入 API 路由中使用的逻辑。您可能需要针对这种方法稍微重构您的代码。 从外部 API 获取很好！ getStaticPaths该方法适用于：每个页面路径都依赖于外部数据的情况 而且如果页面具有动态路由（比如 [id].js）（文档）并使用getStaticProps它，则需要定义必须在构建时呈现为 HTML 的路径列表。 如果您导出从使用动态路由的页面async调用的函数getStaticPaths，Next.js 将静态预渲染所有由getStaticPaths. import Layout from '../../components/layout' export default function Component() { return &lt;Layout>...&lt;/Layout> } export async function getStaticPaths() { return { paths: [ { params: { ... } } // 返回的每个paths数组中每一个元素都是一个对象，且必须有params属性 ], fallback: true, false, or 'blocking' // See the \"fallback\" section below }; } export async function getStaticProps({ params }) { // Fetch necessary data for the blog post using params.id } 然后getStaticPaths的返回值将作为参数传递给getStaticProps 详情可以看官网对path、fallback属性（为加载完成时展示fallback pages）的介绍https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticpaths-static-generation 注意：不要在getStaticProps 或者 getStaticPaths对后端路由服务的api（也就是上方提及到的接收后端服务）发请求，你应该把服务端定死的代码直接写到getStaticProps 或者 getStaticPaths中，毕竟它们俩只能在服务端跑，这意味着我们可以编写诸如直接数据库查询之类的代码 SSR（getServerSideProps）首屏渲染快，但是拿数据的话还是等到用户发送请求后再去后端拿去数据（请求时渲染页面），生成相应html在返回给客户端 实现：通过getSeverSideProps 获取 数据 //服务器响应请求后获取浏览器信息，返回给前端展示 export const getServerSideProps: GetServerSideProps = async (context) => { const headers:IncomingHttpHeaders = context.req.headers; const browser = headers['user-agent']; return { props: { browser } }; }; 参考文章https://zhuanlan.zhihu.com/p/341229054 nextjs优化(1)自身优化图片优化import Image from \"next/image\"; 对图片的优化： 将图片转换为 渐进式图片（先显示一个极小的背景图，使用css的filter属性模糊化），等到图片加载完成再替换为真正的图片 本地图片没设置宽高也不会有布局偏移问题（本身使用一个SVG带有height和width进行占位，使得周边的布局不会当图片加载出来的时候发生位置偏移） 默认加上srcset属性来适配不同的 devicePixelRatio （像素比）的屏幕，显示和加载1倍图 or 2倍图 默认返回压缩后的图片（type：webp） 支持懒加载 支持给图片设置优先级 具体细节可以看https://github.com/findxc/blog/issues/68 (2)开发者定义的优化next异步懒加载使用懒加载方法：同 《PC&amp;移动端网页特效(JS)》中阐述到的，直接import即可 使用懒加载组件： import React, { useState } from \"react\"; import dynamic from 'next/dynamic' const More = dynamic(import('./more')) export default function Detial() { return ( &lt;div> &lt;More>&lt;/More> &lt;/div> ); } 自定义head优化SEO如果我们想要修改网页元数据，我们可以使用 Head 组件 title: 一般有两种方法：每个页面都定义一个title，或者全局title import React from \"react\"; import Head from \"next/head\"; export default function Header() { return ( &lt;div> &lt;Head> &lt;title>撒撒给，Allen&lt;/title> &lt;meta charSet=\"utf-8\">&lt;/meta> &lt;/Head> &lt;/div> ); } 全局的话就是自己封装MyHead组件，然后再每个组件内部引用即可","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"HTML5的基本属性","slug":"HTML5的基本属性","date":"2022-06-26T08:39:45.813Z","updated":"2023-06-12T07:39:02.288Z","comments":true,"path":"2022/06/26/html5-de-ji-ben-shu-xing/","link":"","permalink":"https://taylor12138.github.io/2022/06/26/html5-de-ji-ben-shu-xing/","excerpt":"","text":"1.基本标签介绍&lt;html&gt;&lt;/html&gt;根标签 &lt;head&gt; &lt;/head&gt; 文档头部 &lt;title&gt; &lt;/title&gt; 文档标题 &lt;body&gt;&lt;/body&gt; 文档主体 页面解析顺序： （1）先解析head标签中的代码，head标签中会包含一些引用外部文件的代码，就会开始下载这些被引用的外部文件 当遇到script标签的时候浏览器暂停解析（相关脚本会立即下载并执行），将控制权交给JavaScript引擎（解释器）如果script标签引用了外部脚本，就下载该脚本，否则就直接执行，执行完毕后将控制权交给浏览器 当遇到一个CSS文件时，解析也可以继续进行 （2）然后解析body中的代码（如果此时head中引用的外部文件没有下载完，将会继续下载） 如果此时遇到body标签中的script，同样会将控制权交给JavaScript引擎来解析JavaScript，解析完毕后将控制权交还给浏览器渲染引擎。 （3）当body中的代码全部执行完毕、并且整个页面的css样式加载完毕后，css会重新渲染整个页面的html元素。reflow 因此，script标签放靠后比较好，此时操作dom元素才能正常操作，还能保证页面正常加载出来，如果你想放在开头，可以配合 window.onload就可以放在任意位置 页面具体渲染过程可以看MDN的官方文档https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work 这个链接说明也是我们面试常见问题！（输入url到网页渲染完毕发生了什么） 2.在vscode里使用英文“！”可以直接生成基本结构ctrl+“+”可以放大（写代码）页面 &lt;!DOCTYPE html&gt; 这是我们一直放在 HTML 文件第一行的文档类型（doc-type）声明。你可能认为这个信息是多余的，因为浏览器已经知道响应的 MIME 类型是text/html; 但在 Netscape/Internet Explorer 时代，浏览器有一项艰巨的任务是确定使用哪种 HTML 标准来呈现来自多个竞争版本的页面。（也就是说这是用于确立h5标准的） &lt;html lang=&quot;zh-CN&quot;&gt; (中文) &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;h1&gt;&lt;/h1&gt;---&lt;h6&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; &lt;br /&gt;&lt;strong&gt;&lt;/strong&gt;(字体加粗)&lt;del&gt;&lt;/del&gt;（字体删除线） &lt;em&gt;&lt;/em&gt; 标签告诉浏览器把其中的文本表示为强调的内容 meta标签meta标签永远在head元素内部，用于提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 3.盒子类似于微信小程序的view，用于布局 &lt;div&gt;&lt;/div&gt; //大盒子，独占一整行 &lt;span&gt;&lt;/span&gt; //小盒子 无法设置高度和宽度 4.img&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; height=&quot;&quot; width=&quot;&quot;&gt; srcset属性：根据设备dpr设置x倍图片 &lt;img width=\"320\" src=\"bg@2x.png\" srcset=\"bg.png 1x;bg@2x.png 2x\"/> 微信小程序是image alt为图片无法加载时显示的文字，title为鼠标移到图片上显示的文字提示, 但是对于height和width,一般只修改其中一个，另外一个就会跟着改变 src种绝对路径 \\ 相对路径 / （图片设置宽高一般设置为width：100%，heigh：100%，可以自动适应盒子） 在nextjs中 Regardless of the layout mode used, the Image component will have a consistent DOM structure of one &lt;img&gt; tag wrapped by exactly one &lt;span&gt;. For some modes, it may also have a sibling &lt;span&gt; for spacing. These additional &lt;span&gt; elements are critical to allow the component to prevent layout shifts. 也就是说一般一个img标签他都用span包裹 图片禁止拖拽&lt;img src=\"https://picsum.photos/360/460?random=1\" draggable=\"false\"> 5.超链接&lt; a&gt;&lt;a href=&quot;&quot; target=&quot;&quot; &gt;文本或者图像&lt;/a&gt; 类似于微信小程序中的navigator, href用于指定目标的url，可打开内部，外部链接 target用于来链接打开方式，默认_self _blank为在新窗口打开 锚点链接：设置href=#名字，如&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;可以快速跳转到第二集的页面位置 ​ 在于目标位置标签里添加id=”two” 像对于vue（router-link）、react（Link）这类的框架，他们实现的声明式路由其实差不多是这种方式（hash）： &lt;a href=\"#home\">首页&lt;/a> &lt;a href=\"#about\">关于&lt;/a> 只不过对于vue、react他们还处理了通过url实现跳转时这个a链接自动高亮（react的 NavLink ），实现的路径和跳转标签的绑定（原理：window.onhashChange事件， window.addEventListener(&quot;hashchange&quot;, fn)监听回调 ） &lt;a href=&quot;&quot; title=&quot;&quot;&gt;移动到链接时会出现提示框 一般情况下，a如果包含有宽度的盒子，a需要转换为块级元素 &lt;a href=&#39;javascript:;&#39;&gt;xx&lt;/a&gt; 直接添加javascript:; 可以阻止链接跳转 6.特殊字符空格：&amp;nbsp (因无法识别大于号和小于号) 小于号：&amp;lt 大于号：&amp;gt 7.表格（用于数据）&lt;table&gt; ​ &lt;tr&gt; ​ &lt;td&gt;单元格文字&lt;/td&gt;或者&lt;th&gt;&lt;/th&gt; ​ &lt;/tr&gt; &lt;/table&gt; table是表格，tr是行，td是单元格（th可充当表头单元格）。还可以加入&lt;thead&gt;和 &lt;tbody&gt;来帮助CSS区分表格结构 单元格合并使用colspan=”（列）想要合并的单元个数”或者rowspan=”（行）想要合并的单元个数”，再删除多余的td（或th） 8.列表（用于布局）无序列表ul里只能放li标签，所以其他容器放li里面就可以 &lt;ul&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ul&gt; 有序列表(规则同无序)&lt;ol&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ol&gt; 自定义列表(同上)&lt;dl&gt; ​ &lt;dt&gt;名词1&lt;/dt&gt; ​ &lt;dd&gt;名词1解释1&lt;/dd ​ &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 注意（li默认本身没有margin） list-style-type 用于设置不同列表列表项的样式。 无序列表常使用： ul { list-style-type:circle; /* 每一项前都是圆圈 */ } ul { list-style-type:square; /* 每一项前都是正方形 */ } ul { list-style-type:none; /* 去除圆点 */ } 有序列表也可以用 list-style-type 来设置列表项 ol { list-style-type:upper-roman; /* 每一项前面都是大写罗马数字 */ } ol { list-style-type:lower-alpha; /* 每一项前都是小写字母 */ } li标签包含a标签实际开发中导航栏不会直接用a标签，而是用li（列表）包含a标签的做法，1.语义更加清晰 2.故意对其关键字有被搜索引擎降权的风险 导航栏不给宽度是不想定死，让其自动适应 9.表单（用于填写信息，用户注册）&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot; maxlength=&quot;&quot;&gt;&lt;/form&gt;表单域 url地址为处理表单数据的地址，method有get，post 表单具有默认的提交行为，默认是同步的，同步表单提交，浏览器会锁死（转圈儿）等待服务端的响应结果。 表单的同步提交之后，无论服务端响应的是什么，都会直接把响应的结果覆盖掉当前页面。 表单中需要提交的表单控件元素必须有name属性 表单元素&lt;input&gt;&lt;!-- 通用提交按钮 --> &lt;input type=\"submit\" value=\"Submit Form\" > &lt;!-- 自定义提交按钮 --> &lt;button type=\"submit\">Sunbmit Form &lt;/button> &lt;!-- 图片提交按钮 --> &lt;input type=\"image\" src=\"graphic.gif\" > type可以为text，number，password，button，reset（重置）submit（用于提交），radio（单选框，必须添加name才能使用），checkbox（复选框）等 科普：submit是button的一个特例，用于处理大量表单数据，而此时input里的name是表单的名称，需要填写name才能提交表单数据；亦或者input放在form标签里面 value为输入框内的提示语||充当提交给后台的数据||显示的文字 placeholder=&quot;Search...&quot; 显示提示的文字 用于单选和复选的默认属性 checked checked=&quot;checked&quot;选中 checked=&quot;真值&quot; maxlength=“最大值” 标签元素&lt;Label&gt;&lt;label for=&quot;sex&quot;&gt;男 &lt;/label&gt; label用于增加用户体验，点击范围内即可选中某input（一般一个label绑定一个input） &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; label中的for对应input里的id 或者把input标签放在label里面也能达到同样的效果，此时仍然需要for和id（隐式的联系） &lt;!-- 可以从体验感感觉到两者的不同 --> &lt;form> &lt;label for=\"male\">Male&lt;/label> &lt;input type=\"radio\" name=\"sex\" id=\"male\" /> &lt;br /> &lt;input type=\"radio\" name=\"sex\" id=\"female\" /> &lt;/form> 其实还有 defaultCheck： defaultCheck 只在初次渲染时生效，更新数据时不受控制，但是允许后续你通过点击手动更改它的选定 checked 始终受到控制，必须通过绑定 onchange 事件来控制选中情况 总结defaultChecked、defaultValue 只在初始渲染时由状态控制，之后更新不再跟状态有关系，而checked、value在全过程中都受状态控制 开发中更多的是使用checked + onchange 组合 表单元素&lt;select&gt; 下拉列表&lt;select> &lt;option value=\"1\">选项1&lt;/option> &lt;option value=\"2\">选项2&lt;/option> &lt;!-- 默认选中选项3 --> &lt;option selected=\"selected\">选项3&lt;/option> ... &lt;select> 表单元素&lt;textarea&gt; 文本域textarea 可以写大量文字（个人介绍，评论） 输入的评论作为element.value &lt;textarea> 文字 &lt;/textarea> //如果没文字textarea必须写到同一行 按钮 buttontype属性：button的类型。可选值： submit: 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。 reset: 此按钮重置所有组件为初始值。 button: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。 menu: 此按钮打开一个由指定``元素进行定义的弹出菜单。 10 元素分类块元素，独占一行，是一个容器或者盒子如 &lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &lt;h1&gt; &lt;h2&gt;等 但&lt;p&gt; &lt;h&gt; 不能内置块级元素，只能放文字行元素，不能设置宽高，只能容纳文本或者其他行内元素 &lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;span&gt; 等 但是&lt;a&gt;不能再放&lt;a&gt; 特殊情况&lt;a&gt;可以转块级 &lt;b&gt;是粗文本行内块元素，能在同一行，也能设置宽高，但是行内块之间有缝隙 &lt;input/&gt; &lt;img/&gt; &lt;td&gt; &lt;button&gt;行内元素和块级元素的区别块级元素： 会独占一行,默认情况下,其宽度自动填满其父元素宽度 块级元素可以设置width,height属性. 块级元素即使设置了宽度,仍然是独占一行. 块级元素可以设置margin和padding属性. 块级元素对应于display:block. 行内元素 不会独占一行,相邻的行内元素会排列在同一行里,直到一行排不下,才会换行 行内元素设置width,height属性无效，它的长度高度主要根据内容决定. 行内元素的margin和padding属性,水平方向的padding-left,padding-right,margin-left,margin- right都产生边距效果,但竖直方向的padding-top,padding-bottom,margin-top,margin-bottom却不 会产生边距效果，即水平有效，垂直无效 行块的转换详情请看CSS里的《行块转换》 h5标签推荐网址： http://www.w3school.com.cn/ http://developer.mozilla.org/zh-CN/ 11.HTML5新特性新增标签i9以上版本浏览器才支持 &lt;header>: 头部标签 &lt;nav>: 导航标签 &lt;article>: 内容标签 &lt;section>: 定义文档某个区域 &lt;aside>: 侧边栏标签 &lt;footer>: 尾部标签 &lt;!-- 实质上都和div差不多，只是语义化了而已，主要针对搜索引擎 但是在i9中，需要把这些元素转换成块级元素，所以移动端更喜欢使用这些标签--> 新增&lt;audio&gt;，&lt;video&gt;新增&lt;audio&gt;音频，&lt;video&gt;视频，抛弃flash等插件功能 video尽量使用mp4格式，谷歌把音频，视频自动播放禁止了，audio和video属性用法差不多 &lt;video src=\"文件地址\" autoplay=\"autoplay\"自动播放 谷歌需要添加muted=\"muted\"（静音播放）,才能实现自动播放 controls=\"controls\"添加播放组件 loop=\"loop\"循环播放 poster=\"图片地址\" 视频封面显示图片 >&lt;/video> 遇到不兼容的情况可以写成 &lt;video width=\"320\" height=\"240\"> &lt;source src=\"\" type=\"video/mp4\"> &lt;source src=\"\" type=\"video/ogg\"> &lt;/video> const video = document.createElement('video'); video.crossOrigin = 'anonymous'; //自动播放 video.autoplay = false; //是否静音 video.muted = true; height 视频显示区域的高度，单位是 CSS 像素（仅限绝对值；不支持百分比）。 loop 布尔属性；指定后，会在视频播放结束的时候，自动返回视频开始的地方，继续播放。 muted 布尔属性，指明在视频中音频的默认设置。设置后，音频会初始化为静音。默认值是 false, 意味着视频播放的时候音频也会播放。 playsinline 布尔属性，指明视频将内联（inline）播放，即在元素的播放区域内。请注意，没有此属性并不意味着视频始终是全屏播放的。 poster 海报帧图片 URL，用于在视频处于下载中的状态时显示。如果未指定该属性，则在视频第一帧可用之前不会显示任何内容，然后将视频的第一帧会作为海报（poster）帧来显示。 preload 该枚举属性旨在提示浏览器，作者认为在播放视频之前，加载哪些内容会达到最佳的用户体验。可能是下列值之一： none: 表示不应该预加载视频。 metadata: 表示仅预先获取视频的元数据（例如长度）。 auto: 表示可以下载整个视频文件，即使用户不希望使用它。 空字符串: 和值为 auto 一致。每个浏览器的默认值都不相同，即使规范建议设置为 metadata。 透明视频使用video并不能直接播放出透明视频 需要用到动画（canvas（2个canvas）、webgl）来协同帮助 如上图所示，源素材向右扩充了一倍的像素，用来存储Alpha通道的数值，在客户端渲染的时候，直接使用右侧像素点的R值，除以255，就得到了0-1之间的alpha取值 例如第一个像素点， 红色：右侧的RGB值为(255,0,0) + 左侧的R值(128) ，混合之后的 RGBA = (255,0,0,128/255) ~= (255,0,0,0.5) 客户端渲染 客户端拿到视频轨道数据后，解码出每一帧图片，然后通过左边yuv+右边的yuv混合后再上屏，gl公式可理解为 gl_FragColor = vec4( texture2D(texture, vec2(vUv.x/2, vUv.y)).rgb, texture2D(texture, vec2(0.5 + vUv.x/2, vUv.y)).r ); 新增input的类型type=&quot;email&quot; type=&quot;url&quot; type=&quot;date&quot; type=&quot;number&quot; type=&quot;search&quot; type=&quot;tel&quot;(手机号码) 限制用户只能使用&quot;X&quot;类型 /*表单属性*/ &lt;input type=&quot;search&quot; required=&quot;required&quot; 填写字段不能为空 placeholder=&quot;XX&quot; 表单的提示信息 autofocus=&quot;autofocus&quot; 页面完成时自动聚焦到指定表单 autocomplete=&quot;on&quot; 打开历史记录功能，需要加上name属性，放在表单内，成功提交过，可以可选择&quot;off&quot; mutiple=&quot;multiple&quot; 选择多个文件上传 &gt;此外还有必填属性 &lt;input type=\"text\" required> 除此之外还有canvas、SVG、WebSocket，我分别在css高级、计网personnel的篇章中提及到，这里就不一一继续解释了。 12.网站的缩略图标一般使用favicon.ico作为图标，主要的浏览器都支持。 通过第三方网站将png图片转化成ico图标，如http://www.bitbug.net/ 转化成功后，在&lt;head&gt; &lt;/head&gt;之间引入代码： &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico type=&quot;XX&quot;&gt;(网页那里有代码直接copy) 在某网页的页面，在它的网址后输入”/favicon.ico” 可以直接获取它的ico 13.网站TDK三大标签优化SEOSEO是搜索引擎优化，目的为对网站深度优化，使得网站排名位于搜索引擎使用后较前的位置。 1.title网站名-网站介绍（不超过30字） 2.description简要概述网站内容 3.keywords页面关键字，搜索引擎的关注点 logo的SEO优化logo里首先放一个h1标签来提权，h1里再放一个链接，用于返回至首页，为了让搜索引擎收录我们，我们要在链接里放文字（网站名称），但是文字不要显示出来（文字大小设置为0，font-size: 0），最后给链接一个title属性 14.iframe标签iframe 元素会创建包含另外一个文档的内联框架 听说iframe标签能耗高？安全性差？还很low？我看面试有问到，（我还没用过）所以以下是选取网上我个人觉得比较有用的关于 iframe的知识点 听说你长这样？ &lt;iframe src=\"demo.html\" height=\"300\" width=\"500\" name=\"demo\" scrolling=\"auto\" sandbox=\"allow-same-origin\">&lt;/iframe> &lt;iframe src=\"地址\" frameborder=\"0\">&lt;/iframe> 还可以仿造别人的页面（假装自己做的，手动狗头） 局限1、创建比一般的 DOM 元素慢了 1-2 个数量级 iframe 的创建比其它包括 scripts 和 css 的 DOM 元素的创建慢了 1-2 个数量级，使用 iframe 的页面一般不会包含太多 iframe，所以创建 DOM 节点所花费的时间不会占很大的比重。但带来一些其它的问题：onload 事件以及连接池（connection pool） 2、阻塞页面加载 及时触发 window 的 onload 事件是非常重要的。onload 事件触发使浏览器的 “忙” 指示器停止，告诉用户当前网页已经加载完毕。当 onload 事件加载延迟后，它给用户的感觉就是这个网页非常慢。 window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 SRC 可以避免这种阻塞情况 3、唯一的连接池 浏览器只能开少量的连接到 web 服务器。比较老的浏览器，包含 Internet Explorer 6 &amp; 7 和 Firefox 2，只能对一个域名（hostname）同时打开两个连接。这个数量的限制在新版本的浏览器中有所提高。Safari 3+ 和 Opera 9+ 可同时对一个域名打开 4 个连接，Chrome 1+, IE 8 以及 Firefox 3 可以同时打开 6 个 绝大部分浏览器，主页面和其中的 iframe 是共享这些连接的。这意味着 iframe 在加载资源时可能用光了所有的可用连接，从而阻塞了主页面资源的加载。如果 iframe 中的内容比主页面的内容更重要，这当然是很好的。但通常情况下，iframe 里的内容是没有主页面的内容重要的。这时 iframe 中用光了可用的连接就是不值得的了。一种解决办法是，在主页面上重要的元素加载完毕后，再动态设置 iframe 的 SRC。 4、不利于 SEO 搜索引擎的检索程序无法解读 iframe。另外，iframe 本身不是动态语言，样式和脚本都需要额外导入。 综上，iframe 应谨慎使用。 contentWindowcontentWindow 属性返回当前HTMLIFrameElement的Window对象. 你可以使用这个Window 对象去访问这个iframe的文档和它内部的DOM. 这个是可读属性, 但是它的属性像全局Window 一样是可以操作的. (注意必须同源访问) 关于contentWindow的示例 var x = document.getElementsByTagName(\"iframe\")[0].contentWindow; //x = window.frames[0]; x.document.getElementsByTagName(\"body\")[0].style.backgroundColor = \"blue\"; // this would turn the 1st iframe in document blue. iframe优化方案iframe阻塞问题：https://www.cnblogs.com/sharpxiajun/p/4077515.html 加载优化阅读：https://www.open-open.com/bbs/view/1319458447249 iframe通信和一些很实用的功能：https://afantasy.ninja/2018/07/15/dive-into-iframe/ postMessage需要子应用配合，上面那个网址还讲述了iframe在线编辑器是怎么交互的：每次修改js代码，则发送一个post请求，POST 请求中还带有一个随机生成的 key，此时iframe的src指向对应key的一个url地址 iframe的讨论：https://www.stevesouders.com/blog/2009/06/03/using-iframes-sparingly/","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"DOM","slug":"DOM","date":"2022-06-19T08:53:13.862Z","updated":"2023-04-09T09:00:33.161Z","comments":true,"path":"2022/06/19/dom/","link":"","permalink":"https://taylor12138.github.io/2022/06/19/dom/","excerpt":"","text":"DOM基础DOM：文档对象模型，是一个应用编程接口API W3C已经定义了一系列的dom接口，可以改变网页内容、结构、样式 文档：一个页面就是一个文档，用document表示 元素：页面内的所有标签都是元素，用element表示 节点：网页中所有内容都是一个节点（注释，文本，属性等），用node表示 顶级对象是document 注意：因为文档是从上往下加载，所以script要写到文档标签的下面 （1）获取页面元素前情提要： HTMLCollection是元素集合而NodeList是节点集合（即可以包含元素，也可以包含文本节点）。所以 node.childNodes 返回 NodeList，而 node.children 和 node.getElementsByXXX 返回 HTMLCollection 。 id获取（id是大小写敏感的字符串组成） &lt;div id=\"time\">2019&lt;/div> &lt;script> var timer = document.getElementById('time'); /*返回的是一个元素对象*/ console.dir(timer); /*dir是打印返回的元素对象，更好的查看里面的属性方法*/ &lt;/script> &lt;/body> 根据标签名获取 &lt;script> // 返回的是获取过来的元素对象的集合，（无论多少个）以伪数组的形式储存 var lis = document.getElementsByTagName('li'); console.log(lis); console.log(lis[0]); // 可以使用element.getElementsByTagName('标签名')获取，但是父元素必须是单个对象，不能是伪数组之类的 var oll = document.getElementsByTagName('ol'); console.log(oll[0].getElementsByTagName('li')); &lt;/script> H5新增获取元素方法，根据类名获取 document.getElementsByClassName(&#39;类名&#39;); H5新增的万能选择器，querySelector返回选择器的第一个元素对象，切记里面选择器需要加符号 querySelectorAll 返回指定选择器的所有对象集合（伪数组） querySelectorAll和 getElementsByTagName对比 通过querySelectorAll获取的是返回的是NodeListOf&lt;HTMLElementTagNameMap[K]&gt;，经过了一次包装（有了一个包装对象！），保存的是当时状态的快照，所以是静态的，是死的，不会随着数据更新而改变，最好使用 getElementsByTagName （返回的是HTMLCollection）这些进行替代 它这样做的的原因是避免了使用NodeList对象可能造成的性能问题 里面的原理我们可以从typescript角度来观看 https://blog.csdn.net/HermitSun/article/details/95780715 伪数组可以使用es6的扩展运算符转化为数组：let lis2 = [...lis] // 选择类名 var firstbox = document.querySelector('.box'); // 选择id var secondbox = document.querySelector('#nav'); // 选择标签名 var thirdbox = document.querySelector('li'); //选择全部 var fourth = document.querySelectorAll('li'); 多重嵌套进行选择 var firstbox = document.querySelector('.box').quertSelector(li); var firstbox = document.querySelectorAll('.box .item') 获取body标签和html标签比较简单特殊 //获取html var htmlEle = document.documentElement; // 获取body元素 var bodyEle = document.body; 注意：获取到的每个DOM元素都作为一个对象来使用！ （2）事件基础事件是可以被js侦测到的行为，触发–响应机制 事件由三部分组成：事件源（被触发对象） 事件类型（触发类型） 事件处理程序 一个简单的事件例子： &lt;button id=\"btn\">哈哈哈&lt;/button> &lt;script> var btn = document.getElementById('btn'); btn.onclick = function() { alert('哈哈哈'); } &lt;/script> （3）操作元素我们可以利用dom操作元素来改变元素里面的内容 element.innerText 从起始位置到终止位置的内容，但它除去html标签，空格换行也会去掉（非标准） element.innerHTML 从起始位置到终止位置的内容，保留（识别）html标签和空格，换行（W3C标准） （element.textContent 相当于innerText，只不过 textContent 会获取style= “display:none” 中的文本，而innerText不会 textContent 会获取style标签里面的文本、script标签里的文本，而innerText 不会 ） 同时，这两个标签是可读写的，可以获取元素里面的内容 btn.onclick = function() { div.innerText = '2020'; /*点击后修改它的文字*/ img.src = 'xxxx'; /*改变图片的src*/ img.title = 'xxxx'; /*改变图片的文字提示*/ input.value = 'xxx' /*改变表单的值*/ this.disabled = true; /*点击后此按钮后，此按钮被禁用，this指向的是事件函数的调用者*/ } p.innerText = 'pp'; /*刷新页面直接修改它的文字*/ console.log(p.innerText); 修改样式（通过JS修改后，变成行内样式，权重比较高） div.onclick = function() { //1.样式比较少的话使用此方法 //采用驼峰命名，原来的 background-color -> backgroundColor this.style.backgroundColor = 'purple'; //2.另一个方法就是再写一个类，里面包含了所有你想要改变的样式，但是注意，它会覆盖原先的类名 this.className = '样式名'; //3.保留原先得类 this.className = '原先样式名 新样式名' } 表单的获取焦点 var text = document.querySelector('input'); text.onfocus = function () { //获得焦点 if (this.value) { this.value = ''; } this.style.color = '#333' } text.onblur = function () { //失去焦点 if (this.value === '') { this.value = '手机'; } this.style.color = '#999' } 表单经过事件（类似于“ :hover ”） // 1.获取元素 获取的是 tbody 里面所有的行 var trs = document.querySelector('tbody').querySelectorAll('tr'); // 2. 利用循环绑定注册事件 for (var i = 0; i &lt; trs.length; i++) { // 3. 鼠标经过事件 onmouseover trs[i].onmouseover = function() { this.className = 'bg'; } // 4. 鼠标离开事件 onmouseout trs[i].onmouseout = function() { this.className = ''; } } 全选框小案例： // 获取元素 var Btn_All = document.getElementById('Btn_All'); // 全选按钮 var Btns = document.getElementById('Btns').getElementsByTagName('input'); // 下面所有的复选框 //1.让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可 Btn_All.onclick = function () { for (var i = 0; i &lt; Btns.length; i++) { Btns[i].checked = this.checked; } } // 2. 每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。 for (var i = 0; i &lt; Btns.length; i++) { Btns[i].onclick = function () { var flag = true; for (var i = 0; i &lt; Btns.length; i++) { if (!Btns[i].checked) { flag = false; break; } } Btn_All.checked = flag; } } （4）自定义属性js的两种元素属性获取方法： element.属性获取属性 element.getAttribute(&#39;属性&#39;)也是获取属性，不过这个可以获取自定义属性 自定义属性：&lt;div id=&quot;demo&quot; index=&quot;1&quot;&gt;&lt;/div&gt; 中的index 设定属性值： element.属性 = 值 设置内置属性 element.setAttribute(&#39;属性&#39;,&#39;值&#39;) 同上，主要设置自定义属性，它的class比较特殊，不使用className，使用class，如 div.setAttribute(‘class’, ‘footer’); name 表示属性名称的字符串。DOMString指定要设置其值的属性的名称。setAttribute()在 HTML 文档中的 HTML 元素上调用时，属性名称会自动转换为全部小写。 value 属性的值/新值。一个DOMString包含了分配给这个属性的值。任何非字符串的值都会被自动转换为字符串。 移除属性：element.removeAttribute(&#39;属性名&#39;) 是否拥有该属性：element.hasAttribute(&#39;属性名&#39;) H5规范：H5规定自定义属性以“data-”作为开头，并且赋值，比如 &lt;div data-index=&quot;1&quot;&gt;&lt;/div&gt; H5新增获取自定义属性的方法：div.dataset.index（属性名为data-index）， div.dataset.listName(属性名为data-list-name) ，dataset是一个集合里面存放了所有以data开头的自定义属性 （5）节点操作dom提供的获取元素方法比较繁琐，利用节点父子兄弟关系获取元素比较方便，但是兼容性差 在DOM的所有节点中都实现了Node这个接口 一般的，节点至少拥有节点类型（nodeType）、节点名称（nodeName）、节点值（nodeValue） 元素节点 nodeType = 1 节点操作一般都是操作元素节点，唯一使用attributes属性的DOM节点类型 属性节点 nodeType = 2 文本节点 nodeType = 3 （总共有12种节点，以下展示部分节点） 父亲节点： node.parentNode (得到的是离元素最近的父节点，找不到父节点返回空值) 孩子节点： node.childNodes 返回包含节点的子节点的集合(NodeList，因为繁琐，所以实际开发不提倡使用childNodes) var ul = document.querySelect(&#39;ul&#39;); for (var i = 0; i &lt; ul.childNodes.length; i++) { if(ul.childNodes[i].nodeType == 1) { console.log(lu.childNodes[i]); } }(new) 孩子节点： parentNode.children 返回所有子元素节点 （常用,HTMLCollection） parentNode.firsElementtChild 返回第一个元素子节点，找不到返回null parentNode.firstChild 返回第一个元素子节点，找不到返回null parentNode.lastChild 返回最后一个元素子节点，找不到返回null 这两个方法有兼容问题ie9以上才能使用 所以推荐写法： parentNode.children[0] parentNode.children[parentNode.children.lenth-1] 下一个兄弟元素节点：node.nextElementSibling 找不到返回null 上一个兄弟元素节点：node.previousElementSibling 找不到返回null 这两个方法有兼容问题ie9以上才能使用 创建节点 document.createElement(&#39;targetName&#39;) 动态创建节点 创建文本节点 document.createTextNode(vNode) 添加节点 node.appendChild(child) 创建完后需要添加节点，此方法是将一个节点添加到指定父节点的子节点列表末尾，类似于CSS中的after伪元素 ,child写名称不用加 ‘ ’（不支持追加字符串子元素） 获取父节点 parentElement = node.parentElement or： node.insertBefore(child, 指定元素（子节点）) 将一个节点添加到父节点指定的子节点前面 var li = document.createElement('li'); var ul = document.querySelector('ul'); ul.appendChild(li); var li_2 = document.createElement('li'); ul.insertBefore(li_2, ul.children[0]); /*添加至开头*/ var h=document.createElement(\"H1\") var t=document.createTextNode(\"Hello World\"); h.appendChild(t); /*创建一个标题 (H1), 你必须创建 \"H1\" 元素和文本节点:*/ 发表评论案例： &lt;textarea name=\"\" id=\"\">&lt;/textarea> &lt;button>发布&lt;/button> &lt;ul>&lt;/ul> &lt;script> var btn = document.querySelector('button'); var text = document.querySelector('textarea'); var ul = document.querySelector('ul'); btn.onclick = function() { if (text.value == '') { alert('您没有输入内容'); return false; } else { var li = document.createElement('li'); //并且添加删除功能 li.innerHTML = text.value + \"&lt;a href='javascript:;'>删除&lt;/a>\"; //javascript:;意思是页面不发生跳转 ul.insertBefore(li, ul.children[0]); //删除元素 var as = document.querySelectorAll('a'); for(var i = 0; i &lt; as.length; i++) { as[i].onclick = funciton() { ul.removeChild(this.parentNode) } } } } &lt;/script> 删除节点：node.removeChild(child) 返回删除的节点 node.remove() 返回删除的节点（）删除本身 复制节点： node.cloneNode() 克隆完节点之后，和创建节点一样也必须要添加节点才能显示出来 1.如果括号参数为空，是浅拷贝，只克隆该节点本身，不克隆其子节点，即没有任何内容 node.cloneNode(true) 深拷贝 复制标签并且复制里面的内容 （6）创建标签的四种方法：1.element.write() 写入内容（标签），但是页面文档流加载完毕，如果在页面加载完成后再调用 document.write()，则会重写整个页面 &lt;script type=\"text/javascript\"> window.onload = function() { document.write(\"hello, world\"); //hello world 重写整个页面 } &lt;/script> 2.element.innerHTML 从起始位置到终止位置的内容，保留（识别）html标签和空格，换行（W3C标准） 同时，这两个标签是可读写的，可以获取元素里面的内容 3.document.createElement(&#39;targetName&#39;) 动态创建节点 document.createElement(&#39;targetName&#39;)对比使用element.innerHTML 写多个标签会更省时，省空间，因为他创建多个标签时不用开辟新的空间，而innerHTML使用拼接的原理，所以每次都要要开辟新的空间 但是，如果element.innerHTML 不用拼接字符串的方法来实现创建多个标签，而是采用数组的形式拼接，结构写麻烦一点： var arr[]; for(var i = 0; i &lt; 100; i++) { arr.push('&lt;a href=\"#\">百度&lt;/a>'); } //以''进行拼接，并且转化为字符串 xx.innerHTML = arr.join(''); 执行起来会比 document.createElement(&#39;targetName&#39;) 更快，但是结构不太清晰 element.insertAdjacentHTML(插入的位置, 插入的字符串)可以直接把字符串格式元素添加到父元素中 element.insertAdjacentHTML(\"beforebegin\", \"&lt;a href=\"#\">百度&lt;/a>\"); 插入位置：beforebegin 元素自身前面 afterbegin 插入元素内部第一个子节点之前 ​ beforeend 插入元素内部的最后一个子节点之后 afterend 元素自身的后面 （注意：appendChild不支持追加字符串子元素，insertAdjacentHTML支持追加字符串子元素） document.createDocumentFragment() 有点类似 document.createElement(&#39;targetName&#39;) ，区别在于： （1）需要很多的插入操作和改动，使用createElement效率是比较低的，而innerHTML拼接方法灵活性比较差，利用DocumentFragment，可以弥补这两个方法的不足 （2）createDocumentFragment创建的元素使用innerHTML并不能达到预期修改文档内容的效果 （3）createDocumentFragment创建的元素是一次性的，添加之后再就不能操作了 （4） 通过createElement新建元素必须指定元素tagName,因为其可用innerHTML添加子元素。通过createDocumentFragment则不必。 （5）通过createElement创建的元素插入文档后，还可以取到创建时的返回值 element.outerHTML类似于 innerHTML的效果，只不过是起到了replace的效果 （7）Shadow DOM我们正常的dom结构就是一颗dom树 Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。 你也可以理解为： 一个 DOM 元素可以有以下两类 DOM 子树： Light tree（光明树） —— 一个常规 DOM 子树，由 HTML 子元素组成。我们在之前章节看到的所有子树都是「光明的」。 Shadow tree（影子树） —— 一个隐藏的 DOM 子树，不在 HTML 中反映，无法被察觉。 这里举了一个很好的例子，shadow dom 就像一个video：https://www.cnblogs.com/coco1s/p/5711795.html 创建方式： elem.attachShadow({mode: …}) mode 选项可以设定封装层级。他必须是以下两个值之一： 「open」 —— shadow root 可以通过 elem.shadowRoot 访问。 任何代码都可以访问 elem 的 shadow tree。 「closed」 —— elem.shadowRoot 永远是 null。 我们只能通过 attachShadow 返回的指针来访问 shadow DOM（并且可能隐藏在一个 class 中）。浏览器原生的 shadow tree，比如 &lt;input type=&quot;range&quot;&gt;，是封闭的。没有任何方法可以访问它们。 你可以使用同样的方式来操作 Shadow DOM，就和操作常规 DOM 一样——例如添加子节点、设置属性，以及为节点添加自己的样式（例如通过 element.style 属性），或者为整个 Shadow DOM 添加样式（例如在 `` 元素内添加样式）。不同的是，Shadow DOM 内部的元素始终不会影响到它外部的元素（除了 :focus-within），这为封装提供了便利。 事件部分1.注册事件传统方式： btn.onclick = function() {} 注册事件唯一性，最后注册处理的函数会覆盖掉前面注册处理的函数，即一个元素只能设置一个处理函数 w3c标准的推荐方式：（ie9以前不支持此方法，即ie8等不支持） target.addEventListener(type, listener, options); target.addEventListener(type, listener, useCapture); （ie9以前使用的是eventTarget.attachEvent(type, listener[, useCapture]);） type：事件类型，如click，mouseover，不带on listener：事件处理，事件发生时会调用其监听函数 useCapture：可选参数，默认false，一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。 option：一个指定有关 listener属性的可选参数对象。 capture: Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。 once: Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。 passive: Boolean，设置为 true 时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。查看 使用 passive 改善的滚屏性能 了解更多。 signal：AbortSignal，该 AbortSignal 的 abort() 方法被调用时，监听器会被移除。 btn.addEventListener('click', function() { //必须要字符串 alert(xxx); }) btn.addEventListener('click', function() { //必须要字符串 alert(yyy); }) 同一个元素同一个事件可以添加多个监听器，不会覆盖掉 2.解绑事件传统方式： eventTarget.onclick = null 如 div.onclick = function() {alert(); div.onclick = null;} 在点击一次之后删除该事件 方法监听方式：eventTarget.removeEventListener(type, listener[, useCapture]); （ie9以前使用的是eventTarget.detach(type, listener[, useCapture]);） 方法监听方式来解绑事件不能用匿名函数的方法，即 var fun=function(){} 所以使用以下策略 div.addEventListener('click', fn); function fn() { alert(xx); div.removeEventListener('click', fn); } 使得目标div在点击一次之后解绑事件 3.dom事件流事件发生时会在元素节点之间按照特定的顺序传播（document-&gt;Element gtml-&gt;Element body-&gt;Element div），这个传播过程即DOM事件流 DOM事件流分为三个阶段 ：（执行顺序也是如此 捕获 - &gt; 当前 -&gt; 冒泡）(记住是三个，还有一个目标阶段！！！) 1.捕获阶段（从大往小传播，从最顶层开始，然后逐级向下传播到具体元素接收的过程） 2.当前目标阶段 3.冒泡阶段（从小到大，从里到外的传播，由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程） 注意： JS代码只能执行捕获或者冒泡其中一个阶段（除非你设置两个监听函数，一个执行捕获，一个执行冒泡）； 传统注册事件方式（onclick、attachEvent）只能得到冒泡阶段，eventTarget.addEventListener(type, listerner[, useCapture])第三个参数如果是true，则在事件捕获阶段调用程序，如果是false（默认），则在冒泡阶段调用事件 如果事件触发在“当前目标阶段”，则当前目标会根据事件注册的先后顺序执行，而不是上面提及到的 捕获 - &gt; 当前 -&gt; 冒泡，比如：爷节点，父节点，子节点都绑定了 捕获事件和监听事件，而触发子节点的事件，执行爷、父的事件执行顺序一定是 捕获 - &gt; 当前 -&gt; 冒泡；而子节点是根据事件注册的先后顺序来执行捕获 or 冒泡事件，说白了就是无关了。 以下代码，son包含于father内，使用捕获阶段（true），则点击son后先执行father再执行son，冒泡阶段则相反 &lt;div class=\"father\"> &lt;div class=\"son\">son盒子&lt;/div> &lt;/div> &lt;script> var son = document.querySelector('.son'); son.addEventListener('click', function() { alert('son'); }, true); var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, true); &lt;/script> 但是实际开发中我们更关注的是冒泡，且有些事件是没有冒泡的，如onblur，onfocus，onmouseenter，onmouseleave 事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件：比如通过冒泡父元素管理多个子元素的事件 4.事件对象div.addEventListener(&#39;click&#39;, funciton(event){} ) 中的event为事件对象，写到我们监听函数的小括号里，当形参看 事件对象只有有了事件才会存在，它是系统自动为我们创建的，不需要我们传递参数 事件对象是我们事件一些列相关数据的集合 事件对象也有兼容性问题，比如ie6、7、8，通过window.event获取 常见事件对象属性（对低版本浏览器有兼容性问题）： div.addEventListener('click', function(e) { console.log(e.target); console.log(this); /*两者有些许相似，但是e.target返回的是触发事件的元素，this返回的是绑定事件的对象（元素）*/ console.log(e.type); //返回事件类型 e.preventDefault(); //阻止默认事件，让它成为一个普通盒子，比如让链接不跳转，让input不提交等 e.stopPropagation(); //阻止事件冒泡，使得触发子事件后，不会相应触发父事件，不会向外传播 }) ie6\\7\\8 div.onclick = function() { console.log(e.srcElement); //返回的是触发事件得元素 e.returnValue; // 阻止默认事件 /*我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式*/ return false; window.e.cancelBubble = true; //阻止冒泡 } 5.事件委托事件委托也称为事件代理，在JQuery称为事件委派，它提高了程序性能 若多个子节点同时有事件，不需要将每个子结点单独设置事件监听器，而是将事件监听器设置在父节点上，然后利用冒泡原理影响每个子节点，使得每个子节点反馈到父节点，触发父节点的事件 6.常用的鼠标事件鼠标右键菜单： contextmenu 鼠标选中：selectstart dblclick 鼠标双击事件 mousedown 鼠标按下 mousemove 鼠标移动 ，mousemove是鼠标指针在元素内部移动式重复触发的事件，可用于鼠标指针定位实时变化的案例 mouseup 鼠标松开 mouseover 鼠标经过， 类似于“ :hover ” 它不仅经过自身盒子会触发，经过子盒子还会再触发一次 mouseout 鼠标离开元素，和mouseover相互搭配 mouseenter 鼠标移动到元素上，只会经过自身盒子才触发一次，之所以会这样，是因为mouseenter不会冒泡 mouseleave 鼠标离开元素，和mouseenter相互搭配，同样不会冒泡 wheel鼠标滚轮事件 scroll事件在滚动条滚动的时候被触发 wheel在鼠标滚轮滚动的时候被触发 由于鼠标滚轮滚动时大部分会触发scroll事件 所以时wheel事件先触发 focus 获得焦点 blur失去焦点 //禁用鼠标右键 document.addEventListener('contextmenu', function(e) { e.preventDefault(); }) //禁止选中文字 document.addEventListener('selectstart', function(e) { e.preventDefault(); }) （e代表事件对象，可视区域为除去收藏夹、网址等部分） e.clientX 返回鼠标对于浏览器窗口可视区域的X坐标 e.clientY 返回鼠标对于浏览器窗口可视区域的Y坐标 e.pageX 返回鼠标相对于文档页面的X坐标，ie9+支持 （无滚动时同clientX） e.pageY 返回鼠标相对于文档页面的Y坐标，ie9+支持 （无滚动时同clientY） e.screenX 返回鼠标相对于电脑屏幕的X轴坐标 e.screenY 返回鼠标相对于电脑屏幕的Y轴坐标 pink老师天使跟随鼠标案例 &lt;style> img { position: absolute; } &lt;/style> &lt;body> &lt;img src=\"images/angel.gif\" alt=\"\"> &lt;script> var pic = document.querySelector('img'); document.addEventListener('mousemove', function(e) { /*核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的top和left 值就可以移动图片*/ var x = e.pageX; var y = e.pageY; //千万不要忘记给left 和top 添加px 单位 pic.style.left = x - 50 + 'px'; pic.style.top = y - 40 + 'px'; }); &lt;/script> &lt;/body> 7.常用键盘事件onkeyup 某个按键松开时被触发 （松开瞬间） onkeydown 某个按键被按下时被触发 （按下瞬间），按住会持续触发 onkeypress 同onkeydown 但是它不识别功能键如ctrl shift等，按住会持续触发 执行顺序down&gt;press&gt;up 使用addEventListener不需要加on keyon和keydown不能区分大小写 keyon和keydown不能区分大小写 （a和A得到的ASCII码值得到的都是65） 键盘事件 （e代表事件对象） e.keyCode 返回该键ASCII码值 e.key返回按下的键位值（字符串） 注意：keydown 和 keypress 在文本框（input）比较特殊，当它们两个事件触发的时候，文字还没落入文本框中 而keyup事件触发的时候，文字已经落入文本框， 8.input事件onchange 当input失去焦点并且它的value值发生变化时触发，它也可用于单选框与复选框改变后触发的事件。 比如复选框发生改变（单击鼠标切换“打勾”/“不打勾”状态） oninput 当input的value值发生变化时就会触发，（与onchange的区别是不用等到失去焦点就可以触发了） 此时通过 event.target.value;事件对象中的target的value可以获取input输入的值 onfocus 获得焦点事件 onblur 失去焦点事件 input.select() 让文本框里的文字处于选定状态 remember.addEventListener('change', function () { // 勾选上 if (this.checked) { localStorage.setItem('username', username.value); } else { localStorage.removeItem('username') } }) 9.拖拽事件HTML 的 drag &amp; drop 使用了 DOM event model 以及从 mouse events 继承而来的 drag events 。一个典型的拖拽操作是这样的：用户选中一个可拖拽的（draggable）元素，并将其拖拽（鼠标不放开）到一个可放置的（droppable）元素，然后释放鼠标。 在操作期间，会触发一些事件类型，有一些事件类型可能会被多次触发（比如drag (en-US) 和 dragover (en-US) 事件类型）。 所有的 拖拽事件类型 有一个对应的 拖拽全局属性。每个拖拽事件类型和拖拽全局属性都有对应的描述文档。下面的表格提供了一个简短的事件类型描述，以及一个相关文档的链接。 事件 On 型事件处理程序 触发时刻 drag (en-US) ondrag 当拖拽元素或选中的文本时触发。 dragend (en-US) ondragend (en-US) 当拖拽操作结束时触发 (比如松开鼠标按键或敲“Esc”键). (见结束拖拽 (en-US)) dragenter (en-US) ondragenter (en-US) 当拖拽元素或选中的文本到一个可释放目标时触发（见 指定释放目标 (en-US)）。 dragexit ondragexit (en-US) 当元素变得不再是拖拽操作的选中目标时触发。 dragleave (en-US) ondragleave 当拖拽元素或选中的文本离开一个可释放目标时触发。 dragover (en-US) ondragover (en-US) 当元素或选中的文本被拖到一个可释放目标上时触发（每 100 毫秒触发一次）。 dragstart (en-US) ondragstart (en-US) 当用户开始拖拽一个元素或选中的文本时触发（见开始拖拽操作 (en-US)）。 drop (en-US) ondrop 当元素或选中的文本在可释放目标上被释放时触发（见执行释放 (en-US)）。 注意：当从操作系统向浏览器中拖拽文件时，不会触发 dragstart 和dragend 事件。 在浏览器才有这个事件，移动端好像没有（至少我试了好像不太行） &lt;div key={component.type} draggable onDragStart={() => handleDragStart(component)} className=\"editor-left-item\"> &lt;span>{component.label}&lt;/span> &lt;div>{component.preview()}&lt;/div> &lt;/div> 10.动画结束事件onAnimationEnd: 该事件在CSS 动画完成animationend时触发。如果动画在完成之前中止，例如元素从 DOM 中移除或动画从元素中移除，则不会触发该事件。animationend 句法 在诸如 之类的方法中使用事件名称addEventListener()，或设置事件处理程序属性。 addEventListener(&#39;animationend&#39;, (event) =&gt; {}); onanimationend = (event) =&gt; { };","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"动画库辅助工具","slug":"动画库辅助工具","date":"2022-06-11T11:39:22.951Z","updated":"2023-04-18T12:25:32.949Z","comments":true,"path":"2022/06/11/dong-hua-ku-fu-zhu-gong-ju/","link":"","permalink":"https://taylor12138.github.io/2022/06/11/dong-hua-ku-fu-zhu-gong-ju/","excerpt":"","text":"dat.GUI由于在2d、3d动画中，我们失去了dom结构（canvas），所以我需要特殊的debug工具。 推荐dat.GUI，它同样可以适用于pixijs ，它可以控制每一个区块来debug，通过一个ui界面，慢慢调节成我们想要的参数 github地址：https://github.com/dataarts/dat.gui api文档：https://github.com/dataarts/dat.gui/blob/master/API.md npm i dat.gui import * as dat from 'dat.gui' const gui = new dat.GUI() 然后我们在右上方就可以看到这个 然后给我们的gui添加我们要调节的物体和属性 gui.add(object, property, [min], [max], [step]) ⇒ Controller 给gui增加一个控制器，用来调节对象的属性，如果填入最后三个参数，UI就会变成一个进度条，方便调节 Kind: instance method of GUIReturns: Controller - The controller that was added to the GUI. Param Type Description object Object 调节的对象 property String 想要改变的属性名称 [min]（可选） Number 最小值 [max]（可选） Number 最大值 [step]（可选） Number 间隔 APIadd gui.add(object, property, [min], [max], [step]) ⇒ Controller 给gui增加一个控制器，用来调节对象的属性，如果填入最后三个参数，UI就会变成一个进度条，方便调节 Kind: instance method of GUIReturns: Controller - The controller that was added to the GUI. Param Type Description object Object 调节的对象 property String 想要改变的属性名称 [min]（可选） Number 最小值 [max]（可选） Number 最大值 [step]（可选） Number 间隔 以下例子，就是我往gui添加一个threejs的mesh，对其属性进行修改 //创建正方体 const geometry = new THREE.BoxGeometry(1, 1, 1); const material = new THREE.MeshBasicMaterial({ color: \"red\" }); const cube = new THREE.Mesh(geometry, material); cube.position.set(1, 0, 0); scene.add(cube); obj = { action: () => { console.log('action') } } //gui会自动根据你添加的属性类型，给你转换成相对的调节方式，比如number为进度条、boolean为checkbox gui.add(cube.position, \"y\", -3, 3, 0.1); gui.add(cube, 'visible'); gui.add(cube.position, \"x\", -3, 3, 0.1); gui.add(cube.position, \"z\", -3, 3, 0.1); 你甚至可以添加一个方法，此时gui就会生成一个点击选项，点击后就会调用obj的action方法 gui.add(obj, \"action\"); //当然也可以用链式调用的形式 gui .add(cube.position, \"y\") .min(-3) .max(3) .step(0.01) .name('cube的y轴位置') addColor但是尽管如此智能，但GUI无法识别你的color属性是一个color，所以有一个addColor API gui.addColor(object, property) ⇒ Controller Kind: instance method of GUIReturns: Controller - The controller that was added to the GUI. Param object property 案例： var palette = { color1: '#FF0000', // CSS string color2: [ 0, 128, 255 ], // RGB array color3: [ 0, 128, 255, 0.3 ], // RGB with alpha color4: { h: 350, s: 0.9, v: 0.3 } // Hue, saturation, value }; gui.addColor(palette, 'color1'); gui.addColor(palette, 'color2'); gui.addColor(palette, 'color3'); gui.addColor(palette, 'color4'); //环境光 const lightParams = { color: 0xffffff }; const intensity = 1; const light = new THREE.AmbientLight(lightParams.color, intensity); scene.add(light); console.log(light.color, \"color\"); //由于threejs里的color不能直接通过属性赋值更改，必须通过set方法，所以这里用onchange来监听更改light的color gui.addColor(lightParams, \"color\").onChange(() => { light.color.set(lightParams.color); }); 当然我们也可以写一个color gui类来帮我们设置颜色 class ColorGUIHelper { constructor(object, prop) { this.object = object; this.prop = prop; } get value() { return `#${this.object[this.prop].getHexString()}`; } set value(hexString) { this.object[this.prop].set(hexString); } } const intensity = 1; const color = 0xFFFFFF; const light = new THREE.AmbientLight(color, intensity); const gui = new GUI(); gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color'); gui.add(light, 'intensity', 0, 2, 0.01); addFolder添加gui一个文件夹，方便分类和管理不同的属性，比如你想要控制球体A的x、y、z轴，也想要控制球体B的x、y、z轴，此时我们可以新建一个Folder，此时我们在folder下添加对应的属性即可 function makeXYZGUI(gui, vector3, name, onChangeFn) { const folder = gui.addFolder(name); folder.add(vector3, 'x', -10, 10).onChange(onChangeFn); folder.add(vector3, 'y', 0, 10).onChange(onChangeFn); folder.add(vector3, 'z', -10, 10).onChange(onChangeFn); folder.open(); }","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"编译相关","slug":"编译相关","date":"2022-06-11T11:39:22.951Z","updated":"2022-06-11T11:39:22.951Z","comments":true,"path":"2022/06/11/bian-yi-xiang-guan/","link":"","permalink":"https://taylor12138.github.io/2022/06/11/bian-yi-xiang-guan/","excerpt":"","text":"Monaco EditorMonaco Editor 是一款开源的在线代码编辑器。它是 VSCode 的浏览器版本 使用npm install monaco-editor 新建一个base文件夹，里面装着三件套 html + js + css三件套的代码 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>Monaco Editor Demo&lt;/title> &lt;link rel=\"stylesheet\" href=\"./style.css\"> &lt;script src=\"../node_modules/monaco-editor/min/vs/loader.js\">&lt;/script> &lt;script src=\"./app.js\">&lt;/script> &lt;/head> &lt;body> &lt;div id=\"header\">基础版 Monaco Editor&lt;/div> &lt;div id=\"root\">&lt;/div> &lt;/body> &lt;/html> body { font-family: \"Source Han Sans\", \"San Francisco\", \"PingFang SC\", \"Hiragino Sans GB\", \"Droid Sans Fallback\", \"Microsoft YaHei\", sans-serif; transition: background-color .2s; } #header { position: fixed; top: 0; left: 0; height: 50px; right: 0; background-color: #333; color: #fff; font-size: 20px; line-height: 50px; display: inline-block; vertical-align: middle; padding-left: 15px; overflow: hidden; z-index: 0; } .container { position: fixed; top: 50px; left: 0; height: calc(100vh - 50px); right: 0; margin: 0 auto; display: block; transition: 0.2s; overflow: hidden; z-index: 0; } require.config({ paths: { vs: \"../node_modules/monaco-editor/min/vs\" } }); require([\"vs/editor/editor.main\"], function () { // 初始化变量 var fileCounter = 0; var editorArray = []; var defaultCode = [ \"function helloWorld() {\", ' console.log(\"Hello world!\");', \"}\", ].join(\"\\n\"); // 新建一个编辑器 function newEditor(container_id, code, language) { var model = monaco.editor.createModel(code, language); var editor = monaco.editor.create(document.getElementById(container_id), { model: model, }); editorArray.push(editor); return editor; } // 新建一个 div function addNewEditor(code, language) { var new_container = document.createElement(\"DIV\"); new_container.id = \"container-\" + fileCounter.toString(10); new_container.className = \"container\"; document.getElementById(\"root\").appendChild(new_container); newEditor(new_container.id, code, language); fileCounter += 1; } addNewEditor(defaultCode, \"javascript\"); }); 参考：https://zhuanlan.zhihu.com/p/88828576 推荐阅读：https://zhuanlan.zhihu.com/p/496562929 vscode主题在monaco中的应用：https://segmentfault.com/a/1190000040746839 monaco-editor/react它是一个Monaco编辑器包装器，使得我们可以在React中直接配置monaco-editor。React无需使用webpack（或任何其他模块捆绑器）配置文件/插件。它可以与由create-react-app、create-snowpack-app、vite或Next.js任何其他应用程序生成器生成的应用程序一起使用 -您无需弹出或重新连接它们。 使用npm install @monaco-editor/react 在react脚手架中配置Editor组件即可 import React from \"react\"; import ReactDOM from \"react-dom\"; import Editor from \"@monaco-editor/react\"; function App() { return ( &lt;Editor height=\"90vh\" defaultLanguage=\"javascript\" defaultValue=\"// some comment\" /> ); } const rootElement = document.getElementById(\"root\"); ReactDOM.render(&lt;App />, rootElement); 获取内容 有两种方法，反别是通过useRef获取Editor容器，然后容器ref.current.getValue()就是当前的值 另一种是直接绑定Editor的 onChange方法 function App() { const editorRef = useRef(null); function handleEditorDidMount(editor, monaco) { editorRef.current = editor; } function handleEditorChange(value, event) { console.log(\"here is the current model value:\", value); } function showValue() { alert(editorRef.current.getValue()); } return ( &lt;> &lt;button onClick={showValue}>Show value&lt;/button> &lt;Editor height=\"90vh\" defaultLanguage=\"javascript\" defaultValue=\"// some comment\" onMount={handleEditorDidMount} onChange={handleEditorChange} /> &lt;/> ); } 更多：https://github.com/suren-atoyan/monaco-react 编译器demo200行的js小编译器（Lisp -&gt; JS） https://juejin.cn/post/6844904105937207304 它的github地址：https://github.com/QianYin-Zhou/The-super-tiny-complier","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript基础","slug":"JavaScript基础","date":"2022-06-06T16:16:11.669Z","updated":"2022-10-18T02:02:10.868Z","comments":true,"path":"2022/06/07/javascript-ji-chu/","link":"","permalink":"https://taylor12138.github.io/2022/06/07/javascript-ji-chu/","excerpt":"","text":"1.JS的介绍JS是脚本语言，不需要编译，直接由js解释器逐行进行解释并执行（编译一行，执行一行），（解释型的编程语言）现在也可以基于node.js技术（后台）进行服务器编程 一般编译流程：词法分析（源程序-&gt;单词符号），语法分析（单词符号-&gt;语法单位），中间代码生成（语法单位-&gt;中间代码），代码优化和目标代码的生成（中间代码-&gt;目标代码） 实现业务逻辑和页面控制功能，浏览器的JS引擎，也就是JS解释器，用来读取JS代码 JS执行样式表（Style sheets） 样式表采用另一种不同的模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。 JS本身是没有预编译的 编译器编译（important）： 将所有声明语句，包括变量声明（以var开头）和函数声明（以function开头）里面的标识符（即变量名a和函数名foo）添加到当前作用域中（添加规则是：对var声明的变量来说，如a已存在则忽略该声明，继续编译后面语句;否则就要求在当前作用域声明一个新的变量命名为a，此时a的值是undefined；对于function开头声明的函数来说，函数名foo的声明过程与变量声明一样，不过如果遇到有function声明 2个以上同名函数foo,则后面的函数体会覆盖前面的 ） 一切声明的全局变量和未经声明的变量，全归window所有。 预解析 js引擎运行js，分为两步：1.预解析 2.代码执行 预解析：js会把里面所有var还有function提升到当前作用域的最前面（分别为变量提升和函数提升） 变量提升：把所有变量声明提升至当前作用域于最前，但是不提升赋值操作 函数提升：把所有函数提升至当前作用域最前 编译器查询LHS代表左侧查询（找到变量容器本身），询问作用域有没有该容器 RHS代表右侧查询（但它并非真正意义上的赋值操作右侧，而是“非左侧”） LHS、RHS是 “赋值操作的左侧和右侧”，但是不代表是 “=赋值操作符的左侧和右侧” console.log(a) // 一个RHS引用 a = 2; // 一个LHS引用 如果RHS查询在所有嵌套的作用域中找到不到该变量，则会抛出一个ReferenceError异常 声明 + 赋值操作是LHS查找，LHS找不到引擎会帮你在顶层作用域声明一个具有该名称的变量（严格模式除外，严格模式则抛出一个ReferenceError） 欺骗词法作用域如果词法作用域完全由写代码期间函数所声明的位置来定义，那如何欺骗词法作用域呢？ JavaScript有两种机制 eval：接受一个字符串作为参数，将其中的内容是为好像在书写时就存在于程序中这个位置的代码（《红宝书的啃读note(上)》有解释eval方法） with：with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身；尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中 function foo(obj) { with(obj) { a = 2; } } var o1 = { a: 1 }; var o2 = {}; foo(o1); console.log(o1.a); //2 foo(o2); console.log(o2.a) //undefined console.log(a); // 2,a被泄露到全局作用域了 可以理解为把o1传递给with，with所声明的作用域是o1；而我们将o2设为作用域时，其中并没有a标识符，此时（非严格模式下）进行了LHS查询 eval和new funciton性能对比 ：https://weblogs.asp.net/yuanjian/json-performance-comparison-of-eval-new-function-and-json JS的组成JavaScript语法：ECMAScript 页面文档对象模型：DOM 浏览器对象模型：BOM ECMAScript 它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和拓展 DOM 它是标准编程接口，通过DOM提供的接口可以对页面上各种元素进行操作（大小位置颜色） BOM 它提供了独立于内容，可以与浏览器窗口进行互动的对象，操作浏览器窗口比如弹出窗，控制浏览器跳转，获取分辨率等 JS的插入方式 类似于CSS，有行内式，内嵌式&lt;script&gt;xxxx&lt;/script&gt; 还有从外部引入：(script标签中间别写代码) &lt;script src=\"xx.js\">&lt;/script> 2.JS基本功能介绍输入输出alert(msg); //弹出警示框 console.log(msg) //打印输出信息，是控制台输出，给程序猿测试用的 prompt(info) //弹出输入框，提供用户输入 但是都是以字符的形式输入 console.log()会在浏览器控制台打印出信息 console.dir()可以显示一个对象的所有属性和方法 定义使用var，自动确定类型（JS拥有动态类型） var 如果没有事先声明var，直接使用，会创建一个全局变量 var存在声明提升 功能isNaN() 判断是否非数字 typeof 变量名 查看数据类型 转换转字符串： ​ 变量名.toString() number类型时，变量名.toString(16) 转换成16进制字符串 ​ 强制转换：String(变量名) ​ 隐式转换：变量名+”xxxx”(拼接字符串) String转数字类型： （1）String-&gt;int： parseInt(String)；parseInt()函数将给定的字符串以指定的基数解析为整数。 （2） String-&gt;float: parseFloat(String)； （3）Number强制转换（String转数值）：Number(String) 但是Number转换字符串是相对复杂且有点反常规，建议使用parseInt，比如：Number()在不用new操作符时，可以用来执行类型转换。如果无法转换为数字，就返回NaN。像“123a”，parseInt()返回是123，Number()返回是NaN。 （4）利用减乘除（没有+）：String-String或String-int之类的 String转ascii码 var str = \"A\"; str.charCodeAt(); // 65 var str1 = 'a'; str1.charCodeAt(); // 97 Ascii码转String //将对应的编码值转为字符 var charValue = String.fromCharCode(codeValue); 运算符18==‘18’ 成立true，默认转换数据类型 ===为全等需要完全一致， 18===‘18’为false 逻辑与短路运算：123&amp;&amp;456，返回456，左式为真返回右式子，为假返回左式 逻辑或短路运算：123||456，返回123，左式为真返回左式子，为假返回右式 三元表达式： 条件表达式？表达式1：表达式2，条件为真返回表达式1，为假返回表达式2 数组数组名.length为数组的长度 数组增加元素 （1）直接设定数组长度arr.length=xx,多出来的变成空 （2）arr数组有三个元素，直接arr[3]=xx，进行新增元素 数据类型：基本数据类型（简单数据类型） Boolean Null Undefined Number BigInt：BigInt数据类型的目的是比Number数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用BigInt，整数溢出将不再是问题。 String Symbol 收录于 https://tc39.es/ecma262/#sec-primitive-value A primitive value is a member of one of the following built-in types: Undefined, Null, Boolean, Number, BigInt, String, and Symbol; 复杂数据类型 Object 总结：USONB （you are so niubi） u：undefined s：string、symbol o：object n：null、number b：boolean，bigint 3.判断JS数据类型的四种方法typeoftypeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。 返回值是一个字符串，该字符串说明运算数的类型。 所以经常搭配使用：if(typeof target === &#39;object&#39; &amp;&amp; target !== null){} 注意： typeof null 返回 object typeof 函数 返回 function 以创建对象的方式（显示创建原始值包装类型实例），用typeof判断是否为object都会为true，它不能精确到具体的object let s = new String('abc'); typeof s === 'object'// true s instanceof String // true js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 null：所有机器码均为0（这就是type null 返回 object的原因） undefined：用 −2^30 整数来表示 红宝书阐述：typeof虽然对原始值很有用，但是对引用值用处不大。。 instanceof instanceof 用于判断一个变量是否某个对象的实例，如 var a=new Array();alert(a instanceof Array); 会返回 true 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。 官方解释：instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 注意： 数组可以被 instanceof 判断为 Object 只能判断对象，对原始类型(简单数据类型)不能判断 对于 value instanceof Array，我们还可以使用 Array.isArray(value)，后者是ECMAScript提供为了解决多框架涉及多版本Array的instancof升级版方法 手写instanceOf function myInstanceof(left, right) { let proto = left.__proto__; while (true) { if (proto == null) return false; if (proto == right.prototype) return true; proto = proto.__proto__; } } constructor constructor [].constructor.name; //Array ''.constructor.name; //String alert(c.constructor === Array) ----------> true alert(d.constructor === Date) -----------> true alert(e.constructor === Function) -------> true 注意： constructor 在类继承时会出错， null 和 undefined 是无效的对象，因此是不会有 constructor 存在的 toString toString，利用toString打印出原型对象 Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ;// [object Boolean] //使用Reflect更棒！ console.log(Reflect.toString.call('')); // [object String] console.log(Reflect.toString.call(1)); // [object Number] console.log(Reflect.toString.call(true));// [object Boolean] 4.函数//1.利用函数关键字自定义函数 function 函数名(参数) { 函数体 } //如下： function sort(arr){ } //2.匿名函数 var fun=function(){ } //调用 fun(); 函数没有return，则返回的是undefined 注意在函数内部没有声明直接赋值的变量，也属于全局变量 5.对象对象一定是一个具体的对象，而不是泛指的东西 属性：事物的特征，用对象的属性表示 函数永远不会属于一个对象，所以把对象内部引用的函数称之为“方法”不太妥，严格意义上来说只是对该函数的引用 利用对象字面量创建对象var obj ={ uname:'xx', age:18, sex:'man', say:function(){ console.log('good'); } } //调用对象属性(2种) obj.uname obj['uname'] (1)键 属性名: 值 属性值 (2)用逗号隔开 (3)方法冒号后面跟的一个匿名函数 利用new Object创建对象再赋值的时候创建属性，因此此方法效率不高 var obj = new Object obj.uname='xx'; obj.age=18; obj.say=funciton(){} （1）利用等号赋值添加对象的属性和方法 （2）每个属性和方法用分号 利用构造函数创建对象其过程也称为对象的实例化,构造函数是泛指的某一大类，对象是具体的事物 function 构造函数名(){ this.属性=值; this.方法=function（）{} } 1.使用构造函数，构造函数名字首字母最好大写如 function Star()2.构造函数不需要return3.使用函数new 构造函数名();即构造一个对象，如new Array()，创建一个数组对象4.属性方法前必须加this如this.name=传参name this.song = function（传参）{} 遍历对象for (const k in obj){ //obj为对象 console.log(k); //k输出的是属性名 console.log(obj[k]);//得到的是属性值 } //我们使用for in 喜欢var k或者key //或者使用 for (const item of 迭代对象) { console.log(item); //每个属性的属性值，不过仅适用于可遍历对象，比如map、set、数组之类的， //普通对象不行，遍历普通对象推荐使用Object.keys } 对象删除键值对var json = { name:'张三', age:'23' }; delete json.age; 6.简单类型和复杂类型如果有个数据类型打算作为存储对象，暂时没想好放什么，可以先放null 简单数据类型（值类型）：string（但是string数值不可变）、number、boolean、undefined、null、symbol、bigint 简单数据类型放入栈里面（操作系统），栈里开辟的空间存放的是值 （用函数传参是不会影响变量的值） 复杂数据类型（引用类型）：Object、 Array、 Date 复杂数据类型放入堆里面（操作系统），于栈里存放地址，十六进制表示，然后这个地址指向堆里的数值；一般由程序员分配释放，若程序员不释放，由垃圾回收机制释放 （用函数传参是会影响对象的值） 但是复杂数据类型null赋值时断了地址联系 var obj = new Object(); obj.name = 'allen'; var obj2 = obj; console.log(obj2.name); //allen obj.name = 'bllen'; //改对象 console.log(obj2.name); //bllen obj = null; //改变量 console.log(obj2.name); //bllen 但是JS里没有堆栈的概念，只是通过堆栈的方式理解代码的执行方式 7.其他swiper插件的使用官网地址：https://www.swiper.com.cn （1）下载并解压包后，把其中的swiper.min.js和swiper.min.css放入网页文件夹的js和css中 （2）官网找到类似的案例，复制html，css和js（进入官网swiper演示中，然后新窗口打开，查看网页源代码） （3）根据需求修改模块 浅拷贝和深拷贝深拷贝和浅拷贝是只针对object和Array这样的引用数据类型的 1.赋值当我们把一个对象赋值给一个新的变量时，赋的其实是该对象在栈中的地址，而不是堆中的数据，只要修改了里面的的值，原来都都会受到影响 2.浅拷贝他会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性基本类型，拷贝的基本类型的值（修改后原来的变量的值不会受到影响）；如果属性是内存地址（引用类型，比如数组、对象），拷贝的就是内存地址，即其中一个变量修改了这个地址存放的对象，则另外一个会受到影响 数组的浅拷贝可以使用：Array.prototype.concat()、Array.prototype.slice()、Array.from(arr)，他们不会修改原数组，只是返回了一个浅拷贝的新数组 let arraylike = { 0: 'a', 1; 'b', length: 2 }; let arr2 = Array.from(arraylike); //[a, b] 对象可以使用 ：Object.assgin()或者 let obj2 = {...obj1} (（ECMAScript 2018规范新增特性）) 3.深拷贝所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝，使得两个对象不会相互影响 具体深拷贝的手写我在 “JavaScript进阶ES5+面向对象”篇章中写过 每种for的差异从基本的for循环，到for in、 for of和数组的forEach，差异性在面试的时候有被问到，在这里记录一下 网络上通过高数量级数组的遍历测试（地址：https://blog.csdn.net/qq_24357165/article/details/82748976），得出： 时间上：for循环遍历 &lt; for…of遍历 &lt; forEach遍历 &lt; for…in遍历 &lt; map遍历 for … in语法是第一个能够迭代对象键的JavaScript语句，循环对象键（{}）与在数组（[]）上进行循环不同，引擎会执行一些额外的工作来跟踪已经迭代的属性。 而for of 实现的是迭代器 [Symbol.iterator]方法实际上也是走的原生的for遍历，通过索引获取数组的数值，只是在函数里多增加了next、done判断遍历的结束与否 （实际上我个人认为，内部全都是以传统for为基准实现的遍历，时间和空间的额外花费取决于该遍历方法的调用占用） 递归知识尾递归：https://zhuanlan.zhihu.com/p/36587160 递归的简化模型https://zhuanlan.zhihu.com/p/136511316 其他中的其他小程序中使用eval / new Function：https://zhuanlan.zhihu.com/p/34191831?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=757127387623206912&amp;utm_campaign=shareopn 8.JS数值精度JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数 而位操作并不直接应用到64位，而是先把值转换为32位整数，在进行位操作，最后再把32位转换为34位存储起来 NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 typeof NaN // 'number' NaN === NaN // false，NaN不等于任何值 Boolean(NaN) // false JavaScript 内所有数字都是浮点数，若遇到需要整数才能运算的情况，JavaScript 会自行将64位浮点数转成32位整数，再进行运算，而这个转换过程，便导致了精度丢失。 比如： 0.1 + 0.2 // 0.30000000000000004 0.1 + 0.7 // 0.7999999999999999 0.3 / 0.1 // 2.9999999999999996 (0.3 - 0.2) === (0.2 - 0.1) // false 为什么0.1+0.2===0.3 //false ？？？？ 在计算机里的数表示方式都是二进制，so 0.01 = 1/4 = 0.25 ,太大 0.001 =1/8 = 0.125 , 又太小 0.0011 = 1/8 + 1/16 = 0.1875 , 逼近0.2了 0.00111 = 1/8 + 1/16 + 1/32 = 0.21875 , 又大了 0.001101 = 1/8+ 1/16 + 1/64 = 0.203125 还是大 0.0011001 = 1/8 + 1/16 + 1/128 = 0.1953125 这结果不错 0.00110011 = 1/8+1/16+1/128+1/256 = 0.19921875 整数精度而整数的精度最多只能到53个二进制位，这意味着，绝对值 小于 2^53 的整数，即 (-2^53, 2^53) Math.pow(2, 53) // 9007199254740992【未丢失】 Math.pow(2, 53) + 1 // 9007199254740992【丢失】 Math.pow(2, 53) + 2 // 9007199254740994【未丢失】 Math.pow(2, 53) + 3 // 9007199254740996【丢失】 Math.pow(2, 53) + 4 // 9007199254740996【未丢失】 可以使用Number.isSafeInteger(变量) 方法来判断一个值是否为安全整数，即该整数是否在 (-2^53, 2^53) 范围内 指数范围根据 IEEE 754 标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（211-1 = 2047）。分出一半表示正数，一半表示负数，则 JavaScript 能够表示的数值范围为 (2^1024, 2^-1023) 【开区间】，超出这个范围的数无法表示。 正向溢出与负向溢出 【正向溢出】如果一个数大于等于 2^1024，那么就会发生 “正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity 【负向溢出】如果一个数小于等于 2^-1075（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为 “负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 // 正向溢出 Math.pow(2, 1024) // Infinity【正数数值非常大，无法表示，正向溢出，只能返回正无穷】 // 负向溢出 Math.pow(2, -1075) // 0【正数数值非常小，无法表示，负向溢出，返回 0】 所以无穷大、无穷小由此得来 无穷大：Number.MAX_VALUE，JavaScript里最接近infinity的正值 无穷小：Number.MIN_VALUE，JavaScript 里最接近 0 的正值，而不是最小的负值。 浮点数精度修复为了避免此类事情的发生 (0.3 - 0.2) === (0.2 - 0.1) // false ECMA 给出的解决方法是：将浮点数分别乘 10n 转为整数，再除以 10n。((0.01 * 100) + (0.02 * 100)) / 100 === 0.03; // 来源：https://www.iteye.com/blog/talentluke-1767138 // 两个浮点数求和 function accAdd(num1, num2) { var r1, r2, m; try { r1 = num1.toString().split('.')[1].length; } catch(e) { r1 = 0; } try { r2 = num2.toString().split(\".\")[1].length; } catch(e) { r2 = 0; } m = Math.pow(10,Math.max(r1,r2)); // return (num1*m+num2*m)/m; return Math.round(num1*m+num2*m)/m; } 还有一个办法就是，把小数部分逐个转换成字符，然后一个一个作为单个数字去做加减乘除，实现大数加减乘除，实现方法可能比较繁琐。 使用BigInt要创建BigInt，只需要在数字末尾追加n即可。 console.log( 9007199254740995n ); // → 9007199254740995n console.log( 9007199254740995 ); // → 9007199254740996 复制代码 另一种创建BigInt的方法是用BigInt()构造函数、 BigInt(\"9007199254740995\"); // → 9007199254740995n 注意： BigInt不支持一元加号运算符，这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码 +10n; // → TypeError: Cannot convert a BigInt value to a number 因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作 9.捕获异常try catch无法捕获异步任务的错误，这跟浏览器的执行机制有关。异步任务由 eventloop 加入任务队列，并取出入栈(js 主进程)执行，而当 task 取出执行的时候， main 的栈已经退出了，也就是上下文环境已经改变，所以 main 无法捕获 task 的错误。 // 异步任务 // 捕获不到 const task = () => { setTimeout(() => { throw new Error('async error') }, 1000) } // 主任务 function main() { try { task(); } catch(e) { console.log(e, 'err') console.log('continue...') } } 而微任务promise中， promise.catch 才可以捕获，所以用 Promise 一定要写 catch 啊 然而通过 async await 的方式，是可以在try catch中捕获异常的 async function main () { try { const res = await fetchFailure(); console.log(res, 'res'); } catch(e) { console.log(e, 'e.message'); } } console.error(&quot;服务端数据格式返回异常，使用本地缓存数据&quot;, erorr); 输出台打印红色字体 运行时异常代码也捕获不到 2.”运行时异常”是指非SyntaxError，也就是语法错误是无法捕获的，因为在解析JavaScript源码时就报错了，还怎么捕获呢～～ // 非法标识符a->b，真心捕获不到啊亲～！ try{ a->b = 1 } catch(e){ console.log(e) }","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Docker","slug":"Docker","date":"2022-06-04T16:00:00.000Z","updated":"2022-06-05T16:11:22.731Z","comments":true,"path":"2022/06/05/docker/","link":"","permalink":"https://taylor12138.github.io/2022/06/05/docker/","excerpt":"","text":"Docker概述简要概述IT 软件中所说的 “Docker” ，是指容器化技术，用于支持创建和使用 Linux® 容器。 开源 Docker 社区致力于改进这类技术，并免费提供给所有用户，使之获益。 一般来说，比如我们写了一个web应用，如果朋友们要看/部署到远程服务器，，那么首先都需要配置相同的依赖（数据库啊之类的，甚至要保证操作系统的一致性），为了模拟完全相同的本地开发环境，我们可以使用虚拟机，但是虚拟机的缺点： 虚拟机需要模拟硬件，运行整个操作系统，不但体积臃肿内存占高，程序性能也会受到影响 Docker在概念上和虚拟机十分相似，但是轻量很多，它不会去模拟底层硬件，只是为每个应用提供一个完全隔离的运行环境（类似于sandbox），我们可以在每个不同的环境配置不同的工具 Image/镜像 类似于一个虚拟机快照，里面包含了你要部署的应用程序以及他关联的所有库 通过镜像，我们可以创建许多不同的container容器，这里的容器就像一台台虚拟机，每个container独立运行 Dockerfile 类似于一个自动化脚本，主要用来创建镜像（类比在虚拟机中安装操作系统和软件） 特点 模块化 层和镜像版本控制 回滚 快速部署 应用借助 Docker，您可将容器当做轻巧、模块化的虚拟机使用。同时，您还将获得高度的灵活性，从而实现对容器的高效创建、部署及复制，并能将其从一个环境顺利迁移至另一个环境，从而有助于您针对云来优化您的应用。 原理Docker 使用 Google 公司推出的 Go 语言 进行开发实现 Docker 技术使用 Linux 内核和内核功能（例如 Cgroups 和 namespaces）来分隔进程，以便各进程相互独立运行。这种独立性正是采用容器的目的所在；它可以独立运行多种进程、多个应用，更加充分地发挥基础设施的作用，同时保持各个独立系统的安全性。 参考：https://www.bilibili.com/video/BV1s54y1n7Ev?from=search&amp;seid=15719185628407439607&amp;spm_id_from=333.337.0.0","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"WebAssembly","slug":"WebAssembly","date":"2022-06-04T16:00:00.000Z","updated":"2023-06-01T17:37:32.620Z","comments":true,"path":"2022/06/05/webassembly/","link":"","permalink":"https://taylor12138.github.io/2022/06/05/webassembly/","excerpt":"","text":"WebAssemblywebasembly是一种新型代码，它提供了一种以接近本机的速度在 Web 上运行以多种语言编写的代码的方法，客户端应用程序可以在 Web 上运行，比如可以在浏览器跑C/C++代码 asm.js2012年，Mozilla 的工程师 Alon Zakai做了一个编译器项目 Emscripten。这个编译器可以将 C / C++ 代码编译成 JS 代码，但不是普通的 JS，而是一种叫做 asm.js 的 JavaScript 变体。 问题C / C++ 编译成 JS 有两个最大的困难。 C / C++ 是静态类型语言，而 JS 是动态类型语言。 C / C++ 是手动内存管理，而 JS 依靠垃圾回收机制。 asm.js 就是为了解决这两个问题而设计的：它的变量一律都是静态类型，并且取消垃圾回收机制。除了这两点，它与 JavaScript 并无差异，也就是说，asm.js 是 JavaScript 的一个严格的子集，只能使用后者的一部分语法。 所以可以看到 ts 是 js的超集，asm.js是js的子集 速度快并且一旦 JS 引擎发现运行的是 asm.js，就知道这是经过优化的代码，可以跳过语法分析这一步，直接转成汇编语言。另外，浏览器还会调用 WebGL 通过 GPU 执行 asm.js，即 asm.js 的执行引擎与普通的 JavaScript 脚本不同。这些都是 asm.js 运行较快的原因。据称，asm.js 在浏览器里的运行速度，大约是原生代码的50%左右。 Emscripten虽然 asm.js 可以手写，但是它从来就是编译器的目标语言，要通过编译产生。目前，生成 asm.js 的主要工具是 Emscripten。 如果要获得asm.js的文件，可以通过学习Emscripten，并用Emscripten便衣你要转换的C/C++文件即可 安装Emscripten 看这里 使用 创建一个c文件 #include &lt;stdio.h> int main(){ printf(\"hello world\"); return 0; } emcc hello.c -s WASM=1 -o hello.html 此时可以看到hello.html、hello.css、hello.js文件 emcc hello.c -s WASM=1 -o hello.wasm 此时可以看到hello.wasm文件 编译相关以asm.js为编译目标时，C/C代码被编译为.js文件；以WebAssembly为编译目标时，C/C代码被编译为.wasm文件及对应的.js胶水代码文件。两种编译目标从应用角度来说差别不大——它们使用的内存模型、函数导出规则、JavaScript与C相互调用的方法等都是一致的。我们在实际使用中遇到的主要区别在于模块加载的同步和异步：当编译目标为asm.js时，由于C/C++代码被完全转换成了asm.js（JavaScript子集），因此可以认为模块是同步加载的；而以WebAssembly为编译目标时，由于WebAssembly的实例化方法本身是异步指令，因此模块加载为异步加载。以asm.js为目标的工程切换至WebAssembly时，容易发生Emscritpen运行时未就绪时调用了Module功能的问题，需要按照1.3.3的方法予以规避。 自1.38.1起，Emscripten默认的编译目标切换为WebAssembly。如果仍然需要以asm.js为编译目标，只需要在调用emcc时添加-s WASM=0参数，例如： &gt; emcc hello.cc -s WASM=0 -o hello_asm.jsWebAssembly是二进制格式，体积小、执行效率高是其先天优势。作为比较，上述命令生成的hello_asm.js约300KB，而WebAssembly版本的hello.js与hello.wasm加在一起还不到150KB。在兼容性允许的情况下，应尽量使用WebAssembly作为编译目标。 -o：编译后的文件 -O1、-O2、-O3、-Oz、-Os、-g 等：编译优化，具体可参考 Emscripten 官网相关章节；（压缩代码） 编译参数-s WASM=1 (0/1/2) WASM=0生成asm.js格式(适用于WebAssembly不支持的情况) WASM=1生成包含wasm格式 WASM=2 asm.js与wasm格式均生成，添加支持判定，优先使用wasm格式。 更多参数看： csdn文章：Emscripten 编译器(emcc) 命令总结 知乎文章：emscripten 编译参数 野文章(参数在网页下方)：从 0 开始快速上手 WebAssembly：Emscripten 使用入门 官网：编译为WebAssembly、代码优化 和wasm的对比如果你对 JS 比较了解，可能知道还有一种叫做 WebAssembly 的技术，也能将 C / C++ 转成 JS 引擎可以运行的代码。那么它与 asm.js 有何区别呢？ 回答是，两者的功能基本一致，就是转出来的代码不一样：asm.js 是文本，WebAssembly 是二进制字节码，因此运行速度更快、体积更小。从长远来看，WebAssembly 的前景更光明。 但是，这并不意味着 asm.js 肯定会被淘汰，因为它有两个优点：首先，它是文本，人类可读，比较直观；其次，所有浏览器都支持 asm.js，不会有兼容性问题。 参考阅读推荐：很棒的 WebAssembly 应用程序的精选列表 asm.js 和 Emscripten 入门教程 C/C++面向WebAssembly编程","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Chrome插件小指南","slug":"Chrome插件小指南","date":"2022-05-27T16:00:00.000Z","updated":"2022-05-29T05:05:54.247Z","comments":true,"path":"2022/05/28/chrome-cha-jian-xiao-zhi-nan/","link":"","permalink":"https://taylor12138.github.io/2022/05/28/chrome-cha-jian-xiao-zhi-nan/","excerpt":"","text":"1.开始 重要提示： Chrome 将在所有平台上移除对 Chrome 应用程序的支持。Chrome 浏览器和 Chrome 网上应用店将继续支持扩展。阅读公告并了解有关迁移应用程序的更多信息。 也就是说现在更加推崇插件，而不是chrome应用程序，让我们开始学习插件吧 介绍扩展由不同但有凝聚力的组件组成。组件可以包括背景脚本、内容脚本、选项页面、UI 元素和各种逻辑文件。扩展组件是使用 Web 开发技术创建的：HTML、CSS 和 JavaScript。扩展的组件将取决于其功能，并且可能不需要每个选项。 创建一个新目录来保存扩展的文件夹。 创建一个名为manifest.json并包含以下代码的文件。 { // 插件名称 \"name\": \"Hello Extensions\", // 插件的描述 \"description\" : \"Base Level Extension\", // 插件的版本 \"version\": \"1.0\", // 配置插件程序的版本号，主流版本是2，最新是3 \"manifest_version\": 3 } 在chrome的拓展页面打开开发者模式：chrome://extensions/ 然后选择 “Load unpacked”（加载已解压的拓展程序），导入刚才我们新创建的文件夹，现在就可以看到我们的文件了！！ 但是现在啥也没用。。此时我们可以添加后台脚本，让我们通过添加一些代码来存储背景颜色值。 注册脚本 + 添加存储权限与许多其他重要组件一样，后台脚本必须在清单中注册。在清单中注册一个后台脚本会告诉扩展程序引用哪个文件，以及该文件应该如何运行。 大多数 API，包括存储API，必须&quot;permissions&quot;在清单中的字段下注册，以便扩展使用它们。 { \"name\": \"Getting Started Example\", \"description\": \"Build an Extension!\", \"version\": \"1.0\", \"manifest_version\": 3, \"background\": { \"service_worker\": \"background.js\" }, \"permissions\": [ \"storage\" ] } 好了，现在我们有一个service_worker了，Chrome 将扫描指定文件以获取其他说明，例如它需要侦听的重要事件。 此时我们在根目录下新创建一个 background.js 文件，并且贴上代码 // background.js let color = '#3aa757'; chrome.runtime.onInstalled.addListener(() => { chrome.storage.sync.set({ color }); console.log('Default background color set to %cgreen', `color: ${color}`); }); 此时我们在chrome拓展页面重新加载插件，然后还可以查看后台日志（查看console.log的信息） 声明用户界面类似于前端的html文件 首先在配置文件 manifest.json 中声明 action对象并设置popup.html为操作的default_popup. { \"name\": \"Getting Started Example\", \"description\": \"Build an Extension!\", \"version\": \"1.0\", \"manifest_version\": 3, \"background\": { \"service_worker\": \"background.js\" }, \"permissions\": [\"storage\"], \"action\": { \"default_popup\": \"popup.html\" } } 然后再根目录下创建 popup.html 并且创建 button.css、popup.js在html中引入 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;link rel=\"stylesheet\" href=\"button.css\"> &lt;/head> &lt;body> &lt;button id=\"changeColor\">&lt;/button> &lt;script src=\"popup.js\">&lt;/script> &lt;/body> &lt;/html> //popup.js // Initialize button with user's preferred color let changeColor = document.getElementById(\"changeColor\"); chrome.storage.sync.get(\"color\", ({ color }) => { changeColor.style.backgroundColor = color; }); /*button.css*/ button { height: 30px; width: 30px; outline: none; margin: 10px; border: none; border-radius: 2px; } button.current { box-shadow: 0 0 0 2px white, 0 0 0 4px black; } 重新加载插件 此时插件的弹窗就会显示html内容（我通过了js文件修改了button的颜色） 添加拓展程序的icon工具栏图标的名称也包含action在该default_icon字段中。在此处下载 images 文件夹，解压缩，并将其放在扩展程序的目录中。更新清单，以便扩展知道如何使用图像。 { \"name\": \"Getting Started Example\", \"description\": \"Build an Extension!\", \"version\": \"1.0\", \"manifest_version\": 3, \"background\": { \"service_worker\": \"background.js\" }, \"permissions\": [\"storage\"], \"action\": { \"default_popup\": \"popup.html\", \"default_icon\": { \"16\": \"/images/get_started16.png\", \"32\": \"/images/get_started32.png\", \"48\": \"/images/get_started48.png\", \"128\": \"/images/get_started128.png\" } } } 扩展程序还会在扩展程序管理页面、权限警告和网站图标上显示图像。这些图像在清单中指定icons。 （分别对应16位、32位、48位、128位的图） { \"name\": \"Getting Started Example\", \"description\": \"Build an Extension!\", \"version\": \"1.0\", \"manifest_version\": 3, \"background\": { \"service_worker\": \"background.js\" }, \"permissions\": [\"storage\"], \"action\": { \"default_popup\": \"popup.html\", \"default_icon\": { \"16\": \"/images/get_started16.png\", \"32\": \"/images/get_started32.png\", \"48\": \"/images/get_started48.png\", \"128\": \"/images/get_started128.png\" } }, \"icons\": { \"16\": \"/images/get_started16.png\", \"32\": \"/images/get_started32.png\", \"48\": \"/images/get_started48.png\", \"128\": \"/images/get_started128.png\" } } 重新加载插件 效果展示： 添加交互逻辑将以下代码添加至 popup.js 中 // When the button is clicked, inject setPageBackgroundColor into current page changeColor.addEventListener(\"click\", async () => { let [tab] = await chrome.tabs.query({ active: true, currentWindow: true }); chrome.scripting.executeScript({ target: { tabId: tab.id }, function: setPageBackgroundColor, }); }); // The body of this function will be executed as a content script inside the // current page function setPageBackgroundColor() { chrome.storage.sync.get(\"color\", ({ color }) => { document.body.style.backgroundColor = color; }); } 在配置文件 manifest.json 中添加交互的权限 （清单将需要activeTab允许扩展临时访问当前页面的scripting权限，以及使用脚本 APIexecuteScript方法的权限。） { \"name\": \"Getting Started Example\", ... \"permissions\": [\"storage\", \"activeTab\", \"scripting\"], ... } 重新加载插件 点击绿色button控件就可以看到： 注意：扩展程序不能在“chrome://extensions”等内部 Chrome 页面上注入内容脚本。请务必在https://google.com等真实网页上试用该扩展程序。 以上小demo的拓展目前通过我们自制的chrome插件，只能把当前页面的改为绿色的，现在我们添加选项列表，让用户可以 将背景改为不同的颜色 给插件添加选项页面： 首先在配置文件 manifest.json 中添加 { \"name\": \"Getting Started Example\", //... \"options_page\": \"options.html\" } 新建options.html 和 options.js &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;link rel=\"stylesheet\" href=\"button.css\"> &lt;/head> &lt;body> &lt;div id=\"buttonDiv\"> &lt;/div> &lt;div> &lt;p>Choose a different background color!&lt;/p> &lt;/div> &lt;script src=\"options.js\">&lt;/script> &lt;/body> &lt;/html> let page = document.getElementById(\"buttonDiv\"); let selectedClassName = \"current\"; const presetButtonColors = [\"#3aa757\", \"#e8453c\", \"#f9bb2d\", \"#4688f1\"]; // Reacts to a button click by marking the selected button and saving // the selection function handleButtonClick(event) { // Remove styling from the previously selected color let current = event.target.parentElement.querySelector( `.${selectedClassName}` ); if (current &amp;&amp; current !== event.target) { current.classList.remove(selectedClassName); } // Mark the button as selected let color = event.target.dataset.color; event.target.classList.add(selectedClassName); chrome.storage.sync.set({ color }); } // Add a button to the page for each supplied color function constructOptions(buttonColors) { chrome.storage.sync.get(\"color\", (data) => { let currentColor = data.color; // For each color we were provided… for (let buttonColor of buttonColors) { // …create a button with that color… let button = document.createElement(\"button\"); button.dataset.color = buttonColor; button.style.backgroundColor = buttonColor; // …mark the currently selected color… if (buttonColor === currentColor) { button.classList.add(selectedClassName); } // …and register a listener for when that button is clicked button.addEventListener(\"click\", handleButtonClick); page.appendChild(button); } }); } // Initialize the page by constructing the color options constructOptions(presetButtonColors); 此时重新加载chrome插件，即可在插件位置的拓展选项中找到options，点击进入，然后进入选项页面 参考：https://developer.chrome.com/docs/extensions/mv3/getstarted/（chrome插件官方文档） 关于一些插件的开发细节，推荐一篇详细的文章：https://xieyufei.com/2021/11/09/Chrome-Plugin.html（可惜的是该文章讲的是v2版本的。。） 2.manifest.json根据上文可以知道，manifest.json是用来配置我们的插件的配置文件，让我们来看一下一些配置详情 基础除了上面提到的 { // 插件名称 \"name\": \"Hello Extensions\", // 插件的描述 \"description\" : \"Base Level Extension\", // 插件的版本 \"version\": \"1.0\", // 配置插件程序的版本号 \"manifest_version\": 3 } 使用 Manifest V3 的扩展有许多新特性和功能更改： 服务工作者替换背景页面。 现在使用新的declarativeNetRequest API处理网络请求修改。 不再允许远程托管代码；扩展只能执行包含在其包中的 JavaScript。 许多方法都添加了Promise支持，但仍支持回调作为替代方案。（我们最终将支持所有适当方法的承诺。） Manifest V3 中还引入了许多其他相对较小的功能更改。 2023年1月份不再更新v2版本 弹窗对于使用插件时，弹出的像小窗口页面，我们要设置 弹窗显示的页面和插件弹窗的icon \"action\": { \"default_popup\": \"popup.html\", \"default_icon\": \"popup.png\" } 后台background（后台）属性，用于配置chrome插件的后台，它是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的；它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。 注意：Manifest V3 将后台页面替换为 Service Worker。 \"background\": { \"service_worker\": \"background.js\" } //background.js chrome.runtime.onInstalled.addListener(() => { console.log(\"插件已被安装\") }); 权限{ \"name\": \"My extension\", ... \"permissions\": [ \"storage\" ], ... } 存储方法：chrome.storage可以移步到4章节观看 CSP配置\"content_security_policy\": { \"extension_pages\": \"...\", \"sandbox\": \"...\" } extension_pages此政策涵盖您的扩展程序中的页面，包括 html 文件和服务人员。 这些页面类型由chrome-extension://协议提供。例如，您的扩展程序中的一个页面是chrome-extension://EXTENSION_ID/foo.html. sandbox：此政策涵盖您的扩展程序使用的任何沙盒扩展程序页面。 3.网络请求扩展可以修改网络请求的方式在 Manifest V3 中发生了变化。 Manifest V3 为 Promise 提供一流的支持：许多流行的 API 现在都支持 Promise，我们最终将在所有适当的方法上支持 Promise。 declarativeNetRequest概述declarativeNetRequest API，它允许扩展以保护隐私和高性能的方式修改和阻止网络请求。这个API的本质是： 该扩展程序不是拦截请求并按程序修改它，而是要求 Chrome 代表它评估和修改请求。 该扩展声明了一组规则：匹配请求的模式和匹配时执行的操作。然后浏览器修改这些规则定义的网络请求。 使用这种声明性方法可以显着减少对持久主机权限的需求。 对于某些用例（例如重定向请求），某些扩展可能仍需要广泛的主机权限。有关更多详细信息，请参阅条件权限和 declarativeNetRequest。 与之前版本的 webRequestAPI （v3之前比如v2） 与webRequestAPI的比较 declarativeNetRequest API 允许在浏览器本身中评估网络请求。这使得它比 webRequest API 更高效，在扩展过程中每个网络请求都在 JavaScript 中进行评估。 因为请求不会被扩展进程截获，所以 declarativeNetRequest 不需要扩展有后台页面；从而减少内存消耗。 与 webRequest API 不同，使用 declarativeNetRequest API 阻止或升级请求在与权限一起使用时不需要主机declarativeNetRequest权限。 declarativeNetRequest API 为用户提供了更好的隐私，因为扩展实际上无法读取代表用户发出的网络请求。 与 webRequest API 不同，使用 declarativeNetRequest API 阻止的任何图像或 iframe 都会在 DOM 中自动折叠。 在决定请求是被阻止还是重定向时，declarativeNetRequest API 的优先级高于 webRequest API，因为它允许同步拦截。同样，通过 declarativeNetRequest API 删除的任何标头对于 Web 请求扩展都是不可见的。 与 declarativeNetRequest API 相比，webRequest API 更灵活，因为它允许扩展程序以编程方式评估请求。 4.存储chrome.storage 描述 使用chrome.storageAPI 存储、检索和跟踪对用户数据的更改。 权限 storage 概述该 API 已经过优化以满足扩展的特定存储需求。它提供与localStorage API相同的存储功能，但主要区别如下： 用户数据可以与 Chrome 同步（使用storage.sync）自动同步。 您的扩展程序的内容脚本可以直接访问用户数据，而无需后台页面。 即使使用拆分隐身行为，用户的扩展设置也可以保留。 它与批量读写操作是异步的，因此比阻塞和串行更快localStorage API。 用户数据可以存储为对象（localStorage API将数据存储在字符串中）。 可以读取管理员为扩展配置的企业策略（使用storage.managed模式）。 使用首先要在manifest.json 中声明权限 chrome.storage.sync.set({key: value}, function() { console.log('Value is set to ' + value); }); chrome.storage.sync.get(['key'], function(result) { console.log('Value currently is ' + result.key); }); 或storage.local： chrome.storage.local.set({key: value}, function() { console.log('Value is set to ' + value); }); chrome.storage.local.get(['key'], function(result) { console.log('Value currently is ' + result.key); }); 使用时storage.sync，如果用户启用了同步，存储的数据将自动同步到用户登录的任何 Chrome 浏览器。 当 Chrome 离线时，Chrome 会在本地存储数据。下次浏览器在线时，Chrome 会同步数据。即使用户禁用同步，storage.sync仍然可以工作。在这种情况下，它的行为将与 相同storage.local。 警告 不应存储机密的用户信息！存储区域未加密。 存储限制chrome.storage不是一辆大卡车。这是一系列的管子。如果你不明白，那些管子是可以装满的，如果你把你的信息填满了，它就会排成一行，任何人把大量的材料放进那个管子里都会延迟。 local：QUOTA_BYTES：5242880 sync：MAX_ITEMS：512；QUOTA_BYTES：102400 5.background -&gt; Server worker概述Manifest V2 中的后台页面被 Manifest V3 中的服务工作人员取代：这是影响大多数扩展的基本更改。 Service Worker是基于事件的，并且与事件页面一样，它们不会在调用之间持续存在。此更改通常需要重新设计，需要考虑许多因素：有关更多详细信息，请参阅从后台页面迁移到服务工作者。 对比v2版本： 在 manifest.json 中替换background.page或background.scripts替换为。background.service_worker请注意，该service_worker字段采用字符串，而不是字符串数组。 background.persistent从 manifest.json 中删除。 更新后台脚本以适应服务工作者执行上下文。 配置： { \"background\": { \"service_worker\": \"background.js\" }, } 定时器setTimeoutWeb 开发人员使用orsetInterval方法执行延迟或定期操作是很常见的。但是，这些 API 在Server worker中可能会失败，因为调度程序将在服务工作人员终止时取消计时器。 // background.js // This worked in Manifest V2. const TIMEOUT = 3 * 60 * 1000; // 3 minutes in milliseconds setTimeout(() => { chrome.action.setIcon({ path: getRandomIconPath(), }); }, TIMEOUT); 相反，我们要用警报API // background.js chrome.alarms.create({ delayInMinutes: 3 }); chrome.alarms.onAlarm.addListener(() => { chrome.action.setIcon({ path: getRandomIconPath(), }); }); 6.执行代码在v3之前（v2），我们可以执行外部代码或立即执行某预定义的代码： chrome.scripting.executeScript({code: &#39;...&#39;})、eval()、new Function() 在v3之后我们不能再是使用了 在 Manifest V3 中，有几个方法从APIchrome.tabs转移。chrome.scripting 更改以下任何 Manifest V2 调用以使用正确的 Manifest V3 API： 清单 V2 清单 V3 tabs.executeScript() scripting.executeScript() tabs.insertCSS() scripting.insertCSS() tabs.removeCSS() scripting.removeCSS() chrome插件API清单https://developer.chrome.com/docs/extensions/reference/","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"TypeScript","slug":"TypeScript","date":"2022-05-14T15:04:34.116Z","updated":"2022-05-14T15:04:34.116Z","comments":true,"path":"2022/05/14/typescript/","link":"","permalink":"https://taylor12138.github.io/2022/05/14/typescript/","excerpt":"","text":"1.结识TypeScript传统上，JS旨在用于简短，快速运行的代码片段，作为浏览器脚本语言，主要用途是与用户互动，以及操作DOM，所以JS比较适合单线程。 但是由此导致后期维护性比较差 面向对象撰写麻烦 没有类型规范 微软于2014年推出的TypeScript以JavaScript为基础构建的语言，JavaScript的超集（拓展）引入了类型的概念，它可以在任何支持JS的平台中运行，但是不能被JS解析器直接执行，所以需要我们进行编译 TS -&gt; JS 对比： 1.引入类型，可以理解为TypeScript为JavaScript的静态语言模式， 2.增加了ES不具备的新特性，比如抽象类、工具等 3.丰富的配置选项，可以通过配置转化为兼容性强的es5、es3语法 TS官网文档doc https://www.typescriptlang.org/ 环境搭配1.下载 and 安装Node.js 2.使用npm安装全局TypeScript npm i -g typescript 3.创建一个ts文件 4.使用tsc对ts文件进行编译 进入ts文件目录 执行tsc xxx.ts (此时就会转换成js文件，感觉有点less转css内味了) 5.在项目中，可以使用webpack / ts-node自动编译转换 ts-node有点像node，方便我们直接测试代码 npm i ts-node -g npm i tslib @types/node -g 此时直接ts-node ts文件名 即可运行ts文件 2.TypeScript基础类型选择 类型 例子 描述 number 1, 2, -22 任意数字， string “here we go” 任意字符串 boolean true、false 布尔值true或false 字面量 其本身 限制变量的值就是该字面量的值 any * 任意类型 unknown * 类型安全的any void 空值（undefined） 没有值（或undefined） never 没有值 不能是任何值 object {name:’Allen’} 任意的JS对象 array [1,2,3] 任意JS数组 tuple [4,5] 元素，TS新增类型，固定长度数组 enum enum{A, B} 枚举，TS中新增类型 字面量：相当于定死一个固定的常量，let a: 10，此时a只能赋值为10。 在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。 any：类似于让TS回归JS原生，可以赋值给任意变量，应用在一些类型断言上（as any），函数的参数未声明类型也是any unknown：表示未知类型的值，有点类似any，只能赋值给any和unknown类型（不让你乱传人）。尽量用unknown，不要用any let a: any; a = true; //a可以表任意类型 let b: unknown; b = \"hello\" //b可以表任意类型 let s: string; s = a //通过 s = b //报错 if(typeof b === \"string\"){ s = b //通过 } 类型声明let a: number; //声明一个变量a，同时指定它的类型为number let b: number | string //声明一个变量b，同时指定它的类型为number或者string 由此，在以后的使用过程中，a只能为number类型 // a = 'hello'; //报错，不能将类型string分配给类型number a = 1; 不过还是TS -&gt; JS 编译成功，因为是为了让JS开发人员慢慢熟悉 最常用的类型声明方式还是： （记住number是小写） let a: number = 2; //如果变量的声明和赋值是同时进行，TS可以自动对变量进行类型检测，最后可以简化为 //因为typescript会帮我们推导出来 let a = 2; 函数 虽然在变量声明看不出有多大用处，但是应用于函数上，大有文章 JS中的函数不考虑参数的类型和个数，很容易出现错误 function sum(a, b) { return a + b; } console.log(sum(123, \"456\")); //123456，不是我们想要的结果 // ts语法 function Sum(a: number, b: number): number{ //设置返回值类型为number，也可以由TS自动推导 return a + b; } console.log(Sum(123, \"456\")); //报错 // 传入多个不定数量的参数 function other(...data: number[]){ console.log(...data); } other(1, 2, 3, 5); 当函数作为参数传入时，函数的类型注解也要写上 function bar(fn: () => void) { fn(); } 当函数返回值是void时，实际上返回啥类型都可以，TS编译都通过 有时TS类型推断并不能确定当前函数的this是否有指定的属性，此时我们给和TS说明我们给的this指定类型 type ThisType = { name: string }; function eating(this: ThisType) { console.log(this.name); } const info = { name: \"allen\", eating } info.eating(); void：空值，常用于表示表示函数没有返回值 | 返回undefined | 返回 null function fn(): void{}，如果不设置返回值也是void never：空值，常用于表示表示函数没有返回结果 function fn(): never{}，可用于死循环或者函数抛出异常，实际应用在检测代码对函数的错误修改，而对never类型的变量赋值 官方文档： function fn(x: string | number) { if (typeof x === \"string\") { // do something } else if (typeof x === \"number\") { // do something else } else { x; // has type 'never'! } } object： //声明一个变量d，同时指定它是一个对象，且一定有一个string类型的name属性，可以有其他新的可选属性 let d: { name:string, [propName: string]: any }; //或者直接使用typescript的类型推断，和第一个一样 let e = { name: \"allen\", age: 18 } array： let e: string[]; //声明一个字符串数组（存储字符串） let arr: number[]; let arr2 = Array&lt;number> //声明数值数组，两种都可以，推荐上一种，因为Array&lt;number>这种写法jsx会有冲突 tuple：元组，也就是固定长度的数组，效率相对数组好一点 。可以并行多种类型 //两个元素的数组，分别是string、number类型 let h: [string, number] = ['allen', 18]; enum：枚举的使用 // 平时我们存储男、女这些字符串，数据库占用空间大，像这种在几个值之间选择的情况，可以用枚举替代字符串 // 当然，我们可以不写值，此时Male、Female默认0、1 enum Gender { Male = 1, Female = 0 } let i: { name: string, gender: Gender } = { name: 'Allen', gender: Gender.Male } console.log(i.gender === Gender.Male); //true console.log(Gender['Male']); //1 console.log(Gender[1]); //Male 定时器： 类型为NodeJS.Timeout 自定义类型也可以称之为类型别名 type myType = 1 | 2 | 3 | string; let a: myType; a = 4 //报错 类型断言用来告诉解析器变量实际类型，编译器不知道（所以报错），我们自己是知道的，让它放心使用 在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。 s = b as string //通过 s = &lt;string>b //通过 应用： // &lt;img id=\"img\" /> const el = document.querySelector('#img') as HTMLImageElement; el.src = 'url地址' class Person { } class Student extends Person { study() { console.log(\"studying!\"); } } const foo = (p: Person) => { (p as Student).study() } const s = new Student(); foo(s); const断言 当我们使用关键字 const 声明一个字面量时，类型是等号右边的文字，例如： const x = 'x'; // x has the type 'x' const 关键字确保不会发生对变量进行重新分配，并且只保证该字面量的严格类型。 但是如果我们用 let 而不是 const， 那么该变量会被重新分配，并且类型会被扩展为字符串类型，如下所示： let x = 'x'; // x has the type string; 但是let实质上也可以使用字面量类型，而字面量类型的意义在在于结合联合类型（有点像枚举类型） let x: 'left' | 'right' | 'center' = 'left'; x = 'inner'; //×错误 const断言告诉编译器为表达式推断出它能推断出的最窄或最特定的类型。 比如 const option = { url: 'xxx', methods: \"POST\" } as const 会被推断为（每个属性都被转变为字面量类型） const option: { readonly url: \"xxx\"; readonly methods: \"POST\"; } 如果不使用它，编译器将使用其默认类型推断行为（比如直接进行赋值 let x = &quot;hello&quot;，x自动推断为string类型），这可能会导致更广泛或更一般的类型。 const option = { url: 'xxx', methods: \"POST\" } 也就是会被推断为 const option: { url: string; methods: string; } 网络上还有一个比较形象具体的例子： const args = [8, 5]; // const args: number[] const angle = Math.atan2(...args); // error! Expected 2 arguments, but got 0 or more. console.log(angle); 也可以解释为，当前类型为number[]，数组数量可以被修改，所以时显示 ”0或更多“ 通过const断言进行改动后 const args = [8, 5] as const; // const args: readonly [8, 5] const angle = Math.atan2(...args); // okay console.log(angle); 现在编译器推断args属于readonly [8, 5]类型。。。一个readonly元组，其值正好是按此顺序排列的数字8和5。具体来说，args.length被编译器精确地称为2。（看不懂 readonly可以拆解为 read only，只读的，它仅允许对数组、元组使用 ） 也可以解释为，当前类型为[8, 5]，数组数量固定死了，为2，参数数量可以接收 + 通过 标符小语法 可选属性 可选属性后面加一个 ?（实质上可选就是 xx类型 | undefined 的联合类型） //声明一个变量c，同时指定它是一个对象，且一定有一个string类型的name属性，可选属性age类型为number，不能有其他新的属性 //可选属性一般要放在后面 let c: { name: string, age?: number }; function foo(x: number, y?: number){} 非空类型断言 当前属性一定有值，则加一个 !，此时在函数里定义时不用做null / undefined 判断 （ 比如message一定有值，则设置message!.length ），可以称之为非空类型断言 此时跳过ts在编译阶段对它的检测 可选链 当对象属性不存在时，会短路，直接返回undefined 使用： a.b?.c，如果b属性不为undefined，继续查找 c !!，转布尔值，类似于Boolean()直接转 ??，ES11新增的特性 它是空值合并操作符，当操作符的左侧为null 或者 undefined的时候，返回其右侧操作数，否则返回左侧操作数 const message: string|null = null const content = message ?? \"hello world\" // 同 content = message ? message : \"hello world\" // 同 content = message || \"hello world\" TS函数重载函数的重载一般指函数名称相同，通过不同的参数调用不同的函数的形式 /* *函数声明和函数实现分开 */ function add(num1: number, num2: number): number; //没有函数体 function add(num1: string, num2: string): string; // 没有函数体则会执行以下函数体的实现 // 此时要匹配到上方的重载函数才会执行，也就是说使用函数重载后，这个实现函数不能直接被调用的 function add(num1: any, num2: any): any { return num1 + num2 } const res = add(1, 2); const res2 = add('1', '2'); 编译选项每一次对TS文件进行改动，我们都不得不使用 tsc xxx.ts进行重新编译 tsc xxx.ts -w -w加上后，会自动监视TS文件变化。但是一个文件就得开一个窗口进行监视 如果当前项目有TS的配置文件（tsconfig.json），可以在当前目录下直接执行命令（没有配置文件直接执行命令 tsc --init即可 ） tsc #编译所有ts文件 tsc -w #编译所有TS文件 + 监视所有TS文件的变化 tsconfig.json是ts编译器的配置文件 { \"include\": [ //配置些TS文件需要被编译，这里是根目录/src/任意目录/任意文件 \"./src/**/*\" ], \"exclude\": [\"ndoe_modules\"], //不包含哪些文件 \"files\": [], //和include很像，只不过include列出路径，files直接一一列出文件 \"compilerOptions\":{ //编译器配置选项 \"target\": \"es5\", //target用来指定ts被编译为ES版本，默认ES3 \"module\": \"commonjs\", //module指定模块化的规范 \"lib\": [], //lib用来指定项目中要使用的库，使用场景一般在非浏览器环境下运行，比如在nodejs下我要使用dom，\"lib\": [\"dom\"] \"outDir\": \"./\", //outDir指定编译后文件所在的目录 \"outDir\": \"./dist\", 存于个目录下dist文件夹 \"outFile\":\"./dist/app.js\", //outFile 将代码合并为一个文件，但其实项目开发更多让打包工具去做这个事 \"allowJs\": false, //是否对js文件进行编译，默认false \"checkJs\": false, //检查js文件符合语法规范，一般和allowJs配套使用 \"removeComments\": false, //是否移除备注 \"noEmitOnError\": false, //当有错误时不生成编译后的文件 \"strict\":false, //所有严格检查总开关 \"alwaysStrict\": true, //设置编译后JS文件是否使用严格模式，默认false \"noImplicitAny\": false, //不允许隐式any类型 \"noImplicitThis\": false, //不允许不明确类型this \"strictNullChecks\": false, //严格检查空值（或者可能成为空值的变量） \"moduleResolution\": \"node\",//按照node的方式去解析模块 \"skipLibCheck\": true, //跳过一些库的类型检测（axios->类型 / lodash -> types/lodash / 其他第三方库） //避免掉无意义的检测和性能的浪费，亦或者不同库定义同名类型导致的错误 \"paths\": { \"@/*\": [\"src/*\"] //路径解析 }, \"lib\": [\"esnext\", \"dom\", \"dom.iterable\", \"scripthost\"], //可以指定在项目中可以使用哪里库的类型 } } 备注： 路径 **：任意目录 *：任意文件 exclude 有默认值，[“node_modules”, “bower_components”, “jspm_packages”]，如果只想排除以上默认值，其实我们可以不用写这个配置 使用webpack打包TS代码初始化生成pack.json文件 npm init --yes 安装相关loader，webpack等 npm i -D webpack webpack-cli typescript ts-loader 新建webpack.config.js文件，并且进行配置 const path = require('path') module.exports = { entry: \"./src/index.ts\", output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js' }, module: { // 指定加载规则 rules: [ { test: /\\.ts$/,// test指定规则生效的文件,以ts结尾的文件 use: 'ts-loader', exclude: /node_modules/ } ] } } 新建 + 配置 TS编译的配置文件（tsconfig.json） 亦或者是通过命令 tsc --init 直接生成默认ts配置文件 { \"compilerOptions\": { \"module\": \"ES2015\", \"target\": \"ES2015\", \"strict\": true } } 这时在命令窗口直接输入 webpack，即可成功打包 TS文件模块的许可配置（webpack.config.js） // 用来设置模块，只要js、ts结尾都可以作为模块来使用 module.exports = { //... // 用来设置模块，只要js、ts结尾都可以作为模块来使用 resolve:{ extensions:['.ts', '.js'] } } 3.TypeScript对面向对象的延伸属性封装属性修饰符 如果属性是在对象中设置，则属性可以随意被修改，导致数据不安全 class Person { name: string; age: number; constructor(name: string, age: number) { this.name = name; this.age = age; } } const SpiderMan = new Person(\"SpiderMan\", 18); SpiderMan.age = -30; //被随意修改 TS可以在属性前添加修饰符 public，可以在任意位置访问 / 修改，默认值 private，私有属性，私有属性只能在类内部进行访问 / 修改，子类也不能访问 / 修改 通过在类中添加方法使得私有属性可以被外部访问 （但是却可以通过 (实例as any).私有属性进行访问。。不过有另外一种设置私有的方式，就是 #变量，并且还要在tsconfig.json对 lib 、target 进行配置） protected，受保护属性，仅能在当前类 or 当前类的子类中访问 / 修改 class Person { private _name: string; private _age: number; constructor(name: string, age: number) { this._name = name; this._age = age; } // 现在数据的读写访问权在我们编码人员上了 getAge() { return this._age; } setAge(age: number) { if (age > 0) this._age = age; } // getter和setter被称为属性存取器 } const Bruce = new Person(\"Bruce\", 18); //console.log(Bruce._age); //报错 console.log(Bruce.getAge()) 读写语法糖 但是TS内帮我们提供了读写属性的方法（语法糖） 实际上是应用了Object.defineProperty()的get和set （在使用get函数后，get后面的变量将自动保存为该实例的变量，比如 get Name()，然后类似于在类里添加了 this.Name,） TS设置getter、setter的方式以下所示 class Person { private _name: string; private _age: number; constructor(name: string, age: number) { this._name = name; this._age = age; } get name() { console.log(\"我被执行了\"); return this._name //此时在类外面，通过实例对象.name依然可以获取，即使获取格式看似像是和以前相同 // 但是获取方式已经和以往完全不一样了，是通过函数获取的 } get age() { return this._age } set age(age: number) { if (age > 0) this._age = age; } } const Bruce = new Person(\"Bruce\", 18); //可以，此时.name并不是找属性，而是找是否有get name方法 console.log(Bruce.name); //我被执行了 //数值大于0，可以执行 Bruce.age = 20; 关于类定义属性简便写法（语法糖） 旧的： class Person { private _name: string; private _age: number; constructor(name: string, age: number) { this._name = name; this._age = age; } } 新的： class Person { constructor(private _name: string, private _age: number) {} } 只读属性 只读属性只需在前缀增加 readonly即可，此时无法直接通过 实例.属性 进行修改的形式进行修改，但是机制有点像const，却可以更改引用地址中嵌套的属性 以下阐述的抽象类、接口均为TypeScript新增的 抽象类有时候，我们创建一个类，主要是为了作为多个类的父类，让子类通过继承得到共有的属性和方法，比如创建一个Animal类，然后让Cat、Dog类继承Animal类 以abstract开头的为抽象类，抽象类其实和其他类差别不大，只是不能用来创建对象，也就是专门用于继承的类 抽象类中可以添加抽象方法 抽象方法，使用abstract开头，没有方法体 抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写 abstract class Animal { name: string; constructor(name: string) { this.name = name; } abstract say(): void; } class Dog extends Animal { say() { console.log(\"gogogo\"); } } 接口在typescript基础中，我们学习到了自定义类型的写法； 而接口就是用来定义一个类的结构即类中应该包含哪些属性和方法（我个人理解为，实际上接口也可能看成一种自定义类型，该类型一定要包含接口的规范） 实际上又不一定仅限于定义类的结构，也可以作为一种类型去使用，比如用 :myInterface规范类型， 所以才导致出现type 和 interface都可以使用的场景，所以接口也可以当成类型声明去使用 自定义类型 type myType = { name: string, age: number } const obj: myType = { name:\"allen\", age:18 } 接口 // 该接口规定了我们定义了一个类，该类一定有两个属性，一个是name，一个是age interface myInterface { name: string; age:number } const obj: myInterface = { name: 'allen', age: 18 } （1）接口 VS 自定义类型 VS抽象类1.接口可以同名进行重复声明：比如之前定义了 type myType，后面不能重复定义该类型；而前面个定义了 interface myInterface，后面依旧可以再次定义 interface myInterface（这两个 myInterface会进行合并） interface myInterface{ name: string; age:number } interface myInterface{ gender:string } //两个会发生合并，这种语法在TS里是合理的 2.接口可以在定义类的时候，限制类的结构（这一点有点像在继承抽象类） 接口中所有属性都不能有实际的值（但是抽象类可以定义实际的值） 接口中的方法都是抽象方法（但是抽象类可以有非抽象方法） 定义类时让类去实现（implement）这个接口 interface myInterface{ name: string; saySomething(): void; //抽象方法啊 } // 实现接口，实现接口就是使类满足接口要求 class MyClass implements myInterface{ name: string; constructor(name:string) { this.name = name; } saySomething(): void { throw new Error(\"Method not implemented.\"); } } 3.接口可以实现多个,互相实现,抽象类的子类却只能继承一个抽象类；抽象类只针对类，接口其实也可以应用于函数、属性等 总而言之，接口就相当于一个规范，实现了接口，即满足了规范，就可以在指定场景中进行使用 推荐加点： 如果是定义非对象类型，推荐使用type 对象类型推荐使用 interface 接口的应用场景（很愿意以接口的方式来实现）： 后台接口 第三方和开发的SDK，比如Vue 前端的库 正常的开发任务来说，interface、type都差不多，type更直接更方便 （2）属性接口使用场景：我们如果向约束传入参数是作为一个 string类型，可以直接 function fn(params: string){} 但如果我们需要传入一个参数，它是一个对象，但是我们要求这个对象里的某个属性（或者多个属性），必须为 string类型，我们可以使用属性接口 //对传入对象里面的属性进行约束 interface FullName{ firstName:string; lastName:string } function printName(name: FullName){} freshness擦除 通常情况下，属性接口的实现在TS检测时进行类型推断，如果有多出来的属性，则不能通过 interface IPerson { name: string age: number } const p: IPerson = { name: 'allen', age: 18 sex: 'male' //报错 } 但是如果通过引用地址的方式进行赋值时，TS检测会把多出来的属性进行freshness擦除掉，此时达到了满足条件，则不会报错 interface IPerson { name: string age: number } const info = { name: 'allen', age: 18, sex: 'male' } const p: IPerson = info 因此以后在通过函数传入参数时，参数指定属性接口，可以用引用的方式，传递相对接口规定的属性的有多余属性的对象 function fn(p: IPerson) { console.log(p); } fn(info); （3）函数类型接口对函数方法进行约束 / 批量约束 interface myInterface{ //参数为两个string类型，返回参数为string类型 (key:string, value:string):string } const fn: myInterface = (a: string, b: string) => a + b; （4）可索引接口也可以看成针对数组、对象索引的接口 //针对数组索引 interface myArr{ [index:number]:string } let arr:myArr = ['allen', 'bruce'] //针对对象索引值的约束 interface myObj{ [index:string]:string } let obj:myObj = {name:'allen'} （5）类类型接口//类类型接口，也就是最上方类对接口的实现，和抽象类类似 interface myClass{ name: string; action(params:String):void } interface myClass2{ //... } class Me implements myClass, myClass2{ name = 'Allen'; action() {} } （6）接口继承使用extends，接口可以实现对其他接口的继承，可以对接口进行拓展 注意：类的继承只能实现单继承，但是接口可以实现多个接口 interface Animals{ eat(): void; } interface Person extends Animals{ work(): void; } //这里再套一个baby类进行类的继承 class baby{} class People extends baby implements Person{ eat() { } work(){} } 泛型当出现类型不明确的情况，可以使用泛型（之前也提到过使用any不太好） 之前还提及过unknown，而泛型针对定义函数或者类时，定义的时候类型不明确，而在使用的时候再指定类型的一种特性（也可以理解为类型的参数化）。 泛型比any的好处 1.避免跳过了类型检查部分 2.在这里也能体现出返回值类型和传入参数类型相同 函数 + 泛型基本使用： // 指定了自定义的泛型：T，有点像一个变量的感觉，即类型的变量 function fn&lt;T>(a: T): T { return a; } console.log(fn(10)); //此时T为number，此时是自动推断 console.log(fn&lt;string>(\"string\")); //此时T为string，此时时指定推断，这种方式应该用的比较多 // 指定多个泛型 function fn2&lt;T, K>(a: T, b: K): T { console.log(`I am ${b}!`); return a; } console.log(fn2(10, \"bruce\")); // 在类中使用泛型 class MyClass&lt;T>{ constructor(public name: T) { }; fn(params:T) { return params; } } let c = new MyClass&lt;number>(123); let c2 = new MyClass&lt;string>('str'); 属性接口（ + 泛型）interface IPerson&lt;T1, T2> { name: T1 age: T2 } const p: IPerson&lt;string, number> = { name:'allen', age:12 } 限制泛型假如我只想传入某种指定规格的数据，但是由于泛型没有对传入的参数进行规范校验，就可能可以乱传参数进去而没有被编译器发现 我们可以使用接口对泛型传入的参数加以规范 泛型 + 接口联动实现：应用场景：限制泛型的范围 interface myInterface { length: number } function fn3&lt;T extends myInterface>(a: T) { return a.length; } fn3(\"123\"); //可以通过 // fn3(123); //报错，因为这个参数没有length属性 泛类把类当作参数的泛型类 class MysqlDB&lt;T>{ add(info: T) { console.log(info); } } class User { name: string | undefined; password: string | undefined; } let u = new User(); u.name = \"Allen\"; u.password = \"123\"; 此时我只想让User作为传入add的参数，但是 let db = new MysqlDB(); db.add(u); db.add(123) //也可以,对传入的参数没能进行限制 所以我们要对此进行约束 let db = new MysqlDB&lt;User>(); db.add(u); db.add(123) //报错 promise在ts中使用pormise必须声明它的返回值类型，而它的返回值类型通常可以使用泛型的形式来声明 以Promise&lt;类型&gt; 的形式 function request&lt;T>(config: AxiosRequestConfig): Promise&lt;T> { return new Promise((resolve, reject) => { this.instance .request(config) .then((res) => { console.log(res, 'request方法') resolve(res) }) .catch((err) => { reject(err) }) }) } 通过泛型+泛型嵌套，实现真正约束返回值 interface IUser { account: string password: string } interface ILoginType { id: number name: string token: string } interface IDataType&lt;T = any> { code: number data: T } export function accountRequest(user: IUser) { return myRequest.request&lt;IDataType&lt;ILoginType>>({ method: 'POST' , url: loginAPI.accountAPI, data: { //... } }) } 4.TypeScript其他TS支持两种方法来控制我们的作用域 模块化开发：每个文件可以是一个独立的模块，支持ES module，也支持CommonJS 命名空间：通过namespace来声明一个命名空间 命名空间有时在同一模块中接口、类的名称或许会发生冲突（不同类、接口命名一致）此时一个模块里需要有多个命名空间 import { MySQL } from './database'; //报错，发生冲突 class MySQL{ //... } 此时我们可以在ts文件最上方通过 namespace 自定义空间名 使用命名空间 namespace A{ //代码块 } 此时属于A命名空间的私有该代码块定义的接口、类等 如果我们要在外部使用该命名空间的东西，需要使用export对外部进行暴露 namespace A{ interface Animal{ name: string eat(): void; } export class Dog implements Animal{ constructor(public name: string) { } eat(){} } } // 只能使用Dog类，因为其他比如Animal接口没有暴露，所以在外面也不能使用 let temp = new A.Dog('边牧'); 对外部模块（比如其他文件中）导出该命名空间，直接 export namespace A{}即可 然后外部模块进行导入时 import { A } from &#39;./untils/format&#39; TS关于声明的问题在TS中，必须在编写过程中有声明过的类型，才可以直接使用（不然通不过TS编译），但是也有一些其他的类型： 比如document、axios typescript对类型的管理和查找 内置类型声明（TS自带的，比如document） 外部定义类型声明（axios第三方库已经帮我们做了这个类型声明文件，安装axios之后可以看到node_module文件夹的 axios 中有 index.d.ts 文件） 自定义类型声明（比如lodash库就没有自带的外部定义类型声明，需要自己自定义） 可以去社区有没有人编写好对应的类型声明 通过这个网址得到type，然后根据网址后面的指示进行 npm 安装 完全自己编写，新建一个 xxx.d.ts 文件，通过declare关键字进行声明 //声明模块 declare module 'lodash' { //..编写需要声明的变量、方法 } //声明变量、函数 declare let Myname: string // 声明有Myname这个变量 declare function myFn(): void // 声明文件，把.jpg结尾的文件都当成模块，可以通过编译 declare module '*.jpg' 除了.ts件，还有 .d.ts 文件（declare），这个文件是用来做类型声明的文件，他仅仅用来做类型检测，告知typescript我们有哪些类型，而不用报错 InstanceType&lt;Type&gt;构造一个由 Type 中构造函数的实例类型组成的类型。 例子 // @errors: 2344 2344 // @strict: false class C { x = 0; y = 0; } type T0 = InstanceType&lt;typeof C>; //相当于 type T0 = C type T1 = InstanceType&lt;any>; //相当于 type T1 = any type T2 = InstanceType&lt;never>; //相当于 type T2 = never type T3 = InstanceType&lt;string>; //报错 //Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'. type T4 = InstanceType&lt;Function>; //报错 //Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'. //Type 'Function' provides no match for the signature 'new (...args: any): any'. 而对于在vue3 + ts组件使用中，对组件定义引用时，则要使用到 InstanceType&lt;Type&gt; 譬如 const accountForm = ref&lt;InstanceType&lt;typeof ElForm>>() 这是因为，vue3组件导出是是作为一个对象（组件的描述，可以说和一个类很像） 而我们此时在另外一个组件中使用这个组件，我们是根据导出的对象来创建一个组件实例 此时我们不可以直接 const accountForm = ref&lt;ElForm>() //x 错误 因为此时ElForm是一个对象，而不是一个类型 or 类 之类的 ，而 InstanceType&lt;Type&gt; 可以帮助我们将这个单一的 对象 转化为一个拥有构造函数的实例 也可以理解为 对象类型 -&gt; 被实例化的对象类型 5.装饰器装饰器是一种特殊的类型声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为 通俗来讲装饰器就是一个方法，可以注入到类、方法、属性参数上来拓展类、属性、方法、参数的功能。（把这些东西传进去，然后吐出一个更强大的值） 装饰器是过去几年JS最大成就之一，已经是ES7的标准特性之一 常见的装饰器有类装饰器、属性装饰器、方法装饰器、参数装饰器 装饰器的写法： 普通装饰器（无法传参） 装饰器工厂（可传参） 注意 装饰器是一项实验性特性，在未来的版本中可能会发生改变。 若要启用实验性的装饰器特性，你必须在命令行或tsconfig.json里启用experimentalDecorators编译器选项： tsc --target ES5 --experimentalDecorators { \"compilerOptions\": { \"target\": \"ES5\", \"experimentalDecorators\": true } } 不过装饰器也类似于充当中间层，@withScope.其实最终export default 的是withScope(KeepAlive) 基本使用 （1）类装饰器@装饰器下一行接类 //它在不修改类 MyClass的情况下，对类的功能进行了拓展 function logClass(target: any) { // params就是当前类 console.log(target); // 现在我们可以通过params来操作类了 //拓展一个属性 params.prototype.apiURL = 'xxx'; // 拓展一个方法 params.prototype.fn = () => { console.log(\"I am function!\"); } } @logClass class MyClass { constructor(public name: string) { } } 但我们可以看到，通过 @logClass的方式进行装饰，无法传入参数（params是默认传入，不算） 类装饰器（装饰器工厂）： 实际上说的那么玄乎，不过就是运用了柯里化方式进行传参，类似于React的函数传参方式 function logClass(params: string) { return function (target: any) { //这里的target就是当前类MyClass，也就是上方普通装饰器的params //使用传入参数来拓展属性 target.prototype.apiURL = params; } } @logClass('something') class MyClass { constructor(public name: string) { } } 除此之外，装饰器还能修改当前类的构造函数下面是一个重载构造函数的例子： 类装饰器表达式会在运行时被调用，类的构造函数作为其唯一的参数 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明 function logClass(params: any) { return class extends params { name = 'I am another name'; //getData也要记得一起重载 getData() { console.log(this.name); } //或者getData() { super.getData() } } } @logClass class MyClass { constructor(public name: string) { console.log('我在执行constructor'); console.log(name); } getData() { console.log(this.name); } } let a = new MyClass('Kobe'); a.getData(); //我在执行constructor //Kobe //I am another name （2）属性装饰器属性装饰器表达式会在运行时当作函数被调用，传入下列两个参数： 对于静态成员来说是类的构造函数（constructor），对实例成员来说是类的原型对象（prototype） 成员名字 @装饰器下一行接属性 // 属性装饰器 + 装饰器工厂传参 function logProperty(params: any) { return (target: any, attr: any) => { console.log(target); //MyClass {} console.log(attr); //name //修改target（MyClass）类的attr（name）属性 //中括号的主要优势在于可以通过变量访问属性 target[attr] = params; } } class MyClass { // 当前有一个name的属性 @logProperty('something') name: string; constructor(name: string) { this.name = name } } let a = new MyClass('Kobe'); （3）方法装饰器它会被应用到方法的属性描述符上，可以用来监视、修改、替换方法定义 方法装饰会在运行时传入下列3个参数 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象 成员名字 成员的属性描述符 @装饰器下一行接函数 // 方法装饰器 function logMethod(params: any) { return (target: any, methodName: any, desc: any) => { console.log(target); //MyClass{} console.log(methodName); //fn console.log(desc); //关于该函数的描述（特性），比如writable、enumerable、configurable、value // 修改方法实现： 把参数转为字符串再传入 //1.保存之前方法 let fn = desc.value; desc.value = function(...args: any[]){ //先把参数全部转为字符串 let newArgs = args.map(item => String(item)); console.log(newArgs, params); //复用之前的方法 + 传入参数，保留之前函数定义的内容 fn.apply(this,newArgs); } } } class MyClass { @logMethod('Something') fn(...args: any[]) { } } let a = new MyClass(); a.fn('123', 12345) （4）方法参数装饰器参数装饰器表达式会在运行时被当作函数被调用，可以使用参数装饰器为类的原型增加一些元素数据，传入下列三个参数 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象 传入参数的方法名字 参数在函数参数列表中的索引 // 参数装饰器 + 装饰器工厂传参 function logParams(params: any) { return (target: any, methodName: any, paramsIndex: any) => { console.log(target); //MyClass{} console.log(methodName); //fn console.log(paramsIndex);//0 } } class MyClass { fn(@logParams(123) id: number) { } } let a = new MyClass(); 装饰器执行顺序：在TypeScript中，装饰器的执行顺序为：首先执行属性装饰器，然后执行方法装饰器，其次是方法参数装饰器，最后是类装饰器。如果同一个类型的装饰器有多个，总是先执行后面的装饰器。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"微服务","slug":"微服务","date":"2022-05-09T16:00:00.000Z","updated":"2023-04-13T08:09:13.144Z","comments":true,"path":"2022/05/10/wei-fu-wu/","link":"","permalink":"https://taylor12138.github.io/2022/05/10/wei-fu-wu/","excerpt":"","text":"1.微服务概念微服务：微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，其中每个组件都有各自的责任领域。在处理一个用户请求时，基于微服务的应用可能会调用许多内部微服务来共同生成其响应。 通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程 知乎上一个小案例加深印象：https://www.zhiimportmaphu.com/question/65502802 个人的理解是将拆分的思想贯彻到底（模块也是拆！数据库也是拆！），分工明确，将每个功能细致化分配任务。再加上兼容一下老应用的逻辑，和新框架开发的代码的一套架构理念 但是缺点就是：在微服务架构中，一个服务故障可能会产生雪崩效用，导致整个系统故障 微服务架构整个应用分散成多个服务，定位故障点非常困难。 稳定性下降。服务数量变多导致其中一个服务出现故障的概率增大，并且一个服务故障可能导致整个系统挂掉。事实上，在大访问量的生产场景下，故障总是会出现的。 服务数量非常多，部署、管理的工作量很大。 开发方面：如何保证各个服务在持续开发的情况下仍然保持协同合作。 测试方面：服务拆分后，几乎所有功能都会涉及多个服务。原本单个程序的测试变为服务间调用的测试。测试变得更加复杂。 所以使用微服务的架构要有要有强大的监控体系 2.沙箱(sand box)传统意义上：Sandbox（沙箱）是指一种技术，在这种技术中，软件运行在操作系统受限制的环境中。由于该软件在受限制的环境中运行，即使一个闯入该软件的入侵者也不能无限制访问操作系统提供设施；获得该软件控制权的黑客造成的损失也是有限的 然而，在计算机安全中，沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制，通常用于执行未经测试或不受信任的程序或代码，它会为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行 抽象化：对于操作系统来说，浏览器就是一个沙箱，对于浏览器来说，每个页面就是一个独立的沙箱 实际运用： Vue 模板表达式的计算是运行在一个沙盒之中的，在模板字符串中的表达式只能获取部分全局对象，这一点官方文档有提到，详情可参阅源码。 CodeSanbox ，在线编辑器 许多应用程序带的插件，有很多的限制条件，这些应用程序在运行插件时需要遵循宿主程序制定的运行规则，插件的运行环境和规则就是一个沙箱 …. 从知乎这篇文章可以看到沙箱的基本介绍https://zhuanlan.zhihu.com/p/428039764 里面的《简陋沙箱》、《非常简陋的沙箱（With）》、《没那么简陋的沙箱（With+Proxy）》循序渐进，都可以帮助读者加深印象 里面主要通过new Function、eval、with修改上下文作用域 然后就是天然沙箱：iframe、和 ifame+with+proxy的结合，但是现在简单的沙箱都有可能被使用者使用某种代码漏洞，进行 “沙箱逃逸”，从而获取沙箱之外环境的内容进行读取、修改等，这时候就要去找开源库了 JS隔离Js 沙箱做的事情可以用两句话概括： 为每一个子应用创建一个专属的 “window 对象”（虚假的）； 执行子应用时，将新建的 “window 对象” 作为子应用脚本的全局变量，子应用对全局变量的读写操作都作用到这个 “window 对象”中。 沙箱类型： LegacySandbox（依赖 Proxy)，父子状态隔离，但是window不隔离 ProxySandbox （依赖 Proxy）稳定后会取代 LegacySandbox。 SnapshotSandbox（不依赖Proxy） 参考字节跳动的技术文章：https://juejin.cn/post/7099339595233361934#heading-24 3.微前端微前端（Micro-Frontends）同样是一套体系架构，是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以无关技术栈地独立运行、独立开发、独立部署。 在如今越来越注重拆分和细化的时代，微前端的到来并没有在意料之外，而微前端的意义就： 将这些庞大应用进行拆分，并随之解耦，每个部分可以单独进行维护和部署，提升效率。 整合历史系统，将老架构框架项目兼容性放在新的架构体系中 当然，没有免费的午餐——一切都是有代价的，一些微前端实现可能会导致依赖项重复，但是我们相信这些风险是可以控制的，而且微前端的好处往往超过成本。 ——–Cam Jackson 微前端解决的问题： 实际上，一个典型的基于vue-router的Vue应用与这种架构存在着很大的相似性 微前端方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问 方案 描述 NPM式 子工程以NPM包的形式发布源码；打包构建发布还是由基座工程管理，打包时集成。 iframe式 子工程可以使用不同技术栈；子工程之间完全独立，无任何依赖；基座工程和子工程需要建立通信机制；无单页应用体验；路由地址管理困难。 通用中心路由基座式 子工程可以使用不同技术栈；子工程之间完全独立，无任何依赖；统一由基座工程进行管理，按照DOM节点的注册、挂载、卸载来完成。比如qiankun之类的，qiankun甚至能加载jQuery编写的页面 特定中心路由基座式 子业务线之间使用相同技术栈；基座工程和子工程可以单独开发单独部署；子工程有能力复用基座工程的公共基建。比如React-router、Vue-router （图片源自美团技术团队的文章，而美团用的是基于React的中心路由基座式微前端） 但是微前端仍需解决： 路由切换的分发问题。 主微应用的隔离问题。 通信问题。 路由转发： 通过http请求获取所需的微应用html、css、js，然后可以采用eval的形式运行代码，而分发过程使用router对url进行监听，然后采用一些路由方法（hash方法或者pushState方法等）发送路由信息给微应用，让微应用通过它自己的路由进行接收 Single-Spa虽然实现了自己的一套路由来监听子工程的切换，但是还需要特定的模块管理系统，比如 systemjs来辅助，这导致了改造成本和添加一些额外的库，所以美团直接用的是 React-Router (react-router-dom) 隔离问题： 对于css污染，可以采用CSS Module或者webpack的postcss插件，在打包时添加特定的前缀 对于Js代码，我们害怕一些全局对象在不同微应用的不同表现，我们可以采用沙箱隔离机制，消除冲突和影响 通信问题： 我们可以用发布订阅通信机制，事件由实践中心统一分发 子应用打包的方式微前端架构模式下，子应用打包的方式，基本分为两种： 两者的优缺点也很明显： 很显然，要实现真正的技术栈无关跟独立部署两个核心目标，大部分场景下我们需要使用运行时加载子应用这种方案。 JS Entry vs HTML Entry 如果是 JS Entry 方案，主框架需要在子应用加载之前构建好相应的容器节点(比如这里的 “#root” 节点)，不然子应用加载时会因为找不到 container 报错 &lt;!-- 子应用 index.html --> &lt;script src=\"//unpkg/antd.min.js\">&lt;/script> &lt;body> &lt;main id=\"root\">&lt;/main> &lt;/body> // 子应用入口 ReactDOM.render(&lt;App/>, document.getElementById('root')) JS entry打包问题（可以看 why SystemJS 部分） HTML entry无法抽取公共依赖（很麻烦） 其他： （webpack5有一个联邦模块功能（mf），对于微前端的公共依赖加载是比较好的解决方案。） 一些微前端的框架 Mooa：基于Angular的微前端服务框架 Single-Spa：最早的微前端框架，兼容多种前端技术栈。 Qiankun：基于Single-Spa，阿里系开源微前端框架。 Icestark：阿里飞冰微前端框架，兼容多种前端技术栈。 Ara Framework：由服务端渲染延伸出的微前端框架。 micro-app：京东微前端框架，借鉴了WebComponent的思想，通过CustomElement结合自定义的ShadowDom，将微前端封装成一个类WebComponent组件，从而实现微前端的组件化渲染 你可能就不需要微前端存在以下场景时，你可能就不需要微前端： 你/你的团队 具备系统内所有架构组件的话语权简单来说就是，系统里的所有组件都是由一个小的团队开发的。 你/你的团队 有足够动力去治理、改造这个系统中的所有组件直接改造存量系统的收益大于新老系统混杂带来的问题。 系统及组织架构上，各部件之间本身就是强耦合、自洽、不可分离的系统本身就是一个最小单元的「架构量子」，拆分的成本高于治理的成本。 极高的产品体验要求，对任何产品交互上的不一致零容忍不允许交互上不一致的情况出现，这基本上从产品上否决了渐进式升级的技术策略 满足以下几点，你才确实可能需要微前端 系统本身是需要集成和被集成的 一般有两种情况： 旧的系统不能下，新的需求还在来。没有一家商业公司会同意工程师以单纯的技术升级的理由，直接下线一个有着一定用户的存量系统的。而你大概又不能简单通过 iframe 这种「靠谱的」手段完成新功能的接入，因为产品说需要「弹个框弹到中间」 你的系统需要有一套支持动态插拔的机制。这个机制可以是一套精心设计的插件体系，但一旦出现接入应用或被接入应用年代够久远、改造成本过高的场景，可能后面还是会过渡到各种微前端的玩法。 系统中的部件具备足够清晰的服务边界通过微前端手段划分服务边界，将复杂度隔离在不同的系统单元中，从而避免因熵增速度不一致带来的代码腐化的传染，以及研发节奏差异带来的工程协同上的问题。 4.iframeiframe是一个天然的沙箱 优点： 非常简单，使用没有任何心智负担 隔离完美，无论是 js、css、dom 都完全隔离开来 多应用激活，页面上可以摆放多个iframe来组合业务（适合单页面多应用） 如果页面里有iframe的话，内部的iframe，如果iframe是和标签页属于同一域，那就共用渲染进程，否则会给这个iframe一个单独的渲染进程,所以单页面下（没有路由管理），可能比qiankun等通过拉取代码单线程运行要快 但是它有很多弊端： url 不同步，每次进来都要加载，url状态不能保留 DOM 结构不共享。比如子应用里有一个 Modal（弹窗），显示的时候只能在那一小块地方展示，不能全屏展示 无法跟随浏览器前进后退 天生的硬隔离，无法与主应用进行资源共享，内存变量不共享，交流也很困难 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程，白屏时间太长，对于SPA 应用应用来说无法接受 当然，腾讯提出了一个“完美”的iframe微前端方案，可以看一看基于 iframe 的全新微前端方案(腾讯PCG) 主要是 利用shadow dom插拔html、css来解决dom割裂问题（比如toast） 在iframe中执行js，然后让iframe的路由状态同步到浏览器的路由解决路由问题和通信问题（同域下通信比较简单） 然后内部做了一些缓存（实例化子应用），降低子应用资源加载的成本 而官方也谈及了wujie的不足之处： 内存占用较高，为了降低子应用的白屏时间，将未激活子应用的shadowRoot和iframe常驻内存并且保活模式下每张页面都需要独占一个wujie实例，内存开销较大 兼容性一般，目前用到了浏览器的shadowRoot和proxy能力，并且没有做降级方案 iframe劫持document到shadowRoot时，某些第三方库可能无法兼容导致穿透 5.single-spaSingle SPA 将自己定义为一种“前端微服务 Javascript 框架”，它将生命周期应用于每个应用程序。每个应用程序都可以响应 url 路由事件，并且知道如何从 DOM 引导，加载和卸载自身 single-spa 仅仅是一个子应用生命周期的调度者。single-spa 为应用定义了 boostrap, load, mount, unmount 四个生命周期回调： 值得注意的是 Register 不是生命周期，指的是调用 registerApplication 函数这一步 Load 是开始加载子应用，怎么加载由开发者自己实现（等会会说到） Unload 钩子只能通过调用 unloadApplication 函数才会被调用 当触发到 window.location.href 匹配到 url 时，开始走对应子 App 的这一套生命周期嘛。所以，single-spa 还要监听 url 的变化，然后执行子 app 的生命周期流程。 到此，我们就有了 single-spa 的大致框架了，无非就两件事： 实现一套生命周期，在 load 时加载子 app，由开发者自己玩，别的生命周期里要干嘛的，还是由开发者造的子应用自己玩 监听 url 的变化，url 变化时，会使得某个子 app 变成 active 状态，然后走整套生命周期 根据传入的参数activeWhen判断哪个应用需要加载，哪个应用需要卸载或清除，并将其push到对应的数组 如果应用已经启动，则进行应用加载或切换。针对应用的不同状态，直接执行应用自身暴露出的生命周期钩子函数即可。 如果应用未启动，则只去下载appsToLoad中的应用。 该图作者的评价： 传统 SPA 和 Single SPA 应用程序之间的主要区别在于它们能够与其他应用程序共存，并且它们各自没有自己的 HTML 页面。 single-spa 的理念是希望主应用可以做到非常非常简单的和轻量，简单到只要一个 index.html + 一个 main.js 就可以完成微前端工程，连 Webpack 都不需要，直接在浏览器里执行 在single-spa的角度，微前端就是“微模块加载器”，它主要解决的是：如何实现前端的“微服务化”，从而让应用、组件、逻辑都成为可共享的微服务，这从single-spa关于微前端的概述中可以看出： 翻译过来反别是微应用、微组件、微模块，而single-spa要求它们都以SystemJS的形式打包，所以本质上都是微模块 关于single-spa一部分实践可以看这个，但是由于这里的代码的很多包都比较久远，最好下载和它一致的包再进行实践 github SystemJS1.浏览器里用import/export。SystemJS 的好处和优势有且仅有一点：那就是那就是不需要打包工具，直接在浏览器里使用 ES6 的 import/export，也就是说它是一个允许ES module模块运行在旧版本ES环境的库。 Single SPA 中使用到了SystemJS，SystemJS是一个运行时加载模块的工具（动态导入和导入映射），是现阶段下(浏览器尚未正式支持importMap)原生ES Module的完全替代品，对比Webpack 之类的， 其实你也可以理解为SystemJS是为了解决轻量级，不用打包，即可做到 import Vue from &#39;vue&#39; 形式去导包 importmap的形式，兼容性差 &lt;script type=\"importmap\"> { \"imports\": { \"dayjs\": \"https://cdn.skypack.dev/dayjs@1.10.7\", } } &lt;/script> systemjs形式 &lt;script type=\"systemjs-importmap\"> { \"imports\": { \"@react-mf/root-config\": \"//localhost:9000/react-mf-root-config.js\" } } &lt;/script> SystemJS动态加载的模块必须是SystemJS模块或者UMD模块。 2.引入公共依赖SystemJS 另一个好处就是可以通过 importmap 引入公共依赖。 假如，我们有三个子应用，它们都有公共依赖项 antd，那每个子应用打包出来都会有一份 antd 的代码，就显示很冗余。（qiankun就有这种冗余） 一个解决方法就是在主应用里，通过 importmap 直接把 antd 代码引入进来，子应用在 Webpack 设置 external 把 antd 打包时排除掉。子应用打包就不会把 antd 打包进去了，体积也变小了。 对于公共样式的处理； 将公共的 CSS 放到 importmap 里，也可以理解为在 index.html 里直接加个 link 获取 antd 的 CSS 完事 将所有的公共的 UI 库都 import 到 utility 里，将 antd 所有内容都 export，再把 utility 包放到 importmap 里，然后 import { Button } from &#39;@your-org-name/utility&#39;; 去引入里面的组件 其实上面两个方法都大同小异，思路都是在主应用一波引入，只是一个统一引入CSS，另一个统一引入 UI 库。 JS隔离在single-spa使用 import singleSpaLeakedGlobals from 'single-spa-leaked-globals'; const leakedGlobalsLifecycles = singleSpaLeakedGlobals({ globalVariableNames: ['$', 'jQuery', '_'], // 新添加的全局变量 }) 在 mount A 子应用时，正常添加全局变量，比如 jQuery 的 $, lodash 的 _。在 unmount A 子应用时，用一个对象记录之前给 window 添加的全局变量，并把 A 应用里添加 window 的变量都删掉。下一次再 mount A 应用时，把记录的全局变量重新加回来就好了。 但是，这个库的局限性在于：每个 url 只能加一个子 app，如果多个子 app 之间还是会访问同一个 window 对象，也因此会互相干扰，并不能做到完美的 JS 沙箱。 CSS隔离而关于css的样式隔离，官方的建议是 使用 Scoped CSS 要是嫌麻烦，可以在子应用 Webpack 使用 PostCSS Prefix Selector 给样式自动加前缀 亦或者开发者自己用shadow-dom来处理… why SystemJS都2022年了，怎么还要在浏览器环境写 JS 呢？不上个 Webpack 都不好意思说自己是前端开发了… 那为什么 single-spa 还要推荐 SystemJS 呢？但是根据知乎上优质答主写代码的海怪猜测是因为 single-spa 希望主应用应该就一个空壳子，只需要管内容要放在哪个地方，所有的功能、交互都应该交由 index.html 来统一管理。（直接在html里写满script想想就可怕） 这也表明了： 资源罗列：在systemjs中，我们必须手动实现应用加载逻辑，挨个罗列子应用需要加载的资源，这在大型项目里是十分困难的（特别是使用了文件名hash时）；另外它只能以js文件为入口，无法直接以html为入口，这使得嵌入子应用变得很困难，也正因此，single-spa不能直接加载jQuery应用。 资源加载优化：将整个微应用打包成一个 JS 文件，常见的打包优化基本上都没了，比如：按需加载、首屏资源加载优化、css 独立打包等优化措施。 js名称：项目发布以后出现了 bug ，修复之后需要更新上线，为了清除浏览器缓存带来的影响，一般文件名会带上 chunkcontent，微应用发布之后文件名（js bundle ）都会发生变化，这时候还需要更新主应用中微应用配置，然后重新编译主应用然后发布，这是不能容忍的。 你可以理解为每次文件名一变化：jlkasjfdlkj.jalkjdsflk.js，这样一来，每次子应用一发布，入口 JS 文件名肯定又要改了，导致主应用引入的 JS url 又得改了 所以，为了填平 single-spa 遗留下来的坑，阿里基于 single-spa 造出了 qiankun 微前端框架，真正实现了微前端的所有特性. 6.Qiankunqiankun是基于single-spa开发的 Single-spa控制路由和应用入口 + qiankun JS、CSS隔离和应用通信 + import-html-entry控制应用加载(single-spa用的是system.js) qiankun基于single-spa，加强了微应用集成能力，却抛弃了微模块的能力。所以，它们的区别就是微服务的粒度，qiankun的所能服务的粒度是应用级别，而single-spa则是模块级别。它们都能将前端进行拆分，只是拆分的粒度不同罢了。 微应用加载器：“微”的粒度是应用，也就是HTML，它只能做到应用级别的分享 微模块加载器：“微”的粒度是模块，也就是JS模块，它能做到模块级别的分享 两个框架出现的背景： qiankun：阿里内部有大量年久失修的项目，业务侧急需工具去把他们快速、安全的集成到一起。在这个角度，乾坤根本没有做模块联邦的需求，它的需求仅仅是如何快速、安全的把项目集成起来。所以乾坤是想做一个微前端工具。 single-spa：学习后端的微服务，实现前端的微服务化，让应用、组件以及逻辑都成为可共享的微服务，实现真正意义上的微前端。所以single-spa是想做一个game-changer。 css隔离目前qiankun主要提供了两种样式隔离方案 一种是基于shadowDom的； 在配置的时候当启用strictStyleIsolation时，qiankun将采用shadowDom的方式进行样式隔离，即为子应用的根节点创建一个shadow root，整个应用的所有DOM将形成一棵shadow tree，它内部所有节点的样式对树外面的节点无效，所有就实现了样式隔离。 const supportShadowDOM = !!document.head.attachShadow || !!(document.head as any).createShadowRoot; if (strictStyleIsolation) { if (!supportShadowDOM) { // 报错 // ... } else { // 清除原有的内容 const { innerHTML } = appElement; appElement.innerHTML = ''; let shadow: ShadowRoot; if (appElement.attachShadow) { // 添加 shadow DOM 节点 shadow = appElement.attachShadow({ mode: 'open' }); } else { // deprecated 的操作 // ... } // 在 shadow DOM 节点添加内容 shadow.innerHTML = innerHTML; } } 但是这种方案是存在缺陷的。因为某些UI框架可能会生成一些弹出框直接挂载到document.body下，此时由于脱离了shadow tree，所以它的样式仍然会对全局造成污染。 基于 ShadowDOM 的严格样式隔离并不是一个可以无脑使用的方案，大部分情况下都需要接入应用做一些适配后才能正常在 ShadowDOM 中运行起来（比如 react 场景下需要解决这些 问题，使用者需要清楚开启了 strictStyleIsolation 意味着什么。后续 qiankun 会提供更多官方实践文档帮助用户能快速的将应用改造成可以运行在 ShadowDOM 环境的微应用 另一种则是实验性的，思路类似于Vue中的scoped属性，给每个子应用的根节点添加一个特殊属性，用作对所有css选择器的约束。 qiankun首先判断当前sandbox是否支持scope css，支持的话才添加 export function isEnableScopedCSS(sandbox: FrameworkConfiguration['sandbox']) { if (typeof sandbox !== 'object') { return false; } if (sandbox.strictStyleIsolation) { return false; } return !!sandbox.experimentalStyleIsolation; } 在配置的时候当启用experimentalStyleIsolation。这种方案的策略是为子应用的根节点添加一个特定的随机属性 // 假如子应用名字叫 child // 转换前 .app-main { font-size: 14px; } // 转换后 div[data-qiankun=\"child\"] .app-main { font-size: 14px; } shadowdom的css隔离开启方式：start的时候或者手动加载子应用的时候传入option，option包含sanbox属性，sanbox的strictStyleIsolation为true scope开启方式：start的时候或者手动加载子应用的时候传入option，option包含sanbox属性，sanbox的experimentalStyleIsolation为true start({ sandbox: { strictStyleIsolation?: boolean, experimentalStyleIsolation?: true } }) loadMicroApp(app, { sandbox: { strictStyleIsolation?: boolean, experimentalStyleIsolation?: true } }) 注意事项: 对于scope的css隔离方案，目前 @keyframes, @font-face, @import, @page 等规则不会支持 (i.e. 不会被改写) js隔离qiankun通过import-html-entry，可以对html入口进行解析，并获得一个可以执行脚本的方法execScripts（上面提及到的 execScript ）。 qiankun默认启用沙箱，也就是上面css隔离中 start里的那个sanbox选项，此时会开启js隔离严格模式 strictGlobal 第一步创建一个沙箱容器 sandboxContainer 三种沙箱： 首先初始化一个沙箱ProxySandbox，里面创造一个fakeWindow，它拥有window的所有属性，并且通过new Proxy返回一个fakeWindow的代理对象 SnapshotSandbox： 针对IE11不支持proxy，所以qiankun通过快照策略来隔离js，缺点是无法支持多实例场景。(可以理解为使用single-spa的js隔离方法) if (window.Proxy) { sandbox = useLooseSandbox ? new LegacySandbox(appName, globalContext) : new ProxySandbox(appName, globalContext); } else { sandbox = new SnapshotSandbox(appName); } class SnapshotSandbox { ... active() { // 记录当前快照 this.windowSnapshot = {} as Window; getKeys(window).forEach(key => { this.windowSnapshot[key] = window[key]; }) // 恢复之前的变更 getKeys(this.modifyPropsMap).forEach((key) => { window[key] = this.modifyPropsMap[key]; }); this.sandboxRunning = true; } inactive() { this.modifyPropsMap = {}; // 记录变更，恢复环境 getKeys(window).forEach((key) => { if (window[key] !== this.windowSnapshot[key]) { this.modifyPropsMap[key] = window[key]; window[key] = this.windowSnapshot[key]; } }); this.sandboxRunning = false; } } LegacySandbox: 其实看到源码还有个LegacySandbox，不过后面废弃了，因为没有了sanbox配置没有了loose这个配置 const useLooseSandbox = typeof sandbox === 'object' &amp;&amp; !!sandbox.loose; const sandbox = useLooseSandbox ? new LegacySandbox(appName, globalContext) : new ProxySandbox(appName, globalContext); 执行js代码： 通过html-import-entry得到js执行函数： execScripts 我们可以看到他通过传入proxy，执行 getExecutableScript得到js code，其中使用 function(){}(with(window){fn.bind(window.proxy)(window.proxy, window.proxy, window.proxy)}) var code = getExecutableScript(scriptSrc, rawCode, proxy, strictGlobal); evalCode(scriptSrc, code); function getExecutableScript(scriptSrc, scriptText, proxy, strictGlobal) { var sourceUrl = isInlineCode(scriptSrc) ? '' : \"//# sourceURL=\".concat(scriptSrc, \"\\n\"); // 通过这种方式获取全局 window，因为 script 也是在全局作用域下运行的，所以我们通过 window.proxy 绑定时也必须确保绑定到全局 window 上 // 否则在嵌套场景下， window.proxy 设置的是内层应用的 window，而代码其实是在全局作用域运行的，会导致闭包里的 window.proxy 取的是最外层的微应用的 proxy var globalWindow = (0, eval)('window'); globalWindow.proxy = proxy; // TODO 通过 strictGlobal 方式切换 with 闭包，待 with 方式坑趟平后再合并 return strictGlobal ? \";(function(window, self, globalThis){with(window){;\".concat(scriptText, \"\\n\").concat(sourceUrl, \"}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);\") : \";(function(window, self, globalThis){;\".concat(scriptText, \"\\n\").concat(sourceUrl, \"}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);\"); } // for prefetch 此时with语法内的window就是proxy：把解析出的scriptText（即脚本字符串）用with(window){}包裹起来，然后把window.proxy作为函数的第一个参数传进来，所以with语法内的window实际上是window.proxy。此时我们的js代码执行时，全局变量都会被挂载到沙箱的proxy当中去。 然后再通过 evalCode函数全局执行js代码 export function evalCode(scriptSrc, code) { var key = scriptSrc; if (!evalCache[key]) { var functionWrappedCode = \"window.__TEMP_EVAL_FUNC__ = function(){\".concat(code, \"}\"); (0, eval)(functionWrappedCode); evalCache[key] = window.__TEMP_EVAL_FUNC__; delete window.__TEMP_EVAL_FUNC__; } var evalFunc = evalCache[key]; evalFunc.call(window); } 应用通信一般来说，微前端中各个应用之前的通信都是比较少的。当然部分呢少量的通信是在所难免的，qiankun官方提供了一个简要的方案，思路是基于一个全局的globalState对象。这个对象由基座应用负责创建，内部包含一组用于通信的变量，以及两个分别用于修改变量值和监听变量变化的方法：setGlobalState和onGlobalStateChange。 飞冰JS隔离飞冰也是一款阿里的微前端方案：对于css污染（css隔离），由于微应用是不同的路由，所以暂时没有考虑（实验性的shadow dom方案） js隔离 规范 微应用避免改变全局状态 基于 Proxy 的运行沙箱 参考于： 微前端技术原理 —— 飞书团队 最容易看懂的微前端知识 基于 iframe 的全新微前端方案(腾讯PCG) 将微前端做到极致-无界微前端方案 vivo基于 iframe 的微前端框架 —— 擎天 微前端解决方案 微前端在美团外卖的实践 【微前端】single-spa 到底是个什么鬼 微前端框架qiankun之原理与实战 揭开 import-html-entry 面纱 微前端框架 之 qiankun 从入门到源码分析 可能是你见过最完善的微前端解决方案 【微前端】qiankun 到底是个什么鬼 更多关于微前端的相关介绍，推荐大家可以去看这几篇文章：（qiankun官网的推荐） Micro Frontends Micro Frontends from martinfowler.com 可能是你见过最完善的微前端解决方案 微前端的核心价值 为什么不使用iframe：https://www.yuque.com/kuitos/gky7yw/gesexv","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Hexo的部分问题","slug":"Hexo的部分问题","date":"2022-05-08T07:16:32.890Z","updated":"2022-05-08T07:16:32.890Z","comments":true,"path":"2022/05/08/hexo-de-bu-fen-wen-ti/","link":"","permalink":"https://taylor12138.github.io/2022/05/08/hexo-de-bu-fen-wen-ti/","excerpt":"","text":"Quick Start打开win+R进入cmd，然后在正确目录下进入：cd source_post(指定blog下) 基本操作用typora修改完毕后，1.使用“hexo clean”进行清理（1.5.若是发生主题等修改后，要接上hexo g 来建立）2.接上“hexo s”即可进入网站查看（退出键位：control+C，y）（本地浏览）3.再次部署到远端：hexo d 关于主题1.可以使用git clone 网址.git themes\\新建目录名（或者使用码云gitee进行下载，然后复制到themes目录下）2.cd.. (回到blog目录下)notepad _config.yml把记事本里面的theme：xx修改成theme：主题目录名3.重新执行”基本操作” 关于图片再_post目录下安装 (必须得是这个) npm i https://github.com/CodeFalling/hexo-asset-image 然后再_post下新建和md文件同名的文件夹，放入图片，再md中引入即可 如果还是出现上传后没有图片，可能是因为图片命为 ‘ httpxxx ‘、甚至是文件名为http也是不能被允许的，这种格式也是不能被允许的！！（因此我不得不把文章名改为超文本传输协议。。。） 参考文献 https://hexo.io/docs/one-command-deployment.html) 前端解析markdown文件实现 getStaticProps 首先，安装gray-matter，它可以让我们解析每个 markdown 文件中的元数据。 npm install gray-matter 为了呈现 markdown 内容，我们将使用该remark库。首先，让我们安装它： npm install remark remark-html可以效仿next官网制作的，写一个SSG的博客网站：https://www.nextjs.cn/learn/basics/data-fetching/implement-getstaticprops","categories":[],"tags":[],"author":"Hello"},{"title":"计算机基础知识合集","slug":"计算机基础知识合集","date":"2022-05-05T07:30:01.196Z","updated":"2023-05-29T09:33:35.813Z","comments":true,"path":"2022/05/05/ji-suan-ji-ji-chu-zhi-shi-he-ji/","link":"","permalink":"https://taylor12138.github.io/2022/05/05/ji-suan-ji-ji-chu-zhi-shi-he-ji/","excerpt":"","text":"字符编码ASCII每一位2进制有0、1两种状态，1字节 = 256种状态 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码 但是英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的（特别是亚洲国家，我们汉字就更加难顶了） UnicodeUnicode，统一码（Unicode），也叫万国码。就像它的名字都表示的，这是一种所有符号的编码。 它是一个很大的集合，现在的规模可以容纳100多万个符号 网络上流传比较广的说法是： ASCII编码是1个字节，而Unicode编码通常是多个字节。 用Unicode编码比ASCII编码需要多很多的的存储空间 阮一峰老师：Unicode有两个问题 第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？ 第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 UTF-8UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式 其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 规则！！！ 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxxUTF-8和Unicode 严的 Unicode码 是4E25，UTF-8 编码是E4B8A5 参考：https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html《阮一峰的网络日志》 ArrayBuffer类型化数组ArrayBuffer类型化数组的核心是一个名为ArrayBuffer的类型 每个ArrayBuffer对象表示的只是内存中指定的字节数;但不会指定这些字节用于保存什么类型的数据；通过ArrayBuffer能做的，就是为了将来使用而分配一定数量的字节. // 创建一个8-byte的ArrayBuffer var b = new ArrayBuffer(8); // 创建一个b的引用，类型是Int32，起始位置在0，结束位置为缓冲区尾部 var v1 = new Int32Array(b); // 创建一个b的引用，类型是Uint8，起始位置在2，结束位置为缓冲区尾部 var v2 = new Uint8Array(b, 2); // 创建一个b的引用，类型是Int16，起始位置在2，总长度为2 var v3 = new Int16Array(b, 2, 2); (比如threejs常使用的Float32Array) Uint8uint8是8位无符号整型，uint16是16位无符号整型 整型有无符号（unsigned）和有符号（signed）两种类型，在默认情况下声明的整型变量都是有符号的类型（char有点特别），如果需声明无符号类型的话就需要在类型前加上unsigned。在一些不可能取值为负数的时候，可以定义为unsigned\\，在一些底层的嵌入式编程的数据一般都是无符号。 命令窗口有时候我们执行一些命令失败，但是往上有人是成功的，可能是当前终端不支持 windows用户：powershell是微软用来替代cmd的，我们可以cmd和powershell轮流试一试命令的执行，搜索引擎上也有vscode中默认终端切换的方案；除此之外，coderwhy老师还推荐windows用户使用git bash敲命令，毕竟windows的终端没有linux、macos做得好，和操作系统的连接、内核好用 图形Base64Base64（基底64）是一种基于64个可打印字符来表示二进制数据的表示方法，它是一种编码方式的名称。 由于 log2 64 = 6 所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元 当需要对二进制数据进行编码时，通常会使用 Base64 编码方案，尤其是当数据需要通过旨在处理文本的媒体进行存储和传输时。这种编码有助于确保数据在传输过程中保持完整而不被修改。Base64 常用于许多应用程序，包括通过 MIME 发送电子邮件，以及以 XML 或 JSON 格式存储复杂数据。 Base64Url在编写 HTML 网页时，对于一些简单图片，通常会选择将图片内容直接内嵌在网页中，从而减少不必要的网络请求，但是图片数据是二进制数据，该怎么嵌入呢？绝大多数现代浏览器都支持一种名为 Data URLs 的特性，允许使用 base64 对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。 组成 前缀（data:）、指示数据类型的 MIME 类型、如果非文本则为可选的 base64 标记、数据本身： data:[&lt;mediatype>][;base64],&lt;data> mediatype 是个 MIME 类型的字符串，例如 “image/jpeg“ 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII。如果数据是文本类型，你可以直接将文本嵌入（根据文档类型，使用合适的实体字符或转义字符）。如果是二进制数据，你可以将数据进行 base64 编码之后再进行嵌入。比如嵌入一张图片： &lt;img alt=\"logo\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUg...\"> HTML中，img的src和css样式的background-image都可以接受base64字符串，从而在页面上渲染出对应的图片 再次我们先了解下base64的缺点 如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为该图片经过 base64 编码后的字符串非常大，会明显增大 HTML 页面的大小，从而影响加载速度 base64Url可能会被你的应用多次复用，本来浏览器可以直接从本地缓存取出的图片，换成base64Url，将造成应用中多个页面重复下载1.3倍大小的文本 约等于 流量消耗 * 13倍 低版本浏览器兼容问题 不利于开发者工具调试 优点呢？（减少了http请求） 在http2.0的加持下（二进制帧传输），保留了http1.1的长连接，请求和响应可以交错甚至可以复用，多个并行请求的开销已经大大降低，我已经不知道还有什么理由继续坚持base64Url的使用了。 JPG vs PNG这和普通的HTML差不多，JPG有损压缩，PNG有无损压缩，所以PNG的下载速度一般比较慢。但是，PNG支持透明度。PNG可能也适合作为非图像数据（non-image data）的格式，比如法线图，以及其他种类的非图像图，我们后面会介绍。 请记住，在WebGL中JPG使用的内存并不比PNG少。参见上文。 BMPBMP是英文全称为位图（Bitmap）的缩写，它是一种常见的图像文件格式。BMP格式是一种无损的图像文件格式，它以像素阵列的形式存储图像数据，每个像素都有自己的颜色信息。BMP文件可以包含彩色图像、灰度图像或黑白图像。 BMP格式的文件大小相对较大，现在常用的图片格式往往采用压缩算法，如JPEG、PNG等，以减小文件大小并保持较好的图像质量。然而，BMP格式仍然在某些特定的应用领域中得到广泛使用，比如在一些图像处理软件、打印机和某些老旧的操作系统中。 PAGPAG（Portable Animated Graphics）是腾讯自主研发的一套完整的动画工作流解决方案，助力于将 AE 动画方便快捷的应用于各平台终端。 据官方的介绍，和lottie、SVGA等进行对比 文件更小 AE特性全面支持 矢量动画渲染性能更好一点，但是内存当然也会占用更多一点 还有(截止2023上半年) 缺点：SDK接入体积大，兼容性较差，需要wasm或asm.js的支持，在app端的SDK 部分主要分为两个版本，一个是社区版，免费，一个是企业版，要收费，差异性挺大的，社区版不支持音频播放等，具体可以看这里 演示pag-web的官方demo github地址 数据格式json5json5是json文件的一种升级 他支持： 加注释 key名不一定要使用双引号 支持使用转义字符 Linux一些常用命令vi编辑命令：首先 vim 文件名 进入 wq：表示保存退出 wq!：表示强制保存退出 q：表示退出 q!：表示强制退出 问题记录 VIM编辑文件权限问题:”E45: ‘readonly’ option is set (add ! to override)” 使用 :w/:wq 保存的时候提示 “E45: ‘readonly’ option isset (add ! to override)”，而用 :w! 提示 “E212: Can’t open file forwriting”。 解决方案， :q! 强制关闭文件后，在命令行里输入：sudo !! 后回车再次vim打开文件编辑就正常了 方法来搜罗自网络，vi编辑正常，vim编辑遇到上面的问题，具体原因不详。 pwd：查看当前目录位置 ifconfig：查看网络信息 free -h：查看服务内存状况 df -lh：查看磁盘空间 mkdir 目录名：新建目录 which 包名：假如包安装在全局，通过这个命令可以查看包具体安装在哪个目录下 who：显示当前登录系统的用户 rm -f 文件名 删除⽂件 rmdir dir1 删除’dir1’⽬录 rm -rf dir1 删除’dir1’⽬录和其内容 cat 文件名 查看file1 内容 zip xxx.zip 文件名 把压缩成xxx.zip包 Mac一些命令设置别名 open ~/.bash_profile 这里比如给chrome设置别名 alias chrome=\"/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome\" 保存后执行 source ~/.bash_profile 什么是bash bash是 the Bourne again shell 的缩写，而Bourne shell是一种最常见、UNIX最初使用的shell。shell是用户和Linux内核之间的接口程序 ~/.bashrc是什么 ~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下） ~/.bash_profile是什么？ ~/.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. zshrc: mac默认的shell改了，现在是zsh了，装了oh-my-zsh之后，启动时会运行zshrc而不是上面两个文件。另外它和Login Shell与no-Login Shell都没有关系，不管什么shell都会运行。 Mac可以通过 echo $0 查看当前用的是zsh还是bash","categories":[],"tags":[],"author":"Hello"},{"title":"Nodejs","slug":"Nodejs","date":"2022-05-05T06:07:51.528Z","updated":"2023-04-12T11:58:57.167Z","comments":true,"path":"2022/05/05/nodejs/","link":"","permalink":"https://taylor12138.github.io/2022/05/05/nodejs/","excerpt":"","text":"1.Node概述Node.js是一个能够在服务器上运行JavaScript的环境 为什么选择node： 1.node使用JavaScript语法开发后端应用 2.一些公司要求前端人员掌握Node开发 3.生态系统活跃，有大量开源库 4.现有前端开发工具大多居于node开发 node是基于chrome V8引擎的JavaScript代码运行环境（浏览器也是JavaScript代码运行环境），源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码) 在命令行工具中输入 node -v 即可查看nodejs是否安装成功 node.js和JavaScript的对比JavaScript由3部分组成，ECMAScript+DOM+BOM，可以在不同浏览器的JS引擎上运行 Node.js仅在chrome使用的V8引擎上运行 由ECMAScript及Node环境提供的一些附加API组成的 ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象) os(操作系统) file(文件系统) net(网络系统) database(数据库) 他们都使用了ECMAScript语法，只是分别向前后端的方向拓展了 使用在cmd命令符窗口中使用 node xx.js 即可完成（在执行文件的目录下按住shift+鼠标右键可快速进入当前目录的命令符窗口，然后配合tab键位快速打开） 也可以直接使用 node进行回车，可以直接供测试使用（核心模块可以直接用，不用require），类似于浏览器的console控制台 2.Buffer缓冲区数组不能存储二进制文件，而buffer就是专门来存储二进制数据 从结构上buffer非常像一个数组，他的元素为16进制的两位数 var str = \"hello, 艾伦\"; var buf = Buffer.from(str); console.log(buf.length); //占用内存大小 console.log(str.length); //字符串长度 var s = buf.toString(); //将缓冲区的数据转换回字符串 var j = buf.toJSON(); //将缓冲区的数据转换回json对象 buffer存储的数据都是二进制数据，但是显示的时候都是以16进制显示，范围是00 - ff（00000000 - 11111111），所以是8 bit （位），8 bit = 1 byte （字节）（一个英文占一个字节，一个汉字占3个字节） buffer 构造函数（new Buffer）不推荐使用 但是可以：使用Buffer.alloc(size)分配一个大小为size的新建Buffer 还有：Buffer.allocUnsafe(size) 创建一个指定大小的buffer，但是buffer可能含有敏感数据（分配时未清空上一次使用内存存放的数据，但是性能够好） Buffer的大小一旦确定，则不能修改，Buffer实际上是对底层内存的直接操作 可以通过索引操作buffer中的元素 buf[0] = 88 这里的88是16进制，然后再控制台console.log进行输出时，显示的是10进制（只要数字在控制台输出一定是10进制） 3.文件系统fs通过node操作系统中的文件，在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地文件发送给远程客户端，该模块提供了一些标准文件访问api来打开，读取，写入文件，以及与其交互 引入fs模块，fs是核心模块，直接引用不用下载 fs模块中所有的操作都有两种形式可供选择：同步和异步 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码（顺序执行） 异步文件系统不会阻塞程序的执行，而是在操作完成时（异步都有callback）（异步方法不可能有返回值）通过回调函数结果返回 fs中带Sync的的方法是同步方法，不带Sync的方法是异步方法 文件打开同步文件打开 fs.openSync(path, flags[, mode]) ​ -path 打开的文件路径 ​ flags 打开文件操作类型 比如 r 只读的、 w 可写的 ​ mode 操作权限 ，一般省略 该方法会返回一个文件描述符作为结果，我们可以通过该描述符来对文件进行各种操作 异步文件打开 fs.open(path, flags[, mode], callback) ​ callback不能省略 ​ 回调函数中有两个参数 ​ err 错误对象 没有错误则为null ​ fd 文件描述符 无返回值 文件写入同步文件写入 fs.writeSync(fd, string[, position[, encoding]]) ​ fd文件描述符，需要传递要写入的文件的描述符 ​ string写入内容 ​ position起始位置，一般省略 ​ encoding 默认utf-8 异步文件写入（写在fs.open的回调函数里） fs.write(fd, string[, position[, encoding]], callback) ​ 当前回调有三个参数 ​ err ​ written ​ string 关闭文件服务器是持续运行的，不想我们平时运行的文件，结束后自动释放空间 fs.closeSync(fd) ​ fd文件描述符，需要传递要写入的文件的描述符 fs.close(fd, callback) ​ 异步，完成回调只有一个可能的异常参数 简单文件写入（常用）一步搞定，省略打开，关闭 fs.writeFile(file, data[, options], callback) fs.writeFileSync(file, data[, options]) ​ file 要操作文件的路径 ​ data 要写入的数据 ​ option 选项，可选，对写入进行配置：有encoding（默认utf-8）、mode（权限）、flag（文件操作形式，默认w，如果内容不存在则创建，存在则截断） ​ callback 当写入完成以后执行的函数 var fs = require(\"fs\"); fs.writeFile(\"index.txt\", \"aaa\", function (err) { if (!err) { console.log(\"写入成功！\"); } else { console.log(\"error!\"); } }); Stream流Stream流是一个抽象的接口，在nodejs当中，很多方法，对象，他们都实现了这个接口，例如之前创建一个服务，向服务器发送一个请求，request对象，他其实就是一个流（流简单粗暴的理解就是在线看电视） 在nodeJS中，Stream有四种流类型： ​ Readable -可读操作 ​ Writable -可写操作 ​ Duple -可读可写操作 ​ Transform -操作被写入数据，然后读出结果 所有的Stream对象都是EventEmitte（events模块）r的实例 常用事件： ​ -data 当有数据可读取时触发 ​ -end 没有更多数据可读取时触发 ​ -error 在接收和写入过程中，发生错误时触发 ​ -finish 所有数据已经被写入之后触发 流式读取文件的方法在 5.文件系统fs中 流式文件写入同步、异步、简单文件的写入，都不大适合大文件的写入（都是一次写入），性能较差，容易导致内存溢出 而流式文件的传输相当于两个水池之间插入一条管道，持续的多次的写入 它本质上也是一个异步 创建一个可写流，参数功能和之前的文件读写相同 var ws = fs.createWriteStream(path [, option]) var fs = require(\"fs\"); var ws = fs.createWriteStream(\"index.txt\"); // 监听文件的打开和关闭 ws.once(\"open\", function () { //once为对象绑定一个一次性的事件，jQuery也有出现过类似的one console.log(\"流打开了\"); }); ws.once(\"close\", function () { console.log(\"流关闭了\"); }); ws.write(\"通过可写流写入文件的内容\"); ws.write(\"啊大苏打\"); ws.write(\"大撒大撒\"); //不再有数据写入 Writable ws.end(); //在调用 stream.end() 方法之后，并且所有数据都已刷新到底层系统，则触发 'finish' 事件，一定在前面要有end事件。 ws.on('finish' () => { console.log('写入完成') }) // 关闭流，关闭流入口 // ws.close(); 当前版本也可以了（关闭流出口） 文件读取（all kinds）这里只讲讲简单文件读取和流式文件读取 简单文件读取（参数功能同上） fs.readFileSync(path [, options]) fs.readFile(path [, options], callback) ​ callback回调函数参数 （err, data） ​ err 错误对象 ​ data 读取到的数据，会返回一个Buffer 流式文件读取 它也适合一些比较大的文件，可以分多次将文件读取到内存中 创建一个可读流： fs.createReadStream(path) 如果要读取一个可读流的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，然后读取到的数据存放在参数中返回（它的参数没有err，因为事件触发后就意味着不会再出错了） var fs = require(\"fs\"); var rs = fs.createReadStream(\"cool.jpg\"); var ws = fs.createWriteStream(\"copy.jpg\") // 监听 rs.once(\"open\", function () { console.log(\"可读流打开了\"); }); rs.once(\"close\", function () { console.log(\"可读流关闭了\"); // 数据读取完毕，关闭可写流 ws.end(); }); ws.once(\"open\", function () { console.log(\"可写流打开了\"); }); ws.once(\"close\", function () { console.log(\"可写流关闭了\"); }); // 开始读取 rs.on(\"data\", function (data) { //将数据读到data中 // 将读取的数据写入可写流中 ws.write(data); }) 流式文件原本需要data方法进行读取，但是有个更方便的方法： 将可读流和可写流管道相通，形成管道流，用了 pipe() 的方法 改： // 开始读取 /* rs.on(\"data\", function (data) { //将数据读到data中 // 将读取的数据写入可写流中 ws.write(data); })*/ // 开始读取 rs.pipe(ws); 文件读取配合文件写入，可完成文件的传输 服务器就是接收用户的请求，并返回响应，而请求和响应就是数据流 fs其他方法fs.existsSync(path) 是否存在 fs.stat(path, callback) 文件状态（里面包含文件大小等信息） fs.readdir(path, [, option], callback) 读取文件目录列表 fs.readdir(path, [, option])读取一个目录的目录结构 fs.truncateSync(path, size) 截断文件，将文件修改为指定大小 链式流就是从一个输出流当中，读取数据，创建多个流来操作这个输出流数据的机制 链式流一般来操作管道流 常见的例子就是压缩和解压缩的例子 // 链式流 var fs = require('fs'); var zlib = require('zlib'); // 压缩文件 fs.createReadStream('cool.jpg') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('cool.jpg.gz')); console.log(\"解压完毕！！！\"); // 链式流 var fs = require('fs'); var zlib = require('zlib'); // 解压缩 fs.createReadStream('cool.jpg.gz') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('copy2.jpg')); console.log(\"解压缩完毕！！！\"); 4.创建服务1.先引入模块(Nodejs本身提供了http模块) var _http = require(&#39;http&#39;); 创建服务器http.createServer([options][, requestListener]) request监听事件需要接收两个参数，Request请求对象（获取客户端请求信息），Response响应对象（用来给客户端发送响应消息） 再创建服务器的回调函数里添加http头部信息，然后向客户端发送数据 响应对象1.响应对象response添加信息：response.writeHead(statusCode[, statusMessage][, headers]) ​ statusCode 为状态码 ​ headers为响应头 text/plain:纯文本 text/html: 可识别为html标签的文本 ​ charset=utf-8:防止中文乱码（服务器默认发送数据时utf8，但是浏览器不知道你是utf8，它会默认按照当前操作系统的编码去解析） response.setHeader(name, value)也可以写响应头 （writeHeader可以设置http返回状态码，多个http响应头。但是setHeader只针对单一属性的设置。） 2.响应对象response发送数据，并且结束响应（end）： response.end(&quot;第一个http服务&quot;); （当然也可以response.write(&quot;xxx&quot;); response.end()） 注意：响应内容只能是二进制数据或字符串（Buffer或String） var _http = require('http'); // 创建服务器 _http.createServer(function (request, response) { // http头部信息 response.writeHead(200, { 'Content-type': 'text/plain;charset=utf-8' }); // 向客户端发送数据，并且结束响应（end） response.end(\"第一个http服务\"); }).listen(5205); //自己设置监听的端口号最好不要用8888，8080，可能会被电脑其他应用占用，容易报错 console.log(\"5205已经创建!\"); 绑定端口号也可以直接给实例绑定： ​ var server = http.createServer(){} ​ server.listen(端口号, callback) 此时打开本地浏览器，local:host5205即可查看访问 response的重定向通过服务器让客户端重定向 状态码设置302临时重定向 statusCode 在响应头通过location告诉客户往哪重定向 setHeader 客户端发现收到服务器的响应状态码为302，就会自动去响应头找location，然后对该地址发起新的请求 所以你就能看到客户端自动跳转（这里是跳转至首页） //接收表单数据后（get），进行跳转，跳转至首页 var comment = url.parse(req.url, true).query; comments.unshift(comment); //从头部增加数组元素，comments为数组变量 res.statusCode = 302; res.setHeader('Location', '/'); //响应头的Loacation路径设置为 '/' 即首页 res.end(); url.parse()(弃用)url.parse(urlString , boolean , boolean) parse这个方法可以将一个url的字符串解析并返回一个url的对象。 第一个参数传入一个url地址的字符串 第二个参数（可省）传入一个布尔值，默认为false，为true时，返回的url对象中，query的属性为一个对象。 // url.parse(\"http://user:pass@host.com:8080/p/a/t/h?query=string#hash\"); // return： { protocol: 'http:', slashes: true, auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/p/a/t/h', path: '/p/a/t/h?query=string', href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash' } 现在被弃用之后，改用新的API WHATWG URL API（无需导包，直接使用） const myURL = new URL('http://user:pass@host.com:8080/p/a/t/h?query=string#hash'); console.log(myURL); 直接返回 URL { href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash', origin: 'http://host.com:8080', protocol: 'http:', username: 'user', password: 'pass', host: 'host.com:8080', hostname: 'host.com', port: '8080', pathname: '/p/a/t/h', search: '?query=string', searchParams: URLSearchParams { 'query' => 'string' }, hash: '#hash' } 请求对象 | 数据获取1.请求路径为： request.url, url：统一资源定位符 路径优化问题： var http = require('http'); const url = require('url') var fs = require('fs'); var wwwDir = 'C:/Users/ok-pc/blog/source/_posts'; //文件路径 http.createServer(function (req, res) { var url = = url.parse(req.url, true).pathname var filePath = '/index.html'; if (url !== '/') { filePath = url; } fs.readFile(wwwDir + filePath, function (err, data) { if (err) { return res.end('404'); } else { res.end(data); } }) }) get请求数据： http.createServer(function (req, res) { console.log(new URL(req.url, true).query) }) post请求数据：(因为post是以流的方式传过来的) function (request, response) { if (request.method == 'POST') { var body = ''; request.on('data', function (data) { body += data; // Too much POST data, kill the connection! // 1e6 === 1 * Math.pow(10, 6) === 1 * 1000000 ~~~ 1MB if (body.length > 1e6) request.connection.destroy(); }); request.on('end', function () { var post = qs.parse(body); // use post['blah'], etc. }); } } ip地址与端口所有联网的程序都需要网络通信，计算机只有一个物理网卡，网卡的地址是唯一的（ip地址） 端口号用来定位具体应用程序（类似银行窗口号，服务器类似于银行） 一切需要联网通信的软件都会占用一个端口号 端口号在 0 - 65536 之间 在计算机中有一些默认端口号，最好不要去使用 例如http服务的80 可以同时开启多个服务，但是一定要确保不同服务占用端口号不一致（在一台计算机中，同一端口号同一时间只能被一个程序占用） 处理静态资源浏览器收到html响应内容之后，就要开始从上到下进行解析，当在解析过程中，如果发现： link script img iframe video audio 等带有src 或者 href（link）属性标签的时候（具有外链资源的时候），浏览器会自动对这些资源发起新的请求 我们为了方便统一处理这些静态资源，所以约定把所有静态资源存放在public目录中，即如果请求路径以 /public/开头，则认为你是要获取public的某个资源，所以我们这时可以直接把请求路径当作文件路径进行读取 这时哪些资源能否被用户访问可以达到一个可控的状态 （注意：在服务端中，文件的路径就要要写相对路径了，因为这个时候所有资源都是通过url标识来获取，这里服务器开放了/public/目录，所以这里请求路径写成 /public/xxx） html中的link ：&lt;link rel=&quot;stylesheet&quot; href=&quot;/public/lib/bootstrap/dist/css/bootstrap.css&quot;&gt; nodeJs代码： var http = require('http'); var fs = require('fs'); var rg = /^\\/public\\//; http.createServer(function (req, res) { var url = req.url; if (url === '/') { fs.readFile('./views/index.html', function (err, data) { if (err) { return res.end('404 Not Found.'); } res.end(data); }) } else if (rg.test(url)) { // 如 ：/public/lib/bootstrap/dist/css/bootstrap.css // url.indexOf('/public/') === 0也可以 fs.readFile('.' + url, function (err, data) { if (err) { return res.end('404 Not Found.'); } res.end(data); }); } }).listen(5208, function () { console.log('running!!...'); }); 5.事件nodeJs它基本上，所有事件机制，都是基于设计模式种“观察者模式”来实现的 简单来说，nodejs使用事件驱动的模型，每当接收到一个请求，就把他关掉进行处理，当这个请求完成，就把它放到处理队列当中，最后把结果返回给用户 因为它的服务一直是处理接收请求，但不等待任何读写操作，所以性能很高，这也叫做“非阻塞式IO或是事件驱动IO” nodeJS事件使用events模块，通过实例化它里面的EventEmitter类来绑定和监听事件，也是利用了“发布订阅模式” 使用事件模块：var eve = require(&#39;events&#39;) 实例化EventEmitter类：var event = new eve.EventEmitter() ​ 实例化对象里有个_eventsCount属性，显示绑定事件数量 （也可以： var eventEmitter = require(&#39;events&#39;).EventEmitter; ​ var event = new eventEmitter(); ） 绑定事件：event.on(事件名, callback)（jquery也用on绑定事件） ​ 事件名可以自定义，因为这里的事件名完全不同于浏览器上的各种事件，这里的事件名就是一个“标识”，实际上绑定了一个回调函数 监听事件的触发：event.emit(事件名) // 绑定一个事件 event.on('one', function () { console.log(\"no.1事件被触发了\"); }); // 触发一个事件 event.emit('one'); 所有nodejs里面的异步io操作，都会在完成时，发送一个事件到事件队列 6.模板引擎最早诞生于服务器领域，后来发展到前端 官方文档：https://aui.github.io/art-template/ 安装npm install art-template 浏览器应用引入 &lt;script src=&quot;./node_modules/art-template/lib/template-web.js&quot;&gt;&lt;/script&gt; 类型改为 type = &quot;text/template&quot; 模板引擎不关心字符串内容，只关心自己能认识的模板标记语法，例如(包含if语句判断) {{ 变量名 }} {{ if user }} {{ else }} {{ /if }}{{ each 遍历数组 }} &lt;li&gt;{{ $index + 1 }}&lt;/li&gt; &lt;li&gt;{{ $value }}&lt;/li&gt; {{/each}}该语法被称之为mustache语法，八字胡 template(&#39;script 标签 id&#39;, {对象}) &lt;script src=\"./node_modules/art-template/lib/template-web.js\">&lt;/script> &lt;script type=\"text/template\" id=\"tql\"> hello{{ name }} 今年 {{ age }} 岁了 &lt;/script> &lt;script> var ret = template('tql', { name: 'jack', age: 18 }) console.log(ret); document.querySelector('#表单id号').innerHTML = ret; &lt;/script> nodejs应用核心方法 引入： var template = require(&#39;art-template&#39;); 基于模板名渲染模板template(filename, data); 将模板源代码编译成函数template.compile(source, options); 将模板源代码编译成函数并立刻执行template.render(source, data, options); var ret = template.render('hello {{ name }}', { name: 'Jack' }) 7.PathPath是一个核心模块 var path = require(&#39;path&#39;) path.basename(path[,ext]) 获取给定路径当中文件名部分，第二个参数可以用来去除指定的后缀名 console.log(path.basename('c:/a/b/c/index.js')); //index.js console.log(path.basename('c:/a/b/c/index.js', '.js')); //index console.log(path.basename('c:/a/b/c/index.js', '.html')); //index.js path.dirname(path) 方法会返回 path 的目录名 path.extname(path) 返回 path 的扩展名 console.log(path.extname('c:/a/b/c/index.html');); //.html path.isAbsolute(path) 检测 path 是否为绝对路径。(‘./c/index.js’是相对路径， ‘/c/index.js’是绝对路径) path.join([...paths]) 方法会将所有给定的 path 片段连接到一起，生成规范化路径 path.join('/目录1', '目录2', '目录3/目录4', '目录5'); // \\\\目录1\\\\目录2\\\\目录3\\\\目录4\\\\目录5' path.resolve([from...],to) 把一个路径或路径片段的序列解析为一个绝对路径，有点像join，但是解析结果一定是绝对路径 更多知识点可查看nodejs官方文档的Path部分 在文件操作路径中，使用相对路径是不可靠的，因为相对路径设计就是相对于执行node 命令所处的路径， 所以我们要利用好（以下在node中为全局变量，直接用） __filename 当前模块的完整路径 __dirname 当前模块所在文件夹完整路径（所属目录的绝对路径） 配合Path进行操作（比如拼接路径过程中，防止手动拼接带来低级错误，可以使用path.join），把相对路劲变成绝对路径（注意是动态绝对路径）就好了 //express框架公开指定目录 app.use('/node_modules/', express.static(path.join(__dirname, './node_modules/'))); 特殊 ：模块中的路径标识（比如：require(&#39;./a.js&#39;)）是相对于当前文件模块，不受到node命令所处路径影响 8.其他进程为我们程序的运行提供一个必备的环境（进程是资源分配的最小单位） 线程是计算机中最小的计算单位，线程负责执行保存到进程中的程序（线程是CPU调度的最小单位） JS、浏览器、nodejs是单线程 修改完自动重启服务器我们这里可以使用一个第三方工具：nodemon来帮我们解决修改代码重启服务器问题 #--global 来安装则可以在任意目录执行 npm install --global nodemon 原来我们在命令行输入：node xxx.js 现在：nodemon xxx.js， 他会监视你的文件变化，当文件变化时，会自动帮你重启服务器 JSON方法JSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。 一般用于存储数据时，对对象之类数据以字符串的形式进行保存 JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换(操作)。 一般用于将数据取出时，转化未真正的类型调用的方法 还有手写方法可以参考一波https://juejin.cn/post/6844903992871354375 使用node.js进行爬虫原理：当网页时后端渲染时，对网页源代码进行爬取，得到其html源码 第一步： 使用 npm init --yes初始化创建的文件夹 下载依赖包 npm i superagent cheerio superagent: 是一个轻量的Ajax API，和axios差不多，只不过他不支持浏览器 cheerio：为服务器特别定制的快速灵活jQuery，它并不会产生视觉呈现，应用CSS，加载外部资源，或者执行JavaScript，可以用来从网页css selector取数据，使用方法和jQuery一样 如果你不想用cheerio，就自己一个一个正则匹配去吧！（= = ） 第二步： 通过 superagent &amp; cheerio获取网页数据（后端渲染） 数据处理，可以使用正则表达式，字符串切割，或者eval() 函数（可计算某个字符串，并执行其中的的 JavaScript 代码。） 第三步： 写入本地 superagent.get('https://ncov.dxy.cn/ncovh5/view/pneumonia').then(res => { // 浏览器可以解析代码，node端直接返回源码,而res.text是我们需要的响应数据 const $ = cheerio.load(res.text); //经测试，superagent的res.text = axios的res.data const $getAreaStat = $('#getAreaStat').html(); // 加入全国疫情数据 let data = {}; eval($getAreaStat.replace(/window/g, 'data')); //执行里面的语句，使得data成功被赋值 console.log(data); // 字符串转换json fs.writeFile(path.join(__dirname, './data.json'), JSON.stringify(data), err => { if (err) throw err; console.log(\"写入成功！！！\"); }) }).catch(err => { throw err; }) 如果是爬取到原网页后，对网页标签里的数据进行获取，可以使用 里面的使用和jQuery使用一样，可以使用each方法遍历 const $ = cheerio.load(res.text); const inner = $('#home .col a').text();//在外层是id为home，里面类名为col标签内里的a标签 $('#home .col a').each((index, ele) => { console.log($(ele)) console.log($(ele).attr(\"属性名\")) console.log($(ele).text()) })","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"模块导入","slug":"模块导入","date":"2022-05-05T06:07:51.528Z","updated":"2023-04-13T09:18:55.301Z","comments":true,"path":"2022/05/05/mo-kuai-dao-ru/","link":"","permalink":"https://taylor12138.github.io/2022/05/05/mo-kuai-dao-ru/","excerpt":"","text":"模块化开发JavaScript弊端：文件依赖（a.js-&gt;b.js-&gt;c.js，相互依赖，但是很难直接看出来，分析完后才知道要一个一个引入）和命名冲突（在相互依赖的js中声明同样的变量名导致的错误） 模块化开发：一个功能一个模块，多模块组合完整应用，抽离一个模块不会影响其他功能的运行，降低程序的耦合性，方便代码复用（虽然开发效率低一点） 1.CommonJScommonJS的提出： 为了弥补JavaScript没有标准的缺陷，希望JS’能在任何和地方运行，CommonJS对模块的定义十分简单 注意，一般认为Node.js的模块系统使用了CommonJS的规范，实际上并不完全正确，Node.js使用了轻微修改版本的CommonJS，因为Node.JS主要在服务器环境下使用，所以不需要考虑网络延迟问题 CommonJS特点node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到（除了console.log的输出内容），因为在node的定义中，每个js文件的js代码都是独立运行在一个函数中，而不是全局作用域。 当node执行模块中代码，它首先在代码顶部添加： function(exports, require, module, __filename, __dirname){} 将代码包含进去，此时由于在外部包裹了一层function，就会形成一个作用域，避免了全局污染 模块内部使用exports 对象进行成员导出，使用require方法导入其他模块（注意ES6不使用require而是使用import） CommonJS 规范是在代码运行时同步阻塞性地加载模块，在执行代码过程中遇到 require(X) 时会停下来等待，直到新的模块加载完成之后再继续执行接下去的代码。 虽说是同步阻塞性，但这一步实际上非常快，和浏览器上阻塞性下载、解析、执行 js 文件不是一个级别，硬盘上读文件比网络请求快得多。 但是：模块请求仍然会造成浏览器 JS 解析过程的阻塞，导致页面加载速度变慢 在模块代码被运行前就已经写入了 cache，同一个模块被多次 require 时只会执行一次，重复的 require 得到的是相同的 exports 引用。 const a1 = require('./moduleA'); const a2 = require('./moduleB'); console.log(a1 === a2); // true 出现文件互相引用的情况下，会去缓存查看之前是否写入过，若写入过，被引用下个文件形成循环引用之前的到处变量变得”可视”；否则被统计为 “undefined” // main.js const a = require('./a'); console.log('in main, a.a1 = %j, a.a2 = %j', a.a1, a.a2); // a.js exports.a1 = true; const b = require('./b.js'); console.log('in a, b.done = %j', b.done); exports.a2 = true; // b.js const a = require('./a.js'); console.log('in b, a.a1 = %j, a.a2 = %j', a.a1, a.a2); in b, a.a1 = true, a.a2 = undefined in a, b.done = undefined in main, a.a1 = true, a.a2 = true进入 b 模块前， 这时候 a2 代码还没执行。 进入 b 模块，require a.js 时发现缓存上已经存在了，获取 a 模块上的 exports 。打印 a1, a2 分别是 true，和 undefined。 实践： exports //a.js let version = 1.0; const sayHi = name => `你好, ${name}`; //向模块外导出数据 exports.version = version; exports.sayHi = sayHi; require,如果直接使用模块名来引入，没有添加路径，它会首先在当前目录的node_modules中寻找是否含有该模块，没有则一直往上一级寻找var math = require(&quot;math&quot;) （require加载规则：优先从缓存加载，即之前加载过的模块，不再加载） 模块中的路径标识是相对于当前文件模块，不受到node命令所处路径影响，想查看路径影响可跳转阅读 9. Path //b.js //b.js导入a.js, ./b.js是b.js的路径，路径模块必须加'./', 如果只加了'/'，就当作此盘根目录下路径，也就是绝对路径处理 let a = require('./a.js'); console.log(a.version); console.log(a.sayHi('xx')); //使用a.js的方法 模块导出的另一种方式(和exports差不多)： //a.js module.exports.version = version; module.exports.sayHi = sayHi; //b.js let a = require('./a.js'); //b.js导入a.js, ./b.js是b.js的目录 console.log(a.version); console.log(a.sayHi('xx')); //使用a.js的方法 module代表当前模块本身 exports是module.exports的别名（地址引用关系），它们俩指向同一块内存空间，导出对象（当exports和module.exports对象指向的不是同一个对象时）最终以module.exports为准，即想要直接以对象的方式进行全部修改，只能以module.exports进行声明，比如 module.exports = { name: &#39;allen&#39;,} 用module.exports来改动的话，是改对象，更改对象里的值 用exports以对象方式来改动的话，是改变量，更改了地址 最后return的是 module.exports ，所以给exports重新赋值不管用 __filename 当前模块的完整路径 __dirname 当前模块所在文件夹完整路径（所属目录的绝对路径） 注意：如果a加载了b ，b又加载了a，（即a require b，b require a）说明思路有问题 模块查找过程 从 Y 路径运行 require(X) 1. 如果 X 是内置模块（比如 require(&#39;http&#39;）) a. 返回该模块。 b. 不再继续执行。 2. 如果 X 是以 &#39;/&#39; 开头、 a. 设置 Y 为 &#39;/&#39; 3. 如果 X 是以 &#39;./&#39; 或 &#39;/&#39; 或 &#39;../&#39; 开头 a. 依次尝试加载文件，如果找到则不再执行 - (Y + X) - (Y + X).js - (Y + X).json - (Y + X).node b. 依次尝试加载目录，如果找到则不再执行 - (Y + X + package.json 中的 main 字段).js - (Y + X + package.json 中的 main 字段).json - (Y + X + package.json 中的 main 字段).node c. 抛出 &quot;not found&quot; 4. 遍历 module paths 查找，如果找到则不再执行 5. 抛出 &quot;not found&quot;模块分类核心模块 由node引擎提供 核心模块的标识就是模块的名字（如node提供的文件模块fs） 文件模块 由用户自己定义 第三方模块（可以通过npm下载，它的查找方式是先找到当前目录下node_modules/xx/package.json文件，查看其中main属性，记录了js文件的入口，当main没有指定，默认执行node_modules/xx/目录下的index.js）（模块查找机制：如果以上任何条件不成立，则会进入上一级目录中的node_modules） 2.ES6的模块化ESM常见的模块化规范：CommonJS、AMD、CMD、ES6的Modules ES6模块化 ： export导出 import 导入 在 style 里导入使用 @import 首先将模块化的js文件引入时需要添加类型 module ：&lt;script src=&quot;js地址&quot; type=&quot;module&quot;&gt;&lt;/script&gt; 然后再所需模块内进行导出 / 导入（有模块代码自动进入严格模式） //方式1、2的导出实际上是一致的 // 导出方式1 let name = 'allen'; export { name } // 导出方式2 // 定义的时候导出，先声明再导出必须使用方式1 export var num = 1000; export function sum() { } // 导出方式3,这种方法只能导出一个,使用一次default导出一个 export default adress // 导出方式4，从本文件导出types文件下所导出的所有东西的东西 export * from './types' 因为命名导出和默认导出不会冲突，所有ES6支持一个模块中同时定义这两种导出 const foo = 'foo'; const bar = 'bar'; export { bar }; export default foo; 四种导入方法 // 1.导入单个num（对应导出方式1、2、4） import { num } from \"./aaa.js\"; // 2.导入默认的值（default），能够自己命名（对应导出方式3） import add from \"./aaa.js\"; // 3.统一全部导入（对应导出方式1、2、4） import * as aaa from \"./aaa\"; console.log(aaa.num); //1.下载后module的引用比较特殊 import Vue from 'vue' //当然也可以导入图片（在webpack中使用asset/resource之后） import imgSrc from \"../asset/3.jpg\"; const img = document.createElement(\"img\"); img.src = imgSrc; document.body.appendChild(img); 还可以动态导入： const { origin: originPath, path } = await import(`./path${assetId}.json`); //... 不构建直接引用NPM包当 ES Module 最开始作为一种新的 JS 模块化方案被引入的候，import 语句中需要指定相对路径或绝对路径。 import dayjs from \"https://cdn.skypack.dev/dayjs@1.10.7\"; // ES modules console.log(dayjs(\"2022-08-12\").format(\"YYYY-MM-DD\")); 而我们现在所熟悉的直接引用包名实际上是通过打包工具的构建完成的 import dayjs from \"dayjs\" 而我们如何不需要通过打包工具的构建直接使用这种方式呢？ 我们可以通过 HTML 中的 &lt;script type=&quot;importmap&quot;&gt; 标签来指定一个 Import maps（我们可以把它当成一个映射表） &lt;script type=\"importmap\"> { \"imports\": { \"dayjs\": \"https://cdn.skypack.dev/dayjs@1.10.7\", } } &lt;/script> 我们将写好的importmap放在文档中第一个 &lt;script type=&quot;module&quot;&gt; 标签之前 然后可以直接写 &lt;script type=\"module\"> import dayjs from 'dayjs'; console.log(dayjs) &lt;/script> 另外，importmap 中声明的包并不一定意味着它一定会被浏览器加载。页面上的脚本没有使用到的任何模块都不会被浏览器加载，即便你在 importmap 中声明了它。 我们甚至可以写一个映射表，在里面的importmap中指定我们的映射表(不过据说性能比较差) &lt;script type=\"importmap\" src=\"importmap.json\">&lt;/script> 这项技术目前在 Chrome 和 Edge 浏览器 89 及更高版本提供了全面支持，但 Firefox、Safari 和一些移动浏览器还没有支持。我们可以通过下面的代码来判断浏览器的支持情况： if (HTMLScriptElement.supports &amp;&amp; HTMLScriptElement.supports('importmap')) { // import maps is supported } ES6引入的特点1.首先下载、查找 + 构建关系图 ES6 模块会在程序开始前先根据模块关系查找到所有模块，生成一个无环关系图，并将所有模块实例都创建好，这种方式天然地避免了循环引用的问题，当然也有模块加载缓存，重复 import 同一个模块，只会执行一次代码。 2.内存腾出空间，然后使 import 和 export 指向内存中的这些空间，这个过程也叫连接。 3.ES6和ComonJS1.ES6 模块中不存在 require, module.exports, __filename 等变量，CommonJS 中也不能使用 import。两种规范是不兼容的，一般来说平日里写的 ES6 模块代码最终都会经由 Babel, Typescript 等工具处理成 CommonJS 代码。 ES6 模块和 CommonJS 模块有很大差异，不能直接混着写（实际上好像是可以，只是会产生很多麻烦） 2.通过对模块内变量的修改（非引用值的修改），CommonJS导出的变量不变，但是ES6会改变（其实我们也可以解释为ES6 模块输出的是值的引用，CommonJS模块输出的是值的拷贝） 但是！值得注意的是导出对模块而言是只读的，在使用 * 执行批量导出时，赋值给别名的命名导出就好像使用 Object.freeze() 冻结过一样，直接修改导出的值是不可能的，但是可以修改导出的对象的属性 // counter.js,Commonjs let count = 1; function increment () { count++; } module.exports = { count, increment } // main.js const counter = require('counter.cjs'); counter.increment(); console.log(counter.count); // 1 // counter.mjs,es6 export let count = 1; export function increment () { count++; } // main.mjs import { increment, count } from './counter.mjs' increment(); console.log(count); // 2 3.CommonJS 可以在运行时使用变量进行 require 4.require 会将完整的 exports 对象引入，import 可以只 import 部分必要的内容，这也是为什么使用 Tree Shaking 时必须使用 ES6 模块 的写法。 5.模块加载方式不同 ESM和Commonjs的趋势其实有一个讨论帖，关于pureEsm 的概念： github 其实是主张仅提供esm产物的npm包，推动社区的发展。但是实质上需要面临一个问题：nodejs执行esm没问题，但是CommonJS中执行esm包是不行的，其根本原因在于 require 是同步加载的，而 ES 模块本身具有异步加载的特性，因此两者天然互斥，即我们无法 require 一个 ES 模块。 所以对于底层的库最好同时带commonjs格式和esm格式 而上层的库可以逐渐往pureEsm方向走 4.UMD原理实现一个 UMD 模块，就要考虑现有的主流 javascript 模块规范了，如 CommonJS, AMD, CMD 等。那么如何才能同时满足这几种规范呢 首先要想到，模块最终是要导出一个对象，函数，或者变量。 而不同的模块规范，关于模块导出这部分的定义是完全不一样的。 因此，我们需要一种过渡机制。 （当然你也可以理解为umd是作为一个适配CommonJS、amd、cmd的一个过渡的自动适配函数） #实现(function(root, factory) { if (typeof exports === \"object\" &amp;&amp; typeof module === \"object\") { // CommonJS规范 node 环境 判断是否支持 module.exports 支持 require 这种方法 module.exports = factory(require); } else if (typeof define === \"function\" &amp;&amp; define.md) { // AMD 如果环境中有define函数，并且define函数具备amd属性，则可以判断当前环境满足AMD规范 console.log(\"是AMD模块规范，如require.js\"); define(factory()); } else if (typeof exports === \"object\") { // 不支持 module 但是支持 exports 的情况下使用 exports导出 是CommonJS 规范 exports[\"jiang-hooks\"] = factory(); } else { // 直接挂载在全局对象上 root.umdModule = factory(); } })(this, function() { return { name: \"Umd模块\", }; }); 参考链接 https://juejin.cn/post/6844904080955932680#heading-3 https://mp.weixin.qq.com/s/jyWJX_g-txIm0LIxPAuTDw","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React(上)","slug":"React(上)","date":"2022-05-03T07:31:07.769Z","updated":"2023-04-17T09:30:32.783Z","comments":true,"path":"2022/05/03/react-shang/","link":"","permalink":"https://taylor12138.github.io/2022/05/03/react-shang/","excerpt":"","text":"1.React简介react由Facebook开发 &amp; 开源的一个用于构建用户界面、将数据渲染为html视图的开源JavaScript库 react相对于原生js的优点： 采用组件化模式，声明式编码，提高组件复用率 React Native中可以使用React 语法进行移动端开发 使用了虚拟DOM和diff算法，减少和真实DOM的交互 下载react的文件（当前阐述的是16.8版本） babel.js不仅适用于es6 -&gt; es5 语法的转换，还适用于 jsx -&gt; js 的转换 react.development.js 为react的核心库 react-dom-development为react的拓展库，可用于操作dom等 引入顺序 &lt;div id=\"container\">&lt;/div> &lt;script src=\"./js/react.development.js\">&lt;/script> &lt;script src=\"./js/react-dom.development.js\">&lt;/script> &lt;script src=\"./js/babel.min.js\">&lt;/script> &lt;!-- 告诉浏览器你写不是默认的js，而是jsx --> &lt;script type=\"text/babel\"> // 创建虚拟dom const VDOM = &lt;h1>hello react!&lt;/h1> // 渲染到页面 ReactDOM.render(VDOM, document.querySelector('#container')) &lt;/script> JSX的使用直接使用原生js也能创建虚拟dom // document.createElement为创建真实dom，以下是创建虚拟dom // 不使用jsx创建虚拟dom，React.createElement(标签名, 标签属性, 标签内容) const VDOM = React.createElement('h1', { id: 'title', className: 'title' }, 'hello, world'); // 渲染到页面 ReactDOM.render(VDOM, document.querySelector('#container')) 使用jsx的原因是jsx对于多重嵌套的标签比较容易撰写，而原生js比较难顶 const VDOM = React.createElement('h1', { id: 'title' }, React.createElement('h2', {}, 'hahaha')); 然而使用jsx const VDOM = ( &lt;h1 id=\"title\"> &lt;span>hello, react&lt;/span> &lt;/h1> ) 综上，还是乖乖使用jsx比较吃香 JSX语法1.定义虚拟DOM时，不要写引号 2.在大括号中可以填入js的表达式，但不代表所有js语句、js代码 表达式：一个表达式会产生一个值，可以放在任意一个需要值的地方，简单来说，就是能用变量 const x = 表达式接收的，均为表达式 不可以填入if、for等js语句（但是我们可以使用数组的map、三元表达式等语法来填补） 3.样式指定类名时不要用class，而是使用className 4.内联表达式时，style要注意键值的形式去写，这里使用双括号并不是类似于vue的八字胡语法，而是一个大括号填入js表达式，一个大括号表示这是一个对象 const inner = 'hello, react' const VDOM = ( &lt;h1 className=\"title\"> &lt;span style={{ color: 'white', backgroundColor: 'red' }}>{inner}&lt;/span> &lt;/h1> ) // 渲染到页面 ReactDOM.render(VDOM, document.querySelector('#container')) 5.只能有一个根标签，有点类似vue的template模板 6.标签必须闭合，即使遇到像input这种实质上再html中单标签就可以的，也必须进行双标签闭合 const VDOM = ( &lt;div> &lt;input type=\"text\" /> &lt;/div> ) 7.标签首字母若是小写，则转换为html同名标签元素，若html无该标签对应的，则报错同名元素；若大写字母开头，react则取渲染对应的组件，若没定义该组件，则报错（这里和vue不同，vue也是直接小写，遇到驼峰则用 - 连接） 8.jsx写注释的时候，要 {/*&lt;input type=&quot;text&quot; /&gt;*/}这样写 2.React的组件化函数式组件即用函数定义的组件 它适用于简单的组件定义 &lt;div id=\"container\">&lt;/div> &lt;script src=\"./js/react.development.js\">&lt;/script> &lt;script src=\"./js/react-dom.development.js\">&lt;/script> &lt;script src=\"./js/babel.min.js\">&lt;/script> &lt;!-- 告诉浏览器你写不是默认的js，而是jsx --> &lt;script type=\"text/babel\"> function MyComponent() { return &lt;h2>函数定义的组件&lt;/h2> } // 记住jsx里标签必须闭合 ReactDOM.render(&lt;MyComponent />, document.querySelector('#container')); &lt;/script> 而此时在函数内部打印this，得到的结果为undefined function MyComponent() { console.log(this) //undefined return &lt;h2>函数定义的组件&lt;/h2> } 那是因为babel编译后开启了严格模式，使得指向window都改成指向undefined 此时内部： React解析组件标签 -&gt; 找到组件 -&gt; 调用函数 -&gt; 虚拟DOM转为真实DOM，随后呈现在页面中 类式组件用类定义的组件 它适用于复杂的组件定义 class MyComponent extends React.Component { render() { return &lt;h2>hello React&lt;/h2> } } //这里的的render和上方类定义的render没有关系，只是同名罢了 ReactDOM.render(&lt;MyComponent />, document.querySelector('#container')) 创建类式组件必须1.继承react定义的内置类2.必须写render3.render必须有返回值 而此时在render打印this，得到的结果为MyComponent实例对象（React内部帮你new了一个） class MyComponent extends React.Component { render() { console.log(this) return &lt;h2>hello React&lt;/h2> } } 此时内部： React解析组件标签 -&gt; 找到组件 -&gt; new出实例，调用原型上render方法 -&gt; 将render返回的虚拟DOM转为真实DOM，随后呈现在页面中 看到其他文章中的组件对象，其实基本上可以默认他们是用类式组件定义的。 （1）组件三大核心属性之state实际上隶属于类式组件，毕竟有实例对象，才有对应的属性 state（状态） 有点像vue的data / vuex的state，存储数据，在组件化的使用过程中，我们时常把数据存储在组件们共同的父组件的state里（官方称之为状态提升） class MyComponent extends React.Component { constructor(props) { super(props); this.state = { isHot: true } } render() { return &lt;h2>today is {this.state.isHot ? 'hot' : 'cold'}&lt;/h2> } } 不过一般都是这样写的 class MyComponent extends React.Component { state = { isHot: true } //... } setState (状态更新) 然而在React中，修改完状态，不能和Vue一样直接做到响应式，需要我们去使用setState！！从而改动页面上呈现的数据效果 这里的setState是一个合并的动作，如果其他state属性没有发生改变，并不会发生丢失 setState要求传入一个对象 class MyComponent extends React.Component { constructor(props) { super(props); this.state = { isHot: true } this.changeWeathter = this.changeWeathter.bind(this); } render() { return &lt;h2 onClick={this.changeWeathter}>today is {this.state.isHot ? 'hot' : 'cold'}&lt;/h2> } changeWeathter() { const isHot = !this.state.isHot; //实际上也是因为setState这个方法，才能让state称为核心属性之一，泪目。。 this.setState({ isHot: isHot }) } } ReactDOM.render(&lt;MyComponent />, document.querySelector('#container')) 从这里我们可以看出，每次setState，render都会调用一次对页面进行渲染（有点控制页面回流重绘的感觉，所以绝对不能再render里进行setState），总共调用 1 + n次，而construtor只会在初始化的时候调用一次 （2）组件三大核心属性之props类式组件propsprops用于组件间数据传递 父传子，和vue的props类似，都是在组件标签上赋值传递；父组件传入的props如果是state，发生了setState，重新render()一次，传入的props也会随之更新 注意：props属性是只读的，不可以修改 class MyComponent extends React.Component { render() { return ( &lt;ul> &lt;li>性名：{this.props.name}&lt;/li> &lt;li>性别：{this.props.sex}&lt;/li> &lt;li>年龄：{this.props.age}&lt;/li> &lt;/ul> ) } } //age={18}才能传入number类型 ReactDOM.render(&lt;MyComponent name=\"Allen\" age={18} sex=\"男\" />, document.querySelector('#container')); 在js语法中，使用 let person1 = {...person2}展开对象中的属性 但是通过React内置 + babel语法加成，可以直接 ...person2进行展开，但是仅仅适用于标签属性的传递，也就是通过props传递 虽然你可以在这里看到一个大括号，但是这只是表明要在jsx中插入js表达式的含义 const p = {name=\"Allen\",age=\"18\",sex=\"男\"} ReactDOM.render(&lt;MyComponent {...p} />, document.querySelector('#container')); 接着子组件通过 this.props.xx进行使用 PropTypes当需要对传入的props进行数据类型、数据默认值等进行限制时，需要引入另一个包 （像 Flow 和 TypeScript 等这些静态类型检查器，可以在运行前识别某些类型的问题。他们还可以通过增加自动补全等功能来改善开发者的工作流程。出于这个原因，我们建议在大型代码库中使用 Flow 或 TypeScript 来代替 PropTypes。） （对于Vue，可以直接让子组件在props属性里定义props传入的数据格式即可） &lt;!-- 引入prop-types包 --> &lt;script src=\"./js/prop-types.js\">&lt;/script> 如果是搭建脚手架，React默认没有帮你下载这个限制包，需要自己下载 npm i prop-types import PropType from 'prop-types' // 对标签属性进行类型、必要性(required)的限制 // 记住上面的时小写props，下面的是大写Props MyComponent.propTypes = { name: PropTypes.string.isRequired, //限制name顺序性必须传入，且为string age: PropTypes.number, //限制age为number } // 默认标签属性值 MyComponent.defaultProps = { sex: '男', //不传入时，sex默认值为'男' age: 18 //不传入时，age默认值为18 } ReactDOM.render(&lt;MyComponent name=\"Allen\" age={18} sex=\"男\" />, document.querySelector('#container')); 如果传入的是函数 MyComponent.propTypes = { speak: PropTypes.func //限制speak为函数 } ReactDOM.render(&lt;MyComponent name=\"Allen\" age={18} sex=\"男\" speak={fn}/>, document.querySelector('#container')); function fn(){} 不过在最好还是都写在React类的内部，但是要添加到类上，而不是类的实例的话，不能直接写表达式，要添加一个static class MyComponent extends React.Component { static propTypes = { name: PropTypes.string.isRequired, age: PropTypes.number, speak: PropTypes.func } // 默认标签属性值 static defaultProps = { sex: '男', age: 18 } render() { //... } } propTypes类型一览 import PropTypes from 'prop-types'; MyComponent.propTypes = { optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 任何可被渲染的元素（包括数字、字符串、元素或数组） // (或 Fragment) 也包含这些类型。 optionalNode: PropTypes.node, // 可以指定一个对象由某一类型的值组成 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 任意类型的必需数据 requiredAny: PropTypes.any.isRequired, } 函数式组件的props上面说道属性都是隶属于类式组件，毕竟有实例对象才有属性，但是props比较特殊，函数组件也可以有，因为函数组件可以传参，即在传参部分使用props进行接收。 （实际上除非使用最新版本的hooks，不然函数式组件不能使用到state 和 refs） function MyComponent(props) { const { name, sex, age } = props; return ( &lt;ul> &lt;li>性名：{name}&lt;/li> &lt;li>性别：{sex}&lt;/li> &lt;li>年龄：{age}&lt;/li> &lt;/ul> ) MyComponent.propTypes = { name: PropTypes.string.isRequired, age: PropTypes.number, speak: PropTypes.func } // 默认标签属性值 MyComponent.defaultProps = { sex: '男', age: 18 } } ReactDOM.render(&lt;MyComponent name=\"Allen\" />, document.querySelector('#container')); （3）组件三大核心属性之refs官网提示：请勿过度使用refs，可以通过事件对象event解决（发生事件元素 = 操作的元素），则用event解决 老版字符串ref同样的，refs也类似于vue的refs（只不过vue属性都会加上 $），适用于父组件操作子组件时对子组件的获取，也用于父组件获取子组件数据 class Demo extends React.Component { showData = () => { alert(this.refs.input1.value); } showData2 = () => { alert(this.refs.input2.value); } render() { return ( &lt;div> &lt;input ref=\"input1\" type=\"text\" placeholder=\"点击按钮提示数据\" /> &lt;button onClick={this.showData}>click me&lt;/button> &lt;input onBlur={this.showData2} ref=\"input2\" type=\"text\" placeholder=\"失去焦点提示数据\" /> &lt;/div> ) } } ReactDOM.render(&lt;Demo />, document.querySelector('#container')); 以上我使用的是字符串类型的ref（同Vue），但它目前已经不被官方所推荐使用了，甚至有可能废弃掉，以下是官网解释（可能带效率问题）。 过时 API：String 类型的 Refs 如果你之前使用过 React，你可能了解过之前的 API 中的 string 类型的 ref 属性，例如 &quot;textInput&quot;。你可以通过 this.refs.textInput 来访问 DOM 节点。我们不建议使用它，因为 string 类型的 refs 存在 一些问题。它已过时并可能会在未来的版本被移除。 回调式refs它的回调函数接受 React 组件实例或 HTML DOM 元素作为参数 以 ref = () =&gt; {}形式进行传递 以下代码是对上方字符串形式ref的改进 class Demo extends React.Component { showData = () => { alert(this.input1.value); } showData2 = () => { alert(this.input2.value); } render() { return ( &lt;div> &lt;input ref={currentNode => { this.input1 = currentNode }} type=\"text\" placeholder=\"点击按钮提示数据\" /> &lt;button onClick={this.showData}>click me&lt;/button> &lt;input onBlur={this.showData2} ref={currentNode => { this.input2 = currentNode }} type=\"text\" placeholder=\"失去焦点提示数据\" /> &lt;/div> ) } } ReactDOM.render(&lt;Demo />, document.querySelector('#container')); 官网还有个提示：关于回调 refs 的说明 如果 ref 回调函数是以内联函数的方式定义（也就是把函数直接定义在标签内）的，在更新过程（render调用第二、三次的时候，每次setState，render也都会被调用一次）中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 避免方式也就是在类组件里写一个回调函数，而不是以内联的形式（但是我觉得为了定义一个id，写一个函数，太麻烦了吧0.0） createRef目前React最新版本的ref使用方法就是用 React.createRef方式 React.createRef调用后会创建一个容器，该容器可以存储被ref所标识的节点（保存在current属性里） 如果你想获取多个节点，就要创建多个React.createRef()，因为它是专有的 class Demo extends React.Component { //但是注意，该容器是专人专用的！如果再次在这个容器存储的话，会覆盖掉原来用ref标识的节点 //所以一个容器存一个节点 myRef = React.createRef(); clickEvent = () => { //节点保存在容器里的current中 alert(this.myRef.current.value) } render() { return ( &lt;div> &lt;input type=\"text\" ref={this.myRef} /> &lt;button onClick={this.clickEvent}>click me&lt;/button> &lt;/div> ) } } refs的使用 在Hook中使用useEffect时，如果你想得到“最新”的值，你可以使用ref other：废物构造器（我们在开发的时候，能省就省，几乎不写构造器的原因） 在使用类式组件时，使用其构造器，则会默认传入props，并且需要你使用super(props) 如果直接不传props，直接 super()，React官网已经明示你了，会： 在 React 组件挂载之前，会调用它的构造函数。在为 React.Component 子类实现构造函数时，应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug！！ 在React类式组件里，构造器的作用： 通过给 this.state 赋值对象来初始化内部 state。（可以直接在类中使用表达式替代） 为事件处理函数绑定实例 （可以直接在类中使用表达式 + 箭头函数替代） 实际上也就是之前我们的繁琐两步走，没什么必要。。。so weak constructor(props) { super(props); this.state = { isHot: true } this.changeWeathter = this.changeWeathter.bind(this); } 3.React事件监听React事件监听（前传）原生js onclick -&gt; React onClick (vue的是 v-on:click=&quot;&quot; 或者@click=&quot;&quot;) 原生js onblur -&gt; React onBlur (vue的是 v-on:blur=&quot;&quot; 或者@blur=&quot;&quot;) 原生js onkeyup -&gt; React onKeyUp (vue的是 v-on:keyup=&quot;&quot; 或者@keyup=&quot;&quot;) 普通函数的调用（注意不要加括号！） class MyComponent extends React.Component { render() { return &lt;h2 onClick={fn}>hello React&lt;/h2> } } ReactDOM.render(&lt;MyComponent />, document.querySelector('#container')) function fn(){ console.log('today is a good day'); } React除了把大小写换了之外，实质上它内部重新自定义了方法，拥有更好的兼容性 除此之外，React的事件，是通过事件委托的方式处理的（委托给组件最外层元素，即将事件都加给了jsx里在外层的div） 和原生js一样，React对事件监听时，会传入事件对象event，可以通过以下形式得到事件对象，避免使用了refs clickEvent = (e) => { alert(e.target.value) } render() { return ( &lt;div> &lt;input type=\"text\" onBlur={this.clickEvent} /> &lt;/div> ) } react中this指向要注意的是： 以下代码中render输出this的是MyComponent组件实例 fn输出的this是undefined constructor的this指向的也是MyComponent组件实例 因为在使用类式组件时，是new出组件对象实例，然后都通过该实例调用render方法，所以在render中this指向的是组件对象实例 而constructor构造函数中的this一定是指向当前对象的实例 而这里的fn方法，是在全局下调用的，没有在render下完成调用，this应该是指向window，但是在类内部自动帮你开启了局部严格模式，所以this指向了undefined （我个人在es5笔记中总结的在类中的this指向的是其实例对象，实质上是因为我们调用函数时，是通过实例对象来调用的，比如p1.render()，此时this当然指向的是实例对象，而这里的 函数方法类似于发生了 const x = p1.fn; x();的操作） class MyComponent extends React.Component { constructor(props){ super(props); } render() { console.log(this); //实例对象 return &lt;h2 onClick={this.fn}>hello React&lt;/h2> } fn(){ console.log(this); //undefined } } ReactDOM.render(&lt;MyComponent />, document.querySelector('#container')) 解决方法一：在constructor使用bind（即创造新的函数 const f = fn.bind(xx)，拷贝，无调用） constructor(props){ super(props); this.fn = this.fn.bind(this); } 解决方法二： 简化方案 在实际开发中，不会使用到如上比较麻烦的写法，而是利用类中直接写赋值语句的操作，往实例自身默认追加一个属性 此时函数成为了实例的自定义方法，且this的指向能毫不动摇指向实例 class MyComponent extends React.Component { state = { isHot: true } render() { return &lt;h2 onClick={this.changeWeathter}>today is {this.state.isHot ? 'hot' : 'cold'}&lt;/h2> } //箭头函数this指向函数定义上下文的this //要写成 changeWeathter = function(){}的形式才能改为箭头函数，没有changeWeathter()=>{}的写法，所以只能： changeWeathter = () =>{} changeWeathter = () => { const isHot = !this.state.isHot; this.setState({ isHot: isHot }) } } 非受控组件 &amp; 受控组件非受控组件 外部无法影响到组件内部 说由输入类的DOM，比如 input，如果是现用现取，则为非受控组件，比如下方就是一个非受控组件 class Login extends React.Component { handle = (e) => { e.preventDefault(); const { userName, password } = this; alert(`用户名：${userName.value}, 密码：${password.value}`) } render() { return ( &lt;div> &lt;form action=\"https://www.baidu.com\" onSubmit={this.handle}> 用户名&lt;input type=\"text\" ref={node => this.userName = node} name=\"username\" /> 密码&lt;input type=\"password\" ref={node => this.password = node} name=\"password\" /> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) } } 受控组件（建议） 也可以说是利用触发本身事件，不需要使用到ref，然后保存于state 这个案例实际上可以理解为Vue的 v-model语法糖，只不过这里需要我们自己写 class Login extends React.Component { state = { userName: null, passWord: null } changeName = (e) => { this.setState({ userName: e.target.value }) } changePsw = (e) => { this.setState({ passWord: e.target.value }) } handle = (e) => { e.preventDefault(); const { userName, passWord } = this.state; alert(`用户名：${userName}, 密码：${passWord}`) } render() { return ( &lt;div> &lt;form action=\"https://www.baidu.com\" onSubmit={this.handle}> {/* onChange事件和DOM的onchange不一样，这里只要表单的value发生改变，就会回调事件*/} 用户名&lt;input type=\"text\" onChange={this.changeName} name=\"username\" /> 密码&lt;input type=\"password\" onChange={this.changePsw} name=\"password\" /> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) } } React函数传参在Vue中，如果该方法不需要传递参数，则方法后面的()可以不用添加， 如果需要传入参数，则使用 函数名(参数)的形式 但是在React中，如果使用 函数名()的形式，比如在标签里 &lt;h2 onClick={this.fn()}&gt;hello React&lt;/h2&gt;，则在触发事件时，并不会回调函数，而是在网页渲染的时候调用一次，此时传入的回调函数是fn里的返回值，若没写入返回值，则传入的是undefined 所以我们需要用一个巧妙的方法，方便我们传入参数，即在事件回调函数里，返回一个回调函数！！（即使用函数柯里化的方式） 方法一：柯里化方式 以下是对上方chang事件的优化，实现用户名 和 密码都可以使用同一个函数 cChange = (dataType) => { return (event) => { this.setState({ // 作为键名时，如果是变量名直接写，就必须加[] [dataType]: event.target.value }) } } 然而，除此之外，还有其他不用柯里化的方式也能实现React函数传参 方法二：内联的箭头函数我个人认为实质上和柯里化的意思差不多，只是在内联部分实现罢了 cChange = (dataType, event) => { this.setState({ // 作为键名时，如果是变量名直接写，就必须加[] [dataType]: event.target.value }) } render() { return ( &lt;div> &lt;form action=\"https://www.baidu.com\" onSubmit={this.handle}> 用户名&lt;input type=\"text\" onChange={event => this.cChange('userName', event)} name=\"username\" /> 密码&lt;input type=\"password\" onChange={event => this.cChange('passWord', event)} name=\"password\" /> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) } React生命周期函数生命周期函数可以不用箭头函数，因为它们和render属于同一性质，在创建页面/销毁页面的时候通过类的实例调用一次 1.挂载组件mount 卸载组件unmount componentDidMount（和Vue的mounted一样，只调用一次，即挂载组件的时候调用一次，类似于render的兄弟，只不过setState不能在 render里进行调用，然而setState可以在 mountd里面调用 ） 使用方式： componentWillMount(){}调用：组件即将挂载时 componentDidMount(){}调用：组件挂载完毕（常用） componentWillUnmount() {}调用：组件被卸载前执行，有点像vue里的beforeDestory（常用，一般用于解决一些内存泄漏的问题） 卸载节点(组件)的方式 ReactDOM.unmountComponentAtNode(节点) 2.render：初始化渲染或者状态更新之后（常用） 有点类似Vue的updated，因为Vue官方解释对于updated也是避免在里面操作DOM，可能会引起死循环，而在render里调用setState，也会引起死循环！ 以下为生命周期函数小案例 class Life extends React.Component { state = { opacity: 1 } wind = () => { // 卸载节点 ReactDOM.unmountComponentAtNode(document.querySelector('#container')) } componentDidMount() { if (this.timer) this.timer = null; this.timer = setInterval(() => { console.log('gg'); let { opacity } = this.state; opacity -= 0.1; if (opacity &lt;= 0) opacity = 1; this.setState({ opacity }) }, 200) } componentWillUnmount() { //在卸载节点之前，清除定时器，防止报错 + 内存泄露 clearInterval(this.timer); } render() { return ( &lt;div> &lt;h1 style={{ opacity: this.state.opacity }}>刮风之前&lt;/h1> &lt;button onClick={this.wind}>刮风之后&lt;/button> &lt;/div> ) } } ReactDOM.render(&lt;Life />, document.querySelector('#container')) 旧版React生命周期图 我们可以看到（由ReactDOM.render()触发）初始化阶段： constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount 更新阶段，有 setState、 forceUpdate、 父组件重新render 三条时间线 发生了setState -&gt; shouldComponentUpdate（是否应该重新更新页面），如果返回false，阀门关闭，则停住；如果返回true，则进行下一步（这个生命周期钩子默认返回true） -&gt; componentWillUpdate-&gt; render发生更新 -&gt; componentDidUpdate 第二条线，发生了 forceUpdate() -&gt; componentWillUpdate-&gt; render发生更新 -&gt; componentDidUpdate 第三条，是当其父组件发生了render时，跳转到 -&gt; componentWillReceiveProps(组件将要接收参数) -&gt; shouldComponentUpdate -&gt; componentWillUpdate-&gt; render发生更新 -&gt; componentDidUpdate 但实质上 componentWillReceiveProps 有个坑，就是第一次传入时不算，不会调用这个生命周期函数；然后再第二、三次时，让父组件发生render，子组件就会调用这个生命周期函数 由此我们得到一些其他的生命周期函数 3.shouldComponentUpdate(){} 控制组件是否更新的阀门时钩子 4.componentWillUpdate(){} 组件将要发生更新时钩子 5.componentDidUpdate(){}组件更新完毕时钩子，它可以接收两个参数，第一个参数preProps是先前接收的props值，第二个preState是更新前的state值 6.componentWillReceiveProps(){}父组件 render 再次传入新的props调用 补充： forceUpdate()是强制更新的方法、有时并不想使用setState()，只是单纯想让页面发生更新，可以使用这个函数 新生命周期图 改动一： 在新版本（17.0以上）使用旧的生命周期函数 比如使用 componentWillMount 、 componentWillUpdate、 componentWillReceiveProps 就会出现黄色警告（虽然上图没出现他们三个，但是可以使用）（简称 3 Will组合，但是 componentWillUnMount() 没事 ） 它提示你新版本已经开始使用 UNSAFE_componentWillMount、 UNSAFE_componentWillUpdate，并且提示你可能在18.0版本以后就不能使用旧版本的以上的生命周期函数了 然而为什么这三个生命周期要发生改动？React官方解释道： 这些生命周期方法经常被误解和滥用（不常用，可能导致编程人员用错地方）；此外，我们预计，在异步渲染中，它们潜在的误用问题可能更大。我们将在即将发布的版本中为这些生命周期添加 “UNSAFE_” 前缀。（这里的 “unsafe” 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染之后。） 我个人认为则是fiber分片调度的存在，使得第一阶段相关的这些生命周期函数内的代码可能被多次执行，非常unstable！ 改动二： 出现新的钩子： 1.getDerivedStateFromProps，它横跨初始化 &amp; 更新部分（这部分英文意思可以理解为：从Props得到派生的状态） 它作为一个静态方法（static），应该挂载到类上，而不是挂载到实例上 它必须返回一个状态对象，不然会报错（不然也得返回一个null） 它可以接受两个参数，即接收props、state，此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props（比如state的 某 key : value 取决于 props 传入的 key : value） static getDerivedStateFromProps(props, state){ } 但是：！！！派生状态会导致代码冗余，并使组件难以维护，所以了解即可 2.getSnapshotBeforeUpdate，它钩在React更新DOM 和 refs之前 （这部分英文意思可以理解为：在更新之前，获取快照）（大家回家之前，集体拍个照 * .* ） 它必须返回一个快照值，不然会报错（不然也得返回一个null） 快照值可以是任意类型 之前讲述到componentDidUpdate(){}生命周期函数，实质上它可以接收第三个参数，也就是 snapshotValue，而snapshotValue就是 getSnapshotBeforeUpdate钩子函数返回的值 componentDidUpdate(preProps, preState, snapshotValue){ //xxxx } 虽然这两个新的钩子名字巨长，很恶心，但是官方也阐述了这两个钩子的使用场景极其罕见 总结： 初始化阶段： constructor -&gt; getDerivedStateFromProps -&gt; render -&gt; componentDidMount 更新阶段，同样也有有 setState、 forceUpdate、 父组件重新render 三条时间线，如上图所示 4.React脚手架使用脚手架开发项目的特点：模块化，组件化，工程化 项目整体技术架构为：react + webpack + es6 + eslint 当然创建react脚手架必须在本地主机上安装react的专用脚手架库 npm i -g create-react-app 切换到我们想要的目录下进行初始化 create-react-app 项目名称 启动项目（默认情况下） npm start 打包项目（默认情况下） npm build 启动项目（默认情况下） React脚手架中通用路径写法： %PUBLIC_URL%/favicon.ico ：public目录下的favicon图标 在index.html中可以看到 &lt;!-- 开启理想窗口、做移动端适配 --> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> &lt;!-- 用于配置浏览器页签 + 地址栏的颜色（仅支持安卓手机） --> &lt;meta name=\"theme-color\" content=\"#000000\" /> &lt;!-- 用于适配苹果系统的图标 --> &lt;link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" /> &lt;!-- 在html上套上安卓 / ios的 apk壳 --> &lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" /> 在src文件夹下 于index.js我们可以看到 import React from 'react' import ReactDOM from 'react-dom' import App from './App' ReactDOM.render( &lt;React.StrictMode> &lt;App /> &lt;/React.StrictMode>, document.getElementById('root') ); 其实也就是平时我们渲染的部分，只是 使用了 &lt;React.StrictMode&gt;，它会自动检查插入组件的撰写是否合理，检查代码合理性 而reportWebVitals.js 和 setupTests.js 分别用于页面性能分析 和 组件单元测试 tip： 在脚手架里，引入文件时，如果文件名是index.js、index.jsx，则引到该文件所处文件夹即可 在脚手架里，引入文件时，如果文件是js / jsx，可以不写后缀名 jsx模板生成的快捷键（类式组件）： rcc jsx模板生成的快捷键（函数式组件）： rfc 脚手架中CSS模块化正常在jsx文件里引入css： import &#39;./index.css&#39; 实现css模块化：方法一 1.index.css -&gt; index.module.css 2.引入样式：import xx from &#39;./index.module.css&#39; 3.使用样式 :&lt;h2 className={xx.title}&gt; Hello, React &lt;/h2&gt; 但是注意：如果在css模块中只是单纯使用标签选择器，则无法模块化，有全局影响性 ul li {} 推荐加上 .home ul li {} 在css module中仍要让样式全局化 :global(.home){} 方法二：使用less进行嵌套 （React中less使用教程 https://www.cnblogs.com/liangziaha/p/13632623.html ） 亦或者使用vscode自带的less转化css （还是Vue的scope舒服呀） 方法三：使用sass npm i sass $width:300px ul { .item{ width:$width } } import style from './child.module.scss' &lt;li className={style.item}>&lt;/li> react中设置全局路径npm run eject 暴露出webpack的配置文件webpack.config.js resolve: { //... alias: { //... // 路径引用 @ '@': path.resolve(__dirname, '../src') } } react脚手架prettier和eslintcreate react app自带eslint，我们需要安装prettier npm i prettier -D 然后我们需要让eslint和prettier兼容 npm install eslint-config-prettier eslint-plugin-prettier --save-dev 在根目录下新建文件 .eslintrc.json { \"extends\": [\"react-app\", \"plugin:prettier/recommended\"] } 5.React开发中应用组件数据传递（子传父）利用的是回调函数闭包的特性，和Vue的子组件传递给父组件的 $emit() 有异曲同工之妙 父组件：设置函数，并在子组件上使用props传递该函数 export default class App extends Component { addTodo = (name) => { console.log(name); //得到子组件的数据 } render() { return ( &lt;div> &lt;Header addTodo={this.addTodo}>&lt;/Header> &lt;/div> ) } } 子组件，使用props接收传入的回调函数，并且将数据作为参数进行调用 export default class Header extends Component { addTodo = (e) => { if (e.keyCode !== 13) return; this.props.addTodo(e.target.value); //进行回调 } render() { return ( &lt;div className=\"todo-header\"> &lt;input type=\"text\" onKeyUp={this.addTodo} placeholder=\"请输入你的任务名称，按回车确认\" /> &lt;/div> ) } } id生成库在标识数据唯一性我们需要用到id，当使用random、date.now()生成id都有一定弊端，可以借用uuid，一个id库帮助我们生成id npm i uuid 开发小项目，我更加推荐的是nanoid npm i nanoid nanoid是一个函数，每次调用都会帮你生成一个字符串，保证全球唯一 import {nanoid} from 'nanoid' const str = nanoid(); React内部配置代理跨域(反向代理) 在src目录下新建一个setupProxy.js文件 在此文件中必须使用cjs的方式撰写（CommonJS），因为这个文件是要加到webpack配置里面的，而webpack用的是node语法 npm i http-proxy-middleware 实际上 http-proxy-middleware 也是开了一个exporess服务器，帮你做反向代理 proxy内部选项介绍： 第一个参数设置前缀名，比如设置了前缀名为/api1，也就是以/api开头， 遇到这个前缀的请求就会触发该代理配置，比如猫眼电影的请求示例 原本请求地址 ：https://i.maoyan.com/ajax/comingList?ci=91&amp;limit=10…. -&gt; 此时我们需要改成 /ajax/comingList?ci=91&amp;limit=10….，就会触发代理 axios.get('/ajax/mostExpected?limit=10&amp;offset=0&amp;token=&amp;optimus.........').then((res) => { //自动找本地域名 + /ajax console.log(res) }) 第二个参数是配置 target：我们发送的目标跨域url changOrigin：默认值为false，控制服务器收到请求头中Host（请求资源所在服务器，也就是发送源）字段的值；当changOrigin: true 时，能欺骗服务器，让服务器以为是同源请求，而不知道你的真实host发送源。（实际上不加其实也没关系，但是防止服务器的限制，比较好一点） pathRewrite：重写请求路径，一定要加上，不加上虽然有走代理，请求路径加上了 /api1，不存在该资源，一般会报404 const proxy = require('http-proxy-middleware') ///使用proxy中间件 module.exports = function (app) { //中间件既视感 app.use( proxy('/ajax', { target: 'https://i.maoyan.com', //目标请求地址 changOrigin: true, }), proxy('/api1', { target: 'http://localhost:5000', changOrigin: true, pathRewrite: { '^/api1': '' } //自动帮我们把api1给去掉 }), proxy('/api2', { target: 'http://localhost:5001', changOrigin: true, pathRewrite: { '^/api2': '' } }) ) } 消息订阅与发布机制工具库 ： PubSubJS 可以在github上下载，也可以直接npm npm i pubsub-js --s 引入后（import PubSub from &#39;pubsub-js&#39; / const PubSub = require(&#39;pubsub-js&#39;);） 官网使用的案例 //回调函数 var mySubscriber = function (msg, data) { //在调用时会传入两个参数，第一个msg就是消息名，第二个data就是交互的数据 }; //订阅消息 var token = PubSub.subscribe('MY TOPIC', mySubscriber); //第一个参数消息名 //第二个参数是收到消息后的回调函数，即如果有人发布了该消息名则进行回调 //发布消息 PubSub.publish('MY TOPIC', 'hello world!'); //第一个参数消息名 //第二个参数是传送的数据 //token接收到订阅的返回值，后续可以使用下列方式取消订阅，防止内存泄漏 PubSub.unsubscribe(token); 利用这个订阅发布机制，我们可以实现兄弟组件的通信！（有点像Vue的eventBus） 小栗子： // 订阅消息名为SearchGitHhub的消息 componentDidMount() { this.token = PubSub.subscribe('SearchGitHhub', (msg, stateObj) => { this.setState(stateObj) }); } componentWillUnmount() { // 临走前取消订阅 PubSub.unsubscribe(this.token); } // 发布消息名为SearchGitHhub的数据 PubSub.publish('SearchGitHhub', { isFirst: false, isLoading: true });","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript面向对象","slug":"JavaScript面向对象","date":"2022-04-24T06:49:07.011Z","updated":"2022-09-19T11:11:14.289Z","comments":true,"path":"2022/04/24/javascript-mian-xiang-dui-xiang/","link":"","permalink":"https://taylor12138.github.io/2022/04/24/javascript-mian-xiang-dui-xiang/","excerpt":"","text":"1.编程思想介绍面向过程（POP）：分析解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一步一步调用就行了 面向对象（OOP）：把事物分解成一个个对象，然后由对象之间分工合作（找出对象出来，然后写出这些对象的功能） 面向过程的性能比较高，适合和硬件联系很紧密的东西，如单片机，缺点是难维护、难拓展、难复用 面向对象的代码灵活，代码可复用性高，容易维护和开发，更适合多人合作的大型软件项目 面向对象：封装性（直接使用，不需要了解内部）、继承性、多态性（通过继承 + 不同的拓展） JS的类JavaScript只有一些近似类的语法元素，比如class关键字 但是这并不意味着JavaScript实际上有类，但是类是一种设计模式，所以我们可以用一些方法实现近似类的功能 2.面向对象1.抽取对象公共属性和行为组织封装成一个类（class） class name { class body } 2.对象实例化，获取类的对象（对象是特指某一个，实例化的具体对象） var xx = new name() 利用类创建对象 对象由属性和方法构成 tip： （1）class关键字创建类，类名习惯定义首字母大写 （2）constructor()是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有明显定义，类内部会自动给我们创建一个constructor()（最好自己写上constructor） class Star { constructor(uname, age) { this.name = uname; this.age = age; } } var xxx = new Star('xxx', 20); 假如一个函数进行多次 bind呢？ let a = {} let fn = function () { console.log(this) } fn.bind().bind(a)() // => ? 类里添加方法1.在类里面构造函数，不需要加function 2.多个方法、函数之间不需要添加逗号进行分割 class Star { constructor(uname) { this.name = uname; } init() { //xxxx } } 类里添加实例对象的默认属性在React，我还学到了往类里添加默认属性的骚操作，直接写入赋值语句 写入赋值语句后，实际上就是往实例自身追加一个属性，属性名为a，值为1，适用于一个不需要根据传参改变的写死的值 class Star { a = 1; } 类的继承使用extends进行继承 注意：JavaScript本身不提供“多重继承”功能，毕竟有诸多类似钻石问题的复杂情况，但开发者们还是通过其他方法实现多重继承，比如混入 super关键字用于访问和调用对象父类上的函数，可以调用父类的构造函数，也可以调用父类的普通函数 在constructor中，super必须在子类this的之前进行调用，即必须先调用父类的构造函数，再使用子类的构造函数 super只能在派生类（子类）的构造函数和静态方法中使用 不过要注意的是：（错误示范❌） class Father { constructor(x, y){ this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } class Son extends Father { constructor(x, y) { this.x = x; //会报错 this.y = y; //会报错 } } var son = new Son(1, 2); son.sum(); //会报错 以上有两个错误： 类里面的语法中，只要符合类继承 + 子类有个构造函数(constructor)则一定要调用super，否则也会报错 如果只需要继承到x、y的属性，自身不需要新的属性（类似于下方的id属性），则甚至可以不用写构造函数 此时参数传递给子类的constructor的x和y，而父类的sum函数用的是父类的constructor的x和y class Father { constructor(x, y){ this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } class Son extends Father { constructor(x, y, id) { //调用父类的构造函数 super(x, y); //并且一定要放在最开头，不能把this.id = id 放在它前面 this.id = id; } } var son = new Son(1, 2, 123); son.sum(); //success 继承中属性或者方法的查找原则：就近原则 在继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就执行子类的 如果没有，就去查找父类有没有此方法，如果有就执行父类的 如果子类想要直接调用父类的方法，则： class Father { say() { //xxx } } class Son extends Father { say() { //调用父类的普通函数 super.say(); } } var son = new Son(); son.say(); 如果在子类中添加了和父类相同的方法，则子类的方法会覆盖掉父类的方法（在当前屏蔽掉父类的方法），此举动可以称为方法的重写 需要注意的三点1.ES6中类没有变量提升，所以必须先定义类，才能通过实例化对象 2.类里的共有属性和方法一定要加this进行使用 （this指向我们创立的·实例化对象） var that; class Father { constructor(uname, age) { //that = this; this.uname = uname; this.age = age; //this.sing(); 加小括号会立即调用 this.btn = document.querySelector('button'); this.btn.onclick = this.sing; this.init(); } init() {} sing() { //这里的this指向的是调用者，所以btn点击事件发生时，this.uname指向的是btn的uname console.log(this.uname); //所以可以外面定义变量，然后让btn固定打印的是该对象的uname //console.log(that.uname) } } 3.类构造函数和构造函数最主要的区别是，类构造函数必须使用new，不然会报错，而构造函数不用new会被当作普通函数去使用 static类（class）通过 static 关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能。（也可以解释为实例上加，要想用必先new , 对象上加，可以 直接用） class Father { static sing() { //... } } 3.构造函数和原型在ES6（ECMAScript6.0）之前，JavaScript没有类的概念，在ES6之前，对象不是基于类创建的，而是用一种称为构造函数的特殊函数来定义对象和他们的特征的。 创建对象：(JavaScript基础也有做过笔记) 1.对象字面量 var obj = {} 2.new Object() var obj = new Object() 3.Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__ 自定义构造函数function 构造函数名(){ this.属性=值; this.方法=function (){} } 1.使用构造函数，构造函数名字首字母最好大写如 function Star()2.构造函数不需要return3.使用函数new 构造函数名();即构造一个对象，如new Array()，创建一个数组对象4.属性方法前必须加this如this.name=传参name this.song = function（传参）{} 但毕竟终究是函数，如果在全局下直接调用该构造函数（并非使用new 创建），则会将this的属性添加到window对象上 当然也可以使用call调用，将属性添加到已将创建好的对象上 构造函数中属性和方法我们称之为成员，成员可以添加 实例成员：实例成员就是构造函数内部通过 this 添加的成员 ，实例成员只能通过实例化的对象来访问，不可以通过构造函数访问实例成员，如 function Star(uname){ this.uname = uname; } let star = new Star('xxx'); console.log(star.uname); 静态成员：在构造函数本身上添加的成员，静态成员只能通过构造函数来访问，不能通过对象来访问，如 function Star() {}; Star.sex = 'male'; console.log(Star.sex); 构造函数虽然好用，但是存在浪费内存的问题 构造函数原型对象prototype构造函数通过原型分配的函数是所有对象所共享的 JavaScript规定，每个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype（原型）就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有 因此，我们把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这个方法 使用方法： function Star(uname){ this.uname = uname; } //第一种写法： Star.prototype.sing = function() {} // Star.prototype.sex = 'male'; //第二种写法：（但这种方法不能适用于Array、Object等，会覆盖原来的定型的方法） Star.prototype = { constructor: Star, //不可省略，因为这种写法覆盖掉原来的constructor方法 sing: function() {}, movie: function() {} } 所以一般情况，我们的公共属性定义到构造函数里面，公共的方法我们放到原型对象的身上 注意：虽然随时能给圆形添加属性和方法，并能立即反应在所有对象实例上，但这和重写整个原型是两回事，如果原型的修改是在创建实例之前，则实例引用的仍是最初的原型 let friend1 = new Person(); Person.prototype = { constructor:Person, saySomething(){ console.log(\"yes!\"); } } let friend2 = new Person(); friend1.saySomething() //错误 friend2.saySomething() //通过 对象中的prototype使用for in 遍历对象时原理和查找 [[prototype]] 链类似，任何可以通过原型链访问到的属性（enumberable）都会被枚举，而使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链 const obj = { a: 2, }; const myobj = Object.create(obj); for (k in myobj) { console.log(k); } 属性屏蔽 对于以上代码，如果添加 myobj.foo = \"bar\" 会出现以下几种情况 foo不存在于myobj和 [[prototype]]上，直接把foo添加到myobj身上。 foo仅存在于原型链 [[prototype]] 上 如果是只读的，进行了赋值则啥也不干（严格模式下会报错） 如果存在一个setter，则执行setter 其余情况则在myobj本身添加一个foo，这个foo为屏蔽属性 foo既存在于 myobj上，也存在 foo上，发生屏蔽，myobj中包含的foo属性会屏蔽上层原型链的所有foo属性 相互委托 你无法在两个或两个以上互相（双向）委托的对象之间创建循环委托，这种方法是被禁止的。尽管相互委托理论上可以正常工作，并且在某些情况下非常有用，但是之所以要禁止相互委托，是为了更加高效，也不用检查是否为无限循环引用。 对象原型: __proto__对象都会有一个属性 __proto__ 指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为 __proto__ 的存在 实例化的对象.__proto__ === 构造函数名.prototype 返回true 在社区里其实也因为双下划线，被称为 “笨蛋proto” constructor构造函数对象原型（__proto__）和构造函数原型对象（prototype）里面都有一个constructor属性，constructor我们称为构造函数，因为它指回构造函数本身 注意，实际上 实例化对象.constructor是被委托给了 prototype，是原型链访问到的属性，而实例化对象本身没有这个属性 主要目的：用于记录该对象引用于哪个构造函数（很多情况下我们需要用它来指回原来的构造函数） 但是《你不知道的JavaScript》告诫： constructor 是一个不可靠并且不安全的引用，它不一定会指向默认的函数引用，通常来说尽量避免这些引用 原型链任何构造函数原型对象prototype，它作为一个对象，也有它自己的对象原型 __proto__ ，而此时原型对象的 __proto__ 指向的是Object.prototype， 即某构造函数名.prototype.__proto__ === Object.prototype 而我们Object也有prototype原型对象，而它作为一个对象，也有它自己的对象原型 __proto__ ，而此时指向null（到达了终点） 即Object.prototype.__proto__ === null JavaScript成员查找机制： 所以在成员查找时，先查找最底层，没有则根据它 的__proto__查找至他的原型对象，看看有没有该成员，没有的话继续一层一层往上查找，如果找不到该成员 ，最后返回undefined (undefined是由null派生而来的) 而根据查找规则，使用就近原则来处理重复成员定义问题（即先找到，先使用） （这里未标出实例对象 constructor 指向 构造函数） 同时要注意的是： console.log(Object.__proto__); //Function.prototype console.log(Object.__proto__.__proto__); //Object.prototype console.log(Object.__proto__.__proto__.__proto__); //null 拓展内置对象可以通过原型对象，对原来的内置对象进行拓展自定义的方法，比如给数组增加自定义求偶数和的功能 //在Array原型对象上追加函数，不能采取Array.prototype = {}形式 Array.prototype.sum = function() { let sum = 0; for(let i = 0; i &lt; this.length; i++){ sum+=this[i]; } return sum; } 4.继承在ES6之前没有给我们提供extends，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承 call()fun.call(thisArg, arg1, arg2....) （arg n那些指的是传递的其他参数） 功能：调用这个函数，并且修改函数运行时this的指向 thisArg: 当前调用函数的this的指向对象（一般在JavaScript中直接调用函数时，函数的this指向window） ES5继承的两大步借用构造函数继承父类型的属性 核心原理：通过call() 把父类型的this指向子类型的this，这样就实现了子类型继承父类型的属性 利用原型对象继承父类型的方法 实现如下： function Father(uname, age) { this.uname = uname; this.age = age; } Father.prototype.teach = function () { console('father') } //借用父构造函数继承属性 function Son(uname, age) { Father.call(this, uname, age); } // 这样直接赋值会出问题，因为是赋值父原型对象的地址，如果修改了子原型对象，父原型对象也会随之改变 // Son.prototype = Father.prototype; × // 正确方法： // 借用父构造函数继承方法 Son.prototype = new Father(); // 如果利用了对象形式修改了原型对象，别忘了利用constructor指回原来的构造函数 Son.prototype.constructor = Son; Son.prototype.exam = function () { console('son') } let son = new Son('xxx', 18); console.log(son); 组合继承=原型继承+构造函数继承（结合两者的优点） 组合继承方式的缺点是： 原型中包含的引用值会在所有实例中共享，而使用 Son.prototype = new Father();的方式继承时，Son.prototype 是Father类的一个实例，Father的所有属性都会被继承下来，而这些属性都会被当成共享属性 组合继承会构造函数实例化了两次 更优解法为寄生组合继承： 使用 Object.create()方法来实现，以下为寄生组合继承 — 完美方式 function Shape() { this.x = 0; this.y = 0; } Shape.prototype.move = function(x, y) { //... }; // Rectangle - 子类(subclass) function Rectangle() { Shape.call(this); // call super constructor. } // 子类续承父类 Rectangle.prototype = Object.create(Shape.prototype); Rectangle.prototype.constructor = Rectangle; 但实际上使用 Object.create() 要抛弃掉默认的 Rectangle.prototype ，而ES6开始之后，可以通过 Object.setPrototypeOf(Rectangle.prototype, Shape.prototype) 直接修改原来的原型对象（《你不知道的JavaScript》推荐） 又又又但是MDN对于 Object.setPrototypeOf 有个警告 警告: 由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 obj.__proto__ = ... 语句上的时间花费，而且可能会延伸到任何代码，那些可以访问任何[[Prototype]]已被更改的对象的代码。如果你关心性能，你应该避免设置一个对象的 [[Prototype]]。相反，你应该使用 Object.create()来创建带有你想要的[[Prototype]]的新对象。 所以还是老老实实用 Object.create() 对象关联来实现继承以上为面型对象的设计模式（强调实体和实体间的关系） 以下为《你不知道的JavaScript》中谈及的对象关联的继承实现方式，书中说到该思维模式更加简洁，因为这种代码只关注一件事：对象之间的关联关系。并且看上去这种对象形式让构造和初始化分开了，但是许多情况下这两步分来的话更加灵活 而对比面向对象模式，有时却不得不使用显式伪多态的方法调用，比如这种代码，Shape.prototype.move.call(xxx)（除非用上es6新增的 class，使用super来调用 ），并且还要夹杂着new之类的 const Shape = { init(x, y){ this.x = x; this.y = y; }, move(x, y){ //... } } const Rectangle = Object.create(Shape); Rectangle.ohterFunction = function(){ //.. } // 对象关联的“实例” const r1 = Object.create(Rectangle); r1.init(1, 2) 类的本质（class陷阱）class本质还是function（用 typeof 查看），它只是委托 [[prototype]]机制的一种语法糖 但是新的class写法只是让对象原型的写法更加清晰，更像面向对象编程的语法 和构造函数相同点： 1.类也有原型对象prototype，而prototype里的constructor也是指回类的本身 2.类也可以利用原型对象添加方法 3.类创建的实例对象中的 __proto__ 原型指向类的原型对象 class陷阱： 也就是说，class并不会像传统的面向类语言一般，在声明时静态复制所有行为，如果你有意无意修改了某个父类的方法，它的子类和所有实例都会受到影响","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript进阶ES5","slug":"JavaScript进阶ES5","date":"2022-04-24T06:47:00.674Z","updated":"2022-12-07T02:28:16.871Z","comments":true,"path":"2022/04/24/javascript-jin-jie-es5/","link":"","permalink":"https://taylor12138.github.io/2022/04/24/javascript-jin-jie-es5/","excerpt":"","text":"1.ES5部分的方法数组方法1.forEach() ： arr.forEach(function(vlaue, index, [array])) 分别对应数组的value（值）、index（索引号）、数组本身 （遍历数组的全部元素，即使return true也不会终止迭代） （因为forEach本质是一个函数，参数是一个回调函数，回调函数的return只是终止了回调函数而已，不是终止forEach，而forEach内部应该是多次调用了那个函数） 在 forEach遍历中，无法改变item（原数组里的元素，如果元素是数组 or 对象，那另当别论 0.0 ） // 数组改值 let arr = [1,3,5,7,9]; arr.forEach(function(item){ item = 30; }) console.log(arr); //输出 [1, 3, 5, 7, 9] let arr = [{ a: 1 }, { a: 2 }, { a: 3 }]; let arr2 = [[1], [1], [1]]; arr.forEach(function (item) { item.a = 2; }) arr2.forEach(item => { item.push(2) }) console.log(arr); //[ { a: 2 }, { a: 2 }, { a: 2 } ] console.log(arr2); //[ [ 1, 2 ], [ 1, 2 ], [ 1, 2 ] ] 如果你硬要改变item，也不是不可以，只是方法要稍稍改动，使用引用的方式进行修改 // 数组改值 let arr = [1,3,5,7,9]; arr.forEach(function(item,index,arr){ arr[index] = 30; }) console.log(arr); //输出 (5) [30, 30, 30, 30, 30] 2.filter(): filter() 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组 （注意它直接返回一个新数组） array.filter(function(currentValue, index, [arr])) 分别对应currentValue（数组当前项的值），index（索引号），arr（数组本身），它的回调函数返回的必须是一个Boolean值，返回true自动将value加入新数组中，false则过滤掉，最后整体返回一个新数组 var newArr = arr.filter(function(value, index) { return value >= 20; }) find()方法有点类似filter，只不过返回的不是新数组，而是返回符合测试条件的第一个数组元素值 而对应的findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。 3.some() ：some()方法用于检测数组中的元素是否 存在 满足指定条件，通俗点就是查找数组中是否有满足条件的元素，找到第一个满足条件的元素则停止 （注意它返回的是布尔值）在some里设置return true 以终止遍历 array.some(function(currentValue, index, [arr])) 分别对应currentValue（数组当前项的值），index（索引号），arr（数组本身） 4.map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。和forEach相似，不同在于： ​ 如果更改数组内的值，forEach 不能确保数组的不变性。这个方法只有在你不接触里面的任何值时，才能保证不变性。 ​ 由于它们之间的主要区别在于是否有返回值，所以你会希望使用 map 来制作一个新的数组，而使用 forEach 只是为了映射到数组上(修改原来的数组) 返回值加入新数组中 let newarr = arr.map(function(value, index) { return value * 2; }) map的不变性：当数组为基础类型时原数组不变 let array=[1,2,3,4,5] let newArray=array.map((item) => item*2) console.log(array); // [1,2,3,4,5] console.log(newArray);//[2, 4, 6, 8, 10] 当数组为引用类型时原数组发生改变： let array = [{ name: 'Anna', age: 16 }, { name: 'James', age: 18 }] let newArray=array.map((item) => { item.like='eat'; return item; }) console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}] console.log(newArray);//[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}] 5.every() 方法用于检测数组所有元素是否都符合指定条件 6.arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 参数分别对应回调函数和初始值 对数组中所有内容进行汇总，点像递归 let total = a.reduce(function (preValue, currValue) { return preValue + currValue; }, 0); // 遍历到第一次时，preValue为初始值，currValue为数组里的第一个值 // 遍历到第二次时，preValue为第一次返回的值，currValue为数组里第二个数 以上ES5数组方法有助于链式编程（函数式编程），比如： //this.$store.state.cartList 是一个数组 this.$store.state.cartList .filter((item) => item.checked === true) .reduce((preValue, item) => { return preValue + item.count * item.price; }, 0) .toFixed(2); 数组扁平化方法apply（仅限双层） function Flat1(arr){ return [].concat.apply([],arr); } var arr1 = [[1, 2],[3, 4, 5], [6, 7, 8, 9]]; console.log(Flat1(arr1)); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 展开运算符（仅限双层） function Flat1(arr){ return [].concat(...arr); } 多层需要递归 function Flat5(arr){ var newArr =[]; for(var i= 0; i &lt; arr.length; i++){ if(arr[i] instanceof Array){ newArr = newArr.concat(Flat5(arr[i])); // newArr.push.apply(newArr, Flat5(arr[i])); }else{ newArr.push(arr[i]); } } return newArr; } es6方法 const Flat6 = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? Flat6(b) : b), []); 如果数组的元素都是数字，那么我们可以考虑使用 toString 方法 function flatten(arr) { return arr.toString().split(',').map(function(item){ return +item }) } 对象方法Object.defineProperty() 定义对象中新属性或修改原有的属性（应用于vue响应式双向绑定，还有es5实现const的原理） Object.defineProperty(obj, prop, desciptor) obj：必须，目标对象 prop： 必需，需定义或修改的属性名 descriptor： 必须，目标属性所拥有的特性，一对象的形式{ }进行书写， value设置属性的值，默认undefined； writable值能否重写（修改），默认为false； enumerable：目标属性是否可以被枚举(是否可以被遍历，显示出来)，默认false； configurable目标属性是否可以被删除，或者再次修改特性（是否可以再次更改这个descriptor），默认false； 不管是否为严格模式，尝试修改一个不可配置的属性描述符都会出错，也就是说configurable的修改为false是单向操作！！ 除此外还具有以下可选键值： 当定义getter、setter时，属性就会被定义为“访问描述符”，此时JavaScript会忽略他们的value和writable 特性 通常来说getter和 setter是成对出现的（只定义一个的话通常会产生意料之外的行为） get：当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。 set：当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象(修改后的值)。 var obj = { id: 1, pname: '小米', price: 1999 } //以前的对象添加修改方式 //obj.num = 1000; //obj.price = 99; Object.defineProperty(obj, 'num', { value = 999, enumerable = true }) Object.keys(obj) 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。 Object.keys(obj1).length得到当前对象属性个数 Object.getOwnPropertyNames(obj1)返回对象实例的常规属性数组 Object.getOwnPropertySymbols(obj1)返回对象实例的符号属性数组 这两种方法互斥 2.函数定义和调用函数定义： 自定义函数：function fn() {}; 匿名函数： var fun = function() {}; 匿名函数三大缺点： 1.调用栈更难追踪 2.自我引用更难（递归等） 3.代码较难理解 const a = function b (){ console.log('woshib'); } b(); //b is not defined new Function(&#39;参数1&#39;, &#39;参数2&#39;, &#39;函数体&#39;)形式调用 像构造函数, Function里面的参数都必须是字符串格式 var f = new Function('a', 'b', 'console.log(a + b)'); 实际上所有的函数都是Function的实例 函数也属于对象 函数调用： 普通函数调用 function fn() { //something } fn(); 对象方法 var o = { say: function() { //something } } o.say(); 构造函数 function Star() {}; new Star(); 绑定事件函数btn.onclick = function() {} 定时器函数 setInterval(function() {}, 1000); 立即执行函数（自动调用） (function() {} )(); 立即执行函数和普通函数有实际意义上非常重要的区分，此时函数会被当作函数表达式和不是一个标准的函数声明来处理。此时函数只能在它所代表的位置中被访问，外部作用域不行，不会非必要的污染外部作用域 3.this的指向函数内this的指向是当我们调用函数时，根据调用栈确定的（动态作用域），调用方式不同导致this指向不同 1.普通函数调用：window 2.构造函数调用：实例对象，原型对象也是指向实例对象（同样的，类中this也是指向实例对象） 3.对象方法：该方法所属对象（隐式绑定） 对象属性引用链只有上一层或者最后一层在调用位置中起作用 function foo(){ console.log(this.a); } const obj2 = { a:42, foo } const obj1 = { a:2, obj2 } obj1.obj2.foo(); //42 4.事件绑定：绑定事件对象（当前情况指的是位于回调函数的内部中this指向） 5.定时器函数：window 6.立即执行函数：window （2）但是立即执行函数还得看这时this是否在对象方法或者构造函数中，第二个虽然是立即执行函数，但是此时它的this和foo绑定了，所以还是输出foo的a （3）fn是对foo.bar的一个引用，实质上，它引用的是bar函数本身，因此此时的 fn是一个不带任何修饰的函数调用， 应用默认绑定（发生了隐式丢失） （4）箭头函数按照的是词法作用域，按照词法作用域找就好了（对象没有自己的作用域） （5）而赋值操作 ，会创建一个函数的间接引用，此时调用函数会应用默认绑定（this指向window，严格模式为undefined） foo.bar = foo.bar返回值是目标函数的引用，此时相当于直接调用 bar() （6）最后一个参数传递其实就是一种隐式赋值，传入一个对foo.bar的引用，不加任何修饰，因此是默认绑定（this指向window，严格模式为undefined） var a = 1; var foo = { a: 2, bar: function () { return this.a; }, bad: () => { return this.a //箭头函数导致this永远绑定了父级作用域window }, }; const fn = foo.bar; function doFoo(fn) { console.log('6.', fn()); } console.log('1.', foo.bar()); //1. 2 console.log('2.', (foo.bar)()); //2. 2 console.log('3.', fn()); //3. 1 console.log('4.', foo.bad()); //4. 1 console.log('5.', (foo.bar = foo.bar)());//5. 1 doFoo(foo.bar); //6. 1 “匿名函数的执行环境具有全局性”，所以最里层那个函数中this指向全局环境（走了默认绑定），全局环境没有定义foo变量所以输出undefined。在匿名函数外部将this保存到一个内部函数可以访问的变量self中，可以通过self访问这个对象，所以self.foo为bar var myobject = { foo: \"bar\", func: function () { var self = this; console.log(this.foo); console.log(self.foo); (function () { console.log(this.foo);//undefined console.log(self.foo);//bar })(); } }; myobject.func(); 类的this指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 class Logger { printName(name = 'there') { this.print(`Hello ${name}`); } print(text) { console.log(text); } } const logger = new Logger(); const { printName } = logger; printName(); // TypeError: Cannot read property 'print' of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错。 （1）一个比较简单的解决方法是，在构造方法（constructor）中绑定this，这样就不会找不到print方法了。 class Logger { constructor() { this.printName = this.printName.bind(this); } // ... } （2）另一种解决方法是使用箭头函数。 class Obj { constructor() { this.getThis = () => this; } } const myObj = new Obj(); myObj.getThis() === myObj // true 改变this指向JavaScript为我们专门提供了一些函数方法来帮助我们处理函数内部this指向问题，常用的有bind()、call()、apply()三种方法 1.call()前面讲过，call的主要作用可以实现继承 2.apply()方法调用一个函数，简单理解为调用函数的方式，但是它可以改变this的指向 fun.apply(thisArg, [argsArray]) thisArg：在函数执行时指定的this对象 ，不传，或者传null,undefined， 函数中的 this 指向 window 对象 argsArray: 传递的值，必须包含在数组（伪数组）里面（这个是和call的不同点） 返回值为函数的返回值，因为它就是调用函数 应用方面：apply传递数组参数，所以可以借助数学内置对象求最大值 Math.max.apply(Math,arr) （es6拓展运算符…Math.max(...arr)也可以，但是不能 Math.max(arr)，因为max不接受数组，只接受一个一个的参数） 3.bind()方法不会调用函数，但是能改变函数内部this指向，当使用 new 操作符调用绑定函数时，该参数无效。 fun.bind(thisArg, arg1, arg2....) 返回指定this值和初始化参数改造的原函数拷贝（即创造新的函数 var f = fn.bind(xx)） 应用方面：定时器等不想立即调用的函数（或者处理其他只能用that来暂时储存对象的情况） btn.onclick = function() { this.disabled = true; //var that = this; //old way: /*setTimeout(function() { //that.disabled = false; }, 3000)*/ //new way: setTimeout(function() { this.disabled = false; }.bind(this), 3000) //这个this指向btn } 巧妙运用： 传参的时候可以传递其他对象过来 class Tab { constructor(id) { this.main = document.querySelector(id); //tabsbox this.lis = this.main.querySelectorAll('li'); } // 初始化 init() { for (let i = 0; i &lt; this.lis.length; i++) { this.lis[i].onclick = this.toggleTab.bind(this.lis[i], this); } } // 切换功能 toggleTab(that) { that.clearTab(); this.className = 'liactive' that.sections[this.index].className = 'conactive'; } } 如果一个函数进行多次 bind的情况：！！ let a = {} let fn = function () { console.log(this) } fn.bind().bind(a)() 答案是第一下的结果，即this指向第一个bind传入的this，这里没有的话就是window // fn.bind().bind(a) 等于 let fn2 = function fn1() { return function() { return fn.apply() }.apply(a) } fn2() 也可以理解为变成了 a.window.fn() 三大this指向手写模式实质上原理也是利用隐式绑定，通过 上下文.函数()调用改写this，从而变成显式绑定 解释一下，在Function.prototype里通过属性定义方法，此时this指向函数本身（因为是函数在调用） call指向 Function.prototype.myCall = function(context) { if (typeof this !== 'function') { throw new TypeError('Error') } context = context || window context.fn = this const args = [...arguments].slice(1) const result = context.fn(...args) delete context.fn return result } bind的实现（借助一波apply / call） Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } const _this = this const args = [...arguments].slice(1) // 返回一个函数 return function F() { // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) { return new _this(...args, ...arguments) } return _this.apply(context, args.concat(...arguments)) } } 三大this指向不安全点如果把null 或者 undefined 作为this绑定对象，传入call、bind、apply，则调用时会被忽略，可能给全局window添加副作用，将规则绑定到全局对象，可能导致不可预计的后果 （指向参数传入null的应用场景是柯里化传参） 此时可以传入一个“更空”的空对象（没有Object.prototype这个委托），避免这种危险 const d = Object.create(null); foo.bind(d, ['a', 'b']); 软绑定隐式绑定：对象绑定 显式绑定：apply、call 硬绑定：bind 硬绑定可以把this强制绑定到指定对象。但是硬绑定会大大降低函数的灵活性，使用硬绑定之后则无法使用显式绑定或者隐式绑定修改this 如果可以给默认绑定指定一个除了全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改this的能力 if(!Function.prototype.softBind) { Function.prototype.softBind = function(obj) { var fn = this; var curried = [].slice.call(arguments, 1); var bound = function(){ // 如果this不是window || global则不使用传入的obj，如果是，则将this绑定obj return fn.apply( (!this || this === (window || global)) ? obj : this, curried.concat.apply(curried, arguments) ); }; bound.prototype = Object.create(fn.prototype); return bound; } } 此时实现了软绑定 function foo() { console.log(`name: ${this.name}`); } var obj = { name: \"obj\" } var obj2 = { name: \"obj2\" } var obj3 = { name: \"obj3\" } obj2.foo = foo.softBind(obj); obj2.foo(); //name: obj2 foo.softBind(obj).call(obj3); //name: obj3 setTimeout(obj2.foo, 1000); //name: obj 4.严格模式ie10以上版本才支持 它是让JavaScript以严格的条件下运行代码 1.消除了JavaScript一些语法不严谨的地方，减少怪异行为 2.消除代码一些不安全之处，保证代码运行的安全 3.提高编译器效率，增加运行速度 4.禁用了ECMAscript在未来版本中可能会定义的一些语法，为未来JavaScript做好铺垫，比如class、enum、super等 开启严格模式应用到整个到整个脚本或个别函数中，因此，我们可以讲严格模式分为脚本开启严格模式和为函数开启严格模式两种情况 为脚本开启严格模式： &lt;script> \"use strict\"; //xxxx &lt;/script> 方法二：（写在立即执行函数里的都要按照严格模式） &lt;script> (function() { \"use strict\"; /xxxx })(); &lt;/script> 为函数开启严格模式：(只在此函数内部有严格模式) &lt;script> function fn(){ \"use strict\"; /xxxx } &lt;/script> 变化1.严格模式禁止变量为声明就赋值 2.严禁删除已声明的变量，比如delete x; 是错误的 3.在严格模式下，全局作用域中函数中的this不再是window，而是undefined（但是定时器之类的还是指向window） 4.严格模式下，如果构造函数不配合new来使用，this就会报错 5.函数不能有重名参数 6.函数必须声明在顶层，因为新版本的JavaScript引入了块级作用域，所以不允许在非函数代码块内声明函数 5.闭包闭包指有权访问另外一个函数作用域中变量的函数，简单理解就是一个作用域可以访问另外一个函数内部的局部变量 （被访问作用域的函数就是闭包函数） //在此处fun函数作用域访问了另外一个函数fn里面的局部变量num，形成了闭包，此时fun就是闭包 //fun被赋予了一个全局变量，所以fun始终保存在内存中，而fun依赖fn的num，因此num也始终在内存中 function fn() { var num = 10; function fun() { console.log(num); } fun(); } fn(); 在fn外部作用域访问fn内部局部变量（它返回了当时的作用域）： //所以闭包就是典型的高阶函数 function fn() { var num = 10; return function() { console.log(num) } } var f = fn(); f(); 闭包的主要作用： 延伸了变量的作用范围（读取函数内部的变量） 让这些变量的值始终保持在内存中 闭包缺点： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 利用闭包解决异步问题：（因为函数是一个作用域） //立即执行函数也成为了小闭包，因为立即执行函数里面任何一个函数都可以使用它的i变量，此时里面使用外层i的函数，都是闭包 for (var i = 0; i &lt; lis.length; i++) { (function (i) { lis[i].onclick = function () { console.log(i) } })(i); } 回调函数：获取异步操作的结果，只要使用了回调函数，实际上就是使用闭包—《你不知道的JavaScript》 一般情况下，把函数作为参数的目的就是为了获取函数内部的异步操作的结果 //如果需要获取一个函数中异步操作的结果，则必须通过回调函数来获取 function fn(callback) { setTimeout(function () { var data = 'hello'; callback(data); }, 1000) } fn(function (data) { console.log(data); }) 高阶函数如果一个函数符合下面两个规范的任何一个，那该函数就是高阶函数 若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数（比如Promise、setTimout） 若A函数，调用的返回值仍然是一个函数，那么A就可以称之为高阶函数（比如防抖，React实现传参的回调函数） 函数的柯里化 通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式（比如React实现传参的回调函数） function sum(a){ return (b) => { return (c)=> { return a+b+c; } } } sum(1)(2)(3) 纯函数一类特别的函数 必须遵守以下约束： 不得改写参数数据（如果传入数组、对象，则不能让他们发生改动） 只要是同样的输入（实参），必定得到同样的输出（返回） 不会产生任何副作用（例如网络请求，输入和输出设备） 不能调用Date.now()或者Math.random()等不纯方法 redux的reducer必须是一个纯函数 闭包的模块有两个主要的特征（源自《你不知道的JavaScript》） 为创建内部作用域而调用了一个包装函数 包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包函数内部作用域的闭包 6.递归如果一个函数在内部可以调用其本身，则这个函数是递归（俄罗斯套娃） 但是容易发生“栈溢出”错误，所以必须加退出条件“return” 浅拷贝和深拷贝（jQuery篇目有提及到（$.extend([deep], target, object1, [objectN])）） 1.浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用 2.深拷贝拷贝多层，每一级别的数据都会拷贝 ES6中浅拷贝的语法糖：Object.assign(target, ...source)（把source拷贝给target，它将返回目标对象。） const target = { a: 1, b: 2 }; const source = { b: 4, c: 5 }; const returnedTarget = Object.assign(target, source); console.log(target); // expected output: Object { a: 1, b: 4, c: 5 }，按顺序覆盖掉原来的属性 利用循环写浅拷贝 var obj = { id: 1, name: 'andy', msg: { age: 18 } }; var o = {}; for (var k in obj) { // k是属性名， obj[k]是属性值 o[k] = obj[k]; } 利用递归写深拷贝 缺点在于：性能不好，占用内存很大 var obj = { id: 1, name: 'andy', msg: { age: 18 } }; var o = {}; function deepcopy(newobj, oldobj) { for(let k in oldobj) { // 获取属性值 const item = oldobj[k]; // 判断该值是否属于数组(数组也属于object，所以要先写) if(item instanceof Array) { newobj[k] = []; deepcopy(newobj[k], item); } else if(item instanceof Object) { // 判断该值是否为对象 newobj[k] = {}; deepcopy(newobj[k], item); } else { // 所以剩下的属于简单数据类型 newobj[k] = item; } } } deepcopy(o, obj); console.log(o); 使用 JSON.parse和 JSON.stringify实现深拷贝 const info = {name: \"Allen\", friends: {name: \"Khan\"}}; const newobj = JSON.parse(JSON.stringify(info)); 这个方式的缺点在于：不能有undefined值，不然就会出现不可预期的问题（有可能删除掉undefined的字段） 完整版深拷贝github上一个叫lodash的库，使用深拷贝也差不多是类似的方法 const getType = obj => Object.prototype.toString.call(obj); const isObject = (target) => (typeof target === 'object' || typeof target === 'function') &amp;&amp; target !== null; const canTraverse = { '[object Map]': true, '[object Set]': true, '[object Array]': true, '[object Object]': true, '[object Arguments]': true, }; const mapTag = '[object Map]'; const setTag = '[object Set]'; const boolTag = '[object Boolean]'; const numberTag = '[object Number]'; const stringTag = '[object String]'; const symbolTag = '[object Symbol]'; const dateTag = '[object Date]'; const errorTag = '[object Error]'; const regexpTag = '[object RegExp]'; const funcTag = '[object Function]'; const handleRegExp = (target) => { const { source, flags } = target; return new target.constructor(source, flags); } const handleFunc = (func) => { // 箭头函数直接返回自身 if(!func.prototype) return func; const bodyReg = /(?&lt;={)(.|\\n)+(?=})/m; const paramReg = /(?&lt;=\\().+(?=\\)\\s+{)/; const funcString = func.toString(); // 分别匹配 函数参数 和 函数体 const param = paramReg.exec(funcString); const body = bodyReg.exec(funcString); if(!body) return null; if (param) { const paramArr = param[0].split(','); return new Function(...paramArr, body[0]); } else { return new Function(body[0]); } } const handleNotTraverse = (target, tag) => { const Ctor = target.constructor; switch(tag) { case boolTag: return new Object(Boolean.prototype.valueOf.call(target)); case numberTag: return new Object(Number.prototype.valueOf.call(target)); case stringTag: return new Object(String.prototype.valueOf.call(target)); case symbolTag: return new Object(Symbol.prototype.valueOf.call(target)); case errorTag: case dateTag: return new Ctor(target); case regexpTag: return handleRegExp(target); case funcTag: return handleFunc(target); default: return new Ctor(target); } } const deepClone = (target, map = new WeakMap()) => { if(!isObject(target)) return target; let type = getType(target); let cloneTarget; if(!canTraverse[type]) { // 处理不能遍历的对象 return handleNotTraverse(target, type); }else { // 这波操作相当关键，可以保证对象的原型不丢失！ let ctor = target.constructor; cloneTarget = new ctor(); } if(map.get(target)) return target; map.set(target, true); if(type === mapTag) { //处理Map target.forEach((item, key) => { cloneTarget.set(deepClone(key, map), deepClone(item, map)); }) } if(type === setTag) { //处理Set target.forEach(item => { cloneTarget.add(deepClone(item, map)); }) } // 处理数组和对象 for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = deepClone(target[prop], map); } } return cloneTarget; } immutable.js的拷贝也值得探讨（记住是浅拷贝，如果数据类型复杂，在里面还得继续包裹immutable的Map） 它的实现原理是persistent data structure（持久化数据结构），也就是使用旧数据创建新数据时，保证旧数据同时可用且不变，同时避免了deepcopy把所有的节点都复制一遍带来的性能损耗，immutable使用了structural sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受他影响的父节点，则其他节点进行共享 比如说 a = { b1: { c1:{ d1: 1 }, c2:{} }, b2:{ c3:{} } } 此时通过 immutable 拷贝得到对象 a2，将里面的c1进行更改，此时不会影响到原来的对象，而是从c1分裂新生成一个新的节点，然后b1，a跟着变，得到一个既和a共享部分数据，又有自己的新数据的对象 从这张图可以看到清楚的反应2165169-cebb05bca02f1772 (613×575) (jianshu.io) 而这篇文章用于加深immutable的原理https://zhuanlan.zhihu.com/p/44571842 但是这种为了保持状态的场景比较适用于react的redux（纯函数），如果是vue的话就没必要考虑这么麻烦 7.正则表达式概述正则表达式（regular expression）是用于匹配字符串中字符组合的模式，再JavaScript，正则表达式也是对象 正则表达式通常用来做检索，替换那些符合某个模式（规则）的文本，例如昵称输入框里的对中文的匹配；此外，正则表达式还常用于过滤掉页面一些敏感（替换），或者从字符串获取我们想要的特定部分（提取）等 特点：1.灵活性、逻辑性、功能性非常强 2.可以迅速用极简的形式达到对字符串复杂的控制 3.对刚接触的人来说，比较晦涩难懂 4.一般实际开发，都是直接复制写好的正则表达式，但是要求会使用正则表达式且根据实际情况修改正则表达式 应用1.通过调用RegExp对象的构造函数创建 var 变量名 = new RegExp(/表达式/修饰符) var 变量名 = new RegExp(&#39;表达式&#39;, &#39;修饰符&#39;) 2.通过字面量创建 var 变量名 = /表达式/修饰符（正则表达式不需要加引号，不管是数字型还是字符串型） 测试正则表达式是否符合语法规范：test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数是测试字符串 regexObj.test(str) （只要包含有str这个字符串，返回的都是true） var rg = /123/; var rg2 = /123/g; console.log(rg.test(123)); //true console.log(rg.test(12123)); //true g：全局模式，查找字符串全部内容，再次匹配时会向前搜索下一个匹配项 i：不区分大小写 m：多行模式，表示查找到一行末尾会继续查找 y：粘附模式，每次调用exec()就只会在lastIndex的位置上寻找匹配字段 u：Unicode模式 s：dotAll模式，表示元字符 . 可以匹配任何字符 let a = \"address_address\"; let rg = /a/g; let reg = new RegExp(a, \"g\") //在正则中使用变量 rg.test(\"字符串\"); //是否包含该字符串，返回布尔值 eval(`/a${a}/`).test(\"字符串\") //在正则中使用变量 + 其他字符 a.match(rg); //返回匹配的字符串 + 具体信息，若正则启用全局模式，则返回一个数组，包 含所有匹配的字符串 rg.exec(a); //和match差不多，不过不会因为全局模式改变返回值，如果开全局模式，下次 再匹配一次，则从lastIndex开始匹配，在这里也就是从 下标为1的d 开始匹配 特殊字符一个正则表达式可以由简单的字符构成，比如/abc/， 也可以是简单和特殊字符串的组合，比如/ab*c/。其中特殊字符也被称为元字符，在正则表达式中具有特殊意义的专用符号，如^ 、$ 、+ 等 （匹配特殊字符前面增加 \\就可以了） 正则表达式速查表：https://www.runoob.com/regexp/regexp-metachar.html 边界符：^ 表示匹配行首的文本（以谁开始） $ 表示匹配行尾的文本（以谁结束） var rg = /^abc/; console.log(rg.test('abcd')); //true console.log(rg.test('babc')); //false //必须是abc,类似全等 var rg2 = /^abc$/; console.log(rg.test('abcd')); //false console.log(rg.test('abcabc')); //false 字符类：[]表示有一系列字符可供选择，只要匹配到其中一个就可以了 var rg = /[abc]/; //只要包含有a或者b或者c就返回true console.log(rg.test('andy')); //返回true //var rg = /^[abc]$/ 是三选一，只有是单个a或者b或者c才返回true []使用范围符号 - var rg = /^[a-z]$/; //26个英文小写字母任何一个字母都返回true var rg1 = /^[a-zA-Z]$/; //26个英文字母任何一个字母都返回true var rg2 = /^[a-z0-9_-]$/; //任何单个26小写字母，0-9数字，_, -,都返回true []里使用^：如果中括号里有^表示取反的意思，千万别和边界符^混淆，要区分开来 var rg = /^[^a-z]$/; //26个英文小写字母任何一个字母都返回false 量词符：用来设定某个模式出现的次数，有*、 +、 ?、 {}，{}的量词间不要有空格，可以用test来检测下方正则表达式 var rg = /^a*$/; //a可以出现0-n次，n>=0 var rg1 = /^a+$/; //a可以出现1-n次，n>=1 var rg2 = /^a?$/; //a可以出现1或0次 (?也可以表示禁止贪婪，往最少的匹配方式去选择) var rg3 = /^a{3}$/; //a只能可以出现3次 var rg4 = /^a{3,}$/; //a只可以出现3-n次 n>=3 var rg5 = /^a{3,16}$/; //a只可以出现3-16次 //普遍的用户名规定： var name = /^[a-zA-Z0-9_-]{6,16}$/ 括号总结 []中括号：字符集合，匹配方括号中的任意字符 {} 大括号：量词符，里面表示重复次数，但只让大括号前面一个字符重复 （注意：/^abc{3}$/，只让c重复三次，即abccc） () 小括号：表示优先级 可以用来：/^(abc){3}$/，表示让abc重复三次，即abcabc 预定义类\\d 匹配到0-9任意一数字，相当于[0-9] (var rg = /\\d/; 或者 let reg = new RegExp(&quot;\\\\d&quot;)) \\D 匹配到0-9以外的数字，相当于[^0-9] \\w 匹配任意字母、数字、下划线，相当于[A-Za-z0-9_] \\W匹配除字母数字下划线以外的字符，相当于[^A-Za-z0-9_] \\s 匹配空格（包括换行符、制表符、空格符等），相当于[\\t\\r\\n\\v\\f] \\S匹配非空格字符，相当于[^\\t\\r\\n\\v\\f] 正则里的 “或者符号”：| (var rg = /^\\d{3}-\\d{8}|\\d{4}-\\d{7}$/;) . 除了换行外的任何字符 正则替换replace()方法可以实现替换字符串的操作，用来替换的参数可以是一个字符串或者是一个字符表达式 stringObject.replace(regexp/substr, replacement) var str = 'red and blue and red'; var newstr = str.replace('red', 'yellow'); //结果为yellow and blue and red //var newstr = str.replace(/red/, 'yellow'); 同理 但是replace只能替换掉第一个匹配的字符/正则表达式，无法满足替换掉多个敏感词 可以使用: /表达式/[switch] swtich也成为修饰符，即按照什么样的模式来匹配 var str = 'red and blue and red'; var newstr = str.replace(/red/g, 'yellow'); //结果为yellow and blue and yellow 8.作用域词法作用域：是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是他定义过程发生在代码的书写阶段（除了eval和with） 动态作用域：是JavaScript另一个重要机制this的表亲，它让作用域作为一个运行时被动态确定的形式，而不是在写代码时进行静态确定的形式。 区别是词法作用域是写代码时确定，动态作用域是运行时确定 事实上JavaScript并不具备动态作用域，他只有词法作用域，简单明了，但是this机制某种程度像很像动态作用域 function foo(){ console.log(a); } function bar(){ var a = 3; foo(); } var a = 2; bar(); //2 如果JavaScript具有动态作用域，则会输出3！ 从另外一串代码看词法作用域 function bar(){ var a = 3; function foo(){ console.log(a); } foo(); } var a = 2; bar(); //3","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"红宝书啃读note(上)","slug":"红宝书啃读note(上)","date":"2022-04-07T06:26:45.318Z","updated":"2022-10-18T03:35:37.986Z","comments":true,"path":"2022/04/07/hong-bao-shu-ken-du-note-shang/","link":"","permalink":"https://taylor12138.github.io/2022/04/07/hong-bao-shu-ken-du-note-shang/","excerpt":"","text":"第1、2章（JavaScript）Script标签 在Script标签里面不要出现 console.log(\"&lt;/script>\") //会把它当成script结束标签，即使是字符串也不可以，但是除非 console.log(\"&lt;\\/script>\") 可以使用async代替 DOMContentLoaded事件进行 异步操作（并不是所有浏览器都支持async），使得页面保证dom渲染完毕后再执行js文件，只是不能保证执行次序 defer只对外部脚本有效，按照加载顺序执行脚本的，这一点要善加利用 async不能保证多个script标签事件执行的顺序，加载完了就会立刻执行 noscript标签：当浏览器禁用JavaScript，或者对脚本的支持关闭时可以使用 &lt;script async src=\"xxxx\"> &lt;/script> &lt;script defer src=\"xxxx\"> &lt;/script> 第3章（语言基础）标识符第一个字符不能为数字 推荐语句以分号结尾，除了是一个好习惯之外，有助于在某些情况提升性能 变量在不初始化(直接 var a; )的情况下，会保存一个特殊值：”undefined” 定义一个将来要保存对象值的变量时，建议使用null初始化 undefined 是由 null 派生出来的，所以 null == undefined // true undefined被设计是希望表示一个变量最原始的状态，我们可以通过undefined来判断改变量是否存在，或者是否被赋值（初始化） 当一个对象被赋值了null 以后，原来的对象在内存中就处于游离状态，GC 会择机回收该对象并释放内存。因此，如果需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。 if语句 会自动执行其他类型知道布尔值的转换，注意以下几个会被转化为false：(其他的一般都是true) false “” 0、NAN null undefined NAN：非数值，不等于包括NAN在内的任何值，但是有一个isNAN() 函数 字符串 字符串一旦创建，不可改变，一般我们修改字符串，都是销毁原先的字符串，然后把新的另一个字符串保存到该变量 let lang = 'Java'; lang += 'Script' //改变，进行销毁 + 赋值 变量提升 由于变量提升需要查看是否有var或者function，所以需要注意 console.log(a); //undefined var a = 100 //会变量提升 console.log(a); //报错 a is not defined a = 100 //不会变量提升,但是即使在函数内部声明也会创建一个全局变量，会导致内存泄漏 对象方法 Object.getOwnPropertyNames(obj1)返回对象实例的常规属性数组，比如 [name, value] Object.getOwnPropertySymbols(obj1)返回对象实例的符号属性数组，比如 [Symbol(foo), Symbol(bar)] 这两种方法互斥，但： Object.getOwnPropertyDescriptors(obj1)返回对象实例的符号 + 常规属性的对象 递增递减操作符 &amp; 一元加和减 对于布尔值，如果是false，则转为0再做相应改变；如果为true，则转为1再做相应改变 let s1 = '2', s2 = false; s1++ //值变成了数值3 s2++ //值变成了数值1 而一元加和减，也会执行与Number()相似的类型转换 let s1 = false, s2 = \"1.1\"; s1 = +s1; //得到数值0 s2 = -s2; //得到数值-1.1 左右移和无符号左右移 正常左移操作和右移操作都是直接让数值以二进制形式进行移动。 而无符号右移（&gt;&gt;&gt;），对于正数来说，和右移&gt;&gt;操作一样；对于负数来说，会出现巨大的差异，无符号右移会继续给空位补0 而负数是以一种二补数的二进制编码存储，也就是 先转正数的二进制 0 -&gt; 1, 1 -&gt; 0 结果 +1 let oldValue = -64 let newValue = oldValue >>> 5; //得到134217726 加性操作符 当两个操作数，只有一个为字符串时，另外一个会转变为字符串，然后拼接 let a = 1 + '1'; // \"11\" \"12\" + null //\"12null\" 减法操作符 当任意一个操作数是字符串、布尔值、null或undefined，则先在后台使用Number()转换为数值，若是对象则调用其valueOf()方法取得表示它的数值 == 和 ===、Object.is() ==和 !=都会先进行类型转换（强制类型转换），再确定操作数是否相等 而 === 和 !== 都不会转换操作数 Object.is()确定两个值是否相同。如果以下条件之一成立，则两个值相同： 两者 undefined 两者 null 两者true或两者false 相同长度的两个字符串以相同的顺序具有相同的字符 两者都是同一个对象（意味着两个值都引用了内存中的同一个对象） 数字和 两者 +0 两者 -0 两者 NaN 或两者都非零且两者都不是NaN且两者都具有相同的值 这是不一样根据等于 ==运算符。该 ==运营商应用各种强制转换双方（如果它们不是同一类型）测试相等（导致这种行为像以前一样 &quot;&quot; == false是true），但Object.is不强迫任何一个值。 这也不同于根据===运营商的平等 。Object.is()和之间的唯一区别在于===它们对带符号零和 NaN 的处理。例如，=== 运算符（和==运算符）将数值-0 和+0视为相等。此外，===运算符将 Number.NaN和NaN视为不相等。 break &amp; continue break和continue都可以使用标签语句退出多重循环 let num = 0; outermost: for(let i = 0; i &lt; 10; i++){ for(let j = 0; j &lt; 10; j++){ if(i === 5 &amp;&amp; j === 5)break outermost; num++; } } 第4章（变量、作用域与内存）原始类型初始化可以只是永远是字面量形式，如果是使用new关键字创建，则JavaScript会创建爱一个Object实例，其行为类似原始值 比如 let name1 = \"Allen\"; let name2 = new String(\"Bruce\"); name1.age = 18; name2.age = 19; console.log(name1.age) //undefined console.log(name2.age) //19 console.log(typeof name1) //string console.log(typeof name2) //object 引用值（比如对象、数组）传递参数时，会影响到函数外部的原始变量，因为传入的是指针，保存着数值存放的地址 function change(obj){ obj.name = 'allen' } let obj = {}; change(obj); //{ name: 'allen' } 实质上参数传递有点像let 一个变量 obj2 ，然后让 obj2 = obj的操作 为了补救垃圾回收时类似循环引用的问题，IE9把BOM、DOM对象都改成了JavaScript对象 第5章（基本引用类型）正则表达式 正则表达式使用到元字符需要使用 \\ 进行转义，如果正则表达式是使用 RegExp 构造函数来创建，由于参数模式是字符串，所以需要进行二次转义 \\\\ 比如字面量模式： /\\[bc\\]at/ 字符串模式：\\\\[bc\\\\]at RegExp实例的主要方法是 exec()，返回一个数组，包含匹配的信息，匹配不到返回null 如果要获取匹配的字符串：/.de/.exec(&#39;ffff&#39;)[0] g全局匹配： let text = \"cat, bat, sat, fat\"; let pattern = /.at/g; let matches = pattern.exec(text); //cat的数组 console.log(matches); let matches2 = pattern.exec(text); //bat的数组 console.log(matches2); 字符串方法 str.indexOf(子字符串)从字符串开头找子字符串 str.indexOf(子字符串, index)从字符串index位置开始找子字符串 str.lastindexOf(子字符串)从字符串末尾开始查找子字符串 单例内置对象 Global对象：它是ECMA中最特别的对象，因为代码不会显式地访问它。事实上，不存在全局变量或全局函数这种东西，在全局作用域中定义的变量的函数都会变成Global对象的属性，我们所了解的 isNaN()、 parseInt()、 parseFloat()实际上都是Global对象的方法；而NAN、undefined、Array也都是Global的属性。 而我们平时属性的window对象，是Global对象的代理（ECMA-262没有规定直接访问Global对象的方式） eval()方法：它可能是ECMAScript语言中最强大的方法，它就是一个完整的ECMAScript解释器 eval(\"console.log('good!')\"); //等同于 console.log(\"good\") 当解释器发现 eval()时，会将参数解释为实际的ECMAScript语句，然后将其插入到该位置，通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着包含上下文中的变量可以在eval()调用内部被引用 这里eval调用的msg属于外部上下文，因为第二行代码会被替换成一行真正的函数调用代码 let msg = \"Batman\"; eval(\"console.log(msg)\"); //\"Batman\" 函数say是在eval内部定义的，因为该调用会被替换为真正的函数定义 eval(\"function say(){ console.log('good!'); }\") say(); //good! 非严格模式下直接调用 eval() 时，里面使用 var 声明的变量和使用 function 声明的函数会修改当前词法作用域，里面使用 let 和 const 声明的变量不会修改当前词法作用域，但是会在当前创建新的词法作用域。 严格模式下直接调用的 eval() 时，会在当前创建一个新的独立的词法作用域。 eval(\"let msg = 'Batman'\") console.log(msg); //Err eval(\"var msg = 'Batman'\") console.log(msg); //Batman eval() 是一个危险的函数， 它使用与调用者相同的权限执行代码。如果你用 eval() 运行的字符串代码被恶意方（不怀好意的人）修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。更重要的是，第三方代码可以看到某一个 eval() 被调用时的作用域，这也有可能导致一些不同方式的攻击。相似的 Function 就不容易被攻击。 eval() 通常比其他替代方法更慢，因为它必须调用 JS 解释器，而许多其他结构则可被现代 JS 引擎进行优化。 此外，现代JavaScript解释器将javascript转换为机器代码。 这意味着任何变量命名的概念都会被删除。 因此，任意一个eval的使用都会强制浏览器进行冗长的变量名称查找，以确定变量在机器代码中的位置并设置其值。 另外，新内容将会通过 eval() 引进给变量， 比如更改该变量的类型，因此会强制浏览器重新执行所有已经生成的机器代码以进行补偿。 但是，（谢天谢地）存在一个非常好的eval替代方法：只需使用 window.Function。 这有个例子方便你了解如何将eval()的使用转变为Function()。 关于eval更多介绍 https://zhuanlan.zhihu.com/p/232078517 Eval直接调用和间接调用 间接eval调用： (1, eval)('...') (eval, eval)('...') (1 ? eval : 0)('...') (__ = eval)('...') var e = eval; e('...') (function(e) { e('...') })(eval) (function(e) { return e })(eval)('...') (function() { arguments[0]('...') })(eval) this.eval('...') this['eval']('...') [eval][0]('...') eval.call(this, '...') eval('eval')('...') 直接eval调用： eval('...') (eval)('...') (((eval)))('...') (function() { return eval('...') })() eval('eval(\"...\")') (function(eval) { return eval('...'); })(eval) with({ eval: eval }) eval('...') with(window) eval('...') Ecma 规范将引用视为eval“直接 eval 调用”，但仅产生eval为间接的表达式 - 并且间接 eval 调用保证在全局范围内执行。 你是否注意到ES5定义说明调用表达式的eval应当执行标准的、内置的函数？这意味着根据上下文内容eval(‘1+1’)必定不是直接调用。仅仅当eval真正地（不是重写或者隐含地）引用了标准的、内置的函数的时候，调用才被认为是直接调用。 eval = (function(eval) { return function(expr) { return eval(expr); }; })(eval); eval('1+1'); // 它看前来像直接调用，不过实际上是间接调用。 // 这是因为`eval`解析为定制的函数，而不是标准的、内置的函数。 http://perfectionkills.com/global-eval-what-are-the-options/ new Function 除了eval之外另外一种动态执行js代码的的方式 new Function( param1, param2, …, paramN,funcBody );它创建一个包含0个或者过个参数名为 param1 等的函数，函数体为 funcBody。相当于如下方式创建函数： function ( (param1), (param2), ..., (paramN) ){ (funcBody) } let sum = new Function('a', 'b', 'return a + b'); alert( sum(1, 2) ); // 3 let sayHi = new Function('alert(\"Hello\")'); sayHi(); // Hello let str = ... 动态地接收来自服务器的代码 ... let func = new Function(str); func(); Eval 和 new Function 对比 第6章（集合引用类型）对象属性 一般通过点语法进行获取，但也可以使用中括号 console.log(person[\"name\"]); console.log(person.name); 只不过中括号的主要优势在于可以通过变量访问属性 let s = \"name\"; console.log(person[s]); 属性替代 一个对象中如果有重复的属性，则以下面的属性值为准 const obj = { a: \"ab\", a: \"cd\", }; console.log(obj); // {a:'cd'} 数组 数组空位： 使用数组字面量初始化数组时，可以使用一串逗号来创建空位。ES6之前的方法会忽略空位，ES6新增方法普遍将这些空位当成存在的元素，只不过值为undefined。 const option = [,,,,]; 索引自动扩容 如果把一个值设置给超过数组最大索引的索引，数组长度就会自动扩展到该索引值+1 let colors = [\"red\", \"blue\", \"green\"]; colors[2] = \"black\"; colors[3] = \"white\"; console.log(colors); //red, blue, black, white 修改length 数组length的独特之处在于，它不是只读的，通过修改length属性，可以实现从数组末尾删除 / 添加元素（Vue2.0的缺点之一就是不能通过修改数组length得到响应式的结果），添加的元素通过undefined进行填充 搜索位置和方法 indexOf() lastIndexOf() includes()其中前两个在任何版本都可以使用，第三个时ES7新增 indexOf() includes()从开头搜索匹配元素，lastIndexOf()从结尾开始搜索 indexOf() lastIndexOf()找不到返回-1， includes()返回布尔值 它们都是用全等 ===进行比较的 定性数组 ArrayBuffer是所有定型数组及视图引用的基本单位，它是一个普通的JS构造函数，可用于在内存中分配特定数量的字节空间。 一经创建便不能再调整大小 const buf = new ArrayBuffer(16) //在内存中分配16个字节 第7、8章（迭代器和生成器，对象和类）生成器Generator 可以使用星号增强 yield行为，让他能够迭代一个可迭代对象，从而一次产出一个值 function * generatorFn(){ for(const x of [1,2,3]){ yield x; } } //可以转化为 function * generatorFn(){ yield * [1,2,3]; } 实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把yield放到一个循环里没什么不同 和迭代器类似，生成器也支持 “可关闭概念”，因为 generator实现了 iterator接口，一个实现 iterator接口的对象一定有 next()，还有一个可选的 return()方法用于提前终止迭代器，生成器对象除了这两个方法，还有第三个方法 throw() throw()会在暂停的时候将一个提供的错误注入到生成器对象中，如果错误未处理，生成器就会关闭；如果生成器内部函数处理了这个错误，那生成器就不会关闭，跳过对应的 yield，继续执行。 对象方法 对象定义属性（访问器属性）使用Object.defineProperty()，读取属性的特性可以使用 Object.getOwnPropertyDescriptor()方法，它返回一个对象 对于访问器属性包含 configurable、enumberable、get、set 对于数据属性包含 configurable、enumberable、writable和 value属性 （有点像对对应Object.definePRoperty的属性） Object.assign(target, ...sources)方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举和自有属性复制到目标对象（浅拷贝） const target = { a: 1, b: 2 }; const source = { b: 4, c: 5 }; const returnedTarget = Object.assign(target, source); console.log(target); // expected output: Object { a: 1, b: 4, c: 5 } console.log(returnedTarget); // expected output: Object { a: 1, b: 4, c: 5 } 全等升级 -&gt; 对象标识及相等判定 console.log(true === 1); //false console.log({} === {}); //false console.log(\"2\" === 2); //false console.log(+0 === -0); //true console.log(+0 === 0); //true console.log(-0 === 0); //true console.log(NaN === NaN); //false console.log(isNaN(NaN)); //true ES6规范新增了 Object.is() 这个方法和=== 很像，但也同时考虑了上述边界情形 console.log(Object.is(true, 1)); //false console.log(Object.is({}, {})); //false console.log(Object.is(\"2\", 2)); //false console.log(Object.is(+0, -0)); //false console.log(Object.is(+0, 0)); //false console.log(Object.is(-0, 0)); //false console.log(Object.is(NaN, NaN)); //true 对象的可计算属性（使用变量定义属性时，必须放在方括号内，与普通键值(String)进行区分。） const name = 'Mike'; let person = {[name]: 'Matt'} 原型链 原型对象.isPrototypeOf(实例)方法确定两个对象之间的 [[Prototype]]关系 console.log(Array.prototype.isPrototypeOf([])); // true 还有一个 getPrototypeOf() 和 setPrototypeOf()方法，分别对应湖片区参数的原型对象和修改参数的原型对象，但是 Object.setPrototypeOf()会严重影响代码性能 使用Object.getPrototypeOf(obj)方法 === obj.__proto__ 可以使用hasOwnProerty()方法用于确定某个属性是实例上还是在原型对象，这个方法是继承自Object的，会在属性存在于调用它的对象实例上时返回true（这个方法也应用于Vue3.0检测数组属性的存在 + 修改属性 + 新增属性） //person1有name属性、但是没有othername属性 console.log(person1.hasOwnProperty(\"name\")) //true console.log(person1.hasOwnProperty(\"othername\")) //false 但是hasOwnProperty是确定该实例上有没有这个属性 ，如果该实例的对象原型上有这个属性，也会返回false in操作符就不一样了，in在 for in循环中使用，也可以单独使用，in操作符会在可以通过对象访问指定属性时，返回true //person1有name属性、但是没有othername属性 person1.name = \"Bruce\" person1.prototype.othername = \"Allen\" console.log(\"name\" in person1) //true console.log(\"othername\" in person1) //true 对象迭代 ECMAScript2017新增了两个静态方法：Object.values()（返回对象值的数组）、Object.values()（返回键/值对的数组） 继承拓展 原型式继承： 适用情况于你有一个对象，想在它的基础上再创建一个新对象 它是一种不涉及严格意义上的构造函数继承方法，他的出发点是即使不自定义类型 ES5通过增加 Object.create()方法把原型是继承的概念规范化了 let person = { name:\"Allen\", friends:[\"Bruce\", \"Curry\", \"Devid\"] } let anotherPerson = Object.create(person); //object(person)也可以 anotherPerson.name = \"Greg\"; anotherPerson.fridens.push(\"Rob\"); let yetAnotherPerson = Object.create(person); yetAnotherPerson.name = \"Faker\"; yetAnotherPerson.fridens.push(\"Ariana\"); console.log(person.friends); //\"Bruce\", \"Curry\", \"Devid\", \"Rob\", \"Ariana\" console.log(person.name); //\"Allen\" （即引用类型存共享属性，基本类型存取实例属性） 寄生式继承： function createAnother(original) { let clone = object(original); clone.sayHi = function () { console.log(\"hi!\"); } return clone; } let person = { name:\"Allen\", friends:[\"Bruce\", \"Curry\", \"Devid\"] } let another = createAnother(person); another.sayHi(); 它让新返回的对象具有person的所有属性和方法，还创建了一个新的方法sayHi。 但寄生式继承给对象添加函数会导致函数难以重用，和构造函数模式（构造函数继承）类似。 传统的组合继承也存在效率问题，主要在于父类构造函数始终会被调用两次， 一次在创建子类原型时调用（Son.prototype = new Father();） 一次在子类构造函数中调用（function Son(uname, age) {Father.call(this, uname, age);}） 由此寄生式组合继承的方式可以解决这个问题 //替代原来的Son.prototype = new Father(); function inheritPrototype(subType, superType) { let prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype; } JS实现抽象类(仅继承，本身不会被实例化) class Vehicle{ constructor(){ console.log(new.target); } if(new.target === Vehicle){ throw new Error(\"Vehicle annot be directly instantiated\"); } } 第9章（代理与反射）代理与反射 代理为目标对象的抽象，从很多方面来看，代理类似于C++的指针，因为他们可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以被直接操作，也可以通过代理来操作 const target = { id:'target' } // 传入参数为目标对象和处理程序对象 const proxy = new Proxy(target, {}); console.log(target.id); //target console.log(proxy.id); //target target.id = \"foo\" console.log(target.id); //foo console.log(proxy.id); //foo console.log(target.hasOwnproperty('id')); //true console.log(proxy.hasOwnproperty('id')); //true // 可以通过严格模式区分 console.log(target === proxy); //false 使用代理的主要目的是定义捕获器（基本操作拦截器），我们在处理程序对象中定义即可，比如这里我重新定义了 该对象的 get 方法 const handler = { get() { return 'handler override'; } } const proxy = new Proxy(target, handler); console.log(target.id); //foo console.log(proxy.id); //handler override 根据ECMAScript规范，每个捕获器都知道目标对象的上下文，捕获函数签名，而捕获程序的行为必须遵循“捕获器不变式”，捕获器不变式因方法不同而异，但通常都会防止捕获其定义出现过于反常的行为（比如目标对象有一个不可配置切不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出TypeError） 可撤销代理 使用new Proxy()创建的普通代理，这种联系会在代理对象的生命周期内持续存在，所以有时可能需要中断代理对象和目标对象之间的联系。 Proxy也暴露了 revocable()方法，这个方法支持撤销代理对象和目标对象的关联，撤销代理后再次调用代理会抛出TypeError const {proxy, revoke} = Proxy.revocable(target, handler); //此时我们可以撤销代理 revoke(); //撤销代理 console.log(proxy.id); //TypeError 代理的问题和不足 如果target目标对象过于依赖对象标识，可能会出现意料之外的内容（比如WeakMap） const wm = new WeakMap(); class User { constructor(userId) { wm.set(this, userId) } set id(userId) { wm.set(this, userId); } get id() { return wm.get(this) } } const user = new User(123); console.log(user.id); //123 const proxy = new Proxy(user, {}); console.log(proxy.id); //undefined 有些ECMAScript内置类型可能会以来代理无法控制的机制，导致代理商调用某些方法出错，比如Date类型 代理捕获器与反射方法 get()捕获器会在获取属性值的操作中被调用，反射API为 Reflect.get() set()捕获器会在设置属性值的操作中被调用，反射API为 Reflect.set() has()捕获器会在in操作符中被调用，反射API为 Reflect.has() defineProperty()捕获器会在 Object.defineProperty() 中被调用，反射API为 Reflect.defineProperty() ……. 代理模式还可以实现属性隐藏功能、属性验证功能等 const hiddenProperties = ['foo', 'bar']; const target = { foo: 1, bar: 2, baz:3 } const proxy = new Proxy(target, { //隐藏属性功能 get(target, property) { if (hiddenProperties.includes(property)) return undefined; else return Reflect.get(...arguments); }, //属性验证 set(target, property, value) { if (typeof value !== Number) return false;//拒绝赋值 else return Reflect.set(...arguments); } }) 第10章（函数）实质上，函数是一个对象，是Function类型的实例 ECMAScript6的所有函数对象都会暴露一个只读的name属性，其中包含关于函数的信息（如果它是使用Function构造函数创建，则会表示成”anonymous”） function foo() { } let bar = function () { } let baz = () => { } console.log(foo.name); //foo console.log(bar.name); //bar console.log(baz.name); //baz console.log((new Function()).name); //anonymous 注意：ECMAScript的函数没有重载（重载指同个函数名通过接收不同的参数，包括个数、类型，而实现同函数名实现不同的方法） 事实上，JavaScript引擎在加载数据时对函数声明和函数表达式区分对待的。 JavaScript引擎在任何代码执行之前，都会读取函数声明，并在执行上下文中生成函数定义；而函数表达式必须等到代码执行到他那一行，才会在执行上下文中生成函数定义。 //没问题 console.log(sum(10, 10)); function sum(num1, num2){ return num1 + num2; } //会出错，使用var也会出错 console.log(sum(10, 10)); let sum = function(num1, num2){ return num1 + num2 } 我们学习过arguments，是一个伪数组，包含调用函数时传入的所有参数。实际上它还有一个callee属性，是一个指向arguments对象所在函数的指针，从而实现函数逻辑与函数名解耦 function dfs(num){ if(num &lt;= 1)return 1; else return num * arguments.callee(num-1); //相当于num * dfs(num-1) } 严格模式下，运行的代码不能访问arguments.callee，因为访问会出错 闭包延伸 函数执行时，每个执行上文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中叫做活动对象，只在函数执行期间存在。 函数内部的代码在访问变量时，就会使用给定的名称从作用域链1中查找变量，函数执行完毕后，局部活动对象就会被销毁，内存中就只剩下全局作用域，不过，闭包就不一样了。 在一个函数内部定义的函数，就会把其包含的函数的活动对象添加到自己的作用域链中 第11章（期约与异步函数）promise.all：如果有期约拒绝，则第一个拒绝的契约会将自己的理由作为合成期约的拒绝理由（交给onReject或者catch处理）。之后再拒绝的期约不会影响最终期约的拒绝理由 如果至少有一个包含的期约待定，则合成期约待定（pedding），如果有一个包含的期约拒绝，则合成的期约也会拒绝（一个rejected，则all rejected） promise.race：谁快用谁的状态； 第一个落定的拒绝期约，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约拒绝的理由。 和all类似，合成的期约会静默处理所有包含期约的拒绝操作，不会有错误跑掉。 ES6不支持取消期约和进度通知，一个主要原因是这样会导致期约连锁和期约合成过度复杂化。 但是我们可以利用闭包传入回调函数实现七月的取消和进度通知 async async关键字用在函数声明、函数表达式、箭头函数和方法上 async function foo(){} let bar = async function(){} let baz = async() => {} class Quex(){ async qux(){} } 异步函数如果使用return关键字返回了值（默认返回undefined），这个值会被Promise.resolve()包装成一个期约对象 async function foo(){ console.log(1); return 3; //return Promise.resolve(3) } foo().then(console.log(2)); console.log(2) //1 //2 //3 异步函数async和promise期约一样，抛出错误（throw err）会返回拒绝的期约 async function foo(){ console.log(1); throw 3; } foo.catch()(console.log); console.log(2) //1 //2 //3 不过，拒绝期约的错误不会被异步函数捕获 async function foo(){ console.log(1); Promise.reject(3); } foo.catch()(console.log); console.log(2) //1 //2 //Uncaught 3 对于await，面对拒绝的期约，会释放（unwrap）错误值（将拒绝期约返回） async function foo(){ console.log(1); await Promise.reject(3); console.log(4); //这一行不会被执行 } foo.catch()(console.log); console.log(2) //1 //2 //Uncaught 3 await的限制：await关键字只能在异步函数（async）中使用 要完全理解await，必须知道他并非只是等待一个值可用这么简单，JavaScript运行时碰到await关键字时，会记录那里暂停执行，等到await右边的值可用了，JavaScript运行时会向消息队列推送一个任务，这个任务会恢复异步函数的执行 因此，即使await后面跟着一个立即可用的值，函数的其余部分也会被异步求值 async function foo(){ console.log(2); await null; //await暂停执行，为立即可用的值null向消息队列中添加一个任务，等到同步任务执行完毕后，再取出来 console.log(4) } console.log(1); foo(); console.log(3); //1 //2 //3 //4 async关键字无论从哪个方面来看，都不过是一个标识符，毕竟，异步函数如果不包含await关键字，其执行基本上跟普通函数没有什么区别。 async function foo(){ console.log(2); } console.log(1) foo(); console.log(2) //1 //2 //3 期约和异步函数 栈追踪和内存管理 期约（promise）和异步函数（async）的功能有相当程度的重叠，但是他们在内存中的表示则差别很大。 function fooPromiseExecutor(res, rej) { setTimeout(rej, 1000, 'bar'); } function foo() { new Promise(fooPromiseExecutor); } foo(); //Uncaught (in promise) bar //setTimeout //setTimeout (async) //fooPromiseExecutor //foo 栈追踪信息应该是相当直接地表现JavaScript引擎在当前栈内存中函数调用之间的嵌套关系。在超时处理程序执行时和拒绝期约时，我们看到错误信息包含嵌套函数的标识符，那是被调用以创建初期约实例的函数。可是我们知道这些函数已经返回，因此在追踪栈中不应该看到它们。 而这是因为JavaScript引擎在创建期约时尽可能保留完整的调用栈，在抛出错误时调用栈可以由运行时的错误处理逻辑获取。当然，这意味着栈追踪信息会占用内存，带来计算存储成本。 function fooPromiseExecutor(res, rej) { setTimeout(rej, 1000, 'bar'); } async function foo() { await new Promise(fooPromiseExecutor); } foo(); //Uncaught (in promise) bar //foo //async function (async) //foo 这样一改，栈追踪信息就能准确地反映了当前的调用栈。fooPromiseExecutor()已经返回，所以它不在错误信息中，但foo()由此被挂起了，并没有退出。JavaScript运行时可以简单地在嵌套函数中存储指向包含函数的指针，就跟对待同步函数调用栈一样。这个指针实际上存储在内存中，可用于再出错时生成栈追踪信息。 （这段看不太懂，不过只要理解到异步函数对比期约会减少内存消耗，因此在重视性能的应用中可以优先考虑即可）","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Ajax","slug":"Ajax","date":"2022-04-05T04:16:14.188Z","updated":"2023-03-11T17:58:00.264Z","comments":true,"path":"2022/04/05/ajax/","link":"","permalink":"https://taylor12138.github.io/2022/04/05/ajax/","excerpt":"","text":"1.Ajax概述它最大的特点是可以在网页不刷新的情况下向服务端http请求，然后得到http响应 它全称为 Asynchronous JavaScript And XML，就是异步的JS和XML，通过Ajax可以在浏览器中向服务器发送异步请求，最大优势：无刷新获取数据。AJAX不是新的编程语言，而是一种将现有标准组合在一起使用的新方式 Ajax在应用当中需要一个服务端，可以选择nodejs来配合使用 XML简介XML可扩展标记语言，是被设计用来传输和存储数据的，它和html很像，它们不同的是html中都是预定义标签，而xml没有预定义标签，全是自定义标签，用来表示一些数据 最开始ajax在进行数据交换的时候，所使用的格式就是XML 但是现在ajax都是使用json了，json相对xml更为简洁，而且在数据转换这块比较容易，可以借助json的一些api方法，快速将字符串转成js对象，灵活度远胜XML XML和HTML这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？ 区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。 显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。 Ajax特点优点： 1.可以无需刷新而与服务器端进行通信（提高用户体验） 2.允许根据用户事件来更新部分页面内容 缺点 1.没有浏览记录，不能回退 2.存在跨域问题（同源） 3.SEO不友好（搜索引擎优化）（源代码（响应体）没有部分商品信息，那些商品信息都是ajax向服务端发请求，通过服务端返结果，然后js动态创建到页面，所以爬虫也爬不到商品数据） Ajax原理Ajax请求数据流程最核心的依赖是浏览器提供的XMLHttpRequest对象，它扮演的角色相当于秘书，使得浏览器可以发出HTTP请求与接收HTTP响应。浏览器接着做其他事情，等收到XHR返回来的数据再渲染页面。 2.原生ajax的get/post请求先在script绑定事件对象 创建对象（控制平台中network也有XHR，它是对ajax请求做一个筛选） XMLHttpRequest（XHR）对象用于与服务器交互，是BOM的范畴内。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 ajax 编程中被大量使用。 初始化，设置请求方法（请求类型）和url xhr.open(method, URL, [async, user, password]) 此方法指定请求的主要参数： method —— HTTP 方法。通常是 &quot;GET&quot; 或 &quot;POST&quot;。 URL —— 要请求的 URL，通常是一个字符串，也可以是 URL 对象。 async —— 如果显式地设置为 false，那么请求将会以同步的方式处理，我们稍后会讲到它。 user，password —— HTTP 基本身份验证（如果需要的话）的登录名和密码。 此外，我们还可以通过 responseType 来设置响应格式 &quot;&quot;（默认）—— 响应格式为字符串， &quot;text&quot; —— 响应格式为字符串， &quot;arraybuffer&quot; —— 响应格式为 ArrayBuffer（对于二进制数据，请参见 ArrayBuffer，二进制数组）， &quot;blob&quot; —— 响应格式为 Blob（对于二进制数据，请参见 Blob）， &quot;document&quot; —— 响应格式为 XML document（可以使用 XPath 和其他 XML 方法）或 HTML document（基于接收数据的 MIME 类型） &quot;json&quot; —— 响应格式为 JSON（自动解析）。 xhr.open('GET', '/article/xmlhttprequest/example/json'); xhr.responseType = 'json'; 发送，send方法可以接收一个参数，作为请求体（body）发送的数据，如果不需要发送请求体，则必须传null，因为这个参数在某些浏览器中是必须的 xhr.send(null) xhr.send([body]) 事件绑定，处理服务端返回的结果 onreadystatechange on 有 when的意思，即当。。。的时候readystate是xhr对象当中的属性，表示状态0/1/2/3/4，分别对应以上步骤完成与否的状态 UNSENT，0：未初始化 OPENED，1：open方法已经调用完毕 HEADERS_RECEIVED，2：send方法已经调用完毕，并且头部和状态已经可获得 LOADING，3：loading, 下载中； `responseText` 属性已经包含部分数据。 DONE 4：服务端返回了所有的结果change 改变的时候触发，这里一般会触发四次，改一次触发一次 此时xhr对象的属性有： status状态码（200等） statusText 状态字符串（OK等） getAllResponseHeaders() 所有响应头 response 响应体 若收到相应之前如果想要取消异步请求，可以调通 abort 方法 xhr.abort() ajax的get请求案例const btn = document.querySelector('button'); const result = document.querySelector('#result'); btn.addEventListener('click', () => { //1.创建对象，控制平台中network也有XHR，它是对ajax请求做一个筛选 const xhr = new XMLHttpRequest(); //2.初始化，设置请求方法（请求类型）和url xhr.open('GET', 'http://127.0.0.1:8000/server'); //3.发送 xhr.send(); //4.事件绑定，处理服务端返回的结果 xhr.onreadystatechange = () => { //判断,服务端返回了所有的结果 if (xhr.readyState === 4) { //判断响应状态码 if (xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) { //处理结果 行、头、空行和体 //1.响应行里的数据 console.log(xhr.status); //状态码 console.log(xhr.statusText); //状态字符串 console.log(xhr.getAllResponseHeaders()); //所有响应头 console.log(xhr.response); //响应体 //2.设置result文本 result.innerHTML = xhr.response; } } } }) &lt;/script> ajax的post请求注意post和get的不同点在于： 1.初始化xhr.open(&#39;POST&#39;, url) 2.get是在初始化时，xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/server?a=100&amp;b=200&#39;);进行参数传递的 而post是在发送时send(a=100&amp;b=200);进行参数传递的 load事件Firefox最初在实现XHR的时候，曾致力于简化交互模式。最终增加了一个load事件替代readystatechange事件，load事件会在响应接收完成之后立刻触发，这样就不用检查readystate属性了。虽然onload传入了一个event对象，但是并不是所有浏览器都实现了这个event对象，所以还是使用XHR对象变量比较好 let xhr = new XMLHttpRequest(); xhr.onload = function(){ if((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) { alert(xhr.response) } else { alert('err', 'xhr.status'); } } xhr.open(xxxxxx); xhr.send(null)l 3.ajax其他http请求头 Accept：浏览器可以处理的内容类型 Accept-Charset：浏览器可以显示的字符集 Accept-Encoding：浏览器可以处理的编码类型 Accept-Language：浏览器使用的语言 Connection：浏览器与服务器连接类型 Cookie Host：所在域 Referer：发送请求的页面URI User-Agent：浏览器的用户代理字符串 我们可以通过 xhr.getResponseHeader(请求头名称) 获取响应头部 当然也可以使用 xhr.getAllResponseHeaders() 获取所有包含响应头部的字符串 ajax请求头设置设置请求头，并且必须在open之后，send之前 xhr.setRequestHeader(属性名, 属性值); xhr.open('POST', 'http://127.0.0.1:8000/server'); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send('a=100&amp;b=200&amp;c=300'); Content-Type是来设置请求体内容类型 与此同时还可以自定义属性，xhr.setRequestHeader(&#39;name&#39;, &#39;Allen&#39;); 但会报错，除非后端人员在服务器： 1.先把服务器对当前页面的post请求改成all，这样可以接受任意类型的请求 app.post(url, callback) =&gt; app.all(url, callback) 2.请求里设置 res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;); Content-TypeContent-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，一般用于表明该请求的数据类型 常见的媒体格式类型如下： text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json： JSON数据格式 application/pdf：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ：&lt;form encType=&quot;&quot;&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）使用与 URL 参数相同的编码 另外一种常见的媒体格式是上传文件之时使用的： multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式，否则和x-www-form-urlencoded 差不多 响应json数据保存在json文件的是json字符串 JSON.stringify(对象) JavaScript 值(对象或数组)转换为 JSON 字符串 JSON.parse(data) 字符转对象 或者直接在xhr.open之前设置： xhr.responseType = &#39;json&#39;，这样通过xhr.response得到的响应体数据都是以对象形式，不需要再进行JSON.parse(xhr.response) IE缓存问题ie浏览器它会对ajax的请求结果做一个缓存，这样导致下次再次发送请求时，用的是本地之前的缓存进行响应，而不是最新数据，这样导致时效性比较强的使用场景，ajax这个缓存会影响最终的结果正确的呈现 ajax关于ie缓存问题解决方法：xhr.open(&#39;POST&#39;, &#39;http://127.0.0.1:8000/server/ie?t=&#39;+Date.now()); ajax请求超时问题与网络异常我们永远不能保证服务端快速、及时的响应 这时我们对超时、异常情况给用户进行提醒（超时后自动取消请求） //超时 2s 设置 xhr.timeout = 2000; //超时回调函数 xhr.ontimeout = function () { alert(\"网络异常，请稍后重试\"); } // 网络异常回调设置 xhr.onerror = function () { alert(\"您的网络似乎出了一点问题。。。\"); } ajax取消请求上方是超时自动取消请求 这里演示的是手动取消请求 let xhr = null; btn[0].addEventListener('click', function () { xhr = new XMLHttpRequest(); xhr.open('GET', 'http://127.0.0.1:8000/server/time'); xhr.send(); }); //取消按钮 btn[1].addEventListener('click', function () { xhr.abort(); }) 请求重复发送问题过于频繁地发送请求会导致服务器压力过大 这里可以设置，再次发送请求时，把上一个请求取消掉（这里地重复发送问题让我想起了节流阀） let isSending = false; btn[0].addEventListener('click', function () { // 判断标识变量,如果正是在发送，则取消该请求，创建新的请求 if (isSending) xhr.abort(); xhr = new XMLHttpRequest(); isSending = true; xhr.open('GET', 'http://127.0.0.1:8000/server/time'); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { // 在这里不加状态码判断，因为这可能是一个失败的请求，如果加判断的话，可能导致isSending永远不为false isSending = false; } } }); 表单的同/异步提交使用jQuery实现ajax的注册小案例 （异步提交，即使用submit事件来提交数据，同步提交是直接form表单上增加属性值： action=路径, method=&quot;POST&quot;） 表单具有默认的提交行为，默认是同步的，同步表单提交缺点： 1.浏览器会锁死（转圈儿）等待服务端的响应结果。 2.表单的同步提交之后，无论服务端响应的是什么，都会直接把响应的结果（res.send()）覆盖掉当前页面。（上面crude案例没有覆盖是因为，每次post请求后都直接重定向了） 3.用户提交表单之后，页面重新渲染显示仅仅有“密码/邮箱已存在，请稍后重试”的另外一个页面，重新更改需要后退网页进行再次表单修改、提交，所以体验很不好，所以后面采用了直接res.render(当前页面, {数据渲染})+提示的方法 优点：由服务端处理，更加安全一点 异步提交: 减少服务器压力，让客户端处理更多交互效果 //&lt;form id=\"login_form\"> &lt;button type=\"submit\">登录&lt;/button> &lt;/form> $('#register_form').on('submit', function (e) { e.preventDefault() var formData = $(this).serialize() $.ajax({ url: '/register', type: 'post', data: formData, dataType: 'json', success: function (data) { var err_code = data.err_code if (err_code === 0) { // window.alert('注册成功！') // 服务端重定向针对异步请求无效 window.location.href = '/' } else if (err_code === 1) { window.alert('邮箱已存在！') } else if (err_code === 2) { window.alert('昵称已存在！') } else if (err_code === 500) { window.alert('服务器忙，请稍后重试！') } } }) }) 4.AJAX的使用工具jQuery中的AJAX要去github下载包，或者用script加载工具的网址 又或者在BootCDN网站上找到工具包网址，用script加载使用（相对于github网址更快速） 但是不建议在React、Vue里使用 get和post $.get(url, 参数, callback, type) $.post(url, 参数, callback, type) 回调函数里接收的data为响应，即服务器里send的数据 type：如响应体类型’json’则将json字符串转化为对象 &lt;button>get&lt;/button> &lt;button>post&lt;/button> &lt;script> $('button').eq(0).click(function () { $.get('http://127.0.0.1:8000/server/jquery', { a: 100, b: 200 }, function (data) { console.log(data); }, 'json'); }); $('button').eq(1).click(function () { $.post('http://127.0.0.1:8000/server/jquery', { a: 100, b: 200 }, function (data) { console.log(data); }); }) 另外一种方式，可定义的属性操作比较灵活、结构清晰，但是相对以上两种方式代码以较复杂 $('button').eq(2).click(function () { $.ajax({ url: 'http://127.0.0.1:8000/server/jquery', data: { a: 100, b: 200 }, type: 'GET', //把接收到的数据转成对象 dataType: 'json', // 成功的回调 success: function (data) { console.log(data); }, timeout: 2000, // 失败的回调 err: function () { console.log('出错啦！'); }, //头信息 // headers: { // c: 300, // d: 400 // } }) }) Axios目前（2020）年最热门的ajax工具库，要去github下载包，或者用script加载工具的网址 又或者在BootCDN网站上找到工具包网址，用script加载使用（相对于github网址更快速） 项目中使用axios居多、支持Promise（当成Promise对象来看待） axios常见配置 url：请求地址 method：请求方法 baseURL：请求根路径 transformRequest:[function(data){}]：请求前数据处理 transformResponse:[function(data){}]：请求后数据处理 headers:{‘x-Requested-With’:’XMLRequest’}：自定义请求头 params：URL查询对象（一般用于get请求） 测试请求网址我们可以使用以下网址进行请求测试 http://httpbin.org/ axios的通用方式和jQuery的方式都很像 btn[2].addEventListener('click', function () { axios({ method: 'POST', url: 'http://127.0.0.1:8000/axios', params: { id: 100, level: 500 }, headers: { a: 100, b: 200 }, // 请求体参数 data: { username: 'allen', password: 123456 } }).then(res => { //处理返回结果 console.log(res); }) }) get&amp;postget方法：axios.get(url[, config]) 如果不想把对应参数直接拼接到 url 的后面，则可以把对应参数放到params btn[0].addEventListener('click', function () { axios.get('http://127.0.0.1:8000/axios', { // url参数 params: { ID: 12345 }, }).then(value => { //这里没有使用回调函数，因为axios支持Promise，所以使用痛恨处理回调 //value是一个对象，里面包含了响应的各类信息 console.log(value); }); }); post方法：axios.post(url[, data[, config]]) 一般可以把对应参数放到data（即request.body） btn[1].addEventListener('click', function () { axios.post('http://127.0.0.1:8000/axios', { // post第二个参数可以设置请求体 username: 'allen', password: 'allen' }, { //设置其他参数，如headers等 }) }); axios.all我们在Promise中学习过处理相互依赖的并发网络请求解决方法（多个并发网络请求的响应全部到达后才去做相应处理） 但是axios本身支持支持Promise语法，所以可以直接使用 axios.all([axios(), axios().....]).then(result =&gt; {}) axios.all([ axios({url: ''}), axios({url: ''}) ]).then(results => { // results是一个数组，它包含以上异步操作的结果 console.log(results[0], results[1]); }) 全局配置事实上，在开发中很多参数都是固定的 这时候我们可以进行一些抽取，也可以利用axios全局配置 axios.defaults.配置 axios.defaults.baseURL = 'http://123.207.32.32:8000'; axios.defaults.timeout = 5000; 之后不用再次在axios中设置了（除非你想更改），已经有了默认值 axios实例和模块封装有时我们需要从不同的服务器发送请求，则需要对应不同的ip地址，这时设置全局配置不太合适 所以一般都是创建对应axios实例进行配置 // 创建实例 const instance = axios.create({ // 在里面进行实例的基本配置 baseURL: 'http://123.207.32.32:8000', timeout: 5000 }); instance({ url:'/home/multidata' }).then(res => { console.log(res); }) 而且在开发过程中，不推荐组件内直接引用第三方的 axios 进行依赖，如果有一天axios不再进行维护，改动时会十分麻烦 所以我们可以对其进行模块封装： 在src文件夹下，新建一个network文件夹，然后再该文件夹下新建一个 request.js 文件 在里面撰写基于 axios 发送网络请求、不同实例的代码 //request.js import axios from 'axios' export function request(config) { // 1.创建axios实例 const instance = axios.create({ baseURL: 'http://123.207.32.32:8000', timeout: 5000, }) return instance(config); } //main.js // 使用封装request模块 import { request } from './network/request' request({ url: '/home/multidata' }).then(res => { console.log(res); }).catch(err => { console.log(err); }) axios拦截器axios提供了拦截器，用于我们在每次发送请求或者得到响应后，进行相应的处理 拦截请求：axios.interceptors.request.use(成功的回调, 失败的回调) 拦截响应：axios.interceptors.response.use(成功的回调, 失败的回调) 下面以instance为实例，进行演示 request拦截下来的config参数其实就是我们的网络请求的配置（但没有拦截下数据） response拦截下来的结果（包含数据） request拦截下来进行处理 比如：config一些信息不符合服务器要求，添加headers之类的 比如：每次发送网络请求，都希望在界面中显示一个请求的图标，或者说展示loading组件 比如：某些网络请求（登录（token）），必须携带一些特殊的信息 const instance = axios.create({ baseURL: '...', timeout: 5000, }) //每一次发送请求之前都会被调用 instance.interceptors.request.use(config => { console.log(config); // 拦截完后必须把配置给人还回去，不然网络请求会发送失败 return config; }, err => { console.log(err); }); //每一次得到响应，则会进入到该拦截器 instance.interceptors.response.use(res => { console.log(res); // 拦截完后必须把配置给人还回去，不然网络请求无返回结果（undefined） //这里我只返回data,不看其他res的信息 return res.data; }, err => { console.log(err); }) 利用fetch发送ajax请求fetch属于全局对象，可以直接去调用，不同下载什么包，返回的结果是一个promise对象 const fetchResponsePromise = fetch(resource [, init]) resource：url，或者一个request对象 init：可选的配置项 注意：使用fetch必须定义 Content-Type（axios就不用），用json格式就要设置 ‘application/json’ application/json： 一种传输格式，在postman看到格式内容是raw的一般就是json格式的，raw指的是不会对其进行任何类型的更改 const payload = JSON.stringify({ foo: 'bar' }); const jsonheader = new Headers({ 'Content-Type': 'application/json' }) btn[0].addEventListener('click', function () { fetch('http://127.0.0.1:8000/fetch', { //请求方法 method: 'POST', // 请求头 headers: jsonheader //请求体,经MDN文档上介绍，这里可以以多种形式来撰写 body: payload }).then(res => { //返回的结果是一个promise对象,所以使用then回调方式接收和处理结果 //但是这里的res结果不是返回数据，而是提示联系服务器成功 or 失败 console.log(res); return res.json; },err => console.log(err)) //除非断网，联系不到服务器，才会被调用) .then(data => { //这里才能真正得到我们想要的数据 console.log(data); }) }) 详情可进入了解fetch介绍（十分推荐）https://segmentfault.com/a/1190000003810652 缺点：兼容性较一般 5.TS对axios的封装在typescript中对模块的封装又有点不同，主要在于我们需要预先对接口的定义 首先为我们的网络请求定义一个类 import axios from 'axios' import type { AxiosInstance, AxiosRequestConfig } from 'axios' import { IInterceptor, IConfig } from './type' // 把一大堆东西封装到一块，推荐使用类进行封装 export default class MYRequest { instance: AxiosInstance interceptors?: IInterceptor constructor(config: IConfig) { this.instance = axios.create(config) this.interceptors = config?.interceptors this.instance.interceptors.request.use( this.interceptors?.requesInterceptor, this.interceptors?.requstInterceptorCatch ) this.instance.interceptors.response.use( this.interceptors?.responseInterceptor, this.interceptors?.responseInterceptorCatch ) } request(config: AxiosRequestConfig): void { this.instance.request(config).then((res) => { console.log(res, 'request方法') }) } } 类中使用的接口（type）再给他封装成一个模块 import { AxiosRequestConfig } from 'axios' export interface IInterceptor { requesInterceptor?: (config: AxiosRequestConfig) => AxiosRequestConfig requstInterceptorCatch?: (err: any) => any responseInterceptor?: (config: AxiosRequestConfig) => AxiosRequestConfig responseInterceptorCatch?: (err: any) => any } export interface IConfig extends AxiosRequestConfig { interceptors?: IInterceptor } 然后实例化这个类，每个实例都可以单独作为网络请求的封装函数，到时候通过 实例.方法 的形式进行调用 import MYRequest from './request' import { BASE_URL } from './request/config' const myRequest = new MYRequest({ baseURL: BASE_URL, interceptors: { requesInterceptor: (config) => { const token = '123' if (token &amp;&amp; config.headers) { config.headers.Authorization = `Bearer ${token}` } console.log('请求成功拦截', config) return config }, requstInterceptorCatch: (err) => { console.log('请求失败拦截', err) }, responseInterceptor: (config) => { console.log('响应成功拦截', config) return config } } }) export default myRequest 6.跨域同源策略它是浏览器最核心也最基本的安全功能 同源，即（当前网页的url和ajax请求的目标资源的url之间）协议、域名、端口号必须完全相同，而ajax是默认遵从同源策略， 而违背同源策略就是跨域，假如当前网页时a.com，而你向b.com发送了请求，则此时是跨域请求 单台服务器的性能是有上限的，需要外加更多的计算机、服务器提升服务水平 满足同源的情况： btn.onclick = function () { const xhr = new XMLHttpRequest(); // 这里满足url同源策略，所以在以 //http://127.0.0.1:9000/home打开网站时,可以简写为/data xhr.open('GET', '/data'); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status >= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); } } } }; const express = require('express'); const app = express(); app.get('/home', (req, res) => { res.sendFile(__dirname + '/kuayu.html'); }); app.get('/data', (req, res) => { res.send('用户数据'); }) app.listen(9000, () => { console.log(\"服务已启动，9000端口监听中...\"); }) JSONP实现跨域原理JSONP：JSON with padding JSONP是一个非官方解决跨域的问题，只支持get请求。 在网页有一些标签天生具备跨域能力，比如img，link，script 优点：兼容性非常好 缺点： 是只支持get请求，不支持post请求。 不好确定请求是否失败 要保证Web服务安全性才能使用它，因为域不可信时，可能加入恶意内容，此时只能完全删除掉JSONP &lt;script src=\"http://127.0.0.1:9000/jsonp\">&lt;/script> app.get('/jsonp', (req, res) => { res.send('console.log(\"hello world\")'); }) JSONP跨域实例动态创建script标签，添加src值为请求的域名地址，再动态添加至body内部 const input = document.querySelector('input'); const p = document.querySelector('p'); // 声明handle函数 function handle(data) { input.style.border = \"solid 1px #f00\"; p.innerHTML = data.msg; }; input.addEventListener('blur', function () { let username = this.value; //1. 创建script标签 const script = document.createElement('script'); //2. 设置script的src属性 script.src = 'http://127.0.0.1:9000/jsonp'; //3.将script插入文档中(添加节点) document.body.appendChild(script); }) //服务器部分 //jsonp app.get('/jsonp', (req, res) => { const data = { exist: 1, msg: '用户名已经存在' }; // 转字符串再调用handle函数 res.send(`handle(${JSON.stringify(data)})`); }) 所以使用jsonp传输数据时，后端需要处理数据讲数据转换为json格式 jQuery实现跨域功能$(*selector*).getJSON(*url,data,success(data,status,xhr))* getJSON() 方法使用 AJAX 的 HTTP GET 请求获取 JSON 数据。而跨域的实现是通过在url后增加&#39;?callback=?&#39;，并且在服务器上调用接收jQuerycallback参数的函数 $('button').eq(0).click(function () { // 在jQuery里发送JSONP请求,这里第一个参数后一定要加'?callback=?' $.getJSON('http:127.0.0.1:9000/jQuery-jsonp?callback=?', function (data) { console.log(data); $('#result').html(` 名称: ${data.name},&lt;/br> 城市: ${data.city[1]} `) }); }) //服务器部分 app.get('/jQuery-jsonp', (req, res) => { const data = { name: 'Allen', city: ['北京', '澳门', '广州'] }; // 接收jQuerycallback那个参数 let cb = req.query.callback; // 转字符串再调用handle函数 //cb实际上是jQuery+一串数字，但他保存的其实是调用jQuerygetJSON里的回调函数 res.send(`${cb}(${JSON.stringify(data)})`); }) CORS解决跨域问题CORS，跨域资源共享，它是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊操作，完全在服务器中进行处理，支持get、post请求，跨域资源共享标准新增了一组http首部字段，允许服务器声明哪些源站通过浏览器权限访问哪些资源 工作原理：设置一个响应头（使用自定义的HTTP头部）告诉浏览器，该请求允许跨域，然后浏览器收到该响应以后对响应放行 setHeader(&quot;允许跨域响应头&quot;, &quot;*&quot;); 设置允许跨域的响应头，它们的格式分别所代表的含义是 1.origin 参数的值指定了允许访问该资源的外域 URI，可以指定该字段的值为通配符（*），表示允许来自所有域的请求。 Access-Control-Allow-Origin: | * 2.指明了实际请求所允许使用的 HTTP 方法。 Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*3.指明了实际请求中允许携带的首部字段。 Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*4.表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中，也就是说，不能发送和接受cookie。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Allow-Credentials: true等等……. 第二个参数*是通用的意思，也可以设置专用的url //服务器部分 app.all('/CORS', (req, res) => { // 设置允许跨域的响应头 res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); res.setHeader(\"Access-Control-Allow-Headers\", \"*\"); //这里表示的是只有地址为http://127.0.0.1:5500这样的网页，才能向我们这个服务发送请求 // res.setHeader(\"Access-Control-Allow-Origin\", \"http://127.0.0.1:5500\"); res.send('hello world'); }) 或者是这个（append是追加http响应头） app.use((req, res, next) => { res.append(\"Access-Control-Allow-Origin\", \"*\") res.append(\"Access-Control-Allow-Content-Type\", \"*\") next(); }) 如果设置请求头不行的话可以安装 CORS （1）安装cors： npm install cors express –save （2） 然后在文件中引用： var cors = require('cors'); var express = require('express'); var server = express(); server.use(cors()); 但实际上，上线的网站，很少用cors解决跨域，因为加上这个意味着很多网站都可以访问你 复杂请求和简单请求在涉及到CORS的请求中，我们会把请求分为简单请求和复杂请求。 浏览器限制跨域请求一般有两种方式： 浏览器限制发起跨域请求 跨域请求可以正常发起，但是返回的结果被浏览器拦截了 一般浏览器都是第二种方式限制跨域请求，那就是说请求已到达服务器，并有可能对数据库里的数据进行了操作，但是返回的结果被浏览器拦截了，那么我们就获取不到返回结果，这是一次失败的请求，但是可能对数据库里的数据产生了影响。为了防止这种情况的发生，规范要求，对这种可能对服务器数据产生不可预测影响的HTTP请求方法，浏览器必须先使用OPTIONS方法发起一个预检请求，从而获知服务器是否允许该跨域请求：如果允许，就发送带数据的真实请求；如果不允许，则阻止发送带数据的真实请求。 （OPTIONS不会携带请求参数和cookie,也不会对服务器数据产生副作用） 复杂请求：会发送发预检请求（OPTIONS请求） 简单请求 那么有哪些简单请求呢？以下是来自MDN官方引用： 1、使用下列方法之一： GET、 POST、 HEAD。 2、不得人为设置该集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type 3、Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded4、请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问 5、请求中没有使用 ReadableStream 对象 那什么是复杂请求呢，除了简单请求都是复杂请求。 postMessage这是由H5提出来的的API，IE8以上支持这个功能。window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，都遵循同源策略才能够实现通信。 window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全，原理是将通过消息事件对象暴露给接收消息的窗口。 nginx代理跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本（没有使用ajax，ajax遵守同源策略），不需要同源策略，也就不存在跨越问题。 实现思路： 通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 webpack配置代理React脚手架项目 json文件实现代理 代理未使用ajax，所以不需要遵守同源策略，但代理的域名、端口号、协议均和客户端同源，所以可以进行信息交互 比如在React中的package.json进行配置 { \"proxy\":\"http://localhost:5000\" } 然后axios向本地的代理服务器发送请求（此时本地搭建项目地址为localhost:3000） axios.get('http:localhost:3000/students').then(res => console.log(res)) //此时先去本地3000找该资源，找不到就去到5000找 优点：配置简单 缺点：但是注意这个方法只能代理一个网址，这是个取巧的方式，当我同时需要对 “http//localhost:5000”、”http//localhost:5001”发送请求，就不可以使用了，此时React可以新建一个setupProxy.js 进行正向代理（请跳转至《React(上》篇章） vue3脚手架项目 在vue.config.js文件中实现代理（对我们本地npm run serve 的服务器进行配置） module.exports = { outputDir: './build', devServer: { proxy: { '^/api': { target: '目标地址', pathRewrite: { '^/api': '' }, changeOrigin: true } } } }","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript进阶ES6(下)","slug":"JavaScript进阶ES6(下)","date":"2022-04-02T05:33:33.953Z","updated":"2022-04-02T05:33:33.953Z","comments":true,"path":"2022/04/02/javascript-jin-jie-es6-xia/","link":"","permalink":"https://taylor12138.github.io/2022/04/02/javascript-jin-jie-es6-xia/","excerpt":"","text":"5.SymbolSymbol表示独一无二的值，是ES6引入的第七种数据类型，是一种类似于字符串的数据类型（永远不会重复的字符串） 特点： Symbol的值是唯一的。解决命名冲突的问题（内部实现唯一性，不可见，也就是打印不出来） Symbol不能与其他数据进行运算（隐式类型转换会报错，但是，Symbol 值可以显式转为字符串、转为布尔值） Symbol定义的对象属性不能使用for in 、for...of 进行循环，但是可以使用 Reflect.ownKeys来获取对象的所有键名 基本创建 let s1 = Symbol(); // let s2 = Symbol('描述字符串');，我们可以通过描述字符串更好的理解这个值的作用 let s2 = Symbol('allen'); let s3 = Symbol('allen'); // 返回false，因为描述字符串类似于身份证上的名字，我们可能同名同姓但是不可能同一身份证 console.log(s2 === s3); //false Symbol.for进行创建，是作为一个函数对象，通过这种方式创建，我们是可以通过描述字符串得到得出唯一的symbol值该方法会根据给定的键 key，来从运行时的全局 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。（用于需要共享和重用符号的实例） let s4 = Symbol.for('bruce'); let s5 = Symbol.for('bruce'); //重用已有符号 console.log(s5 === s4); //true Symbol.keyFor(s4); //\"bruce\" 应用能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 注意： Symbol值作为对象属性名时，不能用点运算符。 在对象中使用变量定义属性时，必须放在方括号内，与普通键值(String)进行区分。 let mySymbol = Symbol(); // 第一种写法 let a = {}; a[mySymbol] = 'Hello!'; // 第二种写法 let a = { [mySymbol]: 'Hello!' }; a[mySymbol] // \"Hello!\" let s = Symbol(); let obj = { [s]: function (arg) { ... } }; obj[s](123); 利用Symbol的特性可定义内部私有属性或方法 function getObj(obj) { let privateKey = Symbol('privateKey'); objCopy = { ...obj } || {}; objCopy[privateKey] = function privateFunc() { console.log('privateFunc ') } return objCopy; } let newObj = getObj(); console.log(newObj[privateKey]); // 报错，外部无法获取到privateKey的值 console.log(newObj[Symbol('privateKey')]); //undefined,此时的symbol已经变成新的symbol值 Symbol的内置属性 Symbol.hasInstance：对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。 class MyClass { [Symbol.hasInstance](foo) { return foo instanceof Array; //如果直接 return false，则调用instanceof的时候无论前面接什么实例，都会返回false } } [1, 2, 3] instanceof new MyClass() // true Symbol.isConcatSpreadable：对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 let arr1 = ['c', 'd']; ['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e'] arr1[Symbol.isConcatSpreadable] // undefined let arr2 = ['c', 'd']; arr2[Symbol.isConcatSpreadable] = false; ['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e'] 还有很多，可以去阮一峰的ES6入门查看 在学习过程踩的坑var name = Symbol(); //Uncaught TypeError: Cannot convert a Symbol value to a string 在网上找的的解释： var 定义的变量会把它提升到当前函数作用域顶部，如果是浏览器全局作用域就会成为window的一个属性。 By the way，let会把变量提升到当前块级作用域顶端，如果在浏览器全局作用域下，不会让变量成为window的属性。 name 是window对象的一个固有属性，对它的赋值，会被强制转为string。 可以打开控制台打印一下window，第二个属性就是name。 给name赋值一个对象，会自动转换为string类型 symbol Symbol的隐式类型转换会报错 使用 var 声明变量 =&gt; 给 window 的变量赋值 =&gt; window.name的赋值必须转换为字符串 =&gt; 对值Symbol()转换为字符串的过程中，触犯了的 “Symbol()隐式类型转换” 6.XX器迭代器迭代器是一种接口，为各种不同数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作 实际上 Iterator接口，就是对象里面的一个属性，而属性的名字就叫做 Symbol.Iterator ES6创造了一种 for of循环，Iterator主要供 for of消费，也就是可以使用for of，就有 Symbol.Iterator属性 定义 Symbol.Iterator则定义它的迭代方式 错误：迭代失败！！！ const banji = { name: \"4399\", status: [ 'Allen', 'Bruce', 'Cat' ] } for (item of banji) { console.log(item); } next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。 正确√，重新定义了迭代器，用来迭代status const banji = { name: \"4399\", status: [ 'Allen', 'Bruce', 'Cat' ], [Symbol.iterator]() { let index = 0; return { next: () => { // 这里的this指向我们的banji // value为迭代的值，done表示是否停止迭代的状态 if (index &lt; this.status.length) { const result = { value: this.status[index], done: false }; // 下标自增，继续迭代 index++; return result; } else { return { value: undefined, done: true } } } } } } //这里的item直接输出value for (const item of banji) { console.log(item); } 迭代器中有个 return函数，该方法用于指定在迭代器提前关闭执行的逻辑，必须返回一个IteratorResult对象（通过break、continue、return、throw） class Counter{ constructor(limit){ this.limit = limit; } [Symbol.iterator](){ let count = 1; limit = this.limit; return { next(){ if(count &lt;= limit){ return {done: false, value: count++}; }else { return {done: true}; } } return(){ console.log('Exiting early'); return {done: true} } } } } 不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它们可关闭的 生成器名词解释： Generator 函数是 ES6 提供的一种异步编程解决方案 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 使用方法： Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态（使用yield分割）。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 yield有点像函数的中间返回语句，它生成的值会出现在 next()方法返回的对象里，通过 yield关键字退出的生成器函数会处于 {done: false}状态，直接通过 return 关键字退出的生成器函数会处于 done: true状态 yield语句必须在生成器函数内部使用 生成器和迭代器的关系：generator实现了 iterator接口，每一次生成器调用next方法， 生成器每一次调用 next方法之后， 返回都得是一个对象 {value: xx, done: false / true} // yield用于函数代码的分割，3个分隔符产生4块代码 function* gen() { console.log(\"123\"); yield 'aaaaa'; console.log(\"456\"); yield 'bbbbb'; console.log(\"789\"); yield 'cccc'; } let gen1 = gen(); console.log(gen1); //生成器对象gen // 生成器函数的执行必须调用迭代器的next()，value的值 = yield后的值 //这里的item是执行相对代码块后，然后输出value for (item of gen1) { console.log(item, \"这是一个片段\"); } //123 //aaaaa 这是一个片段 //456 //bbbbb 这是一个片段 //789 //cccc 这是一个片段 //或者使用： // gen1.next(); ///123 // gen1.next(); ///456 在生成器的next传入实参，传入的参数作为上一个yield语句的整体返回结果 function* gen(arg) { console.log(arg); let one = yield 111; console.log(one); let two = yield 222; console.log(two); let three = yield 333; console.log(three); } let iterator = gen('AAA'); //这里输出的是yield的返回值，而不是输出value，所以你看不到111，222，333的输出 iterator.next(); //AAA； 第一个next虽然没有传值，但是第一次调用next()，你即使传入的值不会被使用（来自红宝书 p196），因为这一次调用是为了开始执行生成器函数 iterator.next(); //undefined iterator.next('BBB'); //BBB iterator.next('CCC'); //CCC 生成器应用异步编程 下面使用 setTimeout 模拟异步任务的执行 function getUser() { setTimeout(() => { let data = \"用户信息\" iterator.next(data); }, 1000) } function getGood() { setTimeout(() => { let data = \"商品信息\" }, 1000) } function* gen() { let data = yield getUser(); console.log(data); yield getGood(); } let iterator = gen(); iterator.next(); 不过此时在内部居然要依赖外部的变量 iterator，有点耦合度太大了，不太好 async await 的实现原理此时替换成以下形式（async await 的实现原理） function getUser() { return new Promise((res, rej) => { setTimeout(() => { let data = \"用户信息\" res(data) }, 1000) }) } function getGood(args) { return new Promise((res, rej) => { setTimeout(() => { let data = \"商品信息 \" + args res(data) }, 1000) }) } function* gen() { const data = yield getUser(); console.log(data); const data2 = yield getGood(data); console.log(data2); } function run(fn) { const gen = fn() function next(data) { const res = gen.next(data) if (res.done) return res.value res.value.then(res => { next(res) }) } next() } run(gen) 使用迭代器构造小型计时器（案例） function* gen() { for (let i = 0; i &lt; 5; i++) { setTimeout(() => { console.log(i); a.next(); }, 1000); yield; } } let a = gen(); a.next(); 生成器实现机制协程阮一峰老师也说过：Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 让生成器的阻塞机制：协程，我们需要一探究竟 协程：协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。 协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。 操作系统并不知道协程的存在，它只知道线程，因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。 因此在协程中不能调用导致线程阻塞的操作。也就是说，协程只有和异步IO结合起来，才能发挥最大的威力。 一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将JS 线程的控制权转交给 B协程，那么现在 B 执行，A 就相当于处于暂停的状态 举一个例子（来源于https://juejin.cn/post/6844904004007247880#heading-24的生成器例子） function* A() { console.log(\"我是A\"); yield B(); // A停住，在这里转交线程执行权给B console.log(\"结束了\"); } function B() { console.log(\"我是B\"); return 100;// 返回，并且将线程执行权还给A } let gen = A(); gen.next(); // 我是A 我是B gen.next(); // 结束了 循环状态机通过ES5babel的转换，我们可以看到以下的ES6代码的转换 function* generateRandoms (max) { max = max || 1; while (true) { let newMax = yield Math.random() * max; if (newMax !== undefined) { max = newMax; } } } var generateRandoms = regeneratorRuntime.mark(function generateRandoms(max) { var newMax; return regeneratorRuntime.wrap(function generateRandoms$(context$1$0) { while (1) switch (context$1$0.prev = context$1$0.next) { case 0: max = max || 1; case 1: if (!true) { context$1$0.next = 8; break; } context$1$0.next = 4; return Math.random() * max; case 4: newMax = context$1$0.sent; if (newMax !== undefined) { max = newMax; } context$1$0.next = 1; break; case 8: case \"end\": return context$1$0.stop(); } }, generateRandoms, this); }); 其中是通过状态机的模拟（switch + 无限循环while）实现，退出循环的时候是通过判断当前是否到达最后一步进行break 这一片文章作者自己设计代码模拟原生的generator并且讲解的很详细，值得一看https://zhuanlan.zhihu.com/p/216060145 7.其他可选链可选链是ES11（2020）中增加的特性 它作用是当对象属性不存在时，会短路，直接返回undefined，如果存在，那么才会继续执行 使用：（ 如果b不为undefined则继续进行属性查找找到c ） const a = { b: { c: \"allen\" } } console.log(a.b?.c) 执行上下文 &amp; 作用域变量和函数的上下文决定了他们可以访问哪些数据，以及他们的行为，每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象之上。（个人理解，上下文 = 他们的作用域） 全局上下文：全局上下文是最外层的上下文，根据ESMAScript的宿主环境对象可能不一样。但是在浏览器中，全局上下文就是我们常说的window对象。上下文在其所有代码都执行完毕后会被销毁，而全局上下文在应用程序退出前才会被销毁，比如关闭网页、退出浏览器。 函数上下文：每个函数都有自己的上下文，当函数上下文被推到一个上下文栈上，当函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的上下文 内部上下文可以通过作用域链访问外部上下文的一切，但是外部上下文无法访问内部上下文的一切，即每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文去搜索。 注意 除了全局上下文 和 函数上下文，还有eval()第三种上下文 而且还有其他方式来增强作用域，比如某些语句会导致在作用域链前端临时添加一个上下文，比如 try/catch、with 诡异行为小思考先上代码，先上代码 console.log(a) // undefined { a=1 function a() {} } console.log(a) // 1 console.log(a) // undefined { function a() {} a=1 } console.log(a) // func a 我在网上搜到的部分参考，希望对你们有帮助","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript进阶ES6(上)","slug":"JavaScript进阶ES6(上)","date":"2022-04-02T04:15:14.533Z","updated":"2022-10-17T11:52:34.982Z","comments":true,"path":"2022/04/02/javascript-jin-jie-es6-shang/","link":"","permalink":"https://taylor12138.github.io/2022/04/02/javascript-jin-jie-es6-shang/","excerpt":"","text":"1.ESMAScript6ES6其实是一个泛指，泛指ES2015后续的版本 2.新增语法声明变量ES5之前因为if、for都没有块级作用域的概念，所以很多时候都需要借助 function的作用域 解决应用外部变量的问题 let 声明的变量 1.只在所处块级有效（大括号中有效，也就是说if和for都有它的块级作用域了），可以防止循环变量变成全局变量 2.不存在变量提升，只能先声明再使用，不可重复声明 3.暂时性死区（即在块级作用域中使用某变量，则会先在该块级中查找此变量） var num = 10; if(true) { console.log(num); //报错，变量声明在后面 let num = 20; } 利用let解决异步问题：（因为let仅在当前块级有效，每个迭代蓄奴含声明一个新的迭代变量，然后使用上一个迭代结束时的值来初始化这个变量。） for (let i = 0; i &lt; lis.length; i++) { lis[i].onclick = function () { console.log(i); } } const声明常量，常量就是值（内存地址）不能变化的量（值可以改，内存地址不能变） 1.具有块级作用域 2.const声明常量时必须赋值 3.基本数据类型：常量赋值后，不可修改；复杂数据类型：对象赋值后（数组之类的）不可更改，但是可以更改数据结构内部的值 4.不存在变量提升，只能先声明再使用 const ary = [100, 200]; ary[0] = 'a'; //可以 //ary = ['a', 200]; //不可以 ES6之前的块级作用域： 原来的代码 { let a = 2; console.log(a); } console.log(a); 以前的代码来实现(丑的要死！！！) try{ throw 2; } catch(a) { console.log(a); } console.log(a) 解构赋值ES6允许从数组或者对象（分别使用[]、{}）中一一提取值，按照对应的位置，对变量赋值 //数组 let ary = [1, 2, 3]; let [a, b, c, d, e] = ary; //1, 2, 3, undefined, undefined //也可以 let [a, b, c] = [1, 2, 3]; //对象 let person = {name: 'zhangsan', age: 20}; let {name, age} = person; let {name, age = 18} = person; //解构赋值，如果原来person没有age属性，则定义默认值age = 18 对象的另一解构写法（重命名） let {name: myName, age: myAge} = person; 如果name和age分别和person中的属性值匹配成功，则将左侧该属性值赋值给右边的myName，myAge变量 除此外，还有嵌套解构赋值写法 //4.对象的解构赋值 let obj = {a:{b:1}}; const {a:{b}} = obj; //我们得到b的数据 console.log(b); //1 箭头函数(形参) =&gt; {函数体} 箭头函数用来简化定义函数语法 const fn = () => { console.log('xx'); } // 也可以，返回undefined //const fn = () => console.log('xx'); 如果函数体只有一句话，且代码执行结果就是返回值，则可以省略大括号 //传统 function sum(num1, num2) { return num1+num2; } //new const sum1 = (num1, num2) => num1+num2; 如果形参只有一个，小括号可以省略 //传统 function sum(a) { return a; } //new const sum1 = a => a; 如果返回的是一个对象，不能直接加大括号 //const sum1 = a => {}; 错，返回undefined const sum1 = a => ({}); //对 箭头函数和传统函数不一样，箭头函数的this指向函数定义位置（使用了箭头函数的那个函数）的上下文this（定义函数地点最近作用域中的this） 也就是说，箭头函数的this使用的是词法作用域，而不是this原来的动态作用域 此时我们认为箭头函数将程序员们经常犯的一个错误标准化了，也就是混淆this绑定规则（动态作用域）和词法作用域规则 但是 箭头函数不适合事件回调 function fn() { console.log(this); return () => { console.log(this); } } const obj = { name: 'zhangsan' }; const resFn = fn.call(obj); //这时this指向obj，所以箭头函数跟着指向obj 返回{ name: 'zhangsan' } resFn(); //箭头函数中this指向指向上下文this，此时箭头函数this跟着上下文this发生改动，输出{ name: 'zhangsan' } 2.不适合对象的方法 对象不能产生作用域，所以箭头函数实际被定义在全局作用域下，所以此处的this指向window，所以箭头函数处的this.age未定义 var obj = { age: 20, say: () => { alert(this.age); //undefined }, con: function () { console.log(this); //obj } } obj.say(); obj.con(); const obj = { aaa() { setTimeout(function () { setTimeout(function () { console.log(1, this); //window }) setTimeout(() => { console.log(2, this); //window }) console.log(3, this); //window }) setTimeout(() => { setTimeout(function () { console.log(4, this); //window }) setTimeout(() => { console.log(5, this); //obj }); console.log(6, this); //obj }); } } 3.由于箭头函数必须以赋值声明的方式出现，所以没有变量提升 //会出错，使用var也会出错 console.log(sum(10, 10)); let sum = (num1, num2) => { return num1 + num2 } 4.箭头函数是不存在原型的 const arrow = () => { console.log('a'); } function fn() { console.log('a'); } console.log(arrow.prototype); // undefined console.log(fn.prototype); // {constructor: ƒ} arguments的使用当我们不确定函数用多少个参数来传递的时候，arguments实际上是当前函数的一个内置对象（函数才拥有），arguments储存了传递的所有实参,它展示的方式是伪数组，因此可以进行遍历（使用for等） 注意： 箭头函数是用不了arguments（虽然箭头函数也用不了它，但是可以使用剩余参数补足） arguments对象的值不反映参数的默认值（当函数设置了默认参数值），它始终以调用函数时传入的值为准 function fn(){ console.log(agruments); console.log(agruments.length); } fn(1,2,3); //则输出1，2，3 //3 arguements 的值始终会与对应的命名参数同步（修改arguments[i]，会对应修改第i个参数的值），但这并不意味着它们都访问同一个内存地址，这种同步是单向的，修改命名参数的值，不会影响argument[i] 对应的值 function a(a, b) { arguments[0] = 100; console.log(a, 'this is a'); //100 a = 50; console.log(arguments[0], 'this is argument[0]'); //100 } let aaa = 1, b = 2; a(aaa, b) console.log(aaa); //1 伪数组：1.具有length属性 2.按索引凡是储存数据 3.不具有push，pop功能 注意： 对参数使用slice会阻止某些JavaScript引擎中的优化 (比如 V8 - 更多信息)。如果你关心性能，尝试通过遍历arguments对象来构造一个新的数组。另一种方法是使用被忽视的Array构造函数作为一个函数： var args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));剩余参数剩余参数语法（展开运算符）允许我们将一个不定数量的参数表示为一个数组 ...args 潜规则： ...args要放到参数的最后，不然会报错 //1.作为传参（rest参数） function sum(first, ...args) { console.log(first); //10 console.log(args); //20, 30 } sum(10, 20, 30); //2.剩余参数配合解构 let students = ['allen', 'berry', 'david']; let [s1, ...s2] = students; //s1为allen，s2为[berry. david]的数组 //3.作为参数传入，将数组arr2里的数据划分成若干个，然后一个一个传入数组arr1：（扩展运算符） arr1.push(...arr2); 和arguments不一样的是，arguments得到的是一个对象，而…args中 args得到的是一个数组，可以使用数组方法（filter、some、map、every等） function data1(){ console.log(arguments); } function data2(...args){ console.log(args); } 利用args手写new 应证了《你不知道的JavaScript》里 创建一个全新的对象 这个新对象会被执行Prototype连接 新对象会绑定到函数调用的this 如果函数没有其他返回值，那么new表达式中的函数调用会自动返回这个新对象 function _new(Constructor, ...args) { var obj = {}; obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, args) return ret instanceof Object ? ret : obj; } function One(a) { this.a = a; } let a = new One('good'); let b = _new(One, 'good'); console.log(a); console.log(b); 展开运算符剩余语法(Rest syntax) 看起来和展开语法完全相同，不同点在于, 剩余参数用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：展开语法将数组展开为其中的各个元素，而剩余语法则是将多个元素收集起来并“凝聚”为单个元素。（来源于MDN） 运用于数组 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; arr1 = [...arr2, ...arr1]; 一般展开运算符只能展开可迭代对象，对于对象，但是可以 使用 let person1 = {...person2}进行展开 参数默认值可以给函数附上默认的参数值，在调用时没有给到的形参会用默认值代替 一般具有默认值的参数都靠后（潜规则） function add(a, b ,c=10){ return a + b + c; } console.log(add(1, 2)); //13 3.ES6内置对象的扩展array的扩展 ...ary 扩展运算符是和剩余参数相反的原理，它可以将数组或者对象转为用逗号分隔的参数序列 ...ary let ary = [1, 2, 3]; console.log(...ary); // 1, 2, 3 //相当于 console.log('1', '2', '3'); 扩展运算符应用：数组合并 //方法一： let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; //方法二 ary1.push(...ary2); ...ary扩展运算符还能把伪数组转换成真正的数组，然后可以使用数组的方法 可计算属性名 ES6增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式当作属性名 const prefix = \"foo\"; const obj = { [prefix + \"bar\"]: \"hello\" } string的拓展ES6新增的创建字符串的方式，使用反引号定义 let name = allen;(模板字符串) 模板字符串的特点： 1.可以解析变量，不用字符串拼接${变量名} 2.可以换行，撰写较为美观 3.可以调用函数，得到的结果为函数返回值${函数名()} const saySomething = () => '我是函数'; let a = `allen`; let = `hello, my name is ${name}`; let html = `&lt;div> &lt;span>${saySomething()}&lt;/span> &lt;/div>`; set数据结构ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值（不会存储重复的值）、自动去重 集合实现了 iterator接口，所以可以使用 for of Set本身是一个构造函数，用来生成Set数据结构 const s = new Set([\"a\", \"a\",\"b\"]); console.log(s.size); const ary = [...s]; //数组去重 s.add(value) 添加某个值，返回Set结构本身 s.delete(value) 删除某个值，返回布尔值表示删除成功与否 s.has(value) 返回布尔值，查看是否为Set成员 s.clear() 清空所有成员 s.values()查看所有元素 s[Symbol.iterator] s.size() 返回Set实例的成员总数 Set结构实例与数组一样，也有forEach方法，用于对每个成员执行某种操作，没有返回值 map数据结构 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key），“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键 （Object的键只能为字符串，其实还能为数值或符号，但它们都会转化为字符串）。 Map 的遍历顺序就是插入顺序。 使用对象作为键是 Map 最值得注意和重要的功能之一 let map = new Map(); let john = { name: \"John\" }; map.set('1', 'str1'); // 字符串键 map.set(1, 'num1'); // 数字键 map.set(true, 'bool1'); // 布尔值键 map.set(john, 123)); // 对象键 // 还记得普通的 Object 吗? 它会将键转化为字符串 // Map 则会保留键的类型，所以下面这两个结果不同： alert( map.get(1) ); // 'num1' alert( map.get('1') ); // 'str1' alert( map.size ); // 3 当然也可以接受一个数组作为参数 const map = new Map([ ['name', '张三'], ['title', 'Author'] ]); 方法 + 属性 new Map() —— 创建 map。 map.set(key, value) —— 根据键存储值。 map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。 map.has(key) —— 如果 key 存在则返回 true，否则返回 false。 map.delete(key) —— 删除指定键的值。 map.clear() —— 清空 map。 map.size —— 返回当前元素个数。 map.keys() —— 遍历并返回所有的键（returns an iterable for keys，返回一个引用的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的key值。） map.values() —— 遍历并返回所有的值（returns an iterable for values） map.entries()—— 遍历并返回所有的键值对，entries实际上是引用了 [Symbol.iterator]这个属性 map.entries === map[Symbol.iterator] //true 只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。 const map = new Map(); map.set(['a'], 555); map.get(['a']) // undefined map和Object对比： 1.内存占用：给固定大小的内存，Map大约可以比Object多存储50%键值对 2.插入性能：Object和Map插入新的键值对消耗大致相当，不过插入Map在所有浏览器中一般会稍微快一点儿 3.查找速度：与插入不同，从大型Object和Map中查找键值对的性能差异极小，如果涉及大量查找工作（对两个类型而言，查找速度不会随着键值对数量增加而增加），某些情况可能Object更好一点 4.删除性能：删除Objcet属性的性能一直以来饱受诟病，而对于大多数浏览器引擎来说，Map的delete()删除操作甚至比插入和查找更快，无疑时Map完胜 弱引用类型（很多属性、迭代方法不能用 + 保存的元素有限制） let s = new WeakSet()保存的元素必须得是引用类型（对象 / 数组）（DOM元素也是对象，所以也能存储） let map = new WeakMap()的key 必须得是引用类型（对象 / 数组）（DOM元素也是对象，所以也能存储） 弱引用不支持遍历方法，只有四个方法可用，get()、set()、has()、delete() 正常引用类型的垃圾回收： 谁引用这个数据，就引用次数 + 1， 原来引用这组数据，后面赋值为null，引用次数 -1 当这组数据引用次数为0，则根据垃圾回收机制会被回收掉 弱引用类型的垃圾回收： 当weak弱引用数据时，引用次数不会 + 1 这样的话优点就是，清除变量的时候，不用再去weak弱引用类型那里进行清除（不用赋值null） obj的拓展利用对象字面量创建对象即直接用{}创建对象而不是new出来，而ES6新增对象字面量的增强写法 const name = 'Allen'; const age = 18; const height = 1.88; // ES5对象字面量各类属性、函数写法 obj = { name: name, age: age, height: height, run: function () { } }; // ES6对象字面量各类属性、函数写法 obj2 = { name, age, height, run() { } //此写法仅支持在字面量/类中 }; 判断一个对象是否为空，可以使用 Object.key(对象名称).length === 0 js 判断对象的属性是否存在 in运算符 （属性名 in 对象） 情况1:对象自身属性 var obj={a:1}; \"a\" in obj//true 情况2:对象继承的属性 var objA = {a:1}; var objB = Object.create(A) \"a\" in objB //true 查找符合条件的第一个对象 find(function(currentValue, index, arr),thisValue) 参数 描述 currentValue 必需。当前元素 index 可选。当前元素的索引值 arr 可选。当前元素所属的数组对象 thisValue 可选。 传递给函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值 //实现一步查找符合条件的product let product = state.cartList.find(item => item.id === payload.id); 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined。 对象使用变量名作为键名 let a = 'name'; let obj = {}; //obj.a = 'Allen'错误！ obj[a] = Allen //正确 又或者 let a = 'name'; let obj = { [a]:'Allen' }; 4.Promisecallback hell回调地狱：callback hell，异步里面套着另一个异步 无法保证异步任务执行顺序： var fs = require('fs'); fs.readFile('./index.txt', function (err, data) { if (err) { // throw的作用：抛出异常 //即1.阻止程序的执行， 2.把错误信息打印到控制台 throw err; } console.log(data); }); fs.readFile('./index2.txt', function (err, data) { if (err) throw err; console.log(data); }); fs.readFile('./index3.txt', function (err, data) { if (err) throw err; console.log(data); }); 通过回调嵌套的方式来保证顺序，但由此催生了回调地狱，语法十分丑陋，代码丑陋 fs.readFile('./index.txt', function (err, data) { if (err) { // throw的作用：抛出异常 //即1.阻止程序的执行， 2.把错误信息打印到控制台 throw err; } console.log(data); fs.readFile('./index2.txt', function (err, data) { if (err) throw err; console.log(data); fs.readFile('./index3.txt', function (err, data) { if (err) throw err; console.log(data); }); }); }); Promise为了避免回调地狱嵌套，所以ES6中新增了API：Promise（生产微任务） 应用场景：数据来源于多个接口，出现回调嵌套 Promise本身不是异步的，只是里面的任务往往都是异步的 new Promise(resolve => { resolve(); console.log(\"promise\"); }).then(value => console.log(\"success!\")); console.log(\"end\"); //执行顺序: //promise //end //success! 创建一个promise容器 =&gt; 而这里容器一旦创建，就开始执行里面的代码 =&gt; 容器中存放一个异步任务默认pending状态，表示正准备去做，即将发生的 个人觉得：resolve和reject类似于两个callback，然后再外面进行回调罢了finally()方法用于指定不管Promise对象最后状态如何（无论结果是fulfilled或者是rejected），都会执行的操作，该方法时ES2018引入的标准 var fs = require('fs'); //封装实例化Promise+读取数据API function ProReadFile(Path) { return new Promise(function (resolve, reject) { fs.readFile(Path, 'utf8', function (err, data) { if (err) { // 失败了，承诺容器中的任务失败 // 把容器的pending状态改为Rejected // 调用reject相当于调用了then方法第二个参数函数 reject(err); } else { // 承诺容器中的任务成功 // 把容器的pending状态改为成功Resolved // 调用resolve相当于调用了then方法第一个参数函数 resolve(data); } }) }); }; 当返回结果成功后，then做指定操作 使用Promise过程中resolve或reject后，后面代码还会执行，除非你直接return then的说明： then(resolve(), reject()) 成功状态Fulfilled时（resolve，成功则进入下一个then），then方法接收两个参数:1.容器中的resolve函数, 2.容器中的reject函数，这里把then看成一个整体，then会默认返回一个fulfilled状态的Promise 失败状态Rejected（自己设置判断失败的条件，然后reject函数），会回调catch 在类里面定义 一个then方法，那么他会包装成一个Promise，但是注意这个Promise 默认没有状态，需要手动去 resolve 或者 reject ProReadFile('./index.txt') .then(function (data) { console.log(data); //当第一个读取成功时，这里返回后面想要继续执行的Promise异步任务，如果没有返回，则后面收到的是undefined //我们真正有用的是return 一个Promise对象 //如果return 123，则接下来的then的function参数接受的data是123，而且并不是前面的异步任务执行完毕才进入下一个then return ProReadFile('./index2.txt'); }, err => { console.log('读取文件失败', err); throw 'error message'; //要调用这个，不然返回undefined，会进入下一个then的resolve的回调 }) .then(function (data) { console.log(data); //第二个读取成功时，这里返回后面想要继续执行的Promise异步任务 return ProReadFile('./index3.txt'); }, err => { console.log('读取文件失败', err); throw 'error message'; }) .then(function (data) { console.log(data); }, err => { console.log('读取文件失败', err); }) catch效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中（推荐把catch放在链式结构的最后，前面无论第几个出错，都会跑到最后执行这个catch（除非你事先在前面用reject的回调函数处理过错误结果了））。请看下面的代码： ProReadFile('./index.txt') .then(function (data) { console.log(data); return ProReadFile('./index2.txt'); }).catch(err => {console.log('文件读取失败', err)}) 特殊情况状态传递 注意：如果resolve或reject中的参数是promise实例对象 var p1 = new Promise(function (resolve, reject) { setTimeout(function () { resolve('1'); }, 3000); }) var p2 = new Promise(function (resolve, reject) { setTimeout(function () { resolve(p1); // resolve的参数是一个promise对象 }, 1000); }); p2 .then(function (data) { console.log('resolve执行') console.log(data) }, function (err) { console.log(err) }) 3s后依次打印 ‘resolve执行’ ‘1’ （时间 = max （p1的定时时长, p2的定时时长）） 这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。（实际上有点像是promise.allSettle的原理？） let p1 = new Promise((resolve, reject) => { reject(\"拒绝\"); }) new Promise((resolve, reject) => { resolve(p1); }).then(res => { console.log(\"res\"); }, err => { console.log(\"err\", err); }) //err 拒绝 上面说到p1的状态会传递，所以这里p1的状态是Rejected，传递给了下面这个Promise，执行的是Rejected的回调 返回值问题 注意 如果返回值为一个普通参数 then方法会返回一个新的promise,这个新promise的value由return的值决定 执行return语句后不是Promise实例，是123，则导致当前then方法返回的promise变为成功状态 pending-&gt;fulfilled(Resolved) 在这里它其实是 return new Promise.resolve(123)的简写 var p2 = p1.then(function (data) { console.log(data); return 123456 }, err => { console.log('读取文件失败', err); }) .then(function (data) { console.log(data); // 这个回调一定会被调用，打印123456 }, err => { console.log('读取文件失败', err); }) 注意 甚至没有返回值时，它还会自动给你 pedding -&gt; fulfilled，（因为会返回默认返回值undefined）然后进入下一个then的第一个成功的回调函数里 而反而如果你 return 了一个promise实例，在这个实例里面没有调用 resolve 或者 reject，就进入不了下一个then里面 所以！！！ 因为异步操作我们才使用Promise，而返回值非Promise的情况会导致未执行完异步操作则直接进入下一步的then里面，这样和原来未使用Promise语句地执行方式相同，和我们想要有序地进行异步操作的初衷背道而驰 所以我们推荐返回值返回一个 new Promise，这样等到Promise实例调用resolve / reject后才会进入下一步then，才符合我们的代码规范和初衷！！ 直接抛出异常问题 注意 如果想要返回后直接跳转到下一个then的reject函数里，可以直接 throw ErrorMessage 执行throw语句后，导致当前then方法返回的promise变为失败状态 pending-&gt;Rejected 因为它其实是 return new Promise.reject(&#39;error message&#39;)的简写 var p2 = p1.then(function (data) { console.log(data); throw 'error message'; }, err => { console.log('读取文件失败', err); }) .then(function (data) { console.log(data); }, err => { console.log('读取文件失败', err); // 这个回调一定会被调用 }) 双重then问题 注意 then方法提供一个供自定义的回调函数，若传入非函数，则会忽略当前then方法。 以下的例子就是忽略了第一个then，因为它未传入函数，传入的是 ‘新的值’ let func = function() { return new Promise((resolve, reject) => { resolve('返回值'); }); }; let cb = function() { return '新的值'; } func().then(cb()).then(resp => { console.warn(resp); console.warn('========='); }); //输出：返回值 ============ 状态问题 注意 在执行promise后，return时都会包装成一个新的Promise实例，但如果then方法还未被调用，则这个实例它的状态还是pedding let p1 = new Promise((resolve, reject) => { resolve(\"fulfilled\"); }) let p2 = p1.then( val => {console.log(val);}, err => {console.log(err)} ) console.log(p1); console.log(p2); setTimeout(()=>{ console.log(p1); console.log(p2); }) //输出 //Promise&lt;resolved> //Promise&lt;pending> //fulfilled //Promise&lt;resolved> //Promise&lt;resolved> Promise的all方法使用应用场景：处理多个相互依赖的异步请求 Promise.all([ new Promise((resolve, reject) => { setTimeout(() => { resolve('hello'); }, 1000); }), new Promise((resolve, reject) => { setTimeout(() => { resolve('world'); }, 2000); }) ]) // 两个网络请求都完成后才会进入then // 如果有一个失败，此回调直接失败，失败原因是那个第一个失败的promise .then(results => { // results是一个数组，它包含以上异步操作的结果 console.log(results[0], results[1]); }) 除了 all之外，还有allSettle、race方法，分别表示 allSettle：只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束，返回一个对象数组，每个对象表示对应的promise结果 race：谁执行的快就取决于谁的状态 any：只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 （感觉race方法可能是封装ajax中设置请求超时时长的原理） 有空还可以看看大佬手写promise.all和promise.race https://blog.csdn.net/qq1498982270/article/details/93922893 async和await语法糖async和await时Promise的语法糖 （2021.6.27纠正，我在《红宝书的啃读》篇目解释了它们在内存中的差别） 使用 await 异步函数() 相当于 .then(res =&gt; { return 异步函数() })，处理异步任务，有异步任务 -&gt; 同步任务的感觉，记得每次都把异步任务放在await后面，而且每次在await 异步操作之后的同步任务就像被放在另一个then里面，会等待异步任务的完成后再执行 async function pro(delay = 1000) { return new Promise((resolve, reject) => { setTimeout(() => { resolve(\"hello\"); }, delay); }) } async function show() { for (const item of [\"Allen\", \"Bruce\", \"Carry\"]) { let hello = await pro(); console.log(item); console.log(\"hello\"); console.log(\"world\"); } } show(); // //原始方法 // let p = Promise.resolve(); // for (const item of [\"Allen\", \"Bruce\", \"Carry\"]) { // p = p.then((res) => { // return pro(); // }).then(() => { // console.log(item); // console.log(\"hello\"); // console.log(\"world\"); // }) // } 语法糖可以配合 then、 catch一起使用 async function fn() { return await new Promise((resolve, reject) => { setTimeout(() => { console.log(\"nononon\"); resolve(); }, 1000); }) } fn().then(res => { console.log(\"success\"); }).catch((err) => { console.log(err); }) async + await实现并行执行 （配合Promise.all） async function fn(k) { return await new Promise((resolve, reject) => { setTimeout(() => { console.log(k); resolve(k); }, 1000); }) } async function hd() { let res = await Promise.all([fn(\"hello\"), fn(\"world\")]) console.log(res); } hd(); await 内部实现了 generator，其实 await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator Promise缺点 无法取消Promise,一旦新建它就会立即执行，无法中途取消。（只能抛出错误中断（throw））(JavaScript高级程序设计有提及到) 如果不设置回调函数，promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。(JavaScript高级程序设计有提及到) 可能代码撰写比较繁琐 + 冗长 手写promise函数体内部首先创建了常量 that，因为代码可能会异步执行，用于获取正确的 this 对象（即this一开始指向MyPromise，后面指向window） const PENDING = 'pending' const RESOLVED = 'resolved' const REJECTED = 'rejected' function MyPromise(fn) { const that = this //此时this指向MyPromise that.state = PENDING that.value = null that.resolvedCallbacks = [] that.rejectedCallbacks = [] // 待完善 resolve 和 reject 函数 function resolve(value) { //此时this指向window if (that.state === PENDING) { that.state = RESOLVED that.value = value that.resolvedCallbacks.map(cb => cb(that.value)) } } function reject(value) { if (that.state === PENDING) { that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb => cb(that.value)) } } // 待完善执行 fn 函数 try { fn(resolve, reject) } catch (e) { reject(e) } } // then方法 MyPromise.prototype.then = function (onFulfilled, onRejected) { //实际上这里面的的this都指向MyPromise，甚至不换成that也行，但是为了美观和易读性都换成that const that = this onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v onRejected = typeof onRejected === 'function' ? onRejected : r => { throw r } if (that.state === PENDING) { that.resolvedCallbacks.push(onFulfilled) that.rejectedCallbacks.push(onRejected) } if (that.state === RESOLVED) { onFulfilled(that.value) } if (that.state === REJECTED) { onRejected(that.value) } } 实践 new MyPromise((resolve, reject) => { setTimeout(() => { resolve(1) // 此时环境下this为window }, 2000) }).then(value => { console.log(value) }) 5.Error当运行时错误产生时，Error 对象会被抛出。Error 对象也可用于用户自定义的异常的基础对象。下面列出了各种内建的标准错误类型。 我们通常在异步请求后使用try catch捕获，在发生请求错误的时候可以throw 一个 Error fetchAPI().then((res) => { console.log(res); if (!res) throw new Error('当前没有返回值？？： no response'); }).catch((e) => { console.log(e); }); 其他error除了通用的 Error 构造函数外，JavaScript 还有其它类型的错误构造函数。对于客户端异常，详见异常处理语句。 EvalError 创建一个 error 实例，表示错误的原因：与 eval() 有关。 RangeError 创建一个 error 实例，表示错误的原因：数值变量或参数超出其有效范围。 ReferenceError 创建一个 error 实例，表示错误的原因：无效引用。 SyntaxError 创建一个 error 实例，表示错误的原因：语法错误。 TypeError 创建一个 error 实例，表示错误的原因：变量或参数不属于有效类型。 URIError 创建一个 error 实例，表示错误的原因：给 encodeURI() 或 decodeURI() 传递的参数无效。 AggregateError 创建一个 error 实例，其中包裹了由一个操作产生且需要报告的多个错误。如：Promise.any() 产生的错误。 InternalError 非标准 创建一个代表 Javascript 引擎内部错误的异常抛出的实例。如：递归太多。 当然也可以自定义Error class PayError extends Error { constructor(code, message, other = null) { super(message); this.code = code; this.other = other; } }","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React拓展","slug":"React拓展","date":"2022-03-30T16:00:00.000Z","updated":"2022-11-13T07:55:44.258Z","comments":true,"path":"2022/03/31/react-tuo-zhan/","link":"","permalink":"https://taylor12138.github.io/2022/03/31/react-tuo-zhan/","excerpt":"","text":"拓展GraphQLGraphQL是Facebook开发的一种查询语言，并于2015年发布，它是REST API的替代品 它既是一种用于API的查询语言，也是一个满足你数据查询运行时，GraphQL对你的API的数据提供了一套易于理解的完整描述，使得客户端能够准确获取他需要的数据，且没有任何冗余，也让API更容易随着时间推移而演进 中文网https://graphql.cn/ 特点： 请求需要的数据，不多不少 获取多个资源，只用一个请求 描述所有可能类型的系统，根据需求平滑推进，添加或隐藏字段 但是需要后端也改造成GreaphQL的方式 DvaJSdva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。（用起来怎么和React几乎一样，但是里面的部分功能和vue的vuex一样。） 数据流图 （不过现在好像不更新了） Umiumi 是一个可插拔的react应用框架(集成多个大多数都所需的依赖！)，它以路由为基础，支持类next.js的约定式路由，以及各种进阶的路由功能，并以此进行功能拓展，比如支持路由级的按需加载。umi在约定是路由的功能会更像nuxt.js一点 let us use: mkdir myapp && cd myapp npx @umijs/create-umi-app npm i mock：放假数据测试用 src： umi文件夹：技术内敛，我们不需要关注它 page文件夹，放我们的功能页面，再不配置路由的情况下（注释掉.umiorc.ts中routes选项），在该文件夹下直接新建xx.tsx文件，将自动成为路由，index.tsx文件为首页（对应 &quot;/&quot; 路由），404.tsx为找不到跳转的页面 嵌套路由则新建文件夹（文件夹名为一级路由名），底下的 _layout.tsx 为一级路由组件页面，并且在里面放置 props.children用于作为二级路由的插槽位置 ，新建 nowplay.tsx，则 nowplay为二级路由名 它的声明式导航 // layouts/index.tsx import React from 'react'; import {NavLink} from 'umi' import style from './index.less' export default function(props:any) { if (props.location.pathname.includes('/detail')) { return { props.children } } return ( film cinema center { props.children } ); } 目录结构 .umirc.ts 配置文件，包含 umi 内置功能和插件的配置。 /src 目录 .umi 目录 临时文件目录，比如入口文件、路由等，都会被临时生成到这里。不要提交 .umi 目录到 git 仓库，他们会在 umi dev 和 umi build 时被删除并重新生成。 为什么不是？create-react-appcreate-react-app 是基于 webpack 的打包层方案，包含 build、dev、lint 等，他在打包层把体验做到了极致，但是不包含路由，不是框架，也不支持配置。所以，如果大家想基于他修改部分配置，或者希望在打包层之外也做技术收敛时，就会遇到困难。 next.jsnext.js 是个很好的选择，Umi 很多功能是参考 next.js 做的。要说有哪些地方不如 Umi，我觉得可能是不够贴近业务，不够接地气。比如 antd、dva 的深度整合，比如国际化、权限、数据流、配置式路由、补丁方案、自动化 external 方面等等一线开发者才会遇到的问题。 Recoil目前redux存在的问题： 陡峭的学习曲线 太多的样板代码 重新组织你的项目 缺乏并发模式支持 非反应性方法 难以实现代码拆分 没有内置的异步支持 此时我们需要一个更加轻巧方便的状态库解决它：Recoil 是 React 的状态管理库 它的底层逻辑还是一个 context 加上各种状态更新 优点就是十分方便，我们可以像使用useState一样使用它，适应现在的简洁式编码风气，而且没有redux那种可能会影响其他相关组件重新渲染问题；缺点是SSR场景的状态共享好像有点问题 npm install recoil yarn add recoil 导包： import { RecoilRoot, atom, selector, useRecoilState, useRecoilValue, } from 'recoil'; 首先要包裹住最外层的App组件 import React from 'react'; function App() { return ( &lt;RecoilRoot> &lt;CharacterCounter /> &lt;/RecoilRoot> ); } 一个 atom 代表一个状态。Atom 可在任意组件中进行读写。读取 atom 值的组件隐式订阅了该 atom，因此任何 atom 的更新都将致使使用对应 atom 的组件重新渲染： const textState = atom({ key: 'textState', // unique ID (with respect to other atoms/selectors) default: '', // default value (aka initial value) }); 使用起来和useState一样，很方便，免除了redux写法的烦恼 const [text, setText] = useRecoilState(textState); 如果对于atom 状态只读（在组件中直接像状态一样去使用），或者只写，可以使用 const todoList = useRecoilValue(todoListState); const setTodoList = useSetRecoilState(todoListState); const addItem = () => { setTodoList((oldTodoList) => [ ...oldTodoList, { id: getId(), text: inputValue, isComplete: false, }, ]); setInputValue(''); }; selector 在文档中还有一个selector，有点类似于计算属性，它还有依赖项，使用方法可以在官网查看 react-infinite-scroll-componentreact提供的无限滚动方案，官方文档 usage &lt;InfiniteScroll dataLength={items.length} //This is important field to render the next data next={fetchData} hasMore={true} loader={&lt;h4>Loading...&lt;/h4>} endMessage={ &lt;p style={{ textAlign: 'center' }}> &lt;b>Yay! You have seen it all&lt;/b> &lt;/p> } // below props only if you need pull down functionality refreshFunction={this.refresh} pullDownToRefresh pullDownToRefreshThreshold={50} pullDownToRefreshContent={ &lt;h3 style={{ textAlign: 'center' }}>&amp;#8595; Pull down to refresh&lt;/h3> } releaseToRefreshContent={ &lt;h3 style={{ textAlign: 'center' }}>&amp;#8593; Release to refresh&lt;/h3> } > {items} &lt;/InfiniteScroll> React SSRCSR 模式下，我们把水理解为数据，同样适用于 SSR，只是过程稍复杂些： 服务端渲染：在服务端注入数据，构建出组件树 序列化成 HTML：脱水成人干 客户端渲染：到达客户端后泡水，激活水流，变回活人 类比三体人的生存模式，乱纪元来临时先脱水成人干（SSR 中的服务端渲染部分），恒纪元到来后再泡水复活（SSR 中的客户端 hydrate 部分） 参考：https://juejin.cn/post/6901089942580150280","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Echarts","slug":"Echarts","date":"2022-03-26T05:13:35.297Z","updated":"2022-03-26T05:13:35.297Z","comments":true,"path":"2022/03/26/echarts/","link":"","permalink":"https://taylor12138.github.io/2022/03/26/echarts/","excerpt":"","text":"Echarts.jsEchart.js，它是由百度公司开发的一个使用JavaScript实现的开源可视化库（同时也有D3.js，它是国外的可视化库），兼容性强，底层依赖轻量级的 Canvas 类库 ZRender，可高度个性化定制数据可视化图表（移动端pc端都兼容） 安装： npm install echarts --save 官网：https://echarts.apache.org/zh/index.html 前端可视化工具常见工具：ECharts、g2、d3、vis、hightChart等 g2框架封装：bizcharts（react）、viser（vue） 地理可视化 ：g2、L7、高德的loca、菜鸟的鸟图 3D可视化：three.js 使用步骤 引入Echarts文件 可以通过导入 import * as echarts from 'echarts' 也可以直接放在全局，直接使用 Vue.prototype.$echarts = window.echarts 准备呈现图表的盒子（一定要有宽高，比如width: 600px; height: 400px） 初始化echarts对象 init方法： (dom: HTMLDivElement|HTMLCanvasElement, theme?: Object|string, opts?: { devicePixelRatio?: number, renderer?: string, useDirtyRect?: boolean, // 从 `v5.0.0` 开始支持 width?: number|string, height?: number|string, locale?: string }) => ECharts 创建一个 ECharts 实例，返回 echartsInstance，不能在单个容器上初始化多个 ECharts 实例。 参数 dom 实例容器，一般是一个具有高宽的div元素。 注：如果div是隐藏的，ECharts 可能会获取不到div的高宽导致初始化失败，这时候可以明确指定div的style.width和style.height，或者在div显示后手动调用 echartsInstance.resize 调整尺寸。 ECharts 3 中支持直接使用canvas元素作为容器，这样绘制完图表可以直接将 canvas 作为图片应用到其它地方，例如在 WebGL 中作为贴图，这跟使用 echartsInstance.getDataURL 生成图片链接相比可以支持图表的实时刷新。 theme 应用的主题。可以是一个主题的配置对象，也可以是使用已经通过 echarts.registerTheme 注册的主题名称。参见 ECharts 中的样式简介。 opts 附加参数。有下面几个可选项： devicePixelRatio 设备像素比，默认取浏览器的值window.devicePixelRatio。 renderer 渲染器，支持 &#39;canvas&#39; 或者 &#39;svg&#39;。参见 使用 Canvas 或者 SVG 渲染。 useDirtyRect 是否开启脏矩形渲染，默认为false。参见 ECharts 5 新特性。 width 可显式指定实例宽度，单位为像素。如果传入值为 null/undefined/&#39;auto&#39;，则表示自动取 dom（实例容器）的宽度。 height 可显式指定实例高度，单位为像素。如果传入值为 null/undefined/&#39;auto&#39;，则表示自动取 dom（实例容器）的高度。 locale 使用的语言，内置 &#39;ZH&#39; 和 &#39;EN&#39; 两个语言，也可以使用 echarts.registerLocale 方法注册新的语言包。目前支持的语言见 src/i18n。 如果不指定主题，也需在传入opts前先传入null，如： const chart = echarts.init(dom, null, {renderer: 'svg'}); 准备配置项 将配置设置给echarts实例对象（配置是可以设置多次，叠加设置，这样可以分离数据的代码和初始化的代码） import * as echarts from 'echarts'; // 基于准备好的dom，初始化echarts实例(如果是vue则用ref获取) var myChart = echarts.init(document.getElementById('main')); // 绘制图表 myChart.setOption({ //标题 title: { text: 'ECharts 入门示例' }, //通用配置，可设置对图表接触事件 tooltip: { //默认mousemove，移动到每一项触发光标和详情信息 trigger:'item', //设置后要click，点击才会有信息提示 triggerOn:'click' }, //工具栏，里面有很多好用的工具 toolbox:{ feature:{ //可以直接到导出图片的功能 saveAsImage:{} } } //x轴 xAxis: { type: \"category\", data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子'] }, //y轴 yAxis: { type: \"value\", scale:true //让数据不会从0开始 }, //系列列表，通过type决定图表类型，可以有多个对象 series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); 轴的type： category 类目轴 value数值轴（一般为数值轴则不用设置data属性，它会去另一个轴每个类别取series找到对应的数据） 系列表的type：line（折线图）、bar（柱状图）、pie（饼图）、scatter（散点图）、graph（关系图）、tree（树图） 折线图数据曲线平滑：smooth:true 散点图、涟漪散点图（effectScatter） 需要二维数组配合使用 饼图的数据：{name:&#39;allen&#39;, value:100}，不需要x轴、y轴 map地图的tooltip：提示框组件，可在里面进行修改，得到提示的内容不同 更多配置项详情查看官方文档 一个很有趣的echarts图表实例https://echarts.apache.org/examples/zh/editor.html?c=bar-race-country 还有些echats5新特性：实现图表跨系列的形变动画，更加酷炫！ 图形原理Echarts使用一个名为 zrender 的渲染引擎来管理渲染元素，并以通用的方式渲染到不同的平台 ZRender：二维矢量库Zrender，用于图形元素管理、渲染器管理和事件系统。它支持多种渲染后端，包括canvas、svg和vml。 Echarts最初采用canvas绘制图表，但是从Echarts4.x开始，发布了SVG渲染器，提供了另外一种渲染方式 Echarts的SVG VS Canvas 知乎上的结论大图 绿色表示推荐使用 SVG，红色表示推荐使用 Canvas，↑箭头越多表示推荐程度越强烈 使用SVG 移动平台优选 SVG 图表个数很多时优选 SVG 导出小文件高清晰时使用 SVG 使用Canvas 部分特殊渲染效果只有 Canvas 支持 除了某些特殊的渲染可能依赖 Canvas：如炫光尾迹特效、带有混合效果的热力图等，绝大部分功能 SVG 都是支持的。此外，目前的 SVG 版中，富文本、材质功能尚未实现。 数据量特别大时推荐使用 Canvas 渲染 知乎地址：https://zhuanlan.zhihu.com/p/33093211","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Threejs(上)","slug":"Threejs(上)","date":"2022-03-19T16:00:00.000Z","updated":"2023-06-11T17:05:46.261Z","comments":true,"path":"2022/03/20/threejs-shang/","link":"","permalink":"https://taylor12138.github.io/2022/03/20/threejs-shang/","excerpt":"","text":"1.threejs简介WebGLWebGL（全写Web Graphics Library）字面意义理解就是web图像库.是一种3D绘图协议，种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定 当然也可以说是一个负责图形处理的JavaScript API，可在任何兼容的Web浏览器中渲染高性能的交互式3D和2D图形，而无需使用插件.总结一句话,“webgl是一个专门计算或渲染3D图像的javascriptAPI也可以称之为专门处理3D图像的一种javaScript技术”． WEBGL VS canvas VS SVG SVG:本身會變成瀏覽器 DOM。優點是方便交互，缺點是因為每一個 SVG 元素都是一個 DOM 元素，繪製或移動一個 SVG 元素，瀏覽器都需要重新繪製、渲染頁面 canvas: 不涉及 DOM 元素，和 SVG 繪製的元素相比，交互性差，但也正因如此，在元素自身的動畫特效上不受 DOM 位置限制，在瀏覽器性能（載入速度）上比 SVG 更佳。 WebGL:WebGL 通過 WebGL JS API 連接 Javascript 和 GPU 編譯程序。GPU 繪圖的渲染大部分在 GPU 上進行，對瀏覽器壓力減小，性能幾個量級地提高，使 WebGL 成為瀏覽器內的3D渲染、大數據可視化唯一的選擇。 threejs概述随着WebGL在2011年推出之后，3d技术正式向高级编程语言js敞开大门 threejs是基于原生webGL封装运行的三维引擎，在所有webGL引擎中，threejs是国内资料最多，使用最广泛的三维引擎 并且Threejs会选择性渲染，只渲染屏幕当前出现的Object3D 官网：https://threejs.org/ GitHub：https://github.com/mrdoob/three.js 一个炫酷的threejs网站推荐https://lusion.co/；当然官网也有很多threejs的案例网站 threejs教学： Three.js Fundamentals Three.js Journey Learn Three.js 初めてのThree.js 法国threejs高级开发工程师Bruno Simon的教学视频 threejs程序结构 场景 网络模型 光照 相机 位置 视线方向 投影方式 渲染器 渲染器创建 渲染器渲染 domElement属性 笔者感受感觉threejs很灵活，像js一样，又很细致，你可以灵活把一个物品拆分成许多个单独的节点，你甚至可以把一根手指拆成三个节点，对其进行不同曲率对应的rotation计算，换算下来一只手都可以有几十甚至几百个节点来操控。这里有一个坦克的例子：https://threejs.org/manual/#zh/scenegraph 细的缺点就是麻烦，没有封装好的东西，灵活和便捷总是相对的，并且还需要一些图形学的知识 图片要求threejs用到的一些图，出了一些普通图片，还有时候需要可以本身要调节光亮的图片（使用HDR的图片） HDR图：高动态范围图像(High-Dynamic Range，简称HDR)，相比普通的图像，可以提供更多的动态范围和图像细节，根据不同的曝光时间的LDR(Low-Dynamic Range)图像，利用每个曝光时间相对应最佳细节的LDR图像来合成最终HDR图像，能够更好的反映出真实环境中的视觉效果。 这里有个HDR图推荐网址：https://polyhaven.com/ 安装项目中安装 npm i three 推荐工具threejs参数众多吗，但与图形学能力不好的同学建议配合上 Dat.gui 工具 拼命调整参数，达到自己想要的效果 WebGL兼容性检查（WebGL compatibility check） 虽然这个问题现在已经变得越来不明显，但不可否定的是，某些设备以及浏览器直到现在仍然不支持WebGL。以下的方法可以帮助你检测当前用户所使用的环境是否支持WebGL，如果不支持，将会向用户提示一条信息。 请将https://github.com/mrdoob/three.js/blob/master/examples/jsm/capabilities/WebGL.js引入到你的文件，并在尝试开始渲染之前先运行该文件。 if (WebGL.isWebGLAvailable()) { // Initiate function or other initializations here animate(); } else { const warning = WebGL.getWebGLErrorMessage(); document.getElementById(&#39;container&#39;).appendChild(warning); }2.初始start为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。 const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 ); //一般可以设置为75°、45°的角度等 const renderer = new THREE.WebGLRenderer(); renderer.setSize( window.innerWidth, window.innerHeight ); //最后再添加到文档中 document.body.appendChild( renderer.domElement ); //当然还可以在创建渲染器的时候 添加进ducoment const canvas = document.querySelector('.mycanvas'); const renderer = new THREE.WebGLRenderer({ canvas }); 让我们搭建第一个小案例吧 辅助工具用于辅助找到空间感觉的辅助工具 //显示三维坐标系 // 红色为x轴、绿色为y轴、蓝色为z轴 const axes = new THREE.AxisHelper(20) //新版本是 const axesHelper = new THREE.AxesHelper(20);，传入的参数为坐标轴长度 //添加到场景中 scene.add(axes) 当然还有不同的helper，比如CameraHelper、DirectionalLightHelper 等，都是官方的辅助工具，可以在官网中找到对应的helper进行调试 用于查看帧数等性能相关的工具 import Stats from 'three/examples/jsm/libs/stats.module' const stats = Stats(); document.body.appendChild(stats.dom); renderer.setAnimationLoop(() => { renderer.render(scene, camera); stats.update(); }); debug工具 可以去我的《动画辅助工具》blog查看 三大要素(1)相机three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。 这个相机的特点是能将场景中的物体进行进大远小的渲染 const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); 第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)，一般45、75比较多，75最多，因为比较接近人眼能看到的角度范围。 第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。 接下来的两个参数是近截面（near）和远截面（far）。通俗来讲就是相机能看到的最近的距离和最远的距离。 设置完还得设置相机的位置，参数分别是x、y、z坐标 camera.position.set(-1.8, 0.6, 2.7); .aspect : Float 摄像机视锥体的长宽比，通常是使用画布的宽/画布的高。默认值是1（正方形画布）。 camera.lookAt(scene.position) 让当前相机指向场景中心，这里的参数必须传入一个position 其他相机正交相机（OrthographicCamera） OrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number ) left — 摄像机视左边界。right — 摄像机视右边界。top — 摄像机视上边界。bottom — 摄像机视下边界。near — 摄像机近端距离。far — 摄像机远端距离。 这一摄像机使用orthographic projection（正交投影）来进行投影。 他没有视野角度（fov）的概念，在这种投影模式下，无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变。 这对于渲染2D场景或者UI元素是非常有用的。 updateProjectionMatrix.updateProjectionMatrix () : undefined 更新摄像机投影矩阵，在任何参数被改变以后必须被调用。 比如下面就是相机的 aspect 发生改变，所以需要我们手动update一下 this.camera.aspect = window.innerWidth / window.innerHeight; //其实也就是调整camera第二个参数 // 更新一下摄像机转换3d投影的矩阵 this.camera.updateProjectionMatrix(); 一般最多用到以上2种相机，如果 想了解更多相机 看这里 (2)WebGLRenderer（渲染器）//可以设置抗锯齿 antialias const renderer = new THREE.WebGLRenderer({ antialias: true }); //设置像素比,window.devicePixelRatio为当前浏览器的像素比 renderer.setPixelRatio(window.devicePixelRatio) //设置画布 尺寸大小 renderer.setSize(window.innerWidth, window.innerHeight); 使用渲染器后，还得让其在浏览器中进行渲染 renderer.render(scene, camera) 使用css的背景 .my-canvas { width: 100%; height: 100%; display: block; background: url(resources/images/daikanyama.jpg) no-repeat center center; background-size: cover; } const renderer = new THREE.WebGLRenderer({ antialias: true, canvas, alpha: true, }); 应对HD-DPI显示器如果你确实想用设备的分辨率来渲染，three.js中有两种方法来实现。 一种是使用renderer.setPixelRatio来告诉three.js分辨率的倍数。 访问浏览器从CSS像素到设备像素的倍数然后传给three.js。 renderer.setPixelRatio(window.devicePixelRatio);之后任何对renderer.setSize的调用都会神奇地使用您请求的大小乘以您传入的像素比例. 强烈不建议这样。 看下面。 另一种方法是在调整canvas的大小时自己处理。 function resizeRendererToDisplaySize(renderer) { const canvas = renderer.domElement; const pixelRatio = window.devicePixelRatio; const width = canvas.clientWidth * pixelRatio | 0; const height = canvas.clientHeight * pixelRatio | 0; const needResize = canvas.width !== width || canvas.height !== height; if (needResize) { renderer.setSize(width, height, false); } return needResize; } 第二种方法从客观上来说更好。为什么？因为我拿到了我想要的。 在使用three.js时有很多种情况下我们需要知道canvas的绘图缓冲区的确切尺寸。 比如制作后期处理滤镜或者我们在操作着色器需要访问gl_FragCoord变量，如果我们截屏或者给GPU 读取像素，绘制到二维的canvas等等。 通过我们自己处理我们会一直知道使用的尺寸是不是我们需要的。 幕后并没有什么特殊的魔法发生。 动画loop .setAnimationLoop ( callback : Function ) : undefined callback — 每个可用帧都会调用的函数。 如果传入‘null’,所有正在进行的动画都会停止。 可用来代替requestAnimationFrame的内置函数. 对于WebXR项目，必须使用此函数。(可以理解为就是一个 requestAnimationFrame ) renderFn() { mesh.rotation.y += 0.01; this.renderer.render(this.scene, camera) this.renderer.setAnimationLoop(this.renderFn) } // 动画函数 animate() { this.renderFn(); } 但是有一个缺陷：当你帧数越高（不同手机表现不同），此时动画越快，为此我们需要做一些策略：通过时间调节我们的frame rate 方法一：本地时间 let time = Date.now(); renderFn() { const currentTime = Date.now(); const deltaTime = currentTime - time; time = currentTime; mesh.rotation.y += 0.01 * deltaTime; this.renderer.render(this.scene, camera) this.renderer.setAnimationLoop(this.renderFn) } 方法二：threejs的clock const clock = new THREE.Clock() renderFn() { const elapsedTime = clock.getElapsedTime(); //得到的是秒不是毫秒 mesh.rotation.y += elapsedTime; this.renderer.render(this.scene, camera) this.renderer.setAnimationLoop(this.renderFn) } 色调映射在设置hdr图之后，可以设置色调映射属性，这些常量定义了WebGLRenderer中toneMapping的属性。 这个属性用于在普通计算机显示器或者移动设备屏幕等低动态范围介质上，模拟、逼近高动态范围（HDR）效果。 //色调映射（常量），设置为电影级别 renderer.toneMapping = THREE.ACESFilmicToneMapping; //调节曝光程度 renderer.toneMappingExposure = 2; 其他针对不需要动画的场景，一般我们在材质加载完成后才调用render方法. 我们这么做是因为使用了按需渲染中的方法, 而不是连续渲染. 这样我们仅仅需要在材质加载后渲染一遍就好. (3)scene（场景）const scene = new THREE.Scene() scene.add(xx) //将xx添加入场景, 可传入多个Object3D scene.remove(xx) //将xx移除场景 它继承于Object3D，它代表一个局部空间，以下是官网文档对场景解释的一个例子： 太阳系、太阳、地球、月亮。 地球绕着太阳转，月球绕着地球转，月球绕着地球转了一圈。从月球的角度看，它是在地球的 “局部空间 “中旋转。尽管它相对于太阳的运动是一些疯狂的像螺线图一样的曲线，但从月球的角度来看，它只需要关注自身围绕地球这个局部空间的旋转即可。 这个是我按照官网写的旋转的例子 如果在场景中添加太阳，太阳旋转是个根据场景旋转，把地球添加进太阳中，除了地球自转，地球还会因为太阳的旋转，产生以太阳为相对点进行旋转，此时如果sunMesh.scale.set(5, 5, 5) 比例设置为 5x。这意味着 sunMeshs 的局部空间是 5 倍大。这表示地球现在大了 5 倍，它与太阳的距离 ( earthMesh.position.x = 10 ) 也是 5 倍。这个以太阳为局部空间的一切，都会影响到地球 //创建太阳 const sunMaterial = new THREE.MeshPhongMaterial({ emissive: 0xffff00 }); const sunMesh = new THREE.Mesh(sphereGeometry, sunMaterial); sunMesh.scale.set(5, 5, 5); // 扩大太阳的大小 scene.add(sunMesh); objects.push(sunMesh); //创建地球 const earthMaterial = new THREE.MeshPhongMaterial({ color: 0x2233ff, emissive: 0x112244 }); const earthMesh = new THREE.Mesh(sphereGeometry, earthMaterial); earthMesh.position.x = 10; sunMesh.add(earthMesh); objects.push(earthMesh); 所以我们最好做一个太阳系，再往太阳系里添加地球和太阳 //创建太阳系 const solarSystem = new THREE.Object3D(); scene.add(solarSystem); objects.push(solarSystem); //创建太阳 const sunMaterial = new THREE.MeshPhongMaterial({ emissive: 0xffff00 }); const sunMesh = new THREE.Mesh(sphereGeometry, sunMaterial); sunMesh.scale.set(5, 5, 5); // 扩大太阳的大小 solarSystem.add(sunMesh); objects.push(sunMesh); //创建地球 const earthMaterial = new THREE.MeshPhongMaterial({ color: 0x2233ff, emissive: 0x112244 }); const earthMesh = new THREE.Mesh(sphereGeometry, earthMaterial); earthMesh.position.x = 10; solarSystem.add(earthMesh); objects.push(earthMesh); 最后再试一试加上地月系 //创建地月系 const earthOrbit = new THREE.Object3D(); earthOrbit.position.x = 10; solarSystem.add(earthOrbit); objects.push(earthOrbit); // 创建地球 const earthMaterial = new THREE.MeshPhongMaterial({ color: 0x2233ff, emissive: 0x112244 }); const earthMesh = new THREE.Mesh(sphereGeometry, earthMaterial); earthOrbit.add(earthMesh); objects.push(earthMesh); // 创建月亮 const moonMaterial = new THREE.MeshPhongMaterial({ color: 0x888888, emissive: 0x222222 }); const moonMesh = new THREE.Mesh(sphereGeometry, moonMaterial); moonMesh.position.x = 2; moonMesh.scale.set(0.5, 0.5, 0.5); earthOrbit.add(moonMesh); objects.push(moonMesh); 区块（Object3D）管理的优点通过这种区块（Object3D）的方式，管理每个Mesh，在某个场景下有大量Mesh需要进行移动时有巨大的性能优化空间，此时成百上千的Mesh放在一个Object3D里进行位置变化，可以被当成一次的位置变化 所以可以看到很多案例，在导入.gltf文件之后，不急着通过traverse 遍历 每一个节点进行控制，而是可以吧 节点（mesh）丢到object 3D里，进行统一管理 场景内部方法 .background(Object) 若不为空，在渲染场景的时候将设置背景，且背景总是首先被渲染的。 可以设置一个用于的“clear”的Color（颜色）、一个覆盖canvas的Texture（纹理）， 或是 a cubemap as a CubeTexture or an equirectangular as a Texture。默认值为null。 当然也可以使用threejs的Color scene.background = new THREE.Color(BACKGROUND_COLOR); 如果背景图被拉伸了，说明他被自动适应屏幕宽高，此时需要我们调整图片比例 function render(time) { ... // 设置背景贴图的repeat和offset属性 // 来保证图片的比例是正确的 // 注意图片有可能还没加载完成 const canvasAspect = canvas.clientWidth / canvas.clientHeight; const imageAspect = bgTexture.image ? bgTexture.image.width / bgTexture.image.height : 1; const aspect = imageAspect / canvasAspect; bgTexture.offset.x = aspect > 1 ? (1 - 1 / aspect) / 2 : 0; bgTexture.repeat.x = aspect > 1 ? 1 / aspect : 1; bgTexture.offset.y = aspect > 1 ? 0 : (1 - aspect) / 2; bgTexture.repeat.y = aspect > 1 ? 1 : aspect; ... renderer.render(scene, camera); requestAnimationFrame(render); } .environment(texture) 若该值不为null，则该纹理贴图将会被设为场景中所有物理材质的环境贴图。 然而，该属性不能够覆盖已存在的、已分配给 MeshStandardMaterial.envMap 的贴图。默认为null。 环境贴图是一种用于模拟物体周围环境（天空、地面、远处物体等）反射的贴图，可以用于增强场景的真实感和细节，在一些案例中，我们可以看到金属面反射周边环境，这就是环境贴图（scene.environment的作用）。 .fog( color : Integer, near : Float, far : Float ) 一个fog实例定义了影响场景中的每个物体的雾的类型 // 设置迷雾 this.scene.fog = new THREE.Fog(0xf1f1f1, 20, 100); .near : Float 开始应用雾的最小距离。距离小于活动摄像机“near”个单位的物体将不会被雾所影响。 默认值是1。 .far : Float 结束计算、应用雾的最大距离，距离大于活动摄像机“far”个单位的物体将不会被雾所影响。 雾的颜色是根据 scene.background 来的 .getObjectByName(name:string) 用于查找scene中都某个物件，比如 cube.name = 'nameCube' scene.add(cube) const findRes = scene.getObjectByName('nameCube') console.log(findRes.position) function removeCube(findRes){ if(findRes instanceof Mesh) { scene.remove(findRes) } } traverse 同样的，scene继承了object3D，scene也有traverse方法，用于遍历后代，被调用者和每个后代对象都会调用该函数 scene.traverse((obj) => { if(obj instanceof Mesh &amp;&amp; obj != plane) { obj.rotation.x += 0.01; obj.rotation.y += 0.01; obj.rotation.z += 0.01; } }) .overrideMaterial : Material 如果不为空，它将强制场景中的每个物体使用这里的材质来渲染。默认值为null。 3.texture（纹理）纹理贴图，texture其实就是一张图片，常常放置于材料啊、几何的表面，来呈现外观，可以看成一层“皮” 这里还有一个比较出名的3d纹理网站：https://3dtextures.me/ Loader加载纹理图TextureLoader：加载texture的一个类。 内部使用ImageLoader来加载文件。 .load ( url : String, onLoad : Function, onProgress : Function, onError : Function ) : Texture url — 文件的URL或者路径，也可以为 Data URI.onLoad — 加载完成时将调用。回调参数为将要加载的texture.onProgress — 将在加载过程中进行调用。参数为XMLHttpRequest实例，实例包含total和loaded字节。onError — 在加载错误时被调用。 从给定的URL开始加载并将完全加载的texture传递给onLoad。该方法还返回一个新的纹理对象，该纹理对象可以直接用于材质创建。 如果采用此方法，一旦相应的加载过程完成，纹理可能会在场景中出现。 其实还有一个CubeTextureLoader，用来加载CubeTexture类，立方体贴图，一次性加载当前视角上下左右前后的图，形成一个立体的map 如果真对全局的加载（loading）情况，可以使用 LoadingManager 其功能是处理并跟踪已加载和待处理的数据。如果未手动设置加强管理器，则会为加载器创建和使用默认全局实例加载器管理器 - 请参阅 DefaultLoadingManager. 一般来说，默认的加载管理器已足够使用了，但有时候也需要设置单独的加载器 - 例如，如果你想为对象和纹理显示单独的加载条。 const loadingManager = new THREE.LoadingManager(); loadingManager.onStart = function ( url, itemsLoaded, itemsTotal ) { console.log( 'Started loading file: ' + url + '.\\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' ); }; loadingManager.onLoad = function ( ) { console.log( 'Loading complete!'); }; loadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) { console.log( 'Loading file: ' + url + '.\\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' ); }; loadingManager.onError = function ( url ) { console.log( 'There was an error loading ' + url ); }; //纹理加载器 const textureLoader = new THREE.TextureLoader(); const texture = textureLoader.load(\"color.jpg\"); 给材质赋予纹理jpg贴图纹理（材质） .map : Texture 颜色贴图。默认为null。 const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xcccc }) setEnvMap(hdr) { const textureLoader = new THREE.TextureLoader(); const bricks = textureLoader.load(\"./images/brick.jpg\"); planeMaterial.map = bricks; } 或者在初始化材料的时候 //让立方体6个面图形不同 const materials = [ new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-1.jpg')}), new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-2.jpg')}), new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-3.jpg')}), new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-4.jpg')}), new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-5.jpg')}), new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-6.jpg')}), ]; const cube = new THREE.Mesh(geometry, materials); 但需要注意的是，并不是所有的几何体类型都支持多种材质。BoxGeometry 和 BoxGeometry 可以使用6种材料，每个面一个。ConeGeometry 和 ConeGeometry 可以使用2种材料，一种用于底部，一种用于侧面。 CylinderGeometry 和 CylinderGeometry 可以使用3种材料，分别是底部、顶部和侧面。对于其他情况，你需要建立或加载自定义几何体和（或）修改纹理坐标。 又或者是：(注意加载的异步处理) textureLoader.load(\"color.jpg\", (texture) => { //创建正方体 const geometry = new THREE.BoxGeometry(1, 1, 1); const material = new THREE.MeshBasicMaterial({ map: texture }); const cube = new THREE.Mesh(geometry, material); cube.position.set(1, 0, 0); scene.add(cube); }); .envMap : Texture 环境贴图。默认值为null。 纹理重复 //有2个属性，wrapS 用于水平包裹，wrapT 用于垂直包裹。 texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; //重复是用[repeat]重复属性设置的，一下两个值表示重复的次数 const timesToRepeatHorizontally = 4; const timesToRepeatVertically = 2; someTexture.repeat.set(timesToRepeatHorizontally, timesToRepeatVertically); hdr图设置纹理当然也可以通过hdr图设置纹理背景 import { RGBELoader } from \"three/examples/jsm/loaders/RGBELoader\"; //... // 设置场景（环境背景） setEnvMap(hdr) { // 回调得到的参数是纹理对象 // 怎么感觉这里的路径是直接把hdr文件夹放在public下 new RGBELoader().setPath(\"./hdr/\").load(hdr + \".hdr\", (texture) => { //告诉他该纹理背景是圆柱体映射 texture.mapping = THREE.EquirectangularReflectionMapping this.scene.background = texture; this.scene.environment = texture; }); } 立体贴图如果你想体验立体的贴图环境，我们需要使用到 CubeTextureLoader，传入6个立方体面的贴图 { const loader = new THREE.CubeTextureLoader(); const texture = loader.load([ 'resources/images/cubemaps/computer-history-museum/pos-x.jpg', 'resources/images/cubemaps/computer-history-museum/neg-x.jpg', 'resources/images/cubemaps/computer-history-museum/pos-y.jpg', 'resources/images/cubemaps/computer-history-museum/neg-y.jpg', 'resources/images/cubemaps/computer-history-museum/pos-z.jpg', 'resources/images/cubemaps/computer-history-museum/neg-z.jpg', ]); scene.background = texture; } 我们可以看到效果 尝试一下 此外，我们还可以通过WebGLCubeRenderTarget.fromEquirectangularTexture 直接渲染一张 360 全景相机图 可以看这里的案例 优化：纹理内存纹理往往是three.js应用中使用内存最多的部分。重要的是要明白，一般来说，纹理会占用 宽度 * 高度 * 4 * 1.33 字节的内存。 所以，一般为了让three.js使用纹理，必须把纹理交给GPU，而GPU一般都要求纹理数据不被压缩。所以，不仅仅要让你的纹理的文件大小小，还得让你的纹理尺寸小 但是，虽然我们可以用各种裁剪、缩放的方式，让图片宽高变小，但是这可能导致我们存在GPU的图片太小了，像素颜色可能会变成这样 不过，我们可以用mipmaps解决这个问题，要设置filter， 当在绘制的纹理大于其原始尺寸时设置过滤器，我们可以通过设置 texture.magFilter（THREE.LinearFilter、NearestFilter）来选择像素的展示情况 当在绘制的纹理小于其原始尺寸时设置过滤器，你要设置 texture.minFilter THREE.NearestFilter 同上，在纹理中选择最近的像素。 THREE.LinearFilter 和上面一样，从纹理中选择4个像素，然后混合它们 4.几个比较重要的类 + 概念三维向量（Vector3）该类表示的是一个三维向量（3D vector）。 一个三维向量表示的是一个有顺序的、三个为一组的数字组合（标记为x、y和z）， 可被用来表示很多事物，例如： 一个位于三维空间中的点。 一个在三维空间中的方向与长度的定义。在three.js中，长度总是从(0, 0, 0)到(x, y, z)的 Euclidean distance（欧几里德距离，即直线距离）， 方向也是从(0, 0, 0)到(x, y, z)的方向。 任意的、有顺序的、三个为一组的数字组合。 其他的一些事物也可以使用二维向量进行表示，比如说动量矢量等等； 但以上这些是它在three.js中的常用用途。 对 Vector3 实例进行遍历将按相应的顺序生成它的分量 (x, y, z)。 代码示例 const a = new THREE.Vector3(0, 1, 0); //no arguments; will be initialised to (0, 0, 0) const b = new THREE.Vector3(); const d = a.distanceTo( b ); 比如我要获取物体和相机的距离，或者物体距离某个点的距离 const a = new THREE.Vector3(0, 1, 0); //cube距离相机的距离 console.log(cube.position.distanceTo(camera.position)); 有很多地方继承了Vector，比如Object3D的position属性、scale属性等。 三维物体（Object3D）这是Three.js中大部分对象的基类，提供了一系列的属性和方法来对三维空间中的物体进行操纵。 请注意，可以通过.add( object )方法来将对象进行组合，该方法将对象添加为子对象，但为此最好使用Group（来作为父对象）。 他有postion、scale、rotation等属性，还有add、lookAt、traverse（用于遍历）等方法 可以把它看成js中的object那么通用 Object3D.scale.set(x, y, z)：设置物体大小 Object3D.position.set(x, y, z)：设置物体位置 Object3D.rotation.set(x, y, z)：设置物体旋转角度，分别表示x、y、z轴旋转量（备注，如果在rotation有疑惑的时候，可以尝试一下.cube.rotation.reorder(&#39;YXZ&#39;);，他旋转角度会根据当前物体的x、y、z轴旋转 ） Mesh：网格表示基于以三角形为polygon mesh（多边形网格）的物体的类，它继承object3D。 同时也作为其他类的基类，例如SkinnedMesh。 代码示例 const geometry = new THREE.BoxGeometry( 1, 1, 1 ); //生成一个立方体 const material = new THREE.MeshBasicMaterial({ color: 0xffff00 }); //创建一个材质material const mesh = new THREE.Mesh( geometry, material ); scene.add( mesh ); 你可以理解他为一个类似pixi的sprite，但是它由一个物体几何（geometry） + 材料（material） 合成的，比如一颗木头就是由一个圆柱体 + 木材质合成的 Group它几乎和Object3D是相同的，其目的是使得组中对象在语法上的结构更加清晰。 你可以就把他当成一个Object3D来看，只不过他一般用于装载多个Mesh，在pixi里类似于container的概念 const geometry = new THREE.BoxGeometry( 1, 1, 1 ); const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); const cubeA = new THREE.Mesh( geometry, material ); cubeA.position.set( 100, 100, 0 ); const cubeB = new THREE.Mesh( geometry, material ); cubeB.position.set( -100, -100, 0 ); //create a group and add the two cubes //These cubes can now be rotated / scaled etc as a group const group = new THREE.Group(); group.add( cubeA ); group.add( cubeB ); scene.add( group ); Float32Array源自原生javascript mdn： Float32Array 类型数组代表的是平台字节顺序为 32 位的浮点数型数组 (对应于 C 浮点数据类型) 。 对于 WebGL 应用程序，从Array到的潜在代价高昂的转换Float32Array需要包含在任何性能测量中。 它只能存储float数据 只能存储固定的长度 但是端上处理起来十分快速 // 3个顶点，创建9个数值 const positionArr = new Float32Array(9); //第一顶点（vertex）的x、y、z坐标 positionArr[0] = 0; positionArr[1] = 0; positionArr[2] = 0; //第二顶点（vertex）的x、y、z坐标 positionArr[3] = 0; positionArr[4] = 1; positionArr[5] = 0; //第三顶点（vertex）的x、y、z坐标 positionArr[6] = 1; positionArr[7] = 0; positionArr[8] = 0; //第二种创建方式 const positionArr2 = new Float32Array([0, 0, 0, 0, 1, 0, 1, 0, 0]); BufferAttribute这个类用于存储与BufferGeometry相关联的 attribute（例如顶点位置向量（position），面片索引，法向量（normal），颜色值（color），UV坐标（uv）以及任何自定义 attribute ）。 利用 BufferAttribute，可以更高效的向GPU传递数据。 构造函数 BufferAttribute( array : TypedArray, itemSize : Integer, normalized : Boolean ) array – 必须是 TypedArray. 类型，用于实例化缓存。该队列应该包含：itemSize * numVertices个元素，numVertices 是 BufferGeometry中的顶点数目 itemSize – 队列中与顶点相关的数据值的大小。举例，如果 attribute 存储的是三元组（例如顶点空间坐标、法向量或颜色值）则itemSize的值应该是3。 normalized – (可选) 指明缓存中的数据如何与GLSL代码中的数据对应。例如，如果array是 UInt16Array类型，且normalized的值是 true，则队列中的值将会从 0 - +65535 映射为 GLSL 中的 0.0f - +1.0f。 如果array是 Int16Array (有符号)，则值将会从 -32768 - +32767 映射为 -1.0f - +1.0f。若 normalized 的值为 false，则数据映射不会归一化，而会直接映射为 float 值，例如，32767 将会映射为 32767.0f. const positionArrtribute = new THREE.BufferAttribute(positionArr, 3); //positionArr为上方的Float32Array 因此，如果你要直接修改BufferAttribute，必须通过setAttribute的形式添加，并且传入 Float32Array 数组，详情可以看 下面 Geometry 部分 UVuv坐标可以理解为纹理坐标，像前端精灵图一样，每一块·都会有对应的位置，而且也是二维的 这里引用Bruno Simon 的两张图表现texutre对应的平面坐标（二维uv位置， 在BufferAttribute中它的itemSize为2） 设置uv //创建缓冲几何 const geometry = new THREE.BufferGeometry(); const material = new THREE.MeshStandardMaterial(); material.map = xxTexture; const mesh = new THREE.Mesh(geometry, material); //通过setAttribute，传入一个BufferAttribute //记住这里是二维的 geometry.setAttribute(\"uv2\", BufferAttribute(mesh.geometry.attributes.uv.array, 2)); 这里还有一个草图，很生动形象：https://blog.csdn.net/from_the_star/article/details/106594769 U（图片在显示器水平的坐标）和V（图片在显示器垂直的坐标） 范围是 0 - 1，通过setAttribute我们可以传入当前这个 BufferAttribute 的纹理坐标位置 可以在0~1.0之间任意取值(是百分比值，比如0.3，对应是30%的位置)，纹理贴图左下角对应的UV坐标是(0,0)，右上角对应的坐标(1,1) 而且我们还能通过设置 texture的offset偏移（实际上也是设置uv方向的偏移），来创建一个uv动画，看这里(斑马线案例) Normals法向量维基百科概念： 法向量，是空间解析几何的一个概念，垂直于平面的直线所表示的向量为该平面的法向量。 法向量适用于解析几何。 由于空间内有无数个直线垂直于已知平面，因此一个平面都存在无数个法向量（包括两个单位法向量）。 normals表示的是法向量，一般和光照、反射、折射有关 比如在图片里，我们可以看到如果光照按照左上到右下的角度射进来，左上半球是有光照反应的，右下是逐渐变暗的，并且右下角会随之产生阴影，此时我们还能看到左上能形成反射的向量角度, 这里我创建一个VertexNormalsHelper ，方便观察法向量 下面这个例子，我同方向光正常打光，按照红线的指示是正常的，此时上面的法向量为 [0, 1, 0] 但是当我们把顶点的法向量调整为 [1, 0, 0]此时机会看到和侧面一样的打光情况 5.Mesh组成几何（Geometry）介绍 目前为止，threejs已删除之前有的Geometry，用的都是以BufferGeometry为基类的Geometry https://github.com/mrdoob/three.js/wiki/Migration-Guide#r124--r125 官网介绍 用的比较多的BoxGeometry、PlaneGeometry 、TextGeometry（TextGeometry生成网格前需要先加载 3D 字体数据。 数据的加载是异步的，所以在尝试创建几何体前需要等待。通过将字体加载 Promise 化，并且我们可以通过减少curveSegments、 bevelSegments的值进行优化） 一些大佬甚至可以靠 ShapeGeometry 或者是创建一个empty BufferGeometry改造成自己想要的形状 如果绘制一些像 PlaneGeometry 和 ShapeGeometry 这样的二维图形，没有内部, 如果不设置 side: THREE.DoubleSide，当从反面看时它们会消失。 对于碰撞检测，threejs默认使用sphere bouding 也就是一个球形 其实也就是Geometry的这两个属性 BufferGeometry 在之前有个Geometry，一直和BufferGeometry进行对比： 基于 BufferGeometry 的图元是面向性能的类型。 几何体的顶点是直接生成为一个高效的类型数组形式，可以被上传到 GPU 进行渲染。 这意味着它们能更快的启动，占用更少的内存。但如果想修改数据，就需要复杂的编程。 基于 Geometry 的图元更灵活、更易修改（建立在bufferGeometry之上封装好的api）。 它们根据 JavaScript 的类而来，像 Vector3 是 3D 的点，Face3 是三角形。 它们需要更多的内存，在能够被渲染前，Three.js 会将它们转换成相应的 BufferGeometry 表现形式。 举个简单的例子，BufferGeometry 不能轻松的添加新的顶点。 使用顶点的数量在创建时就定好了，相应的创建存储，填充顶点数据。 但用 Geometry 你就能随时添加顶点。 总结就是：消耗性能的地方最好用BufferGeometry(比如说烟、雾、雪、雨之类的)，但是BufferGeometry用起来很麻烦，普遍的地方正常用Geometry就好了 实际上，BufferGeometry 本质上是一系列 BufferAttributes 的 名称 。每一个 BufferAttribute 代表一种类型数据的数组：位置，法线，颜色，uv，等等…… 这些合起来， BufferAttributes 代表每个顶点所有数据的 并行数组 。 而上面position, normal, color, uv ，它们指的是 并行数组 ，代表每个属性的第N个数据集属于同一个顶点。index=4的顶点被高亮表示贯穿所有属性的平行数据定义一个顶点。 //创建缓冲几何 const geometry = new THREE.BufferGeometry(); //通过setAttribute，传入一个BufferAttribute geometry.setAttribute(\"position\", positionArrtribute); const material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true }); const mesh = new THREE.Mesh(geometry, material); console.log(geometry.attributes) /* { position: Float32BufferAttribute normal: Float32BufferAttribute uv: Float32BufferAttribute } */ 案例 （上万的粒子效果仍然特别流畅） 材质（material）介绍基础属性.opacity : Float 在0.0 - 1.0的范围内的浮点数，表明材质的透明度。值0.0表示完全透明，1.0表示完全不透明。如果材质的transparent属性未设置为true，则材质将保持完全不透明，此值仅影响其颜色。 默认值为1.0。 经常用于 过渡消失动画 .side : Integer 定义将要渲染哪一面 - 正面，背面或两者。 默认为THREE.FrontSide。其他选项有THREE.BackSide 和 THREE.DoubleSide。 经常用于 设置透明时更改为双面，可以看到后面那层 类别 MeshBasicMaterial：一个以简单着色（平面或线框）方式来绘制几何体的材质。这种材质不受光照的影响。（最佳性能） MeshDepthMaterial（深度网格材质）：一种按深度绘制几何体的材质。深度基于相机远近平面。白色最近，黑色最远，可用于阴影。 MeshMatcapMaterial：MeshMatcapMaterial 不对灯光作出反应。 它将会投射阴影到一个接受阴影的物体上(and shadow clipping works)，但不会产生自身阴影或是接受阴影。mapcat材质大全 MeshToonMaterial：一种实现卡通着色的材质。 MeshNormalMaterial：一种把法向量映射到RGB颜色的材质。（有点赛博朋克、宇宙色彩系列的风格） MeshLambertMaterial：一种非光泽表面的材质，没有镜面高光。该材质使用基于非物理的Lambertian模型来计算反射率。 这可以很好地模拟一些表面（例如未经处理的木材或石材），但不能模拟具有镜面高光的光泽表面（例如涂漆木材）。 MeshPhongMaterial：一种用于具有镜面高光的光泽表面的材质。该材质使用非物理的Blinn-Phong模型来计算反射率。 与MeshLambertMaterial中使用的Lambertian模型不同，该材质可以模拟具有镜面高光的光泽表面（例如涂漆木材）。（观感更佳） MeshStandardMaterial：一种基于物理的标准材质，使用Metallic-Roughness工作流程。 基于物理的渲染（PBR）最近已成为许多3D应用程序的标准，例如Unity， Unreal和 3D Studio Max。 在实践中，该材质提供了比MeshLambertMaterial 或MeshPhongMaterial 更精确和逼真的结果，代价是计算成本更高。 MeshPhysicalMaterial：（最耗费性能） MeshStandardMaterial的扩展，提供了更高级的基于物理的渲染属性： Clearcoat: 有些类似于车漆，碳纤，被水打湿的表面的材质需要在面上再增加一个透明的，具有一定反光特性的面。而且这个面说不定有一定的起伏与粗糙度。Clearcoat可以在不需要重新创建一个透明的面的情况下做到类似的效果。 基于物理的透明度:.opacity属性有一些限制:在透明度比较高的时候，反射也随之减少。使用基于物理的透光性.transmission属性可以让一些很薄的透明表面，例如玻璃，变得更真实一些。 高级光线反射: 为非金属材质提供了更多更灵活的光线反射。 物理网格材质使用了更复杂的着色器功能，所以在每个像素的渲染都要比three.js中的其他材质更费性能，大部分的特性是默认关闭的，需要手动开启，每开启一项功能在开启的时候才会更耗性能。请注意，为获得最佳效果，您在使用此材质时应始终指定environment map。 通过 material.wireframe = true 还可以查看顶点相关信息 PointsMaterial: 点材料，主要用来制造点 每个材料的具体属性，可以在threejs官网查看 参考文章 Three.js Fundamentals","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Threejs(下)","slug":"Threejs(下)","date":"2022-03-19T16:00:00.000Z","updated":"2023-05-25T16:11:53.709Z","comments":true,"path":"2022/03/20/threejs-xia/","link":"","permalink":"https://taylor12138.github.io/2022/03/20/threejs-xia/","excerpt":"","text":"5.实践小实践（场景+阴影+小立方体） const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); //一般可以设置为75°、45°的角度等 const renderer = new THREE.WebGLRenderer(); //设置渲染器初始颜色 renderer.setClearColor(new THREE.Color(0xFFFFFF)) renderer.setSize(window.innerWidth, window.innerHeight); // 显示渲染物体的阴影 renderer.shadowMapEnabled = true; //显示三维坐标系 const axes = new THREE.AxisHelper(20) //添加到场景中 scene.add(axes) /*************************地面*************************/ //设置一个地面几何体 const planeGeometry = new THREE.PlaneGeometry(50, 50) //给地面上色 const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xcccc }) //结合材质 const plane = new THREE.Mesh(planeGeometry, planeMaterial) //物品移动位置 plane.rotation.x = -0.5 * Math.PI // 设置地面阴影+接受其他阴影 plane.castShadow = true; plane.receiveShadow = true scene.add(plane) /***********************添加立方体*****************/ //设置一个立方体，传入长宽高 const cubeGeometry = new THREE.BoxGeometry(4, 4, 4) //MeshBasicMaterial材质不受光照的影响，所以这里用MeshLambertMaterial const cubeMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff }) const cube = new THREE.Mesh(cubeGeometry, cubeMaterial) cube.position.y = 5 //对象是否渲染到阴影贴图当中 cube.castShadow = true; scene.add(cube) /***********创建一个聚光灯（才会有阴影效果）***********/ // 传入一个参数，为灯光颜色 const spotLight = new THREE.SpotLight(0xFFFFFF); spotLight.position.set(130, 130, -130); spotLight.castShadow = true; // 添加聚光灯 scene.add(spotLight) /***************定位相机，并且指向场景中心***********/ camera.position.x = 30; camera.position.y = 30; camera.position.z = 30; camera.lookAt(scene.position) //最后再添加到文档中 document.body.appendChild(renderer.domElement); renderer.render(scene, camera) 小实践推荐网站https://github.com/JChehe/blog/issues/44 一个换肤小椅子作为实践 https://github.com/JChehe/blog/issues/45 3d任务交互（进阶版） 6.控制器这里说的控制器，不如说是相机的控制器，一般来说我们可以通过设置控制器，控制镜头，或者其他物体进行变换 这里示范一个轨道控制器(最常用) //导入控制器，轨道控制器（围绕物体查看） import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\"; //镜头控制器 initControls() { // 这里我在dom中控制镜头,进行轨道移动 this.controls = new OrbitControls(this.camera, this.renderer.domElement); } 此时我们就可以转动摄像头进行360°旋转了！ （内部实际上感觉是通过mousemove之类的监听当前dom元素的事件，然后sin、cos调整camera的position，此时形成一个轨道的效果） 然后在使用轨道控制器时，还可以设置target： .target : Vector3 控制器的焦点，.object的轨道围绕它运行，默认为Vector3(0, 0, 0)。 它可以在任何时候被手动更新，以更改控制器的焦点。 请注意，如果该值被启用，你将必须在你的动画循环里调用.update()。 controls.target.set( 0, 0.5, 0 ); 另外一个常用的就是指针锁定控制器（PointerLockControls） 该类的实现是基于Pointer Lock API的。 对于第一人称3D游戏来说， PointerLockControls 是一个非常完美的选择。 其他控制器可以在这里查看 OrbitControls部分属性 注意：使用了控制器之后记得在每次动画render的时候controls.update(); 当然也可以自己添加些控制器的属性 this.controls.maxPolarAngle = Math.PI / 2; this.controls.minPolarAngle = Math.PI / 3; this.controls.enableDamping = true; this.controls.enablePan = false; this.controls.dampingFactor = 0.1; this.controls.autoRotate = false; // this.controls.autoRotateSpeed = 0.2; // 30 .enabled: Boolean 当设置为false时，将暂时关闭控制器，默认为true .maxPolarAngle : Float 你能够垂直旋转的角度的上限，范围是0到Math.PI，其默认值为Math.PI。 .enableDamping : Boolean 将其设置为true以启用阻尼（惯性），这将给控制器带来重量感。默认值为false。你可以理解为它会让你控制器的动作更丝滑，符合物理性质请注意，如果该值被启用，你将必须在你的动画循环里调用.update()。 .enablePan : Boolean 启用或禁用摄像机平移，默认为true。 .dampingFactor : Float 当.enableDamping设置为true的时候，阻尼惯性有多大。请注意，要使得这一值生效，你必须在你的动画循环里调用.update()。 .autoRotate : Boolean 将其设为true，以自动围绕目标旋转。请注意，如果它被启用，你必须在你的动画循环里调用.update()。 .autoRotateSpeed : Float 当.autoRotate为true时，围绕目标旋转的速度将有多快，默认值为2.0，相当于在60fps时每旋转一周需要30秒。请注意，如果.autoRotate被启用，你必须在你的动画循环里调用.update()。 因为启用了以上部分属性，所以需要在animate中调用update 注意，如果通过改变相机位置而发生当前视角偏移，相机视角没有聚焦于对象的情况下，在动画animate中调用this.controls.update()也可以解决 // 动画函数 animate() { this.controls.update(); this.renderer.setAnimationLoop(this.render.bind(this)); } 7.添加模型除了自己手动创建集合体，来给当前场景添加模型，当然也可以导入模型（glb文件、OBJ文件、GLTF文件） glb文件：GLB文件是以图形语言传输格式（GLTF）保存的3D模型，它以二进制格式存储有关3D模型的信息，包括节点层级、摄像机、材质、动画和网格。GLB文件是.GLTF文件的二进制版本。 文件格式（File Format）显然 Three.js 支持很多 3D 对象文件格式，但它推荐的格式之一是 glTF(.glb)。同时 Blender 也支持导出该格式，所以毫无疑虑。 // 导入模型解析器 import { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\"; setModel(modelName) { // 由于添加模型是异步操作，所以可以封装一个promise给它 return new Promise((res, rej) => { //public/gltf/模型文件 const loader = new GLTFLoader().setPath(\"gltf/\"); loader.load(modelName, (gltf) => { this.model = gltf.scene.children[0]; // 调整模型大小,或者不设置也行 this.model.scale.set(7, 7, 7); this.scene.add(this.model); res(modelName + \"添加成功\"); }); }); } 此时modal继承Object 3D，可以设置模型大小、模型位置、模型旋转角度 删除模型： this.model &amp;&amp; this.model.removeFromParent() 模型traverse方法一般blender的glb模型，通过gltf.scene得到的模型（model），都会有 traverse 方法，方法遍历所有网格（mesh）以启用投射和接收阴影的能力。该操作需要在 scene.add(model) 前完成。 因此我们可以通过 ``traverse遍历 修改模型中的某个部位的材质、颜色、阴影 //添加阴影，调整模型材质 this.model.traverse((o) => { if (o.isBone) { console.log(o.name);//输出model里面包含的骨头 } if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; o.material = stacy_mtl; // Add this line } }); 添加模型地板// 添加地板 setFloor() { // Floor var floorGeometry = new THREE.PlaneGeometry(5000, 5000, 1, 1); var floorMaterial = new THREE.MeshPhongMaterial({ color: 0xeeeeee, shininess: 0, }); var floor = new THREE.Mesh(floorGeometry, floorMaterial); floor.rotation.x = -0.5 * Math.PI; floor.receiveShadow = true; floor.position.y = -11; this.scene.add(floor); } PlaneGeometry 一个用于生成平面几何体的类。 width — 平面沿着X轴的宽度。默认值是1。 height — 平面沿着Y轴的高度。默认值是1。 widthSegments — （可选）平面的宽度分段数，默认值是1。 heightSegments — （可选）平面的高度分段数，默认值是1。 当然也可以设置网格 var gridHelper = new THREE.GridHelper(200, 25); gridHelper.position.y = -11; this.scene.add(gridHelper); 模型素材一般前端人员很难自己去造素材，以下是一些3d模型得素材网站 https://www.mixamo.com/ 使用mixamo的模型之后，可以通过以下网站，将动画导入模型：https://nilooy.github.io/character-animation-combiner/ https://sketchfab.com/ （部分付费） 还有一个关于建模很酷的网站：https://marmoset.co/ FBX文件而网站上一些素材下载以后是 .fbx 文件格式，这时候我们使用的加载器可以为FBXLoader import { FBXLoader } from \"three/examples/jsm/loaders/FBXLoader\"; 而它的使用方式仍然是和 GLTFLoader 差不多，通过 setPath 和 .load方法去使用 const loader = new FBXLoader().setPath(`fbx/${this.charactorName}/`); return new Promise((res, rej) => { loader.load( \"people.fbx\", (fbx) => { console.log(fbx, \"fbx\"); // this.loaderAnim.remove(); fbx.scale.setScalar(0.3); this.model = fbx; this.model.position.y = -10; this.model.rotation.y = Math.PI / 2; // 添加阴影 this.model.traverse((o) => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } }); this.scene.add(this.model); res(); }, undefined, function (error) { console.error(error); } ); }); 8.灯光缺少光，摄像机就不能看到任何有反光材质的东西 光源介绍 SpotLight( color : Integer, intensity : Float, distance : Float, angle : Radians, penumbra : Float, decay : Float ) 聚光灯，一个光照范围为锥体的灯（方向光） color - (可选参数) 十六进制光照颜色。 缺省值 0xffffff (白色)。 intensity - (可选参数) 光照强度。 缺省值 1。 distance - 从光源发出光的最大距离，其强度根据光源的距离线性衰减。 angle - 光线散射角度，最大为Math.PI/2。 penumbra - 聚光锥的半影衰减百分比。在0和1之间的值。默认为0。 decay - 沿着光照距离的衰减量。 光线从一个点沿一个方向射出，随着光线照射的变远，光线圆锥体的尺寸也逐渐增大，和手电筒类似（产生阴影） AmbientLight( color : Integer, intensity : Float )（环境光）（不能投射阴影） color - (参数可选）颜色的rgb数值。缺省值为 0xffffff。 intensity - (参数可选)光照的强度。缺省值为 1。 环境光会均匀的照亮场景中的所有物体。特点也就是均匀照亮，让我们看的见物体，实际上我们可以将其视为“亮度” 环境光不能用来投射阴影，因为它没有方向。 PointLight( color : Integer, intensity : Float, distance : Number, decay : Float ) 点光源（方向光） color - (可选参数)) 十六进制光照颜色。 缺省值 0xffffff (白色)。 intensity - (可选参数) 光照强度。 缺省值 1。 distance - 这个距离表示从光源到光照强度为0的位置。 当设置为0时，光永远不会消失(距离无穷大)。缺省值 0. decay - 沿着光照距离的衰退量。缺省值 2。 从一个点向各个方向发射的光源。一个常见的例子是模拟一个灯泡发出的光。 RectAreaLight( color : Integer, intensity : Float, width : Float, height : Float )平面光光源（方向光） color - (可选参数) 十六进制数字表示的光照颜色。缺省值为 0xffffff (白色) intensity - (可选参数) 光源强度／亮度 。缺省值为 1。 width - (可选参数) 光源宽度。缺省值为 10。 height - (可选参数) 光源高度。缺省值为 10。 平面光光源从一个矩形平面上均匀地发射光线，长得像一个打光板一样，这种光源可以用来模拟像明亮的窗户或者条状灯光光源。常应用于家具建模 还可以通过 RectAreaLight.lookAt(x, y, z) 去设置面向的方向 注意：不支持阴影，只支持 MeshStandardMaterial 和 MeshPhysicalMaterial 两种材质，你必须在你的场景中加入 RectAreaLightUniformsLib ，并调用init()。 import {RectAreaLightUniformsLib} from 'three/addons/lights/RectAreaLightUniformsLib.js HemisphereLight：（环境光）（不能投射阴影） skyColor - (可选参数) 天空中发出光线的颜色。 缺省值 0xffffff。 groundColor - (可选参数) 地面发出光线的颜色。 缺省值 0xffffff。 intensity - (可选参数) 光照强度。 缺省值 1。 半球光，光源直接放置于场景之上，光照颜色从天空光线颜色渐变到地面光线颜色。有点像AmbientLight的升级版，可以兼顾上方和下方的环境光 为室外场景创造更加自然的光照 var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.61); hemiLight.position.set(0, 50, 0); // Add hemisphere light to scene this.scene.add(hemiLight); DirectionalLight：定向光，距离很远的光，他的所有光都是平行的（方向光，模拟太阳光， 有target） color - (可选参数) 16进制表示光的颜色。 缺省值为 0xffffff (白色)。 intensity - (可选参数) 光照的强度。缺省值为1。 平行光是沿着特定方向发射的光。这种光的表现像是无限远,从它发出的光线都是平行的。常常用平行光来模拟太阳光 的效果; 太阳足够远，因此我们可以认为太阳的位置是无限远，所以我们认为从太阳发出的光线也都是平行的。 var dirLight = new THREE.DirectionalLight(0xffffff, 0.54); dirLight.position.set(-8, 12, 8); dirLight.castShadow = true; // Add directional Light to this.scene this.scene.add(dirLight); 但是即使是模拟太阳光，但是他也有光照范围（可以使用 CameraHelper 查看阴影的覆盖范围，记住一定要添加完阴影才有效 ） 对于有方向的光，我们可以通过以下方法来指定光照目标 dirLight.target.position.set(-5, 0, 0); //平行光的方向是从它的位置到目标位置。默认的目标位置为原点 (0,0,0)。 //注意: 对于目标的位置，要将其更改为除缺省值之外的任何位置,它必须被添加到 scene 场景中去。 this.scene.add(light.target); 还可以用DirectionalLightHelper辅助查看光线 DirectionalLightHelper： 用于模拟场景中平行光 DirectionalLight 的辅助对象. 其中包含了表示光位置的平面和表示光方向的线段. 代码示例 const light = new THREE.DirectionalLight( 0xFFFFFF ); const helper = new THREE.DirectionalLightHelper( light, 5 ); scene.add( helper ); 这里来一个小例子 让你自己尝试下～：https://codesandbox.io/s/threejs-light-xdehpp?file=/src/script.js 关于光照的思路： 关于光照，我们尚未提及的是 WebGLRenderer 中有一个设置项 physicallyCorrectLights。这个设置会影响（随着离光源的距离增加）光照如何减弱。这个设置会影响点光源（PointLight）和聚光灯（SpotLight），矩形区域光（RectAreaLight）会自动应用这个特性。 在设置光照时，基本思路是不要设置 distance 来表现光照的衰减，也不要设置 intensity。而是设置光照的 power 属性，以流明为单位，three.js 会进行物理计算，从而表现出接近真实的光照效果。在这种情况下 three.js 参与计算的长度单位是米，一个 60瓦 的灯泡大概是 800 流明强度。并且光源有一个 decay 属性，为了模拟真实效果，应该被设置为 2。 更多详情可以在这里找到 注意，我们除了可以给场景scene添加灯光，还可以给摄像机camera添加灯光，比如常见的点光源：pointLight 光源辅助线//辅助函数 //光源辅助工具 const lightHelper = new THREE.DirectionalLightHelper(dirLight); //可以看到当前相机可视范围，这里查看的事阴影的覆盖范围 const shadowCameraHelper = new THREE.CameraHelper(dirLight.shadow.camera); this.scene.add(lightHelper); this.scene.add(shadowCameraHelper); 根据以上方法，我们也可以在使用不同的光线时，从库中引用不同的辅助线 xxxLightHelper 生产环境下我们可以隐藏掉 shadowCameraHelper.visible = false 镜头光晕（Lensflare）创建一个模拟追踪着灯光的镜头光晕。 LensflareElement( texture : Texture, size : Float, distance : Float, color : Color ) texture - 用于光晕的THREE.Texture（贴图） size - （可选）光晕尺寸（单位为像素） distance - （可选）和光源的距离值在0到1之间（值为0时在光源的位置） color - （可选）光晕的（Color）颜色 代码示例 const light = new THREE.PointLight( 0xffffff, 1.5, 2000 ); const textureLoader = new THREE.TextureLoader(); const textureFlare0 = textureLoader.load( \"textures/lensflare/lensflare0.png\" ); //阳光贴图 const textureFlare1 = textureLoader.load( \"textures/lensflare/lensflare2.png\" ); //阳光贴图 const textureFlare2 = textureLoader.load( \"textures/lensflare/lensflare3.png\" ); //阳光贴图 const lensflare = new Lensflare(); lensflare.addElement( new LensflareElement( textureFlare0, 512, 0 ) ); lensflare.addElement( new LensflareElement( textureFlare1, 512, 0 ) ); lensflare.addElement( new LensflareElement( textureFlare2, 60, 0.6 ) ); light.add( lensflare ); 光的性能光源的数量，当然也是影响性能的一部分，越少越好，最小的性能消耗为2个环境光（AmbientLight、HemisphereLight ），最耗费性能的是SpotLight、RectAreaLight，光的性能和阴影的制造 + 渲染次数是捆绑在一起的 9.阴影threejs在渲染的时候，如果需要渲染阴影，会帮我们使用 MeshDepthMaterial 的材质替换所有材质（material），并且生成 + 存储一种名为 shadow maps 的阴影贴图（texture），改shadow maps 记录了产生阴影的物体对应的二维阴影图像 阴影的性能首先关于阴影的性能问题： Three.js 默认使用shadow maps（阴影贴图），阴影贴图的工作方式就是具有投射阴影的光能对所有能被投射阴影的物体从光源渲染阴影，所以你可以理解为阴影这一层，threejs已经帮我们做好了，灯光数量，决定阴影的渲染。所以阴影这部分完全没有啥操作，难的在于阴影的优化部分 那么说明： 如果你有 20 个物体对象、5 个灯光，并且所有的物体都能被投射阴影，所有的光都能投射阴影，那么这个场景这个场景将会绘制 6 次。第一个灯光将会为所有的物体投影阴影，绘制场景。然后是第二个灯光绘制场景，然后是第三个灯光，以此类推。最后一次（即第六次）将通过前五个灯光渲染的数据，渲染出最终的实际场景。 解决方法： 只使用一个光源，从而减少阴影数量 使用光照贴图或者环境光贴图，预先计算离线照明的效果。不过这将导致静态光照（引用不会动） 使用假的阴影 Animal Crossing Pocket Camp，在其中你可以看到每个字符都有一个简单的原型阴影。这种方式很有效，也很方便。Monument Valley 纪念碑谷看起来似乎也使用这种阴影。 常规一点的优化方法： 优化性能：减小阴影贴图大小（mapsize） 优化质量：减少阴影覆盖范围（光照投射范围）（shadowmap范围内被投射的物体体积大了（相对），能得到更高质量的阴影） 优化性能：尝试设置低质量阴影贴图 尝试一下 添加模型阴影第一步，在初始化renderer的时候先设置shadowMap，让渲染器开启阴影 this.renderer.shadowMap.enabled = true; .shadowMap : WebGLShadowMap 如果使用，它包含阴影贴图的引用。- enabled: 如果设置开启，允许在场景中使用阴影贴图。默认是 false。 第二步，给灯光添加阴影投射支持： xxx.castShadow = true 是否投射阴影 第三步，添加地板时需要： floor.receiveShadow = true; 是否能接受阴影 对于场景中的每一个需要阴影的物体，都需要设置 castShadow 、receiveShadow 在 loader 函数内，我们能遍历 3D 模型（的组成元素）。因此，跳到 loader 函数，在 theModel = gltf.scene; 下添加这个操作。为 3D 模型的每一个元素（椅腿、坐垫等）启用投射和接收阴影的选项。该遍历方法在后续会被再次使用。 const loader = new GLTFLoader(); loader.load( modelName, (gltf) => { this.model = gltf.scene; // 添加阴影 this.model.traverse((o) => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } }); this.scene.add(this.model); }, undefined, function (error) { console.error(error); } ); 设置阴影我们给定向光设置阴影，此时通过打印shadow属性可以看到她的shadowmap尺寸 //方向光 const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); directionalLight.castShadow = true; directionalLight.position.set(10, 10, 5); console.log(directionalLight.shadow); mapSize: Vector2 x: 512 y: 512 isVector2: true因此我们还可以设置阴影大小怎么样： xxlight.shadow.mapSize = new THREE.Vector2(1024, 1024); 阴影尺寸越大，性能消耗越大，但是阴影质量越好 下面的图片分别对应 512、1024、128 DirectionalLight小实践 let d = 8.25; let dirLight = new THREE.DirectionalLight(0xffffff, 0.54); dirLight.position.set(-8, 12, 8); dirLight.castShadow = true; //二维向量（Vector2） //表示2D vector（二维向量）的类。 一个二维向量是一对有顺序的数字（标记为x和y），可用来表示很多事物，例如： dirLight.shadow.mapSize = new THREE.Vector2(1024, 1024); dirLight.shadow.camera.near = 0.1; dirLight.shadow.camera.far = 1500; dirLight.shadow.camera.left = d * -1; dirLight.shadow.camera.right = d; dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = d * -1; 这里根据作者的解释：我凭借个人感觉将定向光放置在一个适当的位置。随后，启用其投射阴影的能力并设置了阴影的分辨率。阴影的其余设置则与光的视场相关（译者注：定向光是使用正交摄像机计算阴影，参考 DirectionalLightShadow），这概念对我来说也有些模糊，但只要清晰知道：可通过调整变量 d 以确保阴影不被裁剪。 减少阴影覆盖范围xxLight.shadow.camera 是一个正交相机，可以通过调控修改改灯光下阴影的覆盖范围 通过CameraHelper，我们可以看到当前光源内阴影的覆盖范围，我们可以根据需求稍微调整，提高性能 //这是一个正交相机 //减少覆盖距离 directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 20; //减少覆盖大小,可以参考正交相机部分的参数 directionalLight.shadow.camera.top = 2; directionalLight.shadow.camera.bottom = -2; directionalLight.shadow.camera.left = -2; directionalLight.shadow.camera.right = -2; 刚好到达范围内是最好的 并且还可以通过radius控制阴影虚化 .radius : Float 将此值设置为大于1的值将模糊阴影的边缘。较高的值会在阴影中产生不必要的条带效果 - 更大的mapSize将允许在这些效果变得可见之前使用更高的值。 directionalLight.shadow.radius = 10; 尝试一下吧～ 阴影类型 THREE.BasicShadowMap：低质量高性能阴影贴图 THREE.PCFShadowMap：贴图边缘平滑，性能消耗不高，threejs默认使用的shadow map THREE.PCFSoftShadowMap：性能消耗高于THREE.PCFShadowMap，更加平滑，表现能力更好,radius（阴影虚化）无法生效 THREE.VSMShadowMap renderer.shadowMap.type = THREE.PCFShadowMap 我们通过light.shadow.type 进行控制 10.动画动画方面的制作可以参考threejs官网的AnimationAction系列，不过一般都要传入由blender制作的模型动画会比较方便 以下实例使用的是AnimationMixer，一个动画混合器，它是用于场景中特定对象的动画的播放器。当场景中的多个对象独立动画时，每个对象都可以使用同一个动画混合器。（传入blender制作好的动画） setModel(modelName) { // 由于添加模型是异步操作，所以可以封装一个promise给它 return new Promise((res, rej) => { const loader = new GLTFLoader().setPath(\"gltf/\"); loader.load(modelName, (gltf) => { console.log(gltf); this.model = gltf.scene.children[0]; // 把里面的scene都传进去 this.scene.add(gltf.scene); //摄像头都改为模型应用的摄像头 this.camera = gltf.cameras[0]; //调用动画,我们可以把AnimationMixer当作一个设置好关键帧的播放器 //这里主要还是摄像头在动,children[1]里面放一个摄像机camera this.mixer = new THREE.AnimationMixer(gltf.scene.children[1]); this.animateAction = this.mixer.clipAction(gltf.animations[0]); // 设置动画播放时长 this.animateAction.setDuration(20).setLoop(THREE.LoopOnce); // 播放完毕停止 this.animateAction.clampWhenFinished = true; this.animateAction.play(); //设置模型内部灯光 const spotlight1 = gltf.scene.children[2].children[0]; spotlight1.intensity = 1; const spotlight2 = gltf.scene.children[3].children[0]; spotlight2.intensity = 1; const spotlight3 = gltf.scene.children[4].children[0]; spotlight3.intensity = 1; console.log(gltf, \"again\"); res(modelName + \"添加成功\"); }); }); AnimationMixer( rootObject : Object3D )：动画混合器是用于场景中特定对象的动画的播放器，参数为动画的对象 AnimationClip：动画剪辑（AnimationClip）是一个可重用的关键帧轨道集，可以理解为它就是动画。可以从模型中获取的，案例中为 gltf.animations[0] AnimationActions ，可以理解为使用动画的工具，用来调度存储在AnimationClips中的动画。案例中为 this.animateAction clipAction：一个方法， =》 AnimationActions = mixer.clipAction(AnimationClip); AnimationActions对于存储动画的AnimationActions对象，有以下几个常用的方法 .play () : this 让混合器激活动作。此方法可链式调用。 .enabled : Boolean enabled 值设为false会禁用动作, 也就是无效.默认值是true .setLoop ( loopMode : Number, repetitions : Number ) : this 设置循环（loop mode）及循环重复次数（repetitions）。改方法可被链式调用。 我们通常用来设置动画播放次数 .reset () : this 重置动作。此方法可链式调用。 .crossFadeTo ( fadeInAction : AnimationAction, durationInSeconds : Number, warpBoolean : Boolean ) : this 在传入的时间段内, 让此动作淡出（fade out），同时让另一个动作淡入。此方法可链式调用。 常用于动画中切换动作 如果warpBoolean值是true, 额外的 warping (时间比例的渐变)将会被应用。 添加动态效果然后再添加threejs提供的计时器 this.clock = new THREE.Clock(); //three提供的计时器 该对象用于跟踪时间。如果performance.now可用，则 Clock 对象通过该方法实现，否则回落到使用略欠精准的Date.now来实现。 在每一次render获取每一帧的时间差 但是一般不建议使用getDelta，because 你可能会获取到去乖的值，makes no sense render() { const delta = this.clock.getDelta(); this.mixer &amp;&amp; this.mixer.update(delta); this.renderer.render(this.scene, this.camera); } 当然也可以把mixer作为数组存储，把每一次动画存储到mixer中 loader.load(\"dancing.fbx\", (anim) => { console.log(anim, \"anim\"); const m = new THREE.AnimationMixer(this.model); this.mixer.push(m); this.animateAction = m.clipAction(anim.animations[0]); this.animateAction.play(); }); 然后再渲染函数中逐个调用 // 渲染函数 render() { const delta = this.clock.getDelta(); if (this.mixer.length > 0) { this.mixer.map((m) => m.update(delta)); } this.renderer.render(this.scene, this.camera); } 注意：这种方式可能导致得到的animation仍遗留上一个动作的某个肢体动作，导致动画动作“不规范” 11.对于动画中的事件监听 窗口大小调整：resize 对于窗口大小调整，可以使用 window.addEventListener(\"resize\", this.windowResize.bind(this)); windowResize() { this.camera.aspect = window.innerWidth / window.innerHeight; //其实也就是调整camera第二个参数 // 更新一下摄像机转换3d投影的矩阵 this.camera.updateProjectionMatrix(); //更新渲染器渲染大小 this.renderer.setSize(window.innerWidth, window.innerHeight); } 鼠标移动：mousemove 对于鼠标移动可以使用 window.addEventListener(\"mousemove\", this.windowMouseMove.bind(this)); 鼠标点击、桌面触屏：click、touchend 对于鼠标点击，我们并不能单纯为标签添加点击事件，毕竟不是dom的一部分，这里采用射线实现 即向一定方向发射激光束，然后返回被击中的对象集合。在该案例中，激光线是从摄像机射向光标。 Raycaster() 这个类用于进行raycasting（光线投射）。 光线投射用于进行鼠标拾取（在三维空间中计算出鼠标移过了什么物体）。 // 通过摄像机和鼠标位置更新射线 raycaster.setFromCamera( pointer, camera ); // 计算物体和射线的焦点 const intersects = raycaster.intersectObjects( scene.children ); const raycaster = new THREE.Raycaster(); const currentlyAnimating = false; window.addEventListener('click', e => raycast(e)); window.addEventListener('touchend', e => raycast(e, true)); function raycast(e, touch = false) { var mouse = {}; if (touch) { mouse.x = 2 * (e.changedTouches[0].clientX / window.innerWidth) - 1; mouse.y = 1 - 2 * (e.changedTouches[0].clientY / window.innerHeight); } else { mouse.x = 2 * (e.clientX / window.innerWidth) - 1; mouse.y = 1 - 2 * (e.clientY / window.innerHeight); } // update the picking ray with the camera and mouse position raycaster.setFromCamera(mouse, camera); // calculate objects intersecting the picking ray var intersects = raycaster.intersectObjects(scene.children, true); if (intersects[0]) { var object = intersects[0].object; if (object.name === 'stacy') { //判断 currentlyAnimating 是否为 false，即当有动画正在执行，那么就不会执行新动画。 if (!currentlyAnimating) { currentlyAnimating = true; playOnClick(); } } } } 12.精灵和粒子点云精灵材质平时我们见到的很多下雨、下雪、烟雾效果，都是采用粒子系统功能 使用的材料： 点精灵材质(SpriteMaterial)，一种使用Sprite的材质。 //创建精灵材质 createSprites() { for (let x = -30; x &lt; 30; x++) { for (let y = -20; y &lt; 20; y++) { for (let z = 0; z &lt; 5; z++) { const material = new THREE.SpriteMaterial({ opacity: 1.0, color: Math.random() * 0xffffff, }); const sprite = new THREE.Sprite(material); sprite.position.set(x * 4, y * 4, z * 100); this.scene.add(sprite); } } } } 点云效果在我们创建的精灵数量不多的情况下，精灵对象也可以实现复杂的点云效果，但是会卡到爆炸，这时候的渲染效率是我们所不能接受的 threejs给我们提供了更好的点云方案 // 创建点云 createPoints() { //创建一个缓冲几何体 const geom = new THREE.BufferGeometry(); const material = new THREE.PointsMaterial({ size: 2, //粒子大小 vertexColors: true, //设置顶点颜色开关是否采用缓冲几何体 color: 0xffff, }); const positions = []; const colors = []; for (let x = -30; x &lt; 30; x++) { for (let y = -20; y &lt; 20; y++) { for (let z = -30; z &lt; 30; z++) { positions.push(x * 4, y * 4, z * 100); const clr = new THREE.Color(Math.random() * 0xffffff); colors.push(clr.r, clr.g, clr.b); } } } geom.setAttribute( \"position\", new THREE.Float32BufferAttribute(positions, 3) ); geom.setAttribute(\"color\", new THREE.Float32BufferAttribute(colors, 3)); const cloud = new THREE.Points(geom, material); this.scene.add(cloud); } 不过感觉主要还是缓冲几何体解决了卡顿问题 BufferGeometry：缓存几何体，是面片、线或点几何体的有效表述。包括顶点位置，面片索引、法相量、颜色值、UV 坐标和自定义缓存属性值。使用 BufferGeometry 可以有效减少向 GPU 传输上述数据所需的开销。 读取或编辑 BufferGeometry 中的数据，见 BufferAttribute 文档。 点材质(PointsMaterial) Points使用的默认材质。 下雨效果小实践// 创建雨滴 createRain() { //创建一个缓冲几何体 const geom = new THREE.BufferGeometry(); const material = new THREE.PointsMaterial({ size: 4, //粒子大小 vertexColors: true, //采用每个粒子的颜色 transparent: true, depthWrite: false, //让黑色背景透明显示 opacity: 0.6, map: this.getTexture(\"img/rain2.png\"), blending: THREE.AdditiveBlending, //选择附加的混合模式，模式含义为在画新像素时颜色会被添加到新像素上 sizeAttenuation: true, //雨滴粒子远小近大 color: new THREE.Color(0xffffff), }); const positions = []; const colors = []; const velocities = []; //每个粒子偏移量 const range = 500; for (let i = 0; i &lt; 15000; i++) { positions.push( Math.random() * range - range / 2, Math.random() * range - range / 2, Math.random() * range - range / 2 ); velocities.push((Math.random() - 0.5) / 3, 0.1 + Math.random() / 5); const color = new THREE.Color(0x00eeff); const asHSL = {}; color.getHSL(asHSL); // 颜色采用HSL色彩模式，我们对亮度采用随机值的设置 color.setHSL(asHSL.h, asHSL.s, asHSL.l * Math.random()); colors.push(color.r, color.g, color.b); } geom.setAttribute( \"position\", new THREE.Float32BufferAttribute(positions, 3) ); geom.setAttribute(\"color\", new THREE.Float32BufferAttribute(colors, 3)); // 自定义属性，制造动画下雨效果 geom.setAttribute( \"velocity\", new THREE.Float32BufferAttribute(velocities, 2) ); this.cloud = new THREE.Points(geom, material); console.log(this.cloud); this.scene.add(this.cloud); } //下雨效果动画 raining() { const pos_BufferAttr = this.cloud.geometry.getAttribute(\"position\"); const vel_BufferAttr = this.cloud.geometry.getAttribute(\"velocity\"); for (let i = 0; i &lt; pos_BufferAttr.count; i++) { let pos_x = pos_BufferAttr.getX(i); let pos_y = pos_BufferAttr.getY(i); let vel_x = vel_BufferAttr.getX(i); let vel_y = vel_BufferAttr.getY(i); pos_x = pos_x - vel_x; pos_y = pos_y - vel_y; // 边界判断 if (pos_x &lt;= -20 || pos_x >= 20) vel_x = vel_x * -1; if (pos_y &lt;= 0) pos_y = 60; pos_BufferAttr.setX(i, pos_x); pos_BufferAttr.setY(i, pos_y); vel_BufferAttr.setX(i, vel_x); } //关键代码:把两个缓冲属性的needUpdate属性设置为真,驱使threejs对刚才修改的数值进行更新 pos_BufferAttr.needsUpdate = true; vel_BufferAttr.needsUpdate = true; } 然后再每一次render中调用下雨函数即可 render() { if (this.cloud !== null) { this.raining(); } this.renderer.render(this.scene, this.camera); } 13.其他细节rotation一个cube //第一步 cube.rotation.y = Math.PI / 2; //第二步 cube.rotation.x = Math.PI / 2; 此时的旋转时直接指根据当前标准的坐标轴旋转 如果想要根据物体自身的x、y、z轴（会根据旋转角度变化的坐标）来转，需要在旋转前增加 reorder 应用场景：第一人称视角的应用 //回到第二步 cube.rotation.reorder(\"YXZ\"); cube.rotation.y = Math.PI / 2; cube.rotation.x = Math.PI / 2; gsap动画库gsap库除了能运用于正常的dom和对象，还能在three中使用 import gsap from 'gsap' gsap.to(mesh.position, {duration: 1, x: 2}) gsap.to(mesh.position, {duration: 2, y: 2}) 其他优化细节 响应式渲染（主要是通过取消requestAnimationFrame减少性能消耗） 其内容主要是通过取消requestAnimationFrame减少性能消耗，对于一些整体动画要求不高的3d场景，我们此时可能之需要转动镜头观察可以，可以避免使用requestAnimationFrame，可以通过 controls.addEventListener('change', render); 来实时监听相机的变动，然后再render 并且启用阻尼 （enableDamping）,让翻转更加丝滑 OffscreenCanvas 是一个相对较新的浏览器功能，目前仅在Chrome可用，但显然未来会适用到别的浏览器上。 OffscreenCanvas 允许使用Web Worker去渲染画布，这是一种减轻繁重复杂工作的方法，比如把渲染一个复杂的3D场景交给一个Web Worker，避免减慢浏览器的响应速度。它也意味着数据在Worker中加载和解析，因此可能会减少页面加载时的卡顿。 实例化网格InstancedMesh 一种具有实例化渲染支持的特殊版本的Mesh。你可以使用 InstancedMesh 来渲染大量具有相同几何体与材质、但具有不同世界变换的物体。 使用 InstancedMesh 将帮助你减少 draw call 的数量，从而提升你应用程序的整体渲染性能。 一般用于大量重复的mesh const total = 1000000; let insGeometry = new THREE.BoxBufferGeometry(1, 1, 1); //创建具有多个实例的实例化几何体 let instanceMeshs = new THREE.InstancedMesh(insGeometry, material, total); //修改位置 let transform = new THREE.Object3D(); for (let index = 0; i &lt; total; i++) { transform.position.set(Math.random() * 2000, Math.random() * 2000, Math.random() * 2000); transform.scale.set(Math.random() * 50 + 50, Math.random() * 50 + 50, Math.random() * 50 + 50); transform.updateMatrix(); //修改实例化几何体中的单个实例的矩阵以改变大小、方向、位置等 instanceMeshs.setMatrixAt(i, transform.matrix); } 内存清理Three.js应用经常使用大量的内存，大多数的three.js应用在初始化的时候加载资源，并且一直使用这些资源直到页面关闭。但是，如果你想随时间的变动加载和改变资源怎么办呢？ 不像大多数的JavaScript库，three.js不能自动的清除这些资源。 如果你切换页面，浏览器会清除这些资源，需要我们自己来管理这些东西。 const boxGeometry = new THREE.BoxGeometry(...); const boxTexture = textureLoader.load(...); const boxMaterial = new THREE.MeshPhongMaterial({map: texture}); 然后在你处理完了它们之后，进行内存的释放 boxGeometry.dispose(); boxTexture.dispose(); boxMaterial.dispose(); 如果你嫌麻烦的话，可以造一个类，来自动管理资源清除 一些容易出现的bug防止canvas被清空 canvas截图 获取键盘输入 透明化canvas 透明立方体后半部分消失问题 参考文章 Three.js Fundamentals 学习视频：Three.js Journey","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"websocket","slug":"websocket","date":"2022-03-05T11:17:27.225Z","updated":"2022-03-05T11:17:27.225Z","comments":true,"path":"2022/03/05/websocket/","link":"","permalink":"https://taylor12138.github.io/2022/03/05/websocket/","excerpt":"","text":"1.WebSocket概括WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，是一个持久化的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。（打破了三次握手定律？？！NoNoNo，这里指的是一次握手指的是建立连接，完成握手归根到底于传输层tcp协议的三次握手） 但是WebSocket是基于http1.1（Websocket 通过HTTP/1.1 协议的101状态码进行握手。） + TCP协议的，http/2选择了基于SPDY （借用Wikipedia的） GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade （Connection：通用首部字段） Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== （浏览器随机生成，验证作用） Sec-WebSocket-Protocol: chat, superchat （不同的服务所需要的协议） Sec-WebSocket-Version: 13 （协议版本） Origin: http://example.com 而其中的核心在 Upgrade: websocket Connection: Upgrade WebSocket推送技术现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器 1.浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。（通过握手建立连接，http协议升级为websocket协议，服务端响应101状态码） 2.当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。（允许服务端主动向客户端推送数据） WebSocket推送技术和http2.0的服务端推送（server push）： HTTP协议和WebSocket协议都是应用层的协议，两者应用场景不一样。 HTTP主要用来一问一答的方式交付信息；WebSocket让通信双方都可以主动去交换信息。 HTTP2虽然支持服务器推送资源到客户端，但那不是应用程序可以感知的，主要是让浏览器（用户代理）提前缓存静态资源，所以我们不能指望HTTP2可以像WebSocket建立双向实时通信。 SocketSocket 其实并不是一个协议，是应用层与 TCP/IP 协议通信的中间软件抽象层，它是一组接口。 通过Socket，我们才能使用TCP/IP协议。 websocket协议升级客户端 GET ws://localhost:3000/ws/chat HTTP/1.1 Host: localhost Upgrade: websocket Connection: Upgrade Origin: http://localhost:3000 Sec-WebSocket-Key: client-random-string Sec-WebSocket-Version: 13 1.GET请求的地址以ws://开头的地址； 2.请求头Upgrade: websocket和Connection: Upgrade表示转换成为WebSocket连接； Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据； Sec-WebSocket-Version指定了WebSocket的协议版本。 服务端 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: server-random-string 该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 2.websocket实践在计网personnel篇章中我们阐述了websocket的实现原理，websocket协议让服务端实现向客户端主动推送消息的功能，不再需要采用旧版Ajax轮询这种浪费资源的方式。 websocket基于http 1.1协议 来自客户端的握手形式 GET ws://localhost/chat HTTP/1.1 Host: localhost Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Sec-WebSocket-Extension: permessage-deflate Sec-WebSocket-Version: 13 Upgrade表明是一个升级链接，升级为websocket Sec-WebSocket-Key是客户端采用base64位随机字符序列，服务器接收客户端HTTP协议升级的证明，用于标识该客户端，要求服务端响应一个对应的加密 Sec-WebSocket-Accept Sec-WebSocket-Extension协议拓展类型 来自服务端的握手形式 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Sec-WebSocket-Extension: permessage-deflate 客户端的实现创建websocket对象 var aWebSocket = new WebSocket(url [, protocols]); url 要连接的URL；这应该是WebSocket服务器将响应的URL。 protocols 可选 一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个WebSocket子协议（例如，您可能希望一台服务器能够根据指定的协议（protocol）处理不同类型的交互）。如果不指定协议字符串，则假定为空字符串。 // H5已经提供了websocket的API，可以直接使用 //这是人家websocket官方提供测试的url let socket = new WebSocket('ws://echo.websocket.org') websocket事件 事件 事件处理程序 描述 open websocket对象.onopen 建立连接时触发 message websocket对象.onmessage 客户端接收服务端数据时触发 error websocket对象.onerror 通信发生错误触发 close websocket对象.onclose 连接关闭触发 websocket方法 send()方法，，用于给服务端发送数据 然后再浏览器调试可以看到我们发送成功了 //H5已经提供了websocket的API，可以直接使用 //这是人家websocket官方提供测试的url let ws = new WebSocket('ws://echo.websocket.org'); // 1.连接成功的回调 ws.addEventListener('open', function () { console.log('连接成功'); }) // 2.主动给websocket发消息 button.addEventListener('click', function () { let val = input.value; ws.send(val) }) // 3.接收websocket服务的数据，通过事件对象e可以得到服务端返回的数据 ws.addEventListener('message', function (e) { console.log(e); div.innerHTML = e.data; }) 服务端的实现这里我使用的是nodejs带的websocket包（https://github.com/sitegui/nodejs-websocket 这个是该包对应的源码地点，里面有详解该包创建服务对象后，可以使用的方法） npm install nodejs-websocket 在新建的nodejs服务器上使用 每一次只要有用户进行连接，就会执行该回调函数，然后给当前用户创建一个connect对象 const ws = require(\"nodejs-websocket\") const server = ws.createServer(function (connect) { console.log(\"New connection\") //text事件用于接收用户请求，data为用户发送的数据 connect.on(\"text\", function (data) { console.log(\"Received \" + data) //服务器给客户端发送响应 connect.sendText(data.toUpperCase() + \"!!!\") }) //websocket连接断开（用户关闭网页等操作），执行的回调函数 connect.on(\"close\", function (code, reason) { console.log(\"Connection closed\") }) //一般使用注册close伴随着一个error事件，处理用户错误信息 connect.on('error', () => { console.log('用户连接异常'); }) //监听端口5208 }).listen(5208, () => { console.log('app is running at port!'); }) 给所有用户发送信息（广播）的方法 broadcast function broadcast(server, msg) { server.connections.forEach(function (conn) { conn.sendText(msg) }) } 然后在每个connect对象的事件里调用 broadcast(msg)即可，如果msg是一个对象，要将对象转化为字符串才能发送 send(JSON.stringfy(msg)) 3.websocket框架可以从上面看到，我们使用websocket时每一步事件都需要我们自己去封装，支持的时间太少，可能会比较麻烦，在应对搞复杂度的代码是会略显冗杂； 我们可以使用websocket框架 socket.io 进行替代 + 完善 说是说框架，但官方也解释了socket.io并不是websocket的一个实践，即使他在其中有使用到websocket的传输协议，但它作出了许多拓展，这就是为什么 WebSocket 客户端无法成功连接到 Socket.IO 服务器，而 Socket.IO 客户端也无法连接到普通 WebSocket 服务器的原因。（但在实现功能上，我们可以看成是一致的） 附上官网 https://socket.io/ 服务端使用npm install socket.io 在express中可以使用（官网还有在typescript、koa等语言框架中使用的方法） const app = require(\"express\")(); const httpServer = require(\"http\").createServer(app); //以前我们使用原生nodejs创建服务器、发送请求调用过http包 const options = { /* ... */ }; const io = require(\"socket.io\")(httpServer, [options]); httpServer.listen(3000); 1.此时监听用户连接事件 io.on(&quot;connection&quot;, socket =&gt; {}) socket 参数表示当前用户 socket.emit(事件名, 传入数据参数)socket主动触发事件的方法 socket.on(事件名, 接收数据参数)socket监听浏览器（客户端）/ 服务器 事件的方法 事件名参数是自定义的，该传递方式有点像Vue的事件总线（eventbus），实行订阅和发布消息数据 广播消息: io.emit io.on io.on(\"connection\", socket => { /* ... */ socket.emit('send', {name:'Allen'}); //发送数据到客户端 }); 2.此时监听用户断开事件 io.on(&quot;disconnect&quot;, () =&gt; {}) 3.跨域问题 注意：在 socket.io 中使用 cors允许跨域时，必须在option选项里进行设置，不然会报错 // socket 初始化 const io = require(\"socket.io\")(server, { cors: true }) 客户端使用安装 &lt;script src = \"/socket.io/socket.io.js\" > &lt;/script> &lt;script> const socket = io(); &lt;/script> or $ npm install socket.io-client 在同一个域通信 const socket = io(); 不同域通信 const socket = io(\"服务器地址url\"); 相对服务端，客户端并不需要将监听和发布时间放在 io.on(&quot;connection&quot;, () =&gt; {})里面，直接在script/ js文件里使用 socket.emit(事件名, 数据参数) / socket.on(事件名, 数据参数) 来实施客户端的事件监听和发布 踩坑之路： 部署到服务器上时，url地址记得为协议名 + ip + 端口号","categories":[{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"Hello"},{"title":"whistle","slug":"whistle","date":"2022-03-05T11:17:27.225Z","updated":"2023-01-24T03:52:50.827Z","comments":true,"path":"2022/03/05/whistle/","link":"","permalink":"https://taylor12138.github.io/2022/03/05/whistle/","excerpt":"","text":"Whislte概述Whistle 是一个基于 Node 实现的跨平台 Web 调试代理工具。 和其他抓包软件，如 Charles、Fiddler 一样，它可以查看、修改 HTTP、HTTPS、Websocket 的请求、响应，也可以作为 HTTP 代理服务器使用。得益于其强大的规则配置功能，理论上可以实现对请求、响应的任意修改。Whistle 是开源软件，使用完全免费。 官方文档 &amp; GitHub 快速安装： brew install whistle # 通过 Homebrew 安装 npm i -g whistle # 或者通过 npm 全局安装 启动 Whistle 服务： w2 start 然后就可以看见 配置代理配置代理方式我们可以查看官网：https://wproxy.org/whistle/install.html 其中有mac、windows 全局代理，chrome局部代理、手机全局代理 这里我选择chrome局部代理，使用 Proxy SwitchyOmega 扩展程序，单独为浏览器单独设置代理，进行本地环境调试 安装完成后，我们对其进行代理配置： 以上就配置完了，在开启whistle后，，对于浏览器先打开auto switch， 然后再打开http://127.0.0.1:8899/#network就可以看到包信息了 使用我们点击其中一个请求，在右侧边栏中即可看到该请求与响应的详细信息。其中： Overview 请求的基本信息 Inspectors 请求与响应的详情 Request: Headers, WebForms, Body, JSONView, HexView, Cookies, Raw Response: Headers, Preview, Body, JSONView, HexView, Cookies, Trailers, Raw Timeline 请求的时间线 Composer 构造请求，或者修改请求再次发送 Tools 其他工具 然后点击响应详情的 Inspectors -&gt; response -&gt; +key -&gt; 取个名字，将响应信息保存到本地 然后，在左侧边栏的「Values」菜单中，就可以看到我们保存的响应结果 这是一个编辑页面，编辑完后我们可以用control + s 保存 当然，我们最好把他换成json格式 设置替换规则现在我们有了mock的json文件，可以通过whistle的Rules选项设置规则，让接口匹配对应的mock数据 # 把前面的请求地址复制过来 https://域名/api/moyi/activity/creative/painting file://`{mockname.json}` # 如果你是跨域访问的，可能需要在最后加一个 resCors，就像这样： https://域名/api/moyi/activity/creative/painting file://`{mockname.json}` resCors://enable 而对于一般情况，我们也不可能针对一个地址一次规则替换信息，官方它的匹配模式规则，和正则匹配类似，当然还有其他好用的匹配规则，详情：https://wproxy.org/whistle/pattern.html # 路径匹配 http://www.test.com/xxx operatorURI # 通配符匹配 ^/api/moyi/activity/creative/painting file://`{mockname.json}` # 正则匹配 所有这个域名下的接口都强制开启 CORS /(igame|moyis|music)\\.163\\.com\\/.*api\\/.*/i resCors://enable host替换同样的，在Rules规则页，可以像设置本地/etc/hosts一样设置本地host 127.0.0.1 www.example.com 除此之外还有其他特点： 灵活匹配 除了保留hosts文件单一的语法规则来支持域名匹配外，whistle还提供给开发者更加灵活强大的端口映射(即支持ip带端口)、CNAME、路径匹配、精确匹配、正则表达式、组合等host匹配模式。语法规则的一般描述如下： host pattern1 pattern2 patternN host为计划转发到ip:port，pattern1-N为匹配请求url的表达式。当pattern只有一个时，host和pattern的顺序往往可以互换，具体可参考匹配模式。 端口映射 127.0.0.1:8080 www.example.com # 位置可以调换，等价于： # www.example.com 127.0.0.1:8080 对于本地开发调试，往往无法只在80端口提供Web服务。如果使用传统的hosts文件方式，我们只能通过www.example.com:8080访问到本地的8080端口，使用whistle提供的端口映射功能即可很好解决这一问题。 路径匹配 127.0.0.1:8080 example.com/test # 位置可以调换，等价于： # example.com/test 127.0.0.1:8080 通过配置上述规则，可将example.com/test路径下的请求转发到本地的8080端口，比如请求example.com/test/a.html、example.com/test?a=1，但对于请求example.com/testa则不会进行转发处理。注意，使用传统的hosts语法，是将该域名下的所有请求都进行host替换处理。 其他匹配规则和特性可以查看官网 线上环境打开本地页面经过whistle代理后，我们可以随意通过修改请求内容，将请求内容代理为本地页面，在传给app，就可以实现app线上环境查看本地环境页面 而这里更推荐重定向（redirect）来替换线上页面而不是强行暴力替换html，是因为页面的url地址还是没变的，此时css、js资源如果是依赖url + 路径名获取的话，会导致资源加载失败，甚至出现一些跨域问题 1.首先我们将手机弄个代理 2.给手机装好根证书，好抓https的包 3.在Rules规则页下进行替换 https://m.moyi.163.com/newyear20230117/half/index.html redirect://`http://本地ip地址:8080/half/index.html` # 通配符简化，也可以打开本地开发页面哦，注意要用局域网地址 ^/newyear20230117/half/index.html redirect://`http://本地ip地址:8080` 此时我们就可以在线上环境看到我们本地测试环境的页面了～ 替换js资源除此之外，我们甚至可以替换线上的js资源，帮我们免除掉反复线上部署，测试的问题（本地测试环境没问题，线上环境有问题的时候） 比如，我感觉这个包的js代码有问题，现在想要替换掉 我们直接把原始脚本下载下来，修改它。然后添加以下规则： # 这里在文件里加了个 alert(12345)，当然也可以加 debugger ^/static_public/5fb72673e2a9649c728fbf99/SocialLiveTask/1.0.2/index.min.js file:///Users/localcode/Downloads/index.min.js # 可选：禁用 JS 文件的浏览器缓存 *.js cache://no 刷新页面，可以看到修改的代码已经生效了（如果没生效，你可能需要清空浏览器缓存）。虽然代码是 minified 过的，但格式化一下，大部分情况下也可以调试了。但如果代码很复杂，minified 之后根本看不懂呢？ 没有关系，如果你本地有源码，那么可以修改源码，通过 npm run build 生成编译结果，然后再做资源替换。理论上来说，只要参数正确，本地生产的构建结果应该和线上的是一致的，所以替换也不会有问题。 通过这种方法，可以省去反复部署再验证的麻烦 设置 Cookie在手机上设置 cookie 一直是个比较麻烦的问题，一般可能会做个开发登录页来写入 cookie。通过 Whistle 的 cookie 替换功能，我们可以直接把 cookie 写入手机，无需其他繁琐操作。 以云音乐的 MIDDLE_U cookie 为例，在 whistle -&gt; http://127.0.0.1:8899/#values 中新建一个 JSON： { \"MIDDLE_U\": { \"value\": \"4547604608\", \"maxAge\": 315360000, \"httpOnly\": false, \"path\": \"/\", \"secure\": false, \"domain\": \".moyi.163.com\" } } 在 Rules 中添加如下规则： # 注意：域名需要和上面 cookie 中的 domain 是同源 # 这里匹配的是接口的域名 api.moyi.163.com resCookies://{moyidevcookie.json} 在手机上访问一下这个页面，cookie 就被设置上啦。设置完成后可以把这行规则注释掉，只要手机上不清空会一直生效。","categories":[{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"Hello"},{"title":"BOM","slug":"BOM","date":"2022-03-05T03:03:30.465Z","updated":"2023-01-26T13:28:56.129Z","comments":true,"path":"2022/03/05/bom/","link":"","permalink":"https://taylor12138.github.io/2022/03/05/bom/","excerpt":"","text":"1.BOM概述BOM是浏览器对象模型，他提供独立于内容而与浏览器窗口进行交互的对象，其核心对象是window BOM缺乏标准，Javascript语法的标准化组织是ECMA，DOM标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分，所以它的兼容性比较的差 BOM比DOM更大，它包含着DOM window对象是浏览器的顶级对象，它是JS浏览器的一个接口，是一个全局对象，定义在全局作用域的变量（var）、函数都会变成window对象的属性和方法（alert()、prompt() ），在调用的时候可以省略window 2.onLoad本来我们的内嵌式&lt;script&gt;&lt;/script&gt;只能放在所有标签标签下方 而window.onload可以解决，它是窗口加载事件，当文档内容完全加载以后才会触发该事件（包括图像、脚本、CSS），就调用该函数 &lt;script> window.onload = function() { var btn = document.querySelector('button'); btn.onclick = function() { } } &lt;/script> &lt;button>&lt;/button> 但是window.onload传统注册方式只能写一次，如果写多个，只以最后一个onload为准，所以推荐 window.addEventListener('load', function() {}) 所以一般情况下引入js文件，则该js文件都要添加 ↑ pageshow事件下面三种情况会触发load事件： 1.a标签的超链接 2.F5刷新（或者强制刷新） 3.前进或后退 但是在火狐中有个“往返缓存”，它不仅保留着页面数据，还保存着DOM和Javascript的状态，实际上将整个页面保存在内存里，导致后退按钮不能刷新页面（无法触发load事件） 所以此时可以用pageshow事件来触发，它有点像load，但是事件在页面显示时就会触发，无论页面是否来自缓存（注意这个事件是给window添加的） window.addEventListener('pageshow', fucntion(e){ //e.persisted返回的是true，就是说如果这个页面是从缓存取过来的页面，也需要重新计算一下rem if(e.persisted) { setRemUnit(); //这个函数是设置rem的 } }) DOMContentLoaded当DOM加载完毕时触发，不包括样式表，图片，flash等，ie9以上支持，如果页面图片很多，onload的触发会比较久，用户体验不佳 ，此时DOMContentLoaded比较合适，执行顺序DOMContentLoaded &gt; onload document.addEventListener('DOMContentLoaded',function(){ }); 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。 load和ready（jQuery） 一般情况下一个页面响应加载的基本顺序是：域名解析 -&gt; 加载html -&gt; 加载js和css -&gt; 加载图片等其他信息 $(document).ready()（在原生的jS中不包括ready()） 从字面的意思上理解，就是文档准备好了。也就是浏览器已经加载并解析完整个html文档，dom树已经建立起来了,然后执行此函数（不包含图片，css等） load 是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数，load方法就是onload事件。 所以对应的缺点是：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响 unload事件与load相对的是unload事件，它在文档卸载之后触发（有点像生命周期里的beforeDestory）；一般是从一个页面导航到另外一个页面市被触发，常用于清理引用，避免内存泄漏 window.addEventListener(\"unload\", () => { console.log(\"unLoad!!!!\") }) 3.调整窗口大小只要窗口发生变化，就会触发这个事件 window.onresize = function() {} window.addEventListener(&#39;resize&#39;, function() {}) 响应式布局原理 &lt;div>&lt;/div> &lt;script> var div = document.querySelector('div'); window.addEventListener('resize', function() { if (window.innerWidth &lt;= 800) { div.stye.display = 'none'; } else { div.style.display = 'block'; } }) &lt;/script> 4.定时事件setTimeoutwindow.setTimeout(调用函数, 延时时间) 这个window在调用时可以省略，延时时间单位是毫秒，默认省略为0 延时xx毫秒后，执行该函数，写函数名不加括号、不带参数 var a = setTimeout(function() {}, 1000); var b = setTimeout(callback, 1000); //callback为一个函数 页面中时常有很多定时器，我们经常给定时器加标识符（名字） setTimeout() 这个调用函数我们也称之为回调函数（需要等待时间，时间到了才去调用该函数） callback ，以前onclick之类的函数也是回调函数 注意： HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。 在node中，当第二个参数delay大于2147483647或小于 时1，delay 将设置为1。非整数延迟被截断为整数。 停止定时器 window.clearTimeout (timeoutID) timeID为定时器的名字（所以我们上方说明了经常要给定时器加名字），这里的window也可以省略，调用该停止定时器方法后，定时器的调用函数不执行，时间被停止了 setIntervalwindow.setInterval(回调函数, [间隔毫秒数]) 重复调用一个函数，每隔这个时间就去调用一次，写函数名函数不加括号、不带参数；window也可以省略，默认省略的话为0，同样我们也经常给该定时器加标识符（名字） 这里的关键点是第二个参数，间隔时间，指的是向队列添加新任务之前等待的时间， 比如调用setTimeout的时间为01:00:00，间隔时间为300毫秒，这意味着 01:00:03时，浏览器才会把任务添加到执行队列里，浏览器不关心这个任务什么时候执行，或者执行要花多长时间 因此到了 01:00:06，它会在想队列中添加一个任务 JavaScript中使用 setInterval 开启轮询。定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。而javascript引擎对这个问题的解决是：当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。 停止setInterval定时器 window.clearInterval(intervalID) 同停止定时器 利用定时器自动调用事件 例如调用在js中的某点击事件 // 自动播放轮播图 let timer = setInterval(function () { arrow_r.click(); }, 2000); }) 通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码 function demo() { setInterval(function(){ console.log(2) },1000) sleep(2000) } demo() 以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。 定时器的问题关于定时器延时比设定更久的原因： 最小延时 &gt;=4ms（也就是说有4ms的延时） 在浏览器中，setTimeout()/setInterval() 的每调用一次定时器的最小间隔是4ms（不过，Chrome 已将其更改为 2 毫秒，并且显然存在一些问题。），这通常是由于函数嵌套导致（嵌套层级达到一定深度），或者是由于已经执行的setInterval的回调函数阻塞导致的。例如： function cb() { f(); setTimeout(cb, 0); } setTimeout(cb, 0); setInterval(f, 0); 如果想在浏览器中实现0ms延时的定时器，你可以参考（使用postMessage自己写一个定时器函数加载window对象上） https://dbaron.org/log/20100309-faster-timeouts 因此，在间隔时间极端的情况下，不建议使用定时器 requestAnimationFrame（IE9-浏览器不支持该方法）官方解释：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame() 参数：callback 下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。 注意：这个callback会自带一个参数：该回调函数会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同，它表示requestAnimationFrame() 开始去执行回调函数的时刻。 有点像停留时间为 1 / 60 秒的setTimeout，默认每秒60帧，也就是 1000 / 60，采用系统时间间隔，保持最佳绘制效率，动画不会掉帧，自然流畅 对比起 setInterval和 setTimeout的优势 requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。 (function animloop() { render(); window.requestAnimationFrame(animloop); })(); 当然，requestAnimationFrame也有自己的消除定时器，需要传入requestAnimationFrame的id，而id来自于requestAnimationFrame的返回。 let rafId = null; (function animloop(time) { console.log(time,Date.now()) render(); rafId = requestAnimationFrame(animloop); //如果left等于50 停止动画 if(left == 50){ cancelAnimationFrame(rafId) } })(); 对于requestAnimationFrame 任务类型的划分： W3C 工作组在 2015 年 9 月 22 日的一篇工作笔记《Timing control for script-based animations》 中提到了 animation task source 这一概念，在该文中，确实将 animation frame request callback list 中的 callback 作为 task 处理。另外，在 zone.js 中也将 requestAnimationFrame 划进 macrotask 分类中。但 whatwg 规范中对 requestAnimationFrame callback 未明确出现任何 task 相关字眼，由于 whatwg 和 w3c 的分歧，我对 requestAnimationFrame 是否该划分为 task 存保留意见。 setTimeout(() => { console.log('A') }, 0) requestAnimationFrame(() => { console.log('B') Promise.resolve().then(() => { console.log('C') }) }) /*多刷新几次 结果1： B C A 结果2： A B C */ 执行 requestAnimationFrame callback 是 UI Render 的其中一步。 如果浏览器试图实现 60Hz 的刷新率，那么 UI Render 只需要每秒执行 60 次（每 16.7 ms）。如果浏览器发现『顶层浏览器上下文』无法维持住这个频率，可能会下调到可维持的 30Hz，而不是掉帧。（本规范并不对何时进行 render 做任何规定。）类似的，如果一个顶层浏览器上下文在后台运行，用户代理可能决定将该页面的刷新率降到 4Hz，甚至更低。 由于规范没有做约定，所以浏览器在 render 策略上有充分的自主性。既有可能出现每一轮 eventloop 后都 render 的现象，也有可能出现几十轮 eventloop 都不 render 的情况。 performance.now()performance.now() 方法返回一个精确到毫秒的 DOMHighResTimeStamp。 警告： 这个时间戳实际上并不是高精度的。为了降低像Spectre这样的安全威胁，各类浏览器对该类型的值做了不同程度上的四舍五入处理。（Firefox 从 Firefox 59 开始四舍五入到 2 毫秒精度）一些浏览器还可能对这个值作稍微的随机化处理。这个值的精度在未来的版本中可能会再次改善；浏览器开发者还在调查这些时间测定攻击和如何更好的缓解这些攻击。 它和Date.now()不同的点： 和 JavaScript 中其他可用的时间类函数（比如Date.now）不同的是，window.performance.now()返回的时间戳没有被限制在一毫秒的精确度内，相反，它们以浮点数的形式表示时间，精度最高可达微秒级。 另外一个不同点是，window.performance.now()是以一个恒定的速率慢慢增加的，它不会受到系统时间的影响（系统时钟可能会被手动调整或被 NTP 等软件篡改）。另外，performance.timing.navigationStart + performance.now() 约等于 Date.now()。 5.JS执行队列JS原先是单线程，也就是说同一时间只能做一件事，但是单线程就意味着，所有任务需要排队，钱一个任务结束后，才能执行下一个任务，如果JS执行时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞 多线程十分强大，但是多线程同步比较复杂，并且危险，稍有不慎就会崩溃死锁 &amp; 造成大量并发问题 而传统上，JS旨在用于简短，快速运行的代码片段，作为浏览器脚本语言，主要用途是与用户互动，以及操作DOM，所以JS比较适合单线程 为了解决这个问题，H5提出Web Worker标准，允许JS创建多个线程（实际上是“假”并发），于是JS出现了同步（单线程）和异步（现在的JS可以同时多个任务） 他们本质的区别是，这条流水线上各个流程执行的顺序不同 （1）同步和异步同步任务都放在一个主线程上执行，形成一个执行栈，按顺序执行 异步任务：JS的异步是通过回调函数实现的，一般而言，异步任务有以下三种类型 1.普通事件，如click、resize等 2.资源加载，如load、error等 3.定时器，如setTimeout、setInterval等 （2）宏任务和微任务这里需要注意的是new Promise是会进入到主线程中立刻执行（promise本身不是异步，只是里面的任务是异步的罢了），而promise.then则属于微任务 宏任务(macro-task)：是由宿主（Node、浏览器）发起的，比如整体代码script、setTimeOut、setInterval、postMessage 微任务(mincro-task)：由JavaScript自身发起，比如promise.then、process.nextTick(node) 微任务先执行，宏任务后执行 同步代码执行完成后，会先执行微任务队列。注意：此时会把所有微任务队列全部执行完。再去宏队列macrotask取出一个执行，如果宏任务执行过程中产生新的微任务，会跳过微任务继续执行并立即把微任务放到异步任务队列大池子中。当前宏任务执行完后，又去检查待执行的任务队列大池子，如果有微任务，就优先执行微任务，如果没有就继续执行宏任务队列 （3）执行机制1.先执行执行栈中的同步任务 其实我们平时也可以在报错信息看到执行栈 function foo() { throw new Error('error') } function bar() { foo() } bar() 2.异步任务（回调函数）放入任务队列中（只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。） 3.”任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 4.一旦执行栈所有同步任务执行完毕，系统就会按次序读取任务队列的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 注意：！！ 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。（比如setTimeout(fn, time)，第一个参数为回调函数） 有异步任务交给异步进程处理（新开一个线程用来执行那些异步任务，我们暂且称为工作线程），异步任务执行完毕后推入任务队列 当主线程执行完毕就来查询任务队列，取排在第一位的事件推入主线程处理，执行完再来取，不断循环，这个过程叫作事件循环 （实际上细分异步事件的优先级有宏任务和微任务，优先级：微任务&gt;宏任务） 异步任务执行顺序不一定按照原来顺序，要取决于文件大小、操作系统调度机制等多方面原因 （4）node的执行机制node的事件循环包括六大阶段，每个阶段都有一个自己的先进先出的队列，只有当这个队列的事件执行完或者达到该阶段的上限时，才会进入下一个阶段。 timers阶段（setTimeout、setInterval的事件回调） pending callbacks 阶段：处理上一轮循环中少数未执行的I/O回调 idle，prepare阶段：仅node内部使用 poll阶段：会做两件事，适当条件下node阻塞在这里 两件事情： 回到 timer 阶段执行回调 执行 I/O 回调 check阶段：执行setImmediate回调 close callbacks 阶段：执行socket的close回调 这导致了node和浏览器端执行宏任务和微任务的顺序不一样！！ 不过！！在node新的版本逐步完善了，也就是node新版本标准和浏览器趋于相同 （V12.7以上） process.nextTick 这个函数其实是独立于node的 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。 一个小案例：（https://segmentfault.com/a/1190000023315304） setTimeout(() => { setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }); }, 0); 外层是一个setTimeout，所以执行他的回调的时候已经在timers阶段了 处理里面的setTimeout，因为本次循环的timers正在执行，所以他的回调其实加到了下个timers阶段 处理里面的setImmediate，将它的回调加入check阶段的队列 外层timers阶段执行完，之后事件循环继续往后面的阶段走，进入pending callbacks，idle, prepare，poll，这几个队列都是空的，所以继续往下 到了check阶段，发现了setImmediate的回调，拿出来执行 然后是close callbacks，队列是空的，跳过 又是timers阶段，执行我们的console 但如果把 setTimeout、 setImmediate放在外面会怎么样？ console.log('outer'); setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }); 结果是！多运行几次，结果不一样 而其中的执行是这样子的： 外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段 遇到setTimeout，虽然设置的是0毫秒触发，但是被node.js强制改为1毫秒，塞入timers阶段 遇到setImmediate塞入check阶段 同步代码执行完毕，进入Event Loop 先进入times阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足setTimeout条件，执行回调，如果没过1毫秒，跳过 跳过空的阶段，进入check阶段，执行setImmediate回调 最后总结的原因是： 通过上述流程的梳理，我们发现关键就在这个1毫秒，如果同步代码执行时间较长，进入Event Loop的时候1毫秒已经过了，setTimeout执行，如果1毫秒还没到，就先执行了setImmediate。 每次我们运行脚本时，机器状态可能不一样，导致运行时有1毫秒的差距，一会儿setTimeout先执行，一会儿setImmediate先执行 6.location对象location是window对象提供给我们的一个属性，用于获取或设置窗体的URL，并且可以用于解析URL，返回的是一个对象 URL：统一资源定位符是互联网上标准资源的地址，互联网上每个文件都有唯一的URL，它包含的信息支持文件的位置以及浏览器该如何使用它（URL也就是我们的网址） 组成： protocol://host[:port]/path/[?query]#fragment protocol：通信协议，即http、ftp等 host：主机（域名） port：端口号，可选 path：路径，用 / 分隔 query：参数，以键对的形式，通过 &amp; 分隔 fragment：片段， # 后面内容，常见于链接锚点 location对象属性： location.href 获取或设置（实现页面跳转） 整个URL（最常见） location.hash URL散列值，Vue-Router、的hash模式、React路由的HashRouter 跳转原理 location.host 服务器名和端口号 location.search 返回参数（即query部分 ）（这不就是React的search传参吗？） location.assign() 跟href一样，可以跳转页面，但是可以后退 location.replace() 同上，但是不能记录历史，不能实现后退功能 location.reload() 类似于F5刷新 （location.reload(true)为强制刷新，缓存一起没了） 等等 7.navigator对象navigator对象包含浏览器的信息，它可以知道你是用的是pc端浏览器还是移动端浏览器，有很多属性，最常用的是userAgent，该属性值返回又客户机发送服务器user-agent头部的值 &lt;script> if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href = \"../H5/index.html\"; //手机 } &lt;/script> 引入以上代码可以自动判断是进入了pc端浏览器还是移动端浏览器 此外，navigator还暴露了一些API，可提供浏览器和操作系统的状态信息 Geolocation API navigator.geolocation属性暴露了Geolocation API，可以让浏览器脚本感知当前设备的地理位置。这个API只在安全执行环境（HTTPS）中可用 手机GPS的坐标系统可能具有极高的精度，而IP地址的精度就要差的很多 不过浏览器也有可能会利用 Google Location Service（Chrome和Firefox）等服务确定位置。有时候，你可能发现自己并没有GPS，但浏览器给出的坐标却十分精确，是因为浏览器会收集所有可用的无线网络，包括Wifi和蜂窝信号，拿到这些信息后，再去查询网络数据库。 navigator.geolocation.getCurrentPosition((position) => console.log(position), (err) => console.log(err)) 第一个是回调成功的函数，传入的 postion参数，有众多属性， 比如其中 postion.coordinates对象有 latitude 经度， longitude维度、alititude海拔、speed设备移动速度 第二个接收失败回调函数 Connection State任何时候，都可以通过 navigator.onLine属性来确定浏览器的联网状态，该属性返回一个布尔值，表示浏览器是否联网。 const connectionStateChange = () => console.log(navigator.onLine); window.addEventListener('onLine', connectionStateChange) window.addEventListener('offLine', connectionStateChange) //设备联网 //true //断网 //false 视频录制屏幕共享 const mediaDevices = navigator.mediaDevices; mediaDevices 是 Navigator 只读属性，返回一个 MediaDevices 对象，该对象可提供对相机和麦克风等媒体输入设备的连接访问，也包括屏幕共享。 而 MediaDevices 接口的 getDisplayMedia() 方法提示用户去选择和授权捕获展示的内容或部分内容（如一个窗口）在一个 MediaStream 里. 然后，这个媒体流可以通过使用 MediaStream Recording API 被记录或者作为WebRTC 会话的一部分被传输，也就是被 MediaRecorder传输 const promise = navigator.mediaDevices.getDisplayMedia(constraints); 此时可以共享屏幕 document.querySelector('#start').onclick = function() { if (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getDisplayMedia) { navigator.mediaDevices.getDisplayMedia({ video: true, audio: false }).then((stream) => { document.querySelector('#video').srcObject = stream; }).catch((err) => { console.error(err); }) } else { alert('不支持这个特性'); } } 屏幕录制 MediaRecorder 是 MediaStream Recording API 提供的用来进行媒体轻松录制的接口, 他需要通过调用 MediaRecorder() 构造方法进行实例化. new MediaRecorder(stream, [, options]); MediaRecorder.start(timeslice)开启录制，timeslice是一个可选参数，设置了这个参数就会按照时间段存储数据 const btn = document.querySelector('.button') btn.addEventListener('click', async () => { //一个捕获的接口，此时会弹出一个弹窗，让你选择捕获哪里的，返回一个promise对象（视频流） //目前只能录屏幕，暂无法支持音频，在监听dataavailable、stop阶段出问题 const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false }) // MediaRecorder.isTypeSupported()方法会判断其 MIME 格式能否被客户端录制。 const mime = MediaRecorder.isTypeSupported(\"video/webm; codecs=vp9\") ? \"video/webm; codecs=vp9\" : \"video/webm\" //实例化录制接口 const recorder = new MediaRecorder(stream, { mimeType: 'audio/webm' }) const chunks = [] recorder.addEventListener('dataavailable', (e) => { chunks.push(e.data) }) recorder.addEventListener('stop', () => { //视频流转blob，二进制数据 const blob = new Blob(chunks, { type: chunks[0].type }) let url = URL.createObjectURL(blob) //展示视频 const video = document.querySelector('.video') video.src = url //下载 const a = document.createElement('a') a.href = url a.download = 'video.webm' //设置a标签下载属性 a.click() }) recorder.start() //需要我们去手动启动 }) 查看MIME 格式支持情况 const types = [\"video/webm\", \"audio/webm\", \"video/webm\\;codecs=vp8\", \"video/webm\\;codecs=daala\", \"video/webm\\;codecs=h264\", \"audio/webm\\;codecs=opus\", \"video/mpeg\"]; for (var i in types) { console.log(\"Is \" + types[i] + \" supported? \" + (MediaRecorder.isTypeSupported(types[i]) ? \"Maybe!\" : \"Nope :(\")); } 参考资料https://cloud.tencent.com/developer/article/1793748 7.history对象用于与浏览器历史记录进行交互（实际上和浏览器自带的页面后退，前进功能一样） 实际开发用的少，但是一些OA办公系统会用到 history.back() 后退功能 history.forward() 前进功能 history.go(参数) 前进后退功能，参数是1前进一个页面，-1后退一个页面 history.pushState 历史记录管理 hashchange 会在页面URL的散列变化时被触发，开发者可以在此时执行某些操作，而状态管理API则可以让开发者改变浏览器URL而不会重新加载页面。为此 可以使用history.pushState()方法 接收三个参数 一个state对象 一个新的状态标题 一个可选的 相对URL history.pushState(stateObj, &quot;my title&quot;, &quot;baz.html&quot;) 执行后，状态信息会被推送到历史记录中，浏览器地址栏也会改变以反映新的相对URL，即使location.href返回的是地址栏中的内容，浏览器不会向服务器发送请求。 可以通过 history.state来获取当前的状态对象，也可以使用 replaceState()并传入与 pushState()同样的前两个参数来更新状态（覆盖状态） 注意：使用HTML5状态管理时，要确保通过 pushState()创造的每个“假”的URL背后都对应着服务器上一个真实的的URL，否则单击“刷新”按钮会导致404.所有单页面应用程序（SPA）框架都必须通过服务器或客户端的某些配置解决这个问题。 通过pushState的方式更改href和直接点击 &lt;a href=&quot;/后缀名&quot;&gt; 不同的是，后者会向服务器请求资源 8.获取CSS属性的值Window.getComputedStyle()方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值。 私有的CSS属性值可以通过对象提供的API或通过简单地使用CSS属性名称进行索引来访问。 let style = window.getComputedStyle(element, [pseudoElt]); 对比直接获取 style ： 返回的对象与从元素的 style (en-US) 属性返回的对象具有相同的类型;然而，两个对象具有不同的目的。从getComputedStyle返回的对象是只读的，可以用于检查元素的样式（包括由一个&lt;style&gt;元素或一个外部样式表设置的那些样式）。elt.style对象应用于在特定元素上设置样式。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React中使用TS","slug":"React中使用TS","date":"2022-03-04T16:00:00.000Z","updated":"2022-05-03T03:54:29.541Z","comments":true,"path":"2022/03/05/react-zhong-shi-yong-ts/","link":"","permalink":"https://taylor12138.github.io/2022/03/05/react-zhong-shi-yong-ts/","excerpt":"","text":"在React中使用typescriptReact脚手架 + typescript npx create-react-app my-app --template typescript 如果是对当前React脚手架项目添加typescript支持 npm install --save typescript @types/node @types/react @types/react-dom @types/jest 但是有个问题就是：将 TypeScript 添加到现有项目不会添加 tsconfig https://github.com/facebook/create-react-app/issues/10951 作为一种较为无语的解决方法： 作为一种解决方法，我通过运行创建了一个新的 react 应用程序：npx create-react-app ts-example --template typescript然后将生成的 tsconfig.json 的内容复制粘贴到我现有的应用程序中。 对于类式组件在构建React组件类的时候，还有这一种接口的写法 React.Component&lt;props接口的名称, state接口的名称&gt;，用来说明派生的 Component 使用的 Props 和 State 的类型 React.Component&lt;Props, State> ref对象，我们也需要手动声明它的类型 myRef = React.createRef&lt;ref的元素类型&gt;()比如以下例子 import React, { Component, createRef } from 'react'; interface IState { name: string } // 泛型第一个约定props属性、第二个约定状态 class App extends Component&lt;any, IState> { state = { name: \"allen\" } myRef = createRef&lt;HTMLInputElement>() render() { return ( &lt;div> &lt;input type=\"text\" ref={ this.myRef}/> &lt;button onClick={ () => { console.log((this.myRef.current as HTMLInputElement).value); } }>&lt;/button> &lt;Child name={this.state.name}>&lt;/Child> &lt;/div> ); } } interface IProps { name: string } class Child extends Component&lt;IProps, IState> { } export default App; 对于函数式组件函数式组件十分轻松，不用做什么处理，作为状态state已经被隐式推导了 而其他的规范也十分轻松 import React, {useState, useRef} from 'react' //非要自己显式也不是不行： const [name, setName] = useState&lt;string>(\"allen\") interface IProps { name: string } export default function App(props:IProps) { const [name, setName] = useState(\"allen\") const inputRef = useRef&lt;HTMLInputElement>(null) return ( &lt;div> &lt;div>{name}&lt;/div> &lt;input type=\"text\" ref={inputRef}/> &lt;button onClick={ () => { setName(\"Mikasa\") console.log((inputRef.current as HTMLInputElement).value); } }>&lt;/button> &lt;/div> ) } react路由+TS对于react-router-dom，无法直接使用，需要声明文件（declare）（或者你自己写声明文件，手动狗头） npm i --save-dev @types/react-router-dom 注意事项：作为路由组件，应该带有三个属性：history、location、match 首先引入 RouteComponentProps props的声明，得到路由组件的类型推断 其次可以在该声明中传入泛型，这个泛型是指定路由参数（params）类型的泛型 import React, { useState, useRef } from 'react' import {RouteComponentProps} from 'react-router-dom'; interface IParams { name: string } export default function App(props:RouteComponentProps&lt;IParams>) { return ( &lt;div> {props.match.params.name} &lt;/div> ) } redux+TSredux已经有声明文件了，这里不用下载 三个文件 新建 store.js 新建一个处理xxx组件的 xxx-reducer.js 可选，新建一个处理xx组建的xxx-action.js store几乎照常写就行了，而reducer和action传参的时候小小修改一下 interface IAction { type: string; payload?: any; } interface IPreState { isShow: boolean } export default function countReducer(preState: IPreState = { isShow: true }, action: IAction) { const { type, payload } = action; let newState = preState; //... return newState; } 小坑alias关于TS在create react app应用的小坑 webpack配置 module.exports = { //... resolve: { alias: { '@': path.join(__dirname, '../src') } } }; 但是在项目中使用alias转换的全局路径，ts不买账 为了解决这个问题，需要借助tsconfig，尽管webpack已经配置好了alias， 可是ts并不认账。 tsconfig.json配置如下 需要在compilerOptions 增加2个字段， baseUrl 指定当前工程的路径， paths 用于对别名的映射。 { \"compilerOptions\": { // ... \"baseUrl\": \".\", \"paths\": { \"@/*\": [\"./src/*\"] } // ... } } 在此就能解决上述问题了，如果不行可能需要重启vscode。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"MongoDB","slug":"MongoDB","date":"2022-02-26T12:22:09.129Z","updated":"2022-02-26T12:22:09.129Z","comments":true,"path":"2022/02/26/mongodb/","link":"","permalink":"https://taylor12138.github.io/2022/02/26/mongodb/","excerpt":"","text":"1.MongoDB概述MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 mongoDB不需要学习sql语句 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写 关系型数据库和非关系型数据库 关系型数据库 非关系型数据库 需要通过sql语言来操作 不需要 需要设计表结构，支持约束 不需要 通过事务来控制多张表的更新 没有事务这个概念，每一个数据集都是原子级别的。 以数据库表的形式存储 用key- value键值对存储，结构不稳定 纵向扩展，数据采用纵向扩展，提高处理能力 横向拓展，天然是分布式的，所以可以通过集群来实现负载均衡 非关系型数据库没有行列的概念，用json来存储数据 而MongoDB是长得最像关系型数据库的非关系型数据库 数据库 =&gt; 数据库 数据表 =&gt; 集合（数组） 表记录 =&gt; （文档对象） { 数据库:{ 集合:[ {name: &#39;Allen&#39;}, {name: &#39;Allen&#39;}, {name: &#39;Allen&#39;}, ] } } MongoDB 将数据存储为 BSON 文档。BSON 是 JSON（JavaScript Object Notation）的二进制表示。 tip： 数据库之间的关系： 一对一（身份证号） 一对多（一个班级多名学生） 多对多（一个学生多门课程，一门课可以被多名学生选），一般再建立一个中间表，来保存两个表之间的关系信息 2.使用（windows版）开启服务（服务端）方式一：根据菜鸟教程提供的window MongoDB操作教程，就可以注册成window的一个服务，然后可以通过鼠标右键开启和停止这个服务了 方式二： #mongodb 默认使用执行 mongod 命令所处盘根目录下的/data/db作为自己的数据存储目录 #所以在第一次执行该命令之前，先手动新建一个 E(MongoDB所属盘):/data/db #然后再自己所属盘下 运行该命令 mongod 停止服务：ctrl + C或者直接关闭cmd窗口 如果想要修改默认的数据存储目录路径，可以（但是比较麻烦，不推荐） mongod --dbpath=数据存储目录路径 注意，在mongoDB4.x以后，不需要开启服务这个步骤，因为在客户端执行连接命令的时候，计算机会自动帮我们开启服务 连接（客户端）用一个命令窗口来打开MongoDB数据库 此时再打开一个窗口，输入以下命令进行连接（这个命令执行成功的前提是要把e:mongo/bin，也就是自己安装的mongoDB的bin路径加入到当前系统的环境变量中） #该命令默认连接本机的MongoDB服务 mongo 断开连接 exit基本命令查看显示所有数据库 show dbs 查看当前操作的数据库，默认为test，供测试 db 切换到指定数据库，如果没有该数据库则会新建一个（真正创建出来还得往该数据库里插入一条数据） use 数据库名称删除当前切换到的数据库 db.dropDatabase 查看当前数据库的集合（一个数据库有多个集合） show collections 原生的查询方法对于小项目还好，对于大项目来说可能性能不是很好，推荐使用第三方库来查询 你甚至可以在命令行里写for循环来插入。。 #在当前数据库的students集合中插入一个数据（对象），没有这个集合则会新建一个 db.students.insertOne({\"name\": \"Jack\"}) #在当前数据库的students集合中再插入一个数据（对象） db.students.insert({\"name\": \"Allen\"}) #查看当前数据库的students集合中的数据 db.students.find() #查看当前数据库的students集合中的数据数量 db.students.find().count() #查找当前数据库的students集合中name为Allen的数据 db.students.find({\"name\": \"Allen\"}) #查找当前数据库的students集合中name以A开头的数据 db.students.find({\"name\": A}) #查询前5条数据 db.students.find().limit(5) #跳过10条数据查找 db.students.find().skip(10) #移除 title 为“MongoDB”的文档 db.test.remove({'title': 'MongoDB'}) #一处test集合中所有数据 db.test.remove({}) #修改数据,修改name为Allen的数据，将其age改为33 db.stundents.update({\"name\": \"Allen\"}, {$set:{\"age\": 33}}) #完整替换掉数据 db.stundents.update({\"name\": \"Allen\"}, {\"name\": \"Bruce\"}) 删除集合 db.students.drop()索引使用基础使用索引是指对数据库表中一列或者多列的值进行排序的一种数据结构，可以让我们查询数据库变得更快，MongoDB的索引几乎和传统的关系型数据库一摸一样，其中也包含了一些基本的查询优化技巧 如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。（有点目录的感觉） 创建索引（里面传入要设置索引的字段（key），值为1升序序排序，-1为降序） db.user.ensureIndex({\"name\": 1}) 获取当前集合索引 db.user.getIndexes() 删除索引 db.user.dropIndex({\"name\": 1}) 此时使用 db.students.find({&quot;name&quot;: &quot;Allen&quot;})会发现快了巨多（上百倍的速度） 复合索引如果我们使用find查询时，使用的是复合查询，也就是 db.students.find({&quot;name&quot;: &quot;Allen&quot;, &quot;age&quot;: 1})这种类型的，此时我们需要复合索引，此时我们 1.只对查询name进行查询：会命中索引 1.对查询name &amp; age 进行查询：会命中索引age 1.只对查询age进行查询：不会命中索引 db.user.ensureIndex({\"name\": 1, \"age\": 1}) 唯一索引在缺省的情况下创建的索引均不是唯一索引，下面示例将创建唯一索引 说人话就是设置完唯一索引以后，这个字段就不能重复，比如目前某个数据其中一个键值对为 {&quot;uid&quot;: 1}，则不能再次添加 其中有个键值对为 {&quot;uid&quot;: 1} 的数据 db.user.ensureIndex({\"uid\": 1}, {\"unique\": true}) #再次插入uid重复的文档后，MongDB将报错 db.user.insert({\"uid\": 1}) db.user.insert({\"uid\": 1}) 3.MongoDB权限管理1.创建超级管理员账户(root)，删除管理员为 db,dropUser(用户名) use admin #查看当前数据库的账户 show users db.createUser({ user:\"admin\", pwd:'123456', roles:[{role:'root', db:'admin'}] }) 2.修改Mongdb数据库配置文件 在mongodb安装目录下的bin文件夹中，找到mongod.cfg（）记得先备份一下，用文本编辑打开（注意空格格式） security: [两个空格]authorization:[一个空格]enable3.重启mongodb服务 4.用超级管理员账户连接mongdob数据库，第二个取决于你注册的时候选择的db #超级管理员登录 mongo admin -u 用户名 -p 密码 如果是连接远程服务器，则敲入以下命令 mongo 远程服务器ip地址 -u 用户名 -p 密码 5.给xx数据库创建一个账户，让其只能访问xx数据库，不能访问其他数据库 use xx db.createUser({ user:\"xxmin\", pwd:'123456', roles:[{role:'dbOwner', db:'xx'}] }) 数据库用户角色：read、readWrite; 数据库管理角色：dbAdmin、dbOwner、userAdmin； 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager； 备份恢复角色：backup、restore； 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase 超级用户角色：root 4.在Node中操作MongoDB数据方法一：使用官方的mongodb包来操作（并且根据文档提供的使用方法步骤进行操作） https://github.com/mongodb/node-mongodb-native （new）https://docs.mongodb.com/drivers/node/current/fundamentals/connection/ CRUD const { MongoClient } = require(\"mongodb\"); // Connection URI const uri = \"mongodb://127.0.0.1:27017/\"; // Create a new MongoClient const client = new MongoClient(uri); async function run() { try { // Connect the client to the server await client.connect(); const db = client.db(\"cartoon\"); //数据库名字 const Result = await db .collection(\"bookss\") //集合名词 .find({}) .limit(3) .toArray(); console.log(Result); } finally { // Ensures that the client will close when you finish/error await client.close(); } } run().catch(console.dir); 方法二：使用第三方mongoose来操作 MongoDB数据库 5.Mongoosehttps://mongoosejs.com/ Mongoose是在nodejs异步环境下对MongoDB进行便捷操作的对象模型工具，Mongoose是NodeJS的驱动，不能作为其他语言的驱动 （mongoose所有api都支持promise，npm下载的时候直接下载mongoose就好了，不用下mongodb） npm i mongoose --save 以下代码在mongoose官网也能查看到 1.引包 require(&#39;mongoose&#39;); =&gt; 2.连接数据库 mongoose.connect (指定连接的数据库不一定需要存在，当你插入第一条数据之后就会被自动创建出来)=&gt; 第一个参数是连接的数据库 第二个参数是option，mongodb4.0之后，都需要传入 useNewUrlParser 参数，会识别url里用户所需的db，不传入会报警告，而 useUnifiedTopology 是使用一个统一的拓扑结构 第三个参数可传入一个回调函数 fn ，告诉用户：连接成功 注意：MongooseServerSelectionError: connect ECONNREFUSED ::1:27017的问题可能是由于node版本号导致的，请查看当前node版本是否小于17.0 3.创建模型mongoose.model(表名, 数据结构)（这里模型创建十分灵活，只需要在代码中设计你的数据库就可以了） =&gt; 4.实例化模型(new)，并将每个实例化的数据保存 save() 在该模型集合里 //demo.js // 引包 const mongoose = require('mongoose'); //连接MongoDB数据库（这里顺便创建了一个叫test的数据库） mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true }); //如果数据库要管理员账号密码，则需要以以下方式连接(账户名:密码@) //mongoose.connect('mongodb://allen:123456@localhost:27017/test'); //创建一个模型，说白了就是在设计数据库 //这里第一个参数是表名：Cat，第二个参数是数据结构 const Cat = mongoose.model('Cat', { name: String }); for (let i = 0; i &lt; 10; i++) { // 实例化一个Cat（往cats集合里面插入每一个kitty数据） const kitty = new Cat({ name: 'Zildjian' }); // 持久化保存kitty实例 kitty.save().then(() => console.log('meow')); } 连接本地的时候，连接地址可以在cmd中输入mongo，然后这里会看得到 设计文档结构在第3步创建模型之前，其实还可以独立开来，使用Schema设置文档结构，它会映射到mongodb中的一个collection 这个Schema是mongoose对比mongodb突出的一个特点 字段名称就是表结构的属性名称 约束的目的就是为了保证数据的完整性，不要有脏数据 var mongoose = require('mongoose'); var Schema = mongoose.Schema; mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true }); var userSchema = new Schema({ username: { type: String, required: true //设置该属性必须有配置，使用required }, password: { type: String, required: true }, email: { type: String }, other:{ type: String, default: 'noting' } }); 然后再用mongoose.model(表名, 数据结构)发布模型，此时把这个例子中userSchema放入第二个参数即可 var User = mongoose.model('User', userSchema); 第一个参数：为传入一个大写开头的字符串，用来表示你的文档名称，这个模型会和模型名称相同的复数数据库collectrion建立连接 第二个传的是对文档的约束，架构Schema 这里我们规定的集合规范为users collection，因为的User的复数形式是users，即集合的名称 当然我们这里可以传入第三个参数，此时我们就可以指定集合，不用使用默认的那个第一个参数复数形式!即集合名称的规范 var User = mongoose.model('User', userSchema, 'user'); //我要定义user collection的规范! 返回值是模型构造函数，我们有了模型构造函数之后，就可以对users集合数据进行操作了 操作数据确保数据库MongoDB被打开，并且再另外一个窗口进行连接 注意：mongoose增加数据是给你自动生成id 增加数据 利用返回的模型构造函数，new一个实例对象，顺便使用save()进行保存 let allen = new User({ username: 'allen', password: '123456', email: 'allen@qq.com' }); //ret是刚刚插入的那条数据 allen.save((err, ret) => { if (err) { console.log('保存失败'); } else { console.log('保存成共'); console.log(ret); } }) 查询数据 模型构造函数.find() 查询所有数据，ret返回一个数组，记录里面的数据（文档） User.find(function (err, ret) { if (err) { console.log('查询失败'); } else { console.log(ret); } }); 条件查询，查询username为Bruce的数据(按条件查找，ret返回一个数组，记录里面的数据（文档）) User.find({ username: 'Bruce' }, function (err, ret) { if (err) { console.log('查询失败'); } else { console.log(ret); } }); 只找到第一个匹配到的对象（文档）数据，ret返回一个对象 User.findOne({ username: 'Bruce', password: '123456' }, function (err, ret) { if (err) { console.log('查询失败'); } else { console.log(ret); } }); //promise格式，因为mongoose所有api都支持promise // User.findOne({ username: 'Bruce', password: '123456' }) // .then(data => { // console.log(data); // }, err => { // console.log('查询失败'); // }) 利用或，满足其中一个条件查询成功 User.findOne({ $or: [ { email: body.email }, { nickname: body.nickname } ] }, function (err, data) { if (err) { res.status(500).send('Server err'); }else { console.log(data) } }) 删除数据 remove现在似乎已经废弃了，所以采用delete 删除单个数据，删除条件为username: &#39;Zildjian&#39;的数据 User.deleteOne({ name: 'Zildjian' }, function (err) { if (err) console.log('删除失败'); }); 删除多个，删除条件为username: &#39;Zildjian&#39;的数据 User.deleteMany({ name: 'Zildjian' }, function (err) { if (err) console.log('删除失败'); }); 根据id删除： findByIdAndDelete 更新数据 updateOne 第一个参数为查找条件 第二个参数为更新的数据 回调函数能查看更改操作成功与否 User.updateOne({name: 'Allen'},{name: 'hhhh'}, function (err, data) { if (err) { res.status(500).send('Server err'); }else { console.log(data) } }) 根据id更改数据 User.findByIdAndUpdate('60142a5acbcef341281a7d18', { password: '789456' }, function (err, ret) { if (err) console.log('更新失败'); else console.log('更新成功！'); }) 还有其他更新数据方法可以在mongoose文档查看 模块化//db.js var mongoose = require(\"mongoose\"); mongoose.connect( \"mongodb://localhost:27017/test\", { useNewUrlParser: true, useUnifiedTopology: true }, function (err) { if (err) { console.log(err); return; } console.log(\"数据库连接成功\"); } ); module.exports = mongoose; //user.js const mongoose = require('./db') var Schema = mongoose.Schema; const userSchema = new Schema({ username: String, password: String }); var User = mongoose.model('User', userSchema, 'user'); module.exports = User 此时我们就可以在主目录下的app.js中导入User，使用它的方法直接操作数据库了 6.Mongoose其他预处理修饰符定义文档结构的一些模式修饰符 var userSchema = new Schema({ username: { type: String, trim: true, //自动去掉左右空格 lowercase: true, //自动去掉左右空格 uppercase: true, //自动去掉左右空格 }, password: { type: String, required: true }, }); 除此之外，我们还可以自定义修饰符 通过set（建议使用）修饰符在增加数据的时候进行格式化 通过get（不建议使用）修饰符在实例获取数据的时候对数据进行格式化 set： const mongoose = require(\"./db\"); var Schema = mongoose.Schema; const focusSchema = new Schema({ title: String, pic: String, redirect: { type: String, set(params) { //增加数据的时候对redirect字段进行处理 // 这里的params是redirect对应的值 //返回的数据为数据库实际保存的值 const rg = /^http(s?):\\/\\//; if (rg.test(params)) return params; return \"http://\" + params; }, }, }); var Focus = mongoose.model(\"Focus\", focusSchema, \"focus\"); module.exports = Focus; const Focus = require(\"./model/focus\"); let allen = new Focus({ title: \"title\", pic: \"pic\", redirect: \"netease.com\", }); //ret是刚刚插入的那条数据 allen.save((err, ret) => { if (err) { console.log(\"保存失败\"); } else { console.log(\"保存成功\"); console.log(ret); //redirect: 'https://netease.com', } }); get：使用get方法之后的结果（感觉没啥用处。。） /*pic: { type: String, get(params) { return \"001\" + params; }, },*/ const Focus = require(\"./model/focus\"); let allen = new Focus({ title: \"title\", pic: \"pic\", redirect: \"netease.com\", }); console.log(allen.title, allen.pic) //title, 001pic mongoose索引使用我们可以在Schema（文档约束结构）中直接制定索引 unique为设置唯一索引 index为设置普通索引 const userSchema = new mongoose.Schema({ username: { type: String, unique: true }, password: { type: String, index: true } }); mongoose扩展静态 | 实例方法实际情况扩展静态方法用的比较多 const userSchema = new mongoose.Schema({ //... }); // 静态方法 userSchema.statics.fn1 = function(id, cb){ this.find({\"id\": id}, function(err, dos){ cb(err, dos) }) } // 实例方法 userSchema.mehods.fn2 = function(){ //... } const User = mongoose.model('User', userSchema); 调用方式 User.fn1(123, function(){ //... }) let allen = new User({ username: 'allen', password: '123456', email: 'allen@qq.com' }); allen.fn2() 7.About数据库基础知识事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）； 数据库的事务特性有：原子性、一致性、持久性、隔离性 A atomicity 原子性 指的是事务包含的所有操作，要么全部成功，要么全部回滚失败（要么都做，要么都不做） C consistency 一致性 指的是事务必须使数据库从一个一致性状态到另一个一致性状态，即事务执行前后全部处于一致性状态 I isolation 隔离性 指的是多个并发事物间互相隔离，也就是一个事务执行的过程中,不应该受到其他事务的干扰 D durability 持久性 指的是事务一旦提交了，那么对数据库中数据的修改就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失提交事务的操作 脏读：就是没有提交的数据，举个例子：比如某个事务在对数据库中某条记录进行修改，修改后没有提交也没有回滚，也就是让其处于一个待定的状态，这个时候如果有其他的事务来先一步对这条记录进行读取或者处理了的现象。 不可重复读取：一个事务先后读取某条记录，但在两次读取之间该条记录杯其他另一个事务给修改了，就造成了两次读取的数据不同的现象。 幻读：幻读就是一个事务按照查询条件查询以前检索过的数据可是发现该数据被其他事务插入了满足其查询条件的新数据的现象。 不可重复读和脏读的区别是一个是读取了前一事务提交的数据，而一个是读取了另一个事务未提交的数据 幻读和不可重复读不同的是，幻读针对的是数据条数的变化 明文和密文明文放密码的危险 数据库一旦被攻破，或者被黑客脱库，所有信息都被泄露 数据库管理员“心怀不轨” 密文：明文经过加密之后输出的结果 只要加密的是同一个明文，则输出结果相同 密文是不可以你想转换为明文的 用法是只将输入的转成密文，然后对密文进行对比即可 加密方式：MD5（主流），sha1（微信，不过现在估计用sha2了），而大厂可能是先交给md5加密，然后再交给sha2在加密一次，然后再依靠自己的算法，再加密一次 npm i md5 const md5 = require('md5') const miwen = md5(password) 但是往上百度一下有md5在线解密功能！不过这个解密功能是靠大数据堆起来的，如果密码复杂一点可能就解密不了（惊喜哈哈哈） https://www.cmd5.com/ 本站针对md5、sha1等全球通用公开的加密算法进行反向查询，通过穷举字符组合的方式，创建了明文密文对应查询数据库，创建的记录约90万亿条，占用硬盘超过500TB，查询成功率95%以上，很多复杂密文只有本站才可查询。自2006年已稳定运行十余年，国内外享有盛誉。 2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证 npm i sha1 const sha1 = require('sha1') const miwen = sha1(password) 但是对于弱口令密码，往上还是可以查询查得出来","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"算法知识","slug":"算法知识","date":"2022-01-26T12:00:23.951Z","updated":"2022-01-26T12:00:23.951Z","comments":true,"path":"2022/01/26/suan-fa-zhi-shi/","link":"","permalink":"https://taylor12138.github.io/2022/01/26/suan-fa-zhi-shi/","excerpt":"","text":"判断链表是否有环使用快慢指针，当他们相遇时，则有环 bool IsExitsLoop(slist *head) { slist *slow = head, *fast = head; while ( fast && fast->next ) { slow = slow->next; fast = fast->next->next; if ( slow == fast ) break; } return !(fast == NULL || fast->next == NULL); } 找到环的入口参考博客地址：http://www.cppblog.com/humanchao/archive/2012/11/12/47357.html 公式推导： 快指针经过的路径：2s 慢指针经过的路径：s nr：走了n圈 假设真个链表长度为L，入环口与相遇点距离为x，起点到入环口的距离为a 则有： 2s = s + nr s = nr a + x = nr a + x = (n - 1)r + r = (n-1)r + L - a a = (n - 1)r + (L - a - x)由公式推导可知，只需要我们让两个指针分别指向起点和相遇的点，每次分别next走一步，则一定会在入环点相遇。 求环的大小只需让这两个快慢指针，继续在环里面走，再次相遇时，所走的步数 = 环的长度 背包问题01背包求最大值 x轴代表bag的容量提升，y轴代表不同物体的序号 物品定义： int w[5] = { 0 , 2 , 3 , 4 , 5 }; //商品的体积2、3、4、5 int v[5] = { 0 , 3 , 4 , 5 , 6 }; //商品的价值3、4、5、6 int bagV = 8; //背包大小 状态转移方程： for (int i = 1; i","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"红宝书啃读note(下)","slug":"红宝书啃读note(下)","date":"2021-12-20T04:37:38.669Z","updated":"2021-12-20T04:37:38.669Z","comments":true,"path":"2021/12/20/hong-bao-shu-ken-du-note-xia/","link":"","permalink":"https://taylor12138.github.io/2021/12/20/hong-bao-shu-ken-du-note-xia/","excerpt":"","text":"第12章BOMBOM核心是window对象，window对象在浏览器有双重身份，一个是ECMAScript的Global对象，一个就是浏览器窗口的JavaScript接口。 窗口关系 top对象始终指向最上层窗口，即浏览器窗口本身 parent对象始终指向当前窗口的父窗口，如果当前窗口是最上层窗口，则parent = top self对象始终指向window，是window的终极属性，实际上self和window就是同一对象，暴露self是为了和top、parent保持一致 导航和打开新窗口 window.open()用于导航到指定的URL，分别接受四个参数，返回一个对新建窗口的引用 加载的URL 目标窗口 如果不是已有窗口，则会打开一个新的窗口或标签页 特性字符串（配置） 以逗号分隔，设置字符串 比如fullscreen，表示窗口是否最大化；height，新窗口的高度 新窗口在浏览器历史记录中是否替代当前加载页的布尔值（通常不传这个参数） let wroxWin = window.open(\"https//www.wrox.com/\", \"wroxWindow\", \"height=400, width=400, top=10, left=10, resizable=yes\") 而弹出窗口有点时间被在线广告用滥了，于是，IE7之后、Firefox、Opera等开始弹窗施加限制；此外网页加载过程中调用window.open()没有效果，而且可能导致向用户显示错误，弹窗通常可能在鼠标点击或按下键盘中的某个键才能打开。 弹窗屏蔽：所有现代浏览器都内置了屏蔽弹窗的程序，如果是浏览器内置的弹窗屏蔽组织了弹窗，那么 window.open()返回null let wroxWin = window.open(\"https//www.wrox.com\", \"_blank\"); if (wroxWin == null) { alert(\"The popup was block\") } 如果是浏览器拓展或者其他程序屏蔽弹窗时，window.open()通常会抛出错误 系统对话框 console.log() alert() confirm() ，有点像alert()，但是确认框有两个按钮 Cancel、OK，返回一个布尔值 prompt()，有点像 confirm()的升级版，还多了一个文本框让用户输入，prompt会返回文本框中的值 第13章客户端的检测用户代理检测通过浏览器的用户代理字符串确定使用的是什么浏览器。用户代理字符串包含在每个HTTP请求头部，在JavaScript中可以通过 navigator.userAgent访问。 在服务器端，常见的做法是根据接收到的用户代理字符串确定浏览器并执行相应的操作。而在客户端，用户代理检测被认为是不可靠的（字符串可以造假）。 本来 userAgent是一个只读属性 console.log(window.navigator.userAgent); window.navigator.userAgent = 'foobar'; //无效 不过，通过简单的方法可以绕过这个限制，比如有些浏览器提供伪私有的 __defineGetter__方法，利用它可以篡改用户代理字符串。 console.log(window.navigator.userAgent); window.navigator.__defineGetter__('userAgent', () => 'foobar'); //无效 第14章DOM得到的是当前节点在同一父节点下的兄弟节点: node.previousSibling和 node.nextSibling 是否有孩子节点： hasChildNodes() cloneNode()：会返回与调用它的节点一模一样的节点，该方法接收一个布尔值参数，表示是否深复制 深复制会复制节点及其整个子DOM树，如果传入false，则只会复制调用该方法的节点。 注意：此方法并不会复制JavaScript属性，只复制了html属性 document.URL取得当前页面的完整URL document.domain取得当前页面的域名，浏览器对domain属性还有一个限制，就是这个属性一旦放松就不能再收紧，比如把document.domain设置成A，就不能再设置成B了 document.domain = 'baidu.com'; document.domain = 'google.com'; //收紧，错误 document.referrer取得来源 element.attributes获取当前元素所有属性，他最有用的场景是需要迭代元素上所有属性的时候，这时候往往是要把DOM结构序列化为XML或HTML字符串。 function output(element){ let pairs = []; let len = element.attributes.length; for(let i = 0; i &lt; len; i++) { const attribute = element.attributes[i]; pairs.push(`${attribute.nodeName} = ${attribute.nodeValue}`) } return pairs.join(''); } 用 innerHTML创建的 script标签永远不会被执行 逻辑上可以在JS修改CSS代码(除了IE) let style = document.createElement('style'); style.appendChild(document.createTextNode(\"body{background-color: red}\")) 理解NodeList、HTMLCollection、NamedNodeMap是理解DOM编程的关键，这三个集合都是实时的，意味着它们的值都是“最新的” MutationObserver接口：观察元素属性、子节点、文本或者前三者任意组合的变化 let observer = new MutationObserver(() => console.log('&lt;body> attributes changed')); observer.observe(document.body, {attributes: true}); 执行以上代码之后，body元素任何属性变化都会触发回调 它接受一个MutationRecord数组，保存着变化信息 let observer = new MutationObserver((mutationRecords) => console.log(mutationRecords)); 通常只要被观察元素不被垃圾回收，MutationObserver的回调都会相应DOM变化事件，从而被执行，若要提前终止回调，可以调用 disconnect()方法 observer.disconnect() 个人感觉和 IntersectionObserver API 有所关联 MutationObserver的垃圾回收： MutationObserver拥有对要观察的目标结点的弱引用，因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点 然而目标节点对 MutationObserver有强引用，如果目标节点从DOM被移除，随后被垃圾回收，则关联的 MutationObserver也会被垃圾回收 第17章事件使用click事件执行代码，有人认为，换成mousedown执行代码应用程序会更快，但是对于障碍用户使用的屏幕阅读器上，会导致代码无法执行，因为屏幕阅读器无法触发mousedown事件 oncontextmanu事件默认在网页出现点击鼠标右键弹出上下文菜单 contextmenu事件冒泡，因此只要给document指定一个事件处理程序就可以处理页面上的所有同类事件 这个时间可以在所有浏览器中取消，即使用event.preventDefault hashchange事件：用于URL散列值（#后面部分发生改变而回调的事件） hashchange事件处理必须交付给window，，它的event对象有两个新属性：oldURL、newURL 第19章表单脚本表单可以通过按钮提交表单，也可以通过form.submit()提交表单。通过 submit()提交表单的时候，submit事件不会触发，因此在调用这个方法之前要先做数据验证。 表单提交的一个最大的问题是可能会提交2次表单。如果表单提交之后没有什么反应，那么没有耐心的用户可能会多次点击，结果造成服务器处理重复请求，甚至造成多次下单的严重后果！ 解决方法：1.提交后禁用按钮；2.通过onsubmit事件处理程序取消之后的表单提交 同样的，也可以通过 form.reset()重置表单，但是与submit不同的是，reset()方法会像单击重置按钮一样触发reset事件 let form = document.getElementById(\"myForm\"); form.addEventListener(\"submit\", (e) => { let target = e.target; let btn = target.elements[\"submit-btn\"]; //name属性为submit-btn的在form内嵌的按钮 btn.disabled = true; }) 注意这个功能不能直接通过提交按钮添加click事件来实现，因为不同的浏览器中触发事件的时间是不一样的，有些浏览器是触发时机：submit &gt; click ；有一些是 submit &lt; click9 跨浏览器得到/ 设置剪切板数据 function getClipboardText(event) { var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.get(\"text\"); } function setClipboardText(event, value) { if(event.clipboardData) { return event.clipboardData.setData(\"text/plain\", value); } else if (window.clipboardData) { return window.clip } } 第20章JavaScript APINotifications API 用于向用户显示通知，这里的通知很像alert Notifications API又被滥用的可能性，因此会默认开启两项安全措施 通知只能在运行在安全上下文的代码中被触发 通知必须按照每个源的原则明确得到用户允许 // 设置通知权限 Notification.requestPermission() .then(permission => { console.log(permission); const n = new Notification(\"我是通知，我在被调用\"); n.onshow = () => console.log('show'); n.onclick = () => console.log('click'); n.onclose = () => console.log('close'); n.onerror = () => console.log('error'); }) 此项功能仅在安全上下文(HTTPS), 一些 支持的浏览器. 批量编码，通过 TextEncoder 的实例完成的，该实例上有一个 encode方法，接受一个字符串参数，并以Uni8Array故事返回每一个字符的UTF-8的编码 const textEncoder = new TextEncoder(); const decodedText = 'foo' const encodedText = textEncoder.encode(decodedText); 拖放事件 IE4最早在网页中支持图片和文本的拖放事件，IE5之后不断拓展 现在所有主流浏览器都实现了原生的拖放，在某个元素被拖动时，会按顺序触发以下事件（被拖动元素的事件）：dragstart、drag、dragend dragstart触发之后，只要目标还在被拖动就会不断触发drag事件，类似于mousemove -&gt; 拖动停止触发dragend 若是把元素拖动到目标上（放置位置所在元素的事件），则依次触发：dragenter、dragover、dragleave 大精度时间 const t0 = Date.now(); foo(); const t1 = Date.now(); console.log(t1 - t1); Date.now()只有毫秒级别的精度，如果foo执行的够快，则两者时间戳会相等 可以使用 High Resolution Time API : Performance const t0 = performance.now(); const t1 = performance.now(); console.log(t1 - t1); template模板 在浏览器渲染的时候，不会吧template的内容渲染到页面上，它不属于活动文档，它是DocumentFragment。 它是批量向HTML添加元素的高效工具，不用一个一个 appendChild 。可以看得出Vue、React都有与它有异曲同工之妙在其中 影子DOM 主要解决 / 用于 dom树建立时能够实现维护自身边界的问题。这么说有点像vue的scope保证自身不会被外来修饰入侵或者污染。 影子dom将对应的dom信息隐藏起来依然能在html文档里渲染出来。但不能通过普通的js方法获取到dom信息 影子dom事件捕获遵从常规dom事件，在影子dom内部依然传递，同时也遵从事件冒泡，向整个文档的dom上传递事件。 mode：该引用是否可以被获取，open/closed，一般没人选closed const foo = document.querySelector('#foo'); const bar = document.querySelector('#bar'); const = openShadowDOM = foo.attachShadow({mode: 'open'}); const = openShadowDOM2 = bar.attachShadow({mode: 'open'}); console.log(foo.shadowRoot); // shadow-root console.log(bar.shadowRoot); // null console.log(openShadowDOM); // shadow-root console.log(openShadowDOM2); // shadow-root 利用影子DOM创造三种不同颜色得div for(let color of ['red', 'green', 'blue']){ const div = document.createElement('div'); const shadowDOM = div.attachShadow({mode: 'open'}); document.body.appendChild(div); shadowDOM.innerHTML = ` &lt;p> Make me ${color}&lt;/p> &lt;style> p { color: ${color} } &lt;/style> ` } 影子DOM是为了自定义Web组件设计的，可以使用slot插槽嵌套dom片段（在其中同样可以看得出slot在Vue、React中的应用） document.body.innerHTML = ` &lt;div id=\"foo\"> &lt;p>Foo&lt;/p> &lt;/div> `; document.querySelector('div') .attachShadow({ mode: 'open' }) .innerHTML = ` &lt;div id=\"bar\"> &lt;slot>&lt;/slot> &lt;/div> `; 结果 &lt;div id=\"foo\"> #shadow-root(open) &lt;div id=\"bar\"> &lt;p>Foo&lt;/p> &lt;/div> &lt;/div> 第21章（错误处理和调试）finally子句 try/catch语句中finally子句始终运行，try/catch块无法阻止finally块执行，即使是return语句 function test(){ try { return 2; } catch { return 1; } finally { return 0; // 始终运行，该函数始终返回0 } } try/catch语句最好用在自己无法控制的错误上，假设你的代码中使用了一个大型JavaScript库某个函数，而该函数可能会有意或者处于错误而抛出错误。因为不能修改这个库的代码，就有必要通过try / catch 语句调用包装起来，对可能的错误进行处理。 如果你明确地知道自己的代码会发生某种错误，那么就不适合使用try / catch 语句 error事件 任何没有被try / catch 才处理的错误都会在window对象上触发error事件。在onerror事件处理程序中，任何浏览器都不会传入event对象。相反，会传入三个参数： 错误信息 发生错误的url 行号 window.onerror = (message, url, line) => { console.log(message); } 注意：不同浏览器在使用这个错误处理事件存在明显的差异 这个事件处理应该是浏览器报告错误的最后一道防线，理想状态下，最好不要用到（message其实就是控制台打印的错误罢了） 抛出错误 在大型应用程序中，自定义错误通常在使用assert() 函数抛出错误。这个函数接受一个应该为true的条件，并在条件为false时抛出错误，下面是一个基本的assert函数 function assert(condition, msg) { if(!condition) { throw new Error(); } } 第23章（JSON）JSON是一种轻量的数据格式，方便地表示复杂数据结构 JSON语法支持表示三种类型的值（他虽然借用了JavaScript的语法，但是不要将他们混淆） 简单值：字符串、数值、布尔值和null（特殊值undefined不可以） 对象：第一种复杂数据类型 数组：第二种复杂数据类型 JSON的流行不仅仅因为语法和JavaScript类似，很大程度还是因为JSON可以被及解析成可用的JavaScript对象，与解析为DOM的XML相比，有很大优势 ECMAScript5增加了JSON全局对象，正式引入JSON能力，并且得到所有主流浏览器的支持 JSON对象有两个方法： stringify()：将JavaScript解析为JSON字符串 parse()：将JSON解析为JavaScript值 有时候我们需要在JSON.stringify() 之上自定义 JSON序列化，可以在要序列化的对象中添加toJSON方法，序列化时会根据这个方法返回适当的JSON表示（原生的Date对象就有toJSON方法） const book = { title: 'allen', count: 0, toJSON: function () { return this.title; } } console.log(JSON.stringify(book)); //'allen' 第24章（网络请求和远程资源）Headers对象 Headers对象和map对象极其相似，包括它的get()、set()、has()、delete()等实例方法 但特殊的点在于： 初始化Headers对象时，可以放入键值对的对象 const sed = {foo: 'bar'} let h = new Headers(seed); let m = new Map(seed); //error 一个HTTP头部字段可以有多个值，而Headers对象通过append方法添加多个值 h.append('foo', 'baz'); // 此时foo有bar、baz Beacon API 很多分析工具需要在页面生命周期尽量晚一点的时候向服务器发送遥测或者分析数据，因此理想状态是通过浏览器的unload事件发送网络请求。 但是有一个问题，因为unload事件意味着浏览器没有任何理由发送任何位置结果的网络请求，例如在unload事件处理程序中创建的任何异步请求都会被浏览器取消，因此XMLHttpRequest或fetch不适合这个任务。分析工具可以强制发送同步请求，但是这样会导致用户要等待unload事件处理完成而延迟导航下一个页面 W3C引入了 Beacon API，它给navigator增加了一个sendBeacon方法 navigator.sendBeacon(url, 请求参数) sendBeacon() 不一定在页面生命周期末尾使用，可以在任何时候使用 调用 sendBeacon() 后，浏览器会把请求添加到一个内部的请求队列，浏览器会主动发送队列中的请求 浏览器保证在原始页面已经关闭的情况下也会发送请求 状态码、超时和其他网络问题造成的失败完全是不透明的，不能通过编程解决 信标（beacon）请求会携带 sendBeacon() 时所有相关的cookie 第26章（模块）ES6模块是作为一整块JavaScript代码而存在的，带有 type-&quot;module&quot;属性的 script标签会告诉浏览器相关代码应该作为模块来执行 &lt;script type=\"module\" src=\"xxxx\">&lt;/script> 与传统JavaScript处理方式不同，所有模块都会像 &lt;scirpt defer&gt; 加载脚本一样按照顺序执行，解析到 &lt;script type=&quot;module&quot;&gt; 标签后会立即下载模块文件，但执行会延迟到文档解析完成。 所以模块标签的位置之只决定了文件什么时候加载，并不会影响哪个模块什么时候加载 第27章（工作者线程）工作者线程的价值：在单线程的JavaScript里，允许把主线程的工作转嫁给独立的实体，而不改变现有的单线程模型。 浏览器每打开一个页面，就会分配一个他自己的环境，每个页面有自己的内存、DOM、事件循环等，每个页面就是一个沙盒，不会相互干扰。对浏览器来说，管理多个环境是非常简单的，所以这些环境都是并行执行的。 使用工作者线程，浏览器可以在原始页面环境之外在分配一个完全独立的二级子环境，这个子环境不能依赖单线程交互的API（如DOM）等操作，但是可以与父环境并行执行代码（但是，Worker 线程可以navigator对象和location对象。） 专用工作者线程：只能被创建它的页面使用 new Worker() 共享工作者线程：可以被多个不同的上下文使用，包括不同的页面 new ShareWorker() 服务工作者线程：它主要用途用于拦截、重定向和修改页面发出的请求（它其实就是Service Worker） 但是由于启用工作者线程的代价很大，所以某些情况下可以考虑始终保持固定数量的线程活动，然后使用“线程池”","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"计网personal note","slug":"计网personal note","date":"2021-12-15T11:36:34.005Z","updated":"2022-09-27T12:03:57.973Z","comments":true,"path":"2021/12/15/ji-wang-personal-note/","link":"","permalink":"https://taylor12138.github.io/2021/12/15/ji-wang-personal-note/","excerpt":"","text":"1.计网概念是将一个分散的，具有独立功能的计算机系统，通过通信设备和线路连接起来，由功能完善的软件实现资源共享和信息传递 计算机网络是互连的、自治的计算机集合 功能数据通信（连通性）（通信子网：网络层、数据链路层、物理层）（是点到点的通信） 资源共享（资源子网：应用层、表示层、会话层） （是端到端的通信） ​ 两个子网之间隔着传输层 主机在osi模型中有七层，而中间系统只有物理层、数据链路层、网络层三层（交换机和网桥这种甚至只有物理层、数据层两层） 分布式处理（多台计算机各自承担同一工作任务的不同部分） 提高可靠性 负载均衡 组成硬件、软件、协议（核心） 边缘部分（用户可以直接使用）、核心部分（为边缘部分服务） 功能组成：从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 分类分布范围划分：广域网WAN、城域网MAN、局域网LAN、个人区域网PAN 使用者划分：公用网（电信）、专用网（军队） 交换技术划分：电路交换、报文交换、分组交换 拓扑结构划分：总线型、星型、环型、网状型 传输技术划分：广播式网络（共享公共通信通道）、点对点网络 标准的划分法定标准：OSI 事实标准：TCP/IP（并不是指这两种协议，而是对许多大大小小的协议的泛指） 速率 &amp; 带宽 &amp; 吞吐量1.速率速率即数据率或数据传输率、或比特（bit）率，其实也就是速度 kb/s…. 存储容量是以 字节（Byte）作为单位 2.带宽原本：指某个信号具有的频带宽度，即最高频率和最低频率之差，单位是赫兹Hz 现在：它用来表示网络通信线路传送数据的能力，通常指单位时间内从网络某一点到另外一点的“最高数据率”，单位是比特每秒（和速率一样）（其实就是表示所支持最高速率为多少） 3.吞吐量单位时间内通过某个网络（信道、接口）的数据量，单位是 b/s…… 吞吐量还受到带宽或者网络额定速率的限制 吞吐量更像瞬时速率，带宽像最大速率 时延指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需要的时间，也叫做延迟或迟延，单位是秒s 分别为 发送时延（把所有数据从发送端推到信道上，发生在主机内部）=数据长度/信道带宽，高速链路指的是发送速率的提高，即带宽的提高，导致发送时延的减少 传播时延（在信道上传播一段距离所花费的时间，发生在信道上）=信道长度/电磁波速率 排队时延（等待处理） 处理时延（检错，找出口） 时延带宽积bit = 传播时延s * 带宽b/s，它又称为以比特位单位的链路长度，链路的容量 往返时延RTT：从发送方发送数据开始，到发送方收到接收方的确认经历的时延，RTT = 往返传播时延 + 末端处理时间 = 传播时延*2 + 末端处理时间 利用率信道利用率 = 有数据通过的时间 / 总时间 链路利用率=发送延时/总用时 = 发送延时/（发送时延+2*传播时延+确认帧传输时延） 网络利用率 = 信道利用率加权平均值 分层关于实体、协议、服务和接口： 1.实体：第n层元素称为n层实体，同层另外一端主机的实体叫对等实体 2.协议：对等实体（或多个实体）通信规则，分为语法、语义、同步（操作顺序） 3.接口：上层使用下层服务的入口 4.服务：下层为相邻上层提供功能调用（相邻，下层为上层才能为称之为服务） 计算机网络体系结构是计算机网络各层及其协议的集合 各层功能简洁概述 应用层：在所有能和用户交互产生网络流量的程序，实现协同工作的应用进程之间的通信过程控制。 表示层：用于处理两个通信系统中，交换信息的表示方式（语法和语义）功能：数据格式变换（翻译）、数据加密和解密、数据的压缩和恢复 会话层：向表示层实体/用户进程提供建立连接并连接上有序地传输数据。这是会话，也是建立同步 传输层：负责主机两个进程的通信，即端到端的通信，传输单位是报文段或用户数据段。功能： 可靠传输（有确认机制）、不可靠传输； 差错控制； 流量控制（发送速率，使用滑动窗口，比如停等协议、后退N帧的滑动窗口，选择重传的滑动窗口）； 拥塞控制（慢开始、拥塞避免、快重传、快恢复）； 复用分用（复用是多个应用层可同时使用下层运输层服务，分用是目的主机传输层把收到的信息分别交付给上面应用层中相应进程，应用：端口号）（osi面向连接，tcp/ip无连接+面向连接） 网络层：把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报（osi无连接+面向连接，tcp/ip无连接），路由的选择和分组转发 + 用拥塞控制 数据链路层：主要任务是把网络层传下来的数据组装成帧，同时包括流量控制和差错检测，数据链路层的传输单位是帧 物理层：主要任务是在物理媒体上实现比特流的透明传输 TCP/IP的应用层：合并应用层、表示层、会话层 5层参考模型数据封装与解封装应用层：单位：报文 传输层：单位：报文段 网络层：单位：数据报 数据链路层：单位：帧 物理层：单位：比特 香农定理 2.物理层物理层解决如何连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体（不同厂家生产的介质），它的任务是确定传输媒体接口有关的一些特性（定义标准，类似于水晶头规格，电压范围） 定义的特性：机械特性、电气特性、功能特性、过程特性 数据通信基础知识 数据：传送消息的实体，通常是有意义的符号序列 信号：数据在传输过程中的存在形式 数字信号/离散信号，计量单位是码元 模拟信号/连续信号 信源：产生和发送数据的源头 信宿：接收数据的终点 信道：信号传输的媒介，一般用来表示某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道 三种通信方式 单工信道：只有一个方向，仅需一条信道 半双工信道：双方都可以发送和接收，但是不能同时，类似于对讲机，需要两条信道 全双工信道：双方可同时收发，需要两条信道 两种数据传输方式串行传输 并行传输 编码与调制信道上的信号除了可以分为模拟信道和数字信道、无线信道和有线信道之外，还可以分为基带信号和宽带信号 基带信号：将数字信号1或0直接用两种不同的电压表示，再送到数字信道（在计算机中是使用数字信号，人类是模拟信号）上去传输（基带传输），基带信号最重要的一点就是来自于信源 宽带信号：将基带信号进行调制模拟后形成频分复（载波调制）用模拟信号，再传送到模拟信道上去传输（宽带传输）。载波调制（带通调制）把信号频率范围调到较高的频段以便在信道中传输 编码方式非归零编码：高1低0，容易，但是没有检错功能，无法判断码元的开始与结束，难以同步 归零编码：1：中间高，两边中等；0：中间低，两边中等 曼彻斯特编码：1：前高后低；0：前低后高，这种方法所占频带宽度是基带宽度的两倍，所以它的数据传输速率只有调制速率的1/2 差分曼彻斯特编码：同1异0，即码元为1，则前半段半个码元和上一个码元的后半段的电平相同，0则相反，抗干扰性强于曼彻斯特编码 数字数据调制为模拟信号调制解调器的调制：数字信号-&gt;模拟信号 调幅：0没幅度，1有幅度 调频：0低频，1高频 调相：调成正弦波和余弦波 QAM正交振幅调制，相当于调幅+调向 调制解调器的解调：模拟信号-&gt;数字信号 3.数据链路层结点：主机和路由器 网卡实现的主要功能是物理层与数据链路层的功能。 链路：网络中两个结点之间的物理通道，主要介质为双绞线、光纤等 数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议和硬件和软件加到链路上就构成数据链路 帧：链路层的协议数据单元，封装网络层数报 数据链路层 负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报，它最基本的服务是将源自于网络层的数据可靠的传输到相邻结点的目标机网络层（简单来说就是加强物理层传输原始比特流的功能），将物理层提供可能出现差错的物理连接改造成为逻辑上无差错的数据链路 功能一：为网络层提供：无确认无连接服务、有确认无连接服务、有确认面向连接服务（有连接一定有确认） 功能二：链路管理，即连接的建立、维持和释放（用于面向连接） 功能三：组帧 功能四：流量控制 功能五：差错控制 封装成帧实际上就是将网络层的ip数据报形成帧数据部分，加上帧首部，帧尾部 这样接收端在收到物理层上交的比特流后，就可以根据首尾标记进行识别 帧首部和帧尾部包含许多信息，其中有个重要作用就是：帧定界（确定帧的界限）； 帧同步：接收方应当能从接收到的二进制比特流区分帧的开始和结束 四种封装成帧方法： 1.字符计数法 2.字符填充法（帧首部SOH，帧尾部EOT）：为了保障字符填充的透明传输，在控制信息的前面+转义字符 3.零比特填充法（帧的首尾部都是01111110）：为了保障字符填充的透明传输，中间数据部分，只要有5个1，就立刻填入一个0，简称5110方法 4.违规编码法：曼彻斯特编码都是“高-低”，所以首尾帧用“高-高”、“低-低”定界帧的起始和结束 透明传输指不管所传的数据是什么样的比特组合，都应当能够在链路上传送，因此链路层“看不见”有什么妨碍数据传输的东西（保证传输透明，传输数据的比特组合可能和某控制信息一样（比如对数据链路层进行什么操作），但是数据链路层不管它，完全把它当作一个信息直接传递） 差错控制差错有：位错（比特位出错）和帧错（丢失、重复、失序） 差错控制：检测编码（奇偶校验码、循环冗杂码CRC）和纠错编码 冗余编码：在数据发送前，先按照某种关系加上一定的冗余位（比如余数），构成一个符合某一规则的码字后在发送，根据规则，接收端查看收到的码字是否符合原规则，从而判断对错 CRC循环冗余码： 发送端：要传的数据 / 生成多项式（一个数值） = 商…..FCS冗余码（余数）；最终要发送的数据为 要穿的数据 + FCS冗余码 接收端：收到的数据 / 生成多项式 = 商…0 余数为0，无差错 计算冗余码：（1）加0，生成多项式G(x)的阶（即生成多项式的位数-1）为r，则加r个0；（2）模2除法，同0异1 余数为0，接受，不为0，丢弃 此方法只能做到对帧的无差错接收，但是不能算作“可靠传输”，因为“可靠传输”的定义是数据链路层发送什么，接收端就接收到什么，但是此方法丢弃了部分错误的，没有完全接收 数据链路层流量控制较高发送速度和较低接收能力不匹配会出现传输错误 数据链路层的流量控制是点对点的（接收方收不下就不回复确认），传输层的流量控制是端对端的（接收端给发送端一个窗口公告） 停止等待协议：每发送完一个帧，等待对方确认再发下一个（停止等待协议类似于特殊的滑动窗口协议，但只是发送窗口和接收窗口都只有一个） 滑动窗口协议： 发送窗口指在发送端维持一段连续的，允许发送的帧的序号（正在发送的数据），相对应的是接收窗口，滑动窗口协议解决流量控制问题和可靠传输问题 后退N帧协议，发送窗口大小&gt;1，接收窗口大小=1 选择重传协议，发送窗口大小&gt;1，接收窗口大小&gt;1 在链路层在发送过程，发送窗口和接收窗口大小固定 停止等待协议除了比特出差错，底层还会出现丢包问题（线路、病毒等原因导致数据包的丢失） 停止等待协议重申：每发送完一个帧，等待对方确认再发下一个（停止等待协议类似于特殊的滑动窗口协议，但只是发送窗口和接收窗口都只有一个） 有差错的情况： 1.数据帧丢失或检测到帧出错 每发送一个帧，启动一个超时计时器 重传时间&gt;往返传播时延RTT 超时重传 注意：（1）发完一个帧后，要保留他的副本，（2）数据帧和确认帧必须编号、（3） 2.ACK丢失（确认丢失） 同上，但是接收方丢弃重复帧，重传确认帧 3.ACK迟到 仍然是超时重传，接收方丢弃重复帧，重传确认帧（当后面发送方终于等到一开始的确认帧时，直接收下并且丢弃） 协议的优点：简单，缺点：信道利用率低（发送时间Td / （发送时间Td + RTT + 确认分组时间Ta）） 滑动窗口后退N帧 发送窗口重申：发送窗口指在发送端维持一段连续的，允许发送的帧的序号（正在发送的数据） 接收窗口：接收方维持一组连续的允许接收帧的序号 后退N帧协议，发送窗口大小&gt;1，接收窗口大小=1 累积确认：接收方不用对于每个数据帧返回确认帧，可以隔一会返回一个确认帧，它保证这个帧，以及之前的所有帧都得到了确认 超时事件：发送方会重传所有已发送但是未被确认的帧，比如再等待1号帧，但是一直等不到，等来2，3号帧，会将其丢弃，直到重传的1号帧的到来，并且继续重传刚才已经发过的2、3号帧 滑动窗口长度：窗口大小W小于帧总类的一半 选择重传协议中的滑动窗口（信道利用率高） 和后退N帧不同的是，如果帧没有按序到达，也会将之后序号的帧暂存在接收窗口 如果接收方收到的帧序号是窗口的下界（最左边窗口对应的序号），则窗向前移动到最小序号未确认帧处 超时事件：一个超时事件发生后只重传一个帧 如果收到了窗口序号外的帧（小于窗口下界，可能因为某些原因传的慢，但是已经超时重传了），就返回一个ack 滑动窗口长度：发送窗口最好等于接收窗口 ；窗口大小W小于帧总类的一半 传输数据的链路点对点链路应用：ppp协议、广域网 广播式链路：局域网 广播信道介质访问控制就是采取一定措施，使得两对节点之间通信（因为广播式链路，是多个点共享信道）不会发生互相干扰的情况 静态划分信道：频分复用、时分复用、波分复用、码分复用 动态分配信道（CSMA/CD包含其中）：分为轮询访问介质访问控制、随机访问介质访问控制 随机访问介质访问控制：所有用户可随机发信息，发送信息时占全部带宽 CSMA/CD协议先听再说、边听边说 载波监听多点接入/碰撞检测 CSMA/CD CS：载波监听，每个站在发送数据之前以及发送数据时，都要检测一下总线上是否有其他计算机在发送数据。其实就是检测信道上电压的摆动幅值（在站点的位置检测有没有信号进来），幅值较大，则说明信道上有人在说话，就不发送，直到检测信道上空闲才发送 MA：多点接入，表示许多计算机以多点接入的方式连在一根总线上 ，其实也说明了该协议应用于总线型网络 CD：碰撞检测，“边发送边监听”，适配器边发送数据，边检测信道上信号电压变化，以判断自己发送数据时其他站是否也在发，也说明了该协议应用于半双工网络 为什么先听后还是有可能发生冲突？因为电磁波在总线上总是以有限速率进行传播，即传播时延对载波监听的影响 检测到数据帧有错误，则确定发生了碰撞和冲突，停发 只要经过 2T 时间没有检验出碰撞，就能肯定这次不会发生碰撞（T为单程端到端的传播时延） 采用截断二进制指数规避算法确定重传时机： 1.确定基本规避时间，争用期为2T，2T &lt;= 最小帧长 / 数据传输速率 2.定义参数k，它等于重传次数，但k不超过10，k = min[重传次数, 10] 3.从离散的整数集合[0, 2^k-1]中随机取出一个数r，重传所需要退避的时间，就是r倍的基本规避时间，即2r*T 4.当重传达到16次仍不能成功，说明网络太拥挤，则抛出此帧向高层报错 为了避免帧太短导致该协议的作用无效（传短帧后才知道发生碰撞），以太网定义了最小帧长64byte = 512bit，小于此大小为无效帧 MAC层在局域网中，硬件地址又称为物理地址或MAC地址，它是每个适配器（网卡）都有的一个全球唯一地48位二进制地址 MAC层主要功能包括数据帧的封装和卸装 MAC帧：是以以太网V2的格式 以太网由Xerox等公司联合开发地基带总线局域网规范，是当今现有局域网最通用的通信协议标准，使用CSMA/CD技术 以太网提供无连接、不可靠服务 PPP协议局域网普遍采取多点接入技术（总线型） 广域网中通常采用点对点技术（将多个局域网互联，资源共享） PPP协议是目前使用最广泛的数据链路层协议（拨号上网）只支持全双工 ppp协议的三个组成部分： （1）一个将ip数据报封装到串行链路 （2）链路控制协议LCP（身份验证） （3）网络控制协议NCP，为网络层协议建立和配置逻辑连接 PPP帧格式：零比特填充法 4.网络层主要任务就是把分组从源端传送到目的端，为分组交换网上的不同主机提供通信服务，传输单位是数据报（数据报是比较长的数据，分组是把数据包进行切割，划分出来的片段） 功能一：路由的选择和分组转发（选最佳路径） 功能二：异构网络互联 功能三：拥塞控制 数据交换方式两台主机通过网络核心【路由器】进行数据转发 （1）电路交换：比如电话网络，独占资源 （2）报文交换：报文是源应用发送的信息整体，无需建立连接、可靠、利用率高，且多目标，但报文大小不定，需要网络节点有较大缓存空间 （3）分组交换：大数据块分割成小数据块（把报文切割成小数据块），它相对于报文交换，存储管理更容易；但是乱序到达目的主机时，需要分组排序重组 数据报和虚电路数据报方式为网络层提供无连接服务（因特网在使用）（无连接服务为不事先为分组的传输确定传输路径，不同分组传输路径可能不同） 路由器根据分组目的地址转发分组，基于算法构建的转发表，为每个分组独立选路 虚电路方式为网络层提供连接服务（虚电路是一条源主机到目的主机类似于电路的路径（逻辑连接），路上所有结点都要维持这条虚电路的建立，并有一张虚电路表） 每个分组携带虚电路号，可以使得一系列的分组沿着相同路径转发出去 路由算法和路由器概述算法的“最佳”只能是相对于某一种特定要求下得出的比较合理的选择而已 静态路由算法：非自适应路由选择，即管理员手动配置，不适用于大型网络，适合小的、安全要求高的网络 动态路由算法：自适应路由选择 采用分层次的路由选择协议：（1）因特网规模大（2）许多单位不想让外界知道自己的路由选择协议 因此把互联网划分为许多较小的自治系统AS，一个AS的所有路由器在本自治系统内都应该相互连通；一个AS对其他AS表现出是一个单一的一致的路由选择策略（分层次是分成内部和外部） 内部网关协议IGP，一个AS内使用 外部网关协议EGP，AS之间使用 内部网关协议 RIP基于距离向量的路由选择协议，最大优点是简单（适用于小规模网络） 它要求网络中每个路由器维护它从其他每个目的网络的唯一最佳距离纪录（维护的是路由表），也就是最短跳数 RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达，所以只适合小规模互联网 RIP协议的特点： 1.仅和相邻的路由器交换信息 2.交换的信息时自己的路由表 3.固定时间间隔交换路由信息 路由器刚开始工作时，只知道直接相连的几个网络的距离（距离定义为1） 距离向量算法： 1.修改相邻路由器发来的RIP报文中所有表项，对地址为X的相邻路由器发来的RIP报文，下一跳地址改为X，并把所有“距离”字段+1 2.对修改后RIP报文的每个项目，若原路由表没有目的网络N则添加；若已经含有，且下一跳地址和原来一样，则即使跳数可能增大，但也必须发生更改；若已经含有，且下一跳地址不同，则将跳数相对较小的项目更新入路由表 3.若180s没收到相邻路由表的更新，则记为不可达路由器，距离设置为16 RIP其实是应用层的协议，使用UDP传送数据，使用UDP’无可靠保证，但是开销小 好消息传得快，坏消息传得慢 OSPF协议使用的是迪杰斯特拉最短路径算法，适用于大规模互联网 它最主要的特征就是使用了分布式链路状态协议 30min更新一次 传递协议：IP 外部网关协议 BGP和其他AS邻站BGP发言人交换信息，交换网络可达性信息，发生变化时更新有变化部分 不用找到最佳路径，找到较好路由选择就够了 传递协议：TCP，保证可靠的交付 IP数据报格式在TCP/IP标准中，数据报格式中的数据常常以32位（4Byte）为单位来描述 数据报长度不能超过MTU（1500字节byte），如果超过了就分片 分片流程： 数据报中有标识数据段，同一数据报分片使用同一标识 数据报中有标志数据段，DF = 1禁止分片；DF = 0，允许分片，在DF = 0的条件下，MF = 1后面还有分片；MF = 0最后一块没分片 数据报中有片偏移数据段，指出较长分组分片后，某片在原分组相对位置，以8B为单位，所以能得出除了最后一个分片，每个分片的长度都一定是8B的整数倍 ip数据报固定首部长度为20字节 ip地址ip地址，在全世界范围内唯一的32位标识符，可以唯一标识一个主机或者路由器等设备的接口 ip编制历史阶段： 1.分类的ip地址 2.子网的划分 3.构成超网 分类的ip地址：ip地址{&lt;网络号&gt;, &lt;主机号&gt;}，如果主机连在一个网络上，则网络号是相同的，主机号不相同 分类分成5类，分类方法靠前面的四位来区分 ，分类因为各网络差异比较大，有的网络主机数多，有的少，且ip地址是32位，我们为了便于书写，常常每八位插入一个空格（但在机器中并没有这样的空格） A类：2^7-2是因为全零指本网，全1；127指回环，2^24-2是因为全零指本机，全1指广播地址 B类：128.0.0.0不能指派，2^14-1 C类：192.0.0.0不能只派，2^21-1 特殊ip地址： 网络号全0，主机号全0，本网范围内标识本主机，只能作为源地址 网络号全0，主机号特定值，本网范围某主机，只能作为源地址 网络号全1，主机号全1，本网广播地址，只能作为目的地址 网络号特定值，主机号全0，网络地址，表示一个网络，啥也不能作 网络号特定值，主机号全1，直接广播地址，只能作为目的地址，表示对特定网络上所有主机广播 网络号127，主机号任意，用于本地软件测试 分类ip地址缺点：ip地址空间利用率有时很低；2级地址不够灵活 localhost和0.0.0.0的区别localhost本质上是一个域名，通常被解析为127.0.0.1 127.0.0.1回环地址，表达的意思其实是我们主机发出去的包，直接被自己接收， 正常数据包流程：应用层-传输层-网络层-数据链路层-物理层 而回环地址被网络层获取到，不会往下流 而监听127.0.0.1时，同网段下主机无法通过ip地址访问 0.0.0.0：监听IPV4上所有地址，再根据端口找到不同的地址 比如我们监听0.0.0.0时，同网段下的主机可以通过ip地址访问 当然我们输入127.0.0.1、localhost也可以访问 子网的划分ip地址{&lt;网络号&gt;, &lt;&lt;子网号&gt;，&lt;主机号&gt;&gt;}，三级的ip地址，但是就算划分子网后，对外表现仍然是一个网络，即本单位外网络看不见本单位内子网划分 子网号能否全0、全1要看情况，主机号部分仍然不能全0、全1 子网掩码：极力推荐子网掩码中使用连续的1：比如B类 11111111 11111111 11111111 00000000，子网掩码和ip地址相与，就可以得到子网网络地址 路由表中包含：目的网络地址、目的网络子网掩码、下一跳地址 使用子网分组转发 1.提取目的ip地址 2.判断是否可直接交付，用ip地址与子网掩码相与，匹配则交付 3.若1-2步骤不行，判断特定主机路由 4.若1-3步骤不行，检测路由表有无路径，也是相”与“判断 5.若1-4步骤不行，默认路由处理 0.0.0.0 6.最后还不行丢弃分组，报错 无分类编址CIDR是否可以使用一个变长的子网掩码，而非定长的？CIDR消除了传统A、B、C类和子网划分的概念 ip地址{&lt;网络前缀&gt;，&lt;主机号&gt;} CIDR的记法：ip地址后加上/，然后写上网络前缀的位数即可 128.14.32.0/20，则表示前20位位网络前缀 CIDR把网络前缀相同的连续ip地址组成一个CIDR地址块此时最小地址为：网络前缀保持不变，主机号全0，最大地址为：网络前缀保持不变，主机号全1 CIDR地址掩码为网络前缀的每个位，填充为1，后面的主机号位填充为0 构成超网定义：将多个子网聚合成一个较大的子网，叫作构成超网或路由聚合，使得路由器转发表不用写那么多数据 构成超网方法：将网络前缀缩短 最长前缀匹配：使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由，前缀越长，地址块越小，路由越具体 在CIDR中子网号可全0、全1 ARP协议ARP高速缓存：保存的是ip地址和mac地址的映射（对应），解决下一跳走哪的问题 （DNS）完成域名到 IP 地址的映射，（RARP）实现MAC到IP地址的映射;（ARP）实现IP到MAC. 在实际链路上传送数据帧时，最终必须使用mac地址 注意：硬件地址又称物理地址，从层次的角度，物理地址是给物理层和数据链路层使用的地址，而ip地址时网络层和以上各层使用的地址，是一种逻辑地址；以太网帧在传输过程中有关其内部的mac地址和ip地址的变化情况：源ip地址和目的ip地址不会产生变化，而源mac地址和目的地址逐网络（或逐链路）都发生变化 ARP协议的使用： 检查ARP高速缓存是否已经有对应的ip地址到mac的映射表项,如果没有执行以下步骤 局域网络内：某主机要发射数据帧，但是不知道目的主机的mac地址，但是直到发送主机、目的主机的ip地址，以及知道自身的物理地址，这时发射主机发送广播请求分组（全1），最后收到目的主机的单播响应分组，得到该主机的mac地址，写入ARP缓存 局域网外：寄希望于默认网关（与外界沟通的路由器），跳到路由器的mac地址，然后该路由器响应发送主机的广播请求，把路由器的mac地址映射返回；然后一直传到目的主机局域网的路由器的mac地址，这时该局域网路由器发送广播请求分组（全1），最后收到目的主机的单播响应分组，得到该主机的mac地址 ICMP协议ICMP循序主机或路由器报告差错情况和提供有关异常情况的报告 ICMP报文 + ip数据报首部 = ip数据报的数据部份 +ip数据报首部 = ip数据报 ICMP分为：ICMP差错报文和ICMP询问报文 ICMP差错报文：1.终点不可达（无法交付问题）；2.时间超过（数据报生存时间为0或者数据报片没有收集完整，应用：Traceroute）；3.参数问题（首部字段出问题）；4.改变路由（重定向） ICMP询问报文：1.回送请求和回答（测试目的栈是否可达，应用：ping xxip地址，测试两个主机的连通性）；2.时间戳请求和回答 IPV632位的IPV4地址空间已经分配殆尽了，IPV6从根本解决地址耗尽问题 更大的地址空间：原来的32位 -&gt; 128位 拓展的地址层次结构、灵活的首部格式、改进的选项。。。。。 IPV6由两大数据部分组成，基本首部和有效载荷 IPV6的表示方法为：冒号十六进制记法，允许零压缩 IPV6向IPV4过渡策略：双栈协议（同时启用IPV4和IPV6）、隧道技术（重新封装） 5.传输层主机才会有的层次，功能有： 提供进程和进程之间的通信（网络层提供主机和主机之间的逻辑通信） 复用和分用 对报文进行差错检测 两个协议，TCP和UDP 端口号传输层有一个端口（逻辑端口/软件端口），它可以唯一标识一个具体的进程，端口号只有本地意义 端口号长度为16bit，能表示65536个不同端口号 分为服务端口号和客户端口号 服务端口号：熟知端口号（给TCP/IP最重要的一些应用程序，0-1023，让所有用户都知道）、登记端口号（1024-49151） 客户端口号：49152-65535，仅在客户进程运行时才动态选择 重要端口号： 传输层两个好兄弟，大哥TCP和二弟UDP，大哥靠谱，二弟不靠谱 传输单元为报文段 TCP传送数据前必须建立连接，不提供广播或多播，时延大，适用大文件 1.面向连接（虚连接）的传输控制协议 2.每一条TCP只能有两个端点，点对点 3.TCP提供可靠交付服务 4.全双工通信，发送方的发送缓存：准备发送的数据&amp;已发送但尚未收到确认的数据；接收方的接收缓存：按序到达但违背接受应用读取&amp;不按序到达的数据 5.面向字节流 TCP首部格式最小长度为20字节 序号为发送的数据（报文段）的第一个字节的序号 确认号：用于接收方发送的TCP确认报文段，确认号是期待发送方下一个报文段第一个数据字节序号 数据偏移：实际上就是TCP首部长度 紧急URG：URG = 1，在发送报文段时拥有插队权力 同步SYN：建立连接时同来同步的 TCP连接管理连接的建立 -&gt; 数据的传送 -&gt; 连接的释放 tcp连接建立采用客户服务器方式，主动发起连接的应用进程叫作客户，被动等待连接建立的应用进程叫服务器 连接建立过程：三次握手 客户端发送报文段，里面无应用层数据 SYN（同步位） = 1，ACK = 0，seq（序号） = x（随机） 服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据 SYN = 1，ACK（确认位） = 1，seq = y，ack（确认号） = x + 1. 客户端为TCP连接分配缓存和变量，并向服务器返回确认的确认，可以携带数据 SYN = 0，ACK = 1，seq = x + 1，ack = y + 1 2次不行： 客户端向服务器发送建立连接的请求报文段，有可能因为网络滞留了，之后等到这个滞留报文段到达服务端时，客户端早已重新发送请求连接的报文，而服务端不这么认为，服务端他以为你发了新的连接请求，此时服务端向客户端发送确认报文，而客户端收到这个响应，但是发现这个请求在之前就发过了，就会忽略，而此时服务端苦苦等待客户端的响应，这样就会造成资源浪费 当然也可以概括为：并不知道客户端的接受能力是否正常 4次不行： 意义不大，因为此时我们都知道双方的发送和接收功能都是正常的 洪范攻击：发生在osi第四层，利用三次握手的特性，拼命向服务器发送大量的TCP SYN，也就是三次握手的第一次数据包，当服务器返回ACK后，该攻击者就不对其进行确认，让TCP处于挂起状态，服务器收不到再确认，还会重复发送ACK给攻击者，然后浪费服务器资源，消耗CPU和内存，可能导致服务器死机 连接释放过程：四次挥手（参与一条TCP连接的两个进程任何一个都可以终止该连接，连接结束后主机中的“资源”将被释放） 客户端发送连接释放报文段，停止发送数据，主动关闭TCP FIN（释放位） = 1，seq（序号） = u 服务器回送确认报文段，客户端到服务器这个方向的连接就释放了—-半关闭状态 ACK = 1，seq = v，ack = u+1 服务器端发完数据，发送释放报文段，主动关闭TCP连接 FIN = 1，ACK = 1，seq = w，ack = u+1 客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命，也就是TIME_WAIT状态）后（防止服务器未接收到确认，这时服务器可以及时再次发送释放报文段），连接彻底关闭 SYN：同步序列号，是用来建立连接的握手信号。 ack：确认序号，当ACK为1时，ack有效，当ACK为0时，ack无效。 seq：序号。 ACK：确认序号有效。 FIN: 结束标志，用来表示断开连接。 MSL：的时长被 RFC 定义为 2分钟，但在不同的 unix 实现上，这个值不并确定，我们常用的 centOS 上，它被定义为 30s， 当 TCP 连接主动关闭时，都会经过 TIME_WAIT 状态： TCP 四次握手结束后，连接双方都不再交换消息，但主动关闭的一方保持这个连接在一段时间内不可用。 TCP可靠传输保证接收方从缓存区读出的字节流与发送方发出的字节流是完全一样的 1.检验，与UDP一样，增加伪首部 2.序号，对应TCP首部格式的序号 3.确认号，对应TCP首部格式的确认号 4.重传（超时重传），TPC采用自适应算法，动态改变重传时间RTTs（加权平均往返时间） 5.冗余ACK，当比期望序号大的失序报文段到达时，发送冗余ACK，指明下一个期待字节的序号（发送方收到3个冗余ACK，则认为报文段丢失，选择重发） TCP流量控制同数据链路层的滑动窗口进行流量控制 但是TCP的发送窗口是根据接收方的报文段（rwnd = 400，则窗口大小为400B），动态变化其大小（在链路层在发送过程，发送窗口和接收窗口大小固定），如果设置rwnd = 0，则发送端等待接收方再次发送rwnnd &gt; 0 的报文段，如果一直等不到（可能接收方返回的报文段丢失了），TCP连接的一方（此时仍是0窗口大小）启动计时器开始计时，一段时间结束后发送零窗口的试探报文段，然后接收方会再发一次原来要返回的报文段 TCP拥塞控制出现条件：对资源的需求&gt;可用资源 网络性能下降、网络吞吐量随输入负荷增大而下降 拥塞控制是全局性的过程，防止过多数据注入网络 拥塞控制的方法： 慢开始：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小 拥塞避免：拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。 快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期 快恢复： （1）当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半。这是为了预防网络发生拥塞，但不执行慢开始算法。 （2）由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认）。因此与慢开始不同之处就是现在不执行慢开始算法（即拥塞窗口现在不设置为1）而是把拥塞窗口的值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 发送窗口 = Min{接收窗口，拥塞窗口} 接收窗口：接收方根据接收缓存设置的值，反应接收方容量 拥塞窗口：发送方根据自己估算的网络拥塞程度设置的值，反应当前网络容量 一个传输轮次 = 一个RTT 慢开始 + 拥塞避免 慢开始+拥塞避免+快重传+快恢复 UDP无连接的用户数据报协议 1.传送数据前不用建立连接，收到报文后也不需要任何确认，不保证可靠交付 2.UDP是面向报文的（面对应用层交下来的报文，不拆分也不合并，保留报文边界），适合一次性传输少量数据的网络应用（够小就可以完整交付，不用拆分），适用小文件 3.无拥塞控制，适合很多实时应用 4.UDP首部开销小，8B；TCP则是20B，和ip数据报固定首部长度 它只在ip数据报服务上增加了复用分用、差错检测功能 在分用时，找不到对应端口，则向发送方发送ICMP“端口号不可达”差错报文 提供全双工服务 UDP校验时： 1.会发现有“伪首部”，它只在计算校验和时才出现，不向下传送也不向上递交 2.全0填充数据部分和校验和字段 3.伪首部+首部+数据部分采用二进制反码求和，把和，求它的反码，填入校验和字段，去掉伪首部，发送 4.接收端填上伪首部，采用伪首部+首部+数据部分采用二进制反码求和，全1无差错，否则丢弃数据报/交给应用层附上出差错的警告 二进制反码求和: 规则是从低到高位逐列进行bai计算，0和0加得0,0和1加得1,1和1加得0但要产生一个进位1，加到下一列，若最高位产生了进位，则最后得到的结果要加1。 6.应用层应用层对应用程序的通信提供服务 应用层协议的定义： 应用进程交换的报文类型，请求还是响应 各种报文类型的语法，如报文中各个字段及其详细描述 字段语义及其包含的信息含义 进程何时，如何发送报文 应用层功能： 文件传输、访问和管理 电子邮件 虚拟终端 查询服务和远程作业登陆 有两种模型：客户服务器模型（C/S）、P2P模型 客户服务器模型（C/S）： 服务器：提供计算服务的设备。1. 24小时永久提供服务；2.永久性访问地址 客户机：请求计算服务的主机，1. 与服务器通信，使用服务器提供的服务；2.间歇性接入网络；3.使用动态的ip地址；4.不与其他客户机直接通信 P2P模型： 无服务器 每个主机既可以提供服务，也可以请求服务，任意节点可以直接通讯 DNS域名解析系统域名：www.baidu.com DNS: 域名 -&gt; ip地址（视为一个网络电话簿） 域名自左向右，级别由低到高，分别对应三级域名、二级域名、顶级域名 交给域名服务器解析域名，域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器、本地域名服务器（最近） 1.检查浏览器缓存中是否缓存过该域名对应的ip地址 2.检查本机系统是否缓存过该域名对应的ip地址 3.向本地域名解析服务系统发起域名解析的请求 本地域名系统一般都是本地区的域名服务器，比如你连接的校园网，那么域名解析系统就在你的校园机房里，如果你连接的是电信、移动或者联通的网络，那么本地域名解析服务器就在本地区，由各自的运营商来提供服务 大部分解析，前三个步骤已经完成了，下面是还找不到解析结果的步骤： 4.向根域名解析服务器发起域名解析请求（总共13个，由于根域名的13个地址几乎不发生变化，所以在Local DNS的软件配置文件里内置了13个根域名） 5. 根域名服务器返回gTLD域名解析服务器地址 -&gt; 向gTLD服务器发起解析请求 -&gt; gTLD服务器接收请求并返回Name Server服务器 -&gt; Name Server服务器返回IP地址给本地服务器 6.本地域名服务器缓存解析结果，并返回结果给用户 备注：gTLD：国际顶级域名 首先 在本机域名解析的缓存中查找该域名 ，若找不到 -&gt; 发给本地域名服务器，无法解决-&gt;求助根域名服务器-&gt; 查询顶级域名服务器 -&gt; 查询权限域名服务器 根域名服务器：全球共有13个根域名服务器，1个为主根服务器在美国。其余12个均为辅根服务器,其中9个在美国,欧洲2个,位于英国和瑞典,亚洲1个位于日本 顶级域名：指的是.com（商业机构）、.net（网络提供商）、.edu（教育机构）、.cn（中国域名）；全球共有13个.com（或者其他几个）顶级域名服务器。 权威域名（权限域名服务器）：一般是指能够提供最终IP地址解析能力（最终IP地址是由这个NS来解析的）的一组服务器 域名解析查询过程： 递归查询（一般主机 -&gt; 向本地域名解析器查询的过程都是递归查询） 客户端只发一次请求，要求对方给出最终结果。 迭代查询（靠自己，由自己来查询根域名服务器，顶级域名服务器，一般本地域名服务器 -&gt; 向根域名服务器的查询的迭代查询） 客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。 万维网和http协议万维网是大规模、联机式信息储藏所，无数个网络站点、网页的集合 统一资源定位符URL可以唯一标识资源（文字、视频、音频） URL： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; http默认80端口号 协议：http、ftp 主机：域名、ip地址 端口和路径有时可以被省略掉 http协议定义了浏览器怎么向万维网服务器请求万维网文档，以及万维网怎么把文档传送给浏览器：建立tcp连接 -&gt; http请求报文-&gt; http响应报文 -&gt; 释放TCP连接 http协议的特点 http协议是无状态的，但是在实际工作中，一些万维网网站希望能识别用户（给用户推销产品）=&gt;诞生了cookie小饼干，cookie是存储在用户主机的文本文件，记录一段时间内某用户的访问记录（不太敏感的数据） http采用TCP作为运输层协议，但是http协议本身是无连接的 （交换http报文之前不需要建立连接） http连接方式：持久连接（非流水线式（有点像停等协议）、流水线式（有点像GBN或SR协议，即后退N帧协议和选择重传协议））、非持久连接（每次传输都要三次握手） 无状态： 所谓的无状态是指协议对于事务处理没有记忆能力。服务器向客户机发送被请求的文件时，并不存储任何关于该客户机的状态信息，于是，两种用于保持HTTP状态的技术就应运而生了，一个是Cookie，而另一个则是Session。 他保持了每次请求的独立性，每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更 无连接： 就是假如某个客户机在短时间多次次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，反而每次都不耐其烦重新响应请求。 7.其他臭名昭著的最后一英里问题。光纤固然很快，但是要将您的家庭或办公室连接到 Internet，您的本地 ISP 需要在整个社区布线、聚合信号并将其转发到本地路由节点。实际上，根据连接类型、路由方法和部署的技术，仅这些前几跳就可能需要数十毫秒。 我们都熟悉 IPv4 和 IPv6，但 IPv{1,2,3,5} 发生了什么？IPv4 中的 4 代表 TCP/IP 协议的第 4 版，它于 1981 年 9 月发布。最初的 TCP/IP 提案耦合了这两个协议，而 v4 草案正式将两者拆分为单独的 RFC。因此，IPv4 中的 v4 是其与 TCP 关系的遗产：没有独立的 IPv1、IPv2 或 IPv3 协议。 当工作组在 1994 年开始研究“下一代互联网协议”（IPng）时，需要一个新的版本号，但 v5 已经分配给另一个实验协议：互联网流协议（ST）。事实证明，ST 从未起飞，这就是为什么很少有人听说过它。因此是 IPv6 中的 6。 慢启动TCP三次握手之后，服务器为每个 TCP 连接初始化一个新的拥塞窗口 (cwnd) 变量，并将其初始值设置为一个保守的、系统指定的值（Linux 上的 initcwnd）。 此外，引入了一个新规则：客户端和服务器之间传输（未确认）的最大数据量是 rwnd 和 cwnd 变量中的最小值。到目前为止一切顺利，但是服务器和客户端如何确定拥塞窗口大小的最佳值呢？毕竟，网络条件一直在变化，即使在相同的两个网络节点之间，正如我们在前面的示例中看到的那样，如果我们可以使用该算法而不必为每个连接手动调整窗口大小，那就太好了。 解决方案是缓慢启动并在确认数据包时增加窗口大小：慢启动！原来cwnd的起始值设置为1个网段；RFC 2581 在 1999 年 4 月将此值更新为 4 个段；最近，RFC 6928 在 2013 年 4 月再次将该值增加到 10 个段。 新 TCP 连接的最大传输数据量是 rwnd 和 cwnd 值中的最小值；因此，现代服务器最多可以向客户端发送十个网段，此时它必须停止并等待确认。然后，对于每个接收到的 ACK，慢启动算法指示服务器可以将其 cwnd 窗口大小增加一个段——对于每个 ACK 数据包，可以发送两个新数据包。TCP 连接的这个阶段通常被称为“指数增长”算法（图 2-3），因为客户端和服务器正试图在它们之间网络路径上的可用带宽上快速收敛。 优化TCPTCP 是一种自适应协议，旨在对所有网络对等方公平并最有效地利用底层网络。因此，优化 TCP 的最佳方法是调整 TCP 如何感知当前网络条件并根据其下层和上层的类型和要求调整其行为：无线网络可能需要不同的拥塞算法，某些应用程序可能需要自定义服务质量 (QoS) 语义以提供最佳体验。 虽然每个算法和反馈机制的具体细节会不断发展，但核心原则及其含义保持不变： TCP 三向握手引入了完整的往返延迟。 TCP 慢启动应用于每个新连接。 TCP 流量和拥塞控制调节所有连接的吞吐量。 TCP 吞吐量由当前拥塞窗口大小调节。 推荐阅读： 如何完整优化页面速度(高级指南)","categories":[{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"Hello"},{"title":"数据结构","slug":"数据结构","date":"2021-11-20T08:21:10.727Z","updated":"2021-11-20T08:21:10.727Z","comments":true,"path":"2021/11/20/shu-ju-jie-gou/","link":"","permalink":"https://taylor12138.github.io/2021/11/20/shu-ju-jie-gou/","excerpt":"","text":"线性结构线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系 比如数组、链表 非线性结构一般未一对多的形式 比如树、多维数组、图结构 双向链表双向链表，又稱為双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。 所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。 一般我们都构造双向循环链表。 循环队列队列：是一种可以分别在两端进行增删的特殊线性表。既然是线性表，那么可以使用顺序存储和链式存储来实现 对于链式存储结构，删减和增加元素的操作比较方便 但是对于顺序存储结构，在队头进行删除的时候，会涉及到迁移操作（删除队头，所有元素都要往前移动），此事的解决方案就是循环队列（同时避免了时间复杂度的提升和空间的浪费） front是指向头结点的指针，rear是指向下一个要插入结点的指针 值得注意的是： 满的判断条件应为：(rear+1)%LENGTH == front 。 空的判断条件为 rear == front。 链表VS数组数组优点：访问速度快，内存为连续的区域 链表优点：插入、删除方便，大小不定，动态添加 为什么JS中的数组时可以动态转变大小？ JavaScript 中的数组，本质上还是对象，不过用了 Integer Index 的键名而已，和对象并没有什么本质的区别 堆堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 完全二叉树的特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。 [1] Min-heap: 父节点的值小于或等于子节点的值；Max-heap: 父节点的值大于或等于子节点的值； 堆和二叉搜索树的区别 堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别： 节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。 内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。堆仅仅使用一个数据来存储数组，且不使用指针。 平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。 搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。 数组偏移量数组偏移量：数组的标准定义为：一个存储元素的线性集合（collection），元素可以通过索引来任意存取，索引通常为数字，用来计算元素存储位置的偏移量 如果你有了解过其他语言，就会知道所有编程语言都有类似的数据结构。但javascript的数组和其他语言有所不同。 JavaScript中的数组是一种特殊的对象，索引为该对象的素性，索引可能是整数。然而，这些数字索引在内部被转换为字符串类型，这是因为JavaScript对象的属性名必须是字符串类型。 JS的存储资料基本是这样说的: 基本数据类型用栈存储，引用数据类型用堆存储。 但是还得补充：闭包变量书存储与堆中的，毕竟函数被调用完之后，栈顶空间销毁，但是闭包还得存在 对于系统栈来说，调用以下函数 function f(a) { console.log(a); } function func(a) { f(a); } func(1); func + func的上下文压入栈底 -&gt; f + f的上下文压入栈底 -&gt; 执行完毕f，对应的栈顶空间被回收 -&gt; 执行完func，对应的栈顶空间被回收 修改变量的时候（基本数据类型） : 在当前空间栈开辟一个地址，并且赋予一个值，然后修改原本变量的的地址 如下面的foo变量 let foo = 1; let bar = 2; let obj = { foo: 1, bar: 2 }; let x = foo foo = 'foo' //将 foo 的引用地址修改为 0x0204。 如果碰到const，则会 const foo = 'foo'; foo = 'bar'; // Error 推荐链接https://blog.csdn.net/weixin_40013817/article/details/103287271 JAVA的HashMapHashMap是一个数组+链表的结合，通过key计算哈希值，放入“桶”，如果当前桶已经存放过，则将以链表的形式加入桶的后面 当每个桶的链表只有一个元素的时候，则存储效率最高，但如果链表过长（碰撞次数过多），则十分不理想 优化hash算法： 初始化HashMap中Hash算法减少碰撞的两个做法： Hash方法中存在奇怪的位移运算，以使最终的Hash值中0和1较为均匀。 使用h &amp; （length-1）来进行桶的定位，length应为2的指数幂。 为什么当HashMap初始化大小为2的指数幂时，效率最高？ h&amp;（length-1）原理时，比如和14（1110） 进行与运算，0001、0011、0101、1001、1011、0111、1101这几个位置永远都不能存放元素，空间浪费相当大 回头看一下 HashMap 中默认的数组大小，查看源代码可以得知是16，为什么是16而不是15，也不是20呢？因为16是2的整数次幂，在数据量小的情况下16比15和20更能减少碰撞，进而提高查询的效率。 扩容当HashMap中的元素越来越多的时候，碰撞的概率也就越来越高（因为数组的长度是固定的），所以为了提高查询效率，就要对 HashMap 的数组进行扩容 当HashMap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor 的默认值为0.75。也就是说，在默认情况下，数组大小为16，当HashMap中元素个数超过16×0.75=12的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。","categories":[{"name":"personal","slug":"personal","permalink":"https://taylor12138.github.io/categories/personal/"}],"tags":[],"author":"Hello"},{"title":"Vue3(上)","slug":"Vue3(上)","date":"2021-11-04T16:00:00.000Z","updated":"2022-03-04T06:49:42.317Z","comments":true,"path":"2021/11/05/vue3-shang/","link":"","permalink":"https://taylor12138.github.io/2021/11/05/vue3-shang/","excerpt":"","text":"1.Vue3 Start他在介绍中表明的是： 更小、更快、更易维护，一些命令的变化。 3.0 新加入了 TypeScript 以及 PWA 的支持 支持了 composiiton API vdom的对比算法更新，只更新绑定了动态数据部分 单独功能可以抽离 取代了mixin（尤雨溪作者本人指出minxin模块来源不清晰、命名问题、性能开销问题） 源码改动 它的源码是通过monorepo的形式管理源代码的 Mono单个 Repo：repository仓库 主要是将许多项目的代码存储在同一个repository仓库中，，这样的话可以让多个包相互独立的同时，又在同一个仓库下管理 使用TypeScript进行代码重写 性能改动 使用Proxy进行数据劫持，这也在之前做Vue2笔记的时候提及过，避免了很多索引类的bug 删除了一些没必要的API，如$on、$off、$once等，删除了一些特性，如filter、内联模板等 编译优化，生成block tree、Slot编译优化、diff算法优化 新的API Options API -&gt; Composition API 使用Hooks函数增加代码的复用性 在Vue2的时候也是因为Options和mixins相互关联，多个mixins还有命名冲突问题 基础语法基础语法和Vue2大致相同，除了 原来 const app = new Vue({}) 变成了 const app = Vue.createApp({}) 查看源码（2021/11/6），在官网git clone项目，使用pnpm下载依赖，使用 yarn dev打包出文件进行调试，然后在项目下引用这个打包好的包（/dist/vue.global.js）即可 可以在webpack的设置里面 \"scripts\": { \"dev\": \"node scripts/dev.js --sourcemap\", //... } 此时再次打完包之后会在dist下出现一个 vue.global.js.map 文件，此时调试代码的时候 进行 step into next function可以跳转到达文件夹而非打包文件下对应的方法 注意：需要在chrome的setting里设置 Enable JavaScript source map 阅读源码推荐的插件：vscode的拓展插件bookmarks，然后control + option + k 键即可标记当前函数，以后方便在拓展中直接找到（还能明明标记名称）；重复 control + option + k键可以取消 2.回顾VnodeVNode全称Virtual Node，也就是虚拟节点（VNode Tree组成虚拟DOM）；在Vue中无论大大小小元素都可以在Vue中被VNode表示出来， 类似如下 const vnode = { type: \"div\", props: { class: \"title\" }, children: \"hello world\" } 它本质上是一个对象，作为一个对象而未转化为DOM，最大的好处在于多平台的适配 diffvue3的diff做了一点优化 对于diff算法来说，如果列表中有key，则执行 patchKeyedChildren方法；没有 key，执行 patchUnkeyedChildren方法 patchUnkeyedChildren函数：取较短的节点进行遍历，一一对比（patch） patchKeyedChildren函数：从头开始while循环，让节点进行对比，节点类型不同直接break； 然后从尾部开始while，让节点进行对比，不同直接跳出循环； 然后判断是否新增节点，拿一个null和新节点进行patch，挂载一个新的节点； 然后再判断如有仍残留旧节点，则进行删除（unmount）； 最后处理中间乱序的节点，新建一个map哈希表，以key和节点作为键值对存储，使用key进行匹配、对比，最后等移动/删除/增加 render的优化1.对于不会改动的静态节点，会进行作用域的提升 2.只对动态的节点进行diff算法（将动态的节点的数据放入dynamicChildren，diff的时候执行patchBlockChildren函数） &lt;template> &lt;div>Allen&lt;/div> &lt;div>Allen&lt;/div> &lt;div>{{message}}&lt;/div> &lt;button @click=\"changeMessage\">修改&lt;/button> &lt;/template> function anonymous{ //静态节点 const _hoisted_1 =/*#_PURE_*/createVNode( \"div\", null,\"Allen\",-1/* HOISTED */); const _hoisted_2 =/*#_PURE_*/createNode (\"h2\" ,null,\"Allen\" , -1/* HOISTED */); return function render(_ctx, _cache){ with (_ctx) { const { createVNode: _createWNode, toDisplayString: _toDisplayString, Fragment:_Fragment, openBlock: _openBlock, createBlock:_createBlock} = _cache; return (_openBlock(), _createBlock(_Fragment,null,[ _hoisted_1, _hoisted_2, _createVode(\"p\",null，_toDisplayString(message)，1,/* TEXT*/), _createVNode( \"button\", i oncClick: changeMessage }，\"修改\" , 8 /* PROPS */，[ \"onClick\"1)],64/*STABLE_FRAGMENT */)) } } } 3.API对于2.x的改动全局API调用 createApp 返回一个应用实例，一个 Vue 3 中的新概念。 许多原本 Vue.xxx的操作，现在是通过 const app = Vue.createApp({})创建实例，，然后变成了 app.xxx 2.x 全局 API 3.x 实例 API (app) Vue.config app.config Vue.config.productionTip 移除 Vue.config.ignoredElements app.config.compilerOptions.isCustomElement Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties Vue.extend 移除 template原来Vue2.x中只允许有一个根元素（一般为div） Vue3.x以上，允许template有多个根元素，且允许不需要div标签进行包裹，从源码可以知道，如果有多个根元素，则他会在最外层给你多加一层 Fragment option API - &gt; Composition API 并且 在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML。 Vue2.x app.$mount('#app') &lt;body> &lt;div id=\"app\"> Some app content &lt;/div> &lt;/body> &lt;body> &lt;div id=\"rendered\">Hello Vue!&lt;/div> &lt;/body> Vue3 app.mount('#app') &lt;body> &lt;div id=\"app\" data-v-app=\"\"> &lt;div id=\"rendered\">Hello Vue!&lt;/div> &lt;/div> &lt;/body> data选项组件选项 data 的声明不再接收纯 JavaScript object，而是接收一个 function（只接收 funciton 形式了）。 子组件emitVue 3 现在提供一个 emits 选项，和现有的 props 选项类似。这个选项可以用来定义一个组件可以向其父组件触发的事件。 和 prop 类似，现在可以通过 emits 选项来定义组件可触发的事件： OK {{ text }} OK export default { props: ['text'], emits: ['accepted'], methods: { increment() { this.$emit('accepted', '参数') } } } 该选项也可以接收一个对象，该对象允许开发者定义传入事件参数的验证器，和 props 定义里的验证器类似。 emit的对象写法，一般针对于将传递给父组件的参数进行验证，如果false，则vue会报一个警告（但是参数还是会传过去） export default { emits: { add: null, //不需要传参数 addn: (payload1, payload2) => { //有俩参数 if (payload1 &lt; 10) return false; return true; } } } keep-alive内置组件可以传入数组类的值作为include、exclude属性 include - string | RegExp | Array。只有名称匹配的组件会被缓存。 exclude - string | RegExp | Array。任何名称匹配的组件都不会被缓存。 max - number | string。最多可以缓存多少组件实例。 &lt;keep-alive include=\"a,b\"> &lt;component :is=\"componentId\">&lt;/component> &lt;/keep-alive> &lt;keep-alive :include=\"/a|b/\"> &lt;component :is=\"componentId\">&lt;/component> &lt;/keep-alive> &lt;keep-alive :include=\"[a,b]\"> &lt;component :is=\"componentId\">&lt;/component> &lt;/keep-alive> 异步组件Vue3中使用异步组件可以导入内置的 defineAsyncComponent 它接受两种参数 类型一工厂函数，该工厂函数需要返回一个Promise对象 import {defineAsyncComponent} from vue; // 此时vue打包时会将该异步组件单独打包到另外一个js文件里 const AsyncComponent = defineAsyncComponent(() => import('./AsyncTest.vue')) 接受一个对象类型，对异步函数进行配置 const AsyncComponent = defineAsyncComponent({ loader: () => import('./AsyncTest.vue'), loadingComponent: Loading, //加载时占位的组件 }) 组件的v-model在 3.x 中，自定义组件上的 v-model 相当于传递了 modelValue prop 并接收抛出的 update:modelValue 事件： &lt;ChildComponent v-model=\"pageTitle\" /> &lt;!-- 是以下的简写: --> &lt;ChildComponent :modelValue=\"pageTitle\" @update:modelValue=\"pageTitle = $event\" /> 子组件则相对处理 I am Son export default { props: { modelValue: String, }, emit: [\"update:modelValue\"], methods: { changeInput(event) { this.$emit(\"update:modelValue\", event.target.value); }, }, }; 当然也可以使用computed，以计算属性关联数据的设置和获取，子组件直接通过v-model绑定computed，一种更优雅的方式 I am Son export default { props: { modelValue: String, }, emit: [\"update:modelValue\"], computed: { value: { set(value) { this.$emit(\"update:modelValue\", value); }, get() { return this.modelValue; }, }, }, }; 值得注意的是，如果v-model传进去的值是一个对象，而对象里面属性值发生改变的时候，子组件的computed并不能及时emit发送消息到父组件进行更改，而是直接修改props，从而让我们“看到”父组件的对象的属性值修改以后的样子，所以这种方法面对对象类型的props时，是无用的！！！！！！ 组件v-model注意事项&lt;!-- 父组件传入的pageObj是一个对象 --> &lt;child-component v-model=\"pageObj\" /> I am Son export default { props: { modelValue: Object, }, emit: [\"update:modelValue\"], computed: { value: { set(newvalue) { this.$emit(\"update:modelValue\", newvalue); }, get() { return this.modelValue.value; }, }, }, }; 实际上相当于 I am Son export default { props: { modelValue: Object, } }; 而面对复杂数据类型v-model的解决方案为 方案一：子组件使用ref包裹浅拷贝 + watch监听，向父组件发送事件 export default defineComponent({ props: { modelValue: { type: Object, default: () => ({}) } }, setup(props, { emit }) { const FormField = ref({ ...props.modelValue }) watch( FormField, (newValue) => { emit('update:modelValue', newValue) }, { deep: true } ) return { FormField } } }) 而此时父组件修改这个props时要这样修改才有效 //... export default defineComponent({ props: { FormItems: { type: Array as PropType, require: true } }, setup(props) { const originField: any = {} // 动态获取FormField属性名 const arr = props.FormItems || [] for (const item of arr) { const field = item.field originField[field] = '' } // 表单field数据, 这里用ref是因为reactive在v-model使用双向绑定的时候有可能会有些问题 const FormField = ref(originField) // 重置函数（修改props） const ResetHandle = () => { for (const key in FormField.value) { FormField.value[key] = originField[key] } //FormField.value = originField 打咩，无效更改，子组件无法响应 } return { FormField, ResetHandle } }, components: { ChildComponent } }) 方案二：子组件直接不使用v-model，直接用值来绑定就好了（更容易理解） 对input使用v-bind分批绑定，然后input里面的修改使用事件监听 + 发送事件到父组件那边 &lt;!-- 子组件: --> &lt;el-input :modelValue=\"\" @update:modelValue=\"事件处理\" /> 自定义v-model如果想要在一个子组件上绑定多个v-model，则可以使用 v-model:自定义名称=&quot;xx&quot;来定义其他绑定的属性名称 此时子组件通过 props: { 自定义名称: String, },来接收，通过 this.$emit(&#39;update:自定义名称&#39;, value)方法来发送监听事件参数 示例： 父组件 &lt;child v-model=\"message\" v-model:title=\"title\" /> 子组件 I am Son export default { props: { modelValue: String, title: String, }, emit: [\"update:modelValue\", \"update:title\"], computed: { value: { set(value) { this.$emit(\"update:modelValue\", value); }, get() { return this.modelValue; }, }, value2: { set(value) { this.$emit(\"update:title\", value); }, get() { return this.title; }, }, }, }; h()函数Vue推荐绝大多数情况下使用template模板创建你的HTML，如果一些场景你真的需要JavaScript的完全编程能力，这时候你可以使用渲染函数，他比模板更接近编译器 可以理解为 template（经过compile） -&gt; render -&gt; vnode，此时我们直接写render，过程可以在Vue(中)的脚手架部分的runtime only看到 h函数 用于创建一个vnode的函数 其实原名为createVNode函数，但是为了简便在Vue简称为h函数 参数传入： // @returns {VNode} h( // {String | Object | Function} tag // 一个 HTML 标签名、一个组件、一个异步组件、或 // 一个函数式组件。 // // 必需的。 'div', // {Object} props // 与 attribute、prop 和事件相对应的对象。 // 这会在模板中用到。 // // 可选的。 {}, // {String | Array | Object} children // 子 VNodes, 使用 `h()` 构建, // 或使用字符串获取 \"文本 VNode\" 或者 // 有插槽的对象。 // // 可选的。 [ 'Some text comes first.', h('h1', 'A headline'), h(MyComponent, { someProp: 'foobar' }) ] ) 总结就是：1.标签 | 组件，2. 属性， 3. 子组件 | 子标签 注意：如果没有props（属性），可以将子组件作为第二个传入；而如果会产生歧义，则将null作为第二个参数传入 import { h } from \"vue\"; export default { render() { return h( \"div\", { class: \"app\", }, \"hello Render\" ); }, }; 在setup中替代h函数 在setup函数的返回值替换成一个函数，函数返回值为h函数 setup() { const count = ref(0); return () => { return h(\"div\", { class: \"app\" }, [ h(\"h2\", null, `当前计数${count.value}`), h( \"button\", { onClick: () => count.value++, }, \"+\" ), h( \"button\", { onClick: () => count.value--, }, \"-\" ), h(Child, null, \"\"), ]); }; }, 使用JSX和h函数同理，只不过在render函数中写成jsx形式 export default { render() { return &lt;h1>hello world&lt;/h1>; }, }; 生命周期beforeDestroy -&gt; beforeUnmount destroyed -&gt; unmounted setup函数执行 -&gt; applyOptions调用（beforeCreate、Created生命周期函数调用）-&gt; 剩下的生命周期转换成setup的API（onBeforeMount、onMounted） 对于beforeMount之后的生命周期函数，其中beforexxx的生命周期函数，都是立即调用，而xxx的生命周期函数，则放入队列，等到该周期完毕之后，再flushPostFlushCbs刷新队列，执行函数 所以setup执行时机比beforeCreate生命周期还早！ 路由使用若在搭建脚手架时没有安装，则需要手动安装vue路由管理 npm i vue-router@next 原本导出路由： import Router from 'vue-router' import Vue from 'vue' Vue.use(Router); const routes = []; const router = new Router({ routes }) export default router; 现在同createApp，导出单个方法createRouter 而模式的选择也不是之前使用字符串的形式对mode属性赋值，而要导入 createWebHistory、createWebHashHistory import { createRouter, createWebHistory, createWebHashHistory } from 'vue-router' const router = createRouter({ routes, history: createWebHistory(); }) export default router; 然后在main.js中 //... import router from './router' const app = createApp(App) app.use(router); app.mount('#app'); 而 router-view、router-link的使用同之前vue2.x一样 router-link v-slot API (Vue Router3.1.0 新增) router-link的插槽slot，同样可以使用作用域插槽，但是它的插槽自定义props对象其中有包含了一些属性 props: href 跳转的链接 props: route route对象 props: navigate导航函数，需要配合custom属性使用 props: isActive 是否当前处于活跃状态 &lt;router-link to=\"/home\" v-slot=\"props\"> &lt;h2>{{ props.href }}&lt;/h2> &lt;/router-link> &lt;router-view /> router-view v-slot API (Vue Router3.1.0 新增) &lt;!-- 通过props.Component得到目前渲染出来的组件 --> &lt;!-- 此时通过component拿到对应的组件，然后就可以放入transition / keep-alive 中，使用动画 / 缓存了 --> &lt;router-view v-slot=\"props\"> &lt;transition name=\"allen\"> &lt;keep-alive> &lt;component :is=\"props.Component\">&lt;/component> &lt;/keep-alive> &lt;/transition> &lt;/router-view> 动态添加路由有时候一些应用场景需要我们去动态添加路由，而不是一开始将routes写死，我们可以使用 router.addRoute addRoute(route: RouteConfig): () =&gt; void 添加一条新路由规则 addRoute(parentName: string, route: RouteConfig): () =&gt; void 添加一条新的路由规则记录作为现有路由的子路由 const routes = []; const router = createRouter({ routes, }) if(管理员){ router.addRoute({ path: \"/order\", component = () => import('../components/order') }) // 添加二级路由 router.addRoute('home', { path:'moment', component: () => import('../components/HomeMoment') }) } export default router; 当然，除了动态添加路由，当然也有动态删除路由 方式一：添加一个name相同的路由 方式二：使用 removeRoute(路由名称) 方式三：addRoute返回一个函数，调用这个函数则会删除该路由 vuex安装 npm i vuex@next 使用和之前类似，只是依然要导包 import { createStore } from 'vuex'; const store = createStore({ state() { return { //... } } }); export default store 然后在main.js中 //... import store from './store' const app = createApp(App) app.use(store); app.mount('#app'); vue中全局变量、函数可以使用 app.config.globalProperties 进行定义（vue.prototype废除） import { createApp } from 'vue' import App from './App.vue' import router from './router' import store from './store' const app = createApp(App) app.use(store) app.use(router) // 为了区分全局变量，在函数前面加一个$ app.config.globalProperties.$filter = { formatTime(time: string) { console.log('time', time); } } app.mount('#app') 在组件中使用 &lt;strong>{{ $filter.formatTime('666') }}&lt;/strong> 4.Composition APIoption API 模式的弊端 当我们实现一个功能时，这个功能对应的代码逻辑会被拆分到各个属性当中 当我们的组件变得很大很复杂的时候，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散 尤其对那些开始没有编写这些组件的人来说，代码变得难以阅读 composition API使得逻辑代码重合部分可以拆分为一个函数（使用hook，和React一样，使用useXXX命名），然后导入使用 setup其实就是组件的一个选项，只不过这个选项可以强大到替代之前的所有选项 setup里面无法使用this，没有绑定！！ setup的参数 props 还是需要写props的option进行声明 父组件还是需要写components选项 context，它包含三个属性 attrs：所有非props的attribute，比如class、id之类的； slots：父组件传过来的插槽 emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，无法通过this.$emit发出事件） setup的返回值可以在模板template中被使用，也就是说我们可以通过setup的返回值来替代data选项 reactive但是在setup里定义的变量非响应式的，因为他没有放在data，所以我们可以包裹一个 reactive，将其变身称为响应式的（此时包裹在reactive里面的数据会被Vue使用Proxy进行数据劫持） 事实上，我们编写的data选项，也是在内部就给了reactive函数将其变成响应式的 注意：reactive API对传入类型是有限制的，他要求我们必须传入一个对象或者数组类型 {{ state.count }} + import { reactive } from \"vue\"; export default { setup(props, { attrs, slots, emit }) { console.log(props); console.log(attrs); console.log(slots); console.log(emit); // let count = 100; const state = reactive({ count: 100, message: \"hello world\", }); // 局部函数 const increment = () => { state.count++; }; return { state, increment, }; }, }; 注意：reactive在v-model使用双向绑定的时候有可能会有些问题，所以即使数据是对象，此时也建议使用ref包裹 Ref API 官方推荐（尤雨溪）能用ref就用ref，而不是reactive，后期方便抽离 如果我们对reactive传入一个基本数据类型，就会报一个警告，提示我们使用ref ref API会返回一个可变的响应式对象，该对象作为一个响应式引用维护它内部的值，这就是ref名称的来源 它内部的值是在ref的value属性被维护的 但是，虽然是最为ref的value进行存储，但是我们并不需要在模板中使用 变量名.value 来获取存储的数据，在tempplate模板中使用ref对象，它会自动进行解包： 浅层解包，只能对未包裹外层（如果外层有包裹，必须被reactive对象包裹）的基本数据类型进行解包 但是并不代表在逻辑代码里，也就是setup里有自动解包的功能，所以在setup函数里还是得通过 变量名.value 来操作 {{ count }} + import { ref } from \"vue\"; export default { setup() { let count = ref(100); const increment = () => { count.value++; }; return { count, increment, }; }, }; toRefs toRefs：将 reactive对象中所有属性都转换为ref，建立链接 toRef：对 reactive对象其中一个属性转换ref，建立链接 注意，两者都是建立在 reactive API 之上的 正常情况下，对reactive包裹的对象做解构是无法得到响应式数据的，除非使用 toRefs 进行包裹，将里面结构的数据转换为 ref 如果是仅仅只需要解构reactive之后得到一个我们需要的属性，则使用 toRef就可以了（对比 toRefs，性能开销较小 ） // 得不到响应式的 × setup() { const info = reactive({count: 100}) let { count } = info const increment = () => { count++; }; return { count, increment, }; }, import { reactive, toRefs } from \"vue\"; //..... //响应式的count setup() { const info = reactive({ name: 'allen', count: 100 }); //也可以 //let { name, count } = toRefs(info); let count = toRef(info, \"count\"); const increment = () => { count.value++; }; return { count, increment, }; } 还有一个 unref API，用于判断当前是否为ref 实质上也不过就是 unref(val) =&gt; val = isRef(val) ? val.value : val; options API和Composition API 中响应式数据的命名冲突 Vue3内部取值的时候，如果有 $符号，则 先找缓存，没有的话再找setup中保存的响应式数据，找不到再找data，找不到再找props，找不到再找ctx里面有没有值（ctx里面保存computed、methods的数据） if (key[0] !== '$') { const n = accessCache![key] if (n !== undefined) { switch (n) { case AccessTypes.SETUP: return setupState[key] case AccessTypes.DATA: return data[key] case AccessTypes.CONTEXT: return ctx[key] case AccessTypes.PROPS: return props![key] // default: just fallthrough } } else if (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) { accessCache![key] = AccessTypes.SETUP return setupState[key] } else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) { accessCache![key] = AccessTypes.DATA return data[key] } else if ( // only cache other properties when instance has declared (thus stable) // props (normalizedProps = instance.propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key) ) { accessCache![key] = AccessTypes.PROPS return props![key] } else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) { accessCache![key] = AccessTypes.CONTEXT return ctx[key] } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) { accessCache![key] = AccessTypes.OTHER //找不到了 } } ref获取组件/元素对象 import { ref } from \"vue\"; export default { setup() { // 只不过title要在元素挂在完毕之后才有值 const title = ref(null); return { title } }, }; 无法使用this官方： 在 setup() 内部，this 不是该活跃实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这使得 setup() 在和其它选项式 API 一起使用时可能会导致混淆。 coderwhy老师：组件实例被创建 -&gt; setup被调用 -&gt; 其他option出来 也就是说 在 setup 中this并没有绑定组件实例 并且在 setup 被调用之前，data、computed、methods等option都没有被解析 readonly有时候我们通过reactive 或者 ref 获取到一个响应式对象，但是我们传入其他地方（组件）的时候，并不想在另外一个地方（组件）被修改，只读就可以 比如说父组件传入到子组件，我们要遵循“单向数据流”的规范 使用readonly readonly会返回原生对象的只读代理（也就是它依旧是一个Proxy，这是一个proxy的set方法被劫持，而不能对其进行修改） const dataProxy = new Proxy(info, { get(target, key){ return target[key] }, set(target, key, value) { warning(); } }) import { reactive, ref, readonly } from 'vue' //... setup(){ const data = reactive({name: 'allen'}); const data2 = ref(100); const readonlyData = readonly(data); const readonlyData2 = readonly(data2); readonly.name = 'bruce'; //失败，警告 } computed通过导包的方式，直接再 setup 函数中使用 传入一个函数作为参数，该返回值（也变身为ref对象）直接作为缓存 or 传入一个对象，包含get和set方法，同以前的computed option（也返回成一个ref对象） import { ref, computed } from \"vue\"; export default { setup() { const firstname = ref(\"Allen\"); const lastname = ref(\"bruce\"); const fullname = computed(() => firstname.value + \" \" + lastname.value); return { fullname, }; }, }; watch在composition API中，我们可以使用watchEffect和watch来完成响应式数据侦听 watchEffect用于自动收集响应式数据依赖，首屏渲染就会立即执行一次 立即执行一次就是为了查看函数里面包含了什么响应式的数据，进行依赖收集 之后若该依赖发生改变，则watchEffect函数就会被触发； 第二个参数是option，可以指定 flush：”pre”|”post”|”sync”，分别是 默认|dom挂载之后再执行|强制同步触发，低效的 function watchEffect( effect: (onInvalidate: InvalidateCbRegistrator) => void, options?: WatchEffectOptions ): StopHandle setup() { const name = ref(\"Allen\"); const age = ref(18); const changeName = () => { name.value = \"Bruce\"; }; const changeAge = () => { age.value++; }; //依赖项发生改变自动重新执行，个人感觉有点像react的useEffect来用了 watchEffect(() => { console.log(\"name:\", name.value); // name发生改变则调用，因为name被watchEffect收集了 }); return { name, age, changeAge, changeName, }; }, watch需要手动指定侦听数据源，几乎等同于watch option 但是在setup里面，格式上还是有少许不同 第一个参数传入一个getter函数（reactive 或者 ref 或者一个装着多个ref/reactive的数组） 第二个参数传入一个函数，代表监听数据变化后进行的操作 第三个参数可选，作为watch的option设置监听，比如deep（深度侦听）、immediate（是否首屏渲染就会立即执行一次） setup() { const info = reactive({ name: \"allen\", age: 18 }); const changeName = () => (info.name = \"Bruce\"); watch(info, (newval, oldval) => { console.log(newval, oldval); }); /* 避免newval，oldval变为一个代理proxy，解构掉reactive watch(() => { return {...info}; }, (newval, oldval) => { console.log(newval, oldval); }); */ return { changeName, info, }; }, 注意：如果第一个参数是reactive，则默认深度监听 停止侦听器 and 清除副作用 watchEffect 返回一个 停止器，调用该停止器之后，watchEffect将不会被触发 watchEffect还接受一个参数，该参数传入的函数会在watchEffect被销毁时调用，个人感觉可以把它当成React中 useEffect的 返回值 setup() { const name = ref(\"Allen\"); const age = ref(18); // watchEffect 返回一个停止侦听器，调用即停止 const stop = watchEffect((onInvalidate) => { onInvalidate(() => { // 用于清除函数中的副作用，比如可以放一些取消请求功能request.cancel() // 当依赖项发生改变，watchEffect重新执行，则这里面的的代码也会被执行。 console.log(\"我被执行了！\"); }); console.log(\"name:\", age.value); }); const changeAge = () => { age.value++; if (age.value > 25) stop(); }; return { name, age, changeAge, }; }, 生命周期替代使用：可以直接导入 onX 函数，注册生命周期钩子函数 option API Hook inside setup beforeCreate no need（由于setup比它早，放在setup执行即可） created no need（由于setup比它早，放在setup执行即可） beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted activated onActivated deactivated onDeactivated import { onMounted, onUpdated, onUnmounted, ref } from \"vue\"; export default { setup() { const counter = ref(100); const increnment = () => counter.value++; onMounted(() => { console.log(\"onMounted\"); }); // 可以注册多个生命周期 onMounted(() => { console.log(\"onMounted2\"); }); onUpdated(() => { console.log(\"onUpdated\"); }); onUnmounted(() => { console.log(\"onUnmounted\"); }); return { counter, increnment, }; }, }; provide / inject父组件：导包之后，以键值对的形式，存储于父组件的provide中 子组件：导包之后，通过inject(键)来获取传入的数据；也可以给inject传入第二个参数来添加默认值 // 父组件 import { provide, ref, readonly } from \"vue\"; import Child from \"./Child.vue\"; export default { setup() { const name = \"Allen\"; let count = ref(10); provide(\"name\", name); provide(\"count\", readonly(count)); }, components: { Child, }, }; // 子组件 import { inject } from \"vue\"; export default { setup() { const name = inject(\"name\"); const count = inject(\"count\", 10); return { name, count, }; }, }; script setupscript setup 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。 2021.6.21为止还是实验性，但是到了2021.11.28好像已经被纳入正式版了 相比于普通的 &lt;script&gt; 语法，它具有更多优势： 更少的样板内容，更简洁的代码。 能够使用纯 Typescript 声明 props 和抛出事件。 更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。 更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作) import MyComponent from './MyComponent.vue' import { ref } from 'vue' const count = ref(0); {{ count }} 在 &lt;script setup&gt; 中必须使用 defineProps 和 defineEmits API 来声明 props 和 emits 获取路由对象依旧是因为setup中获取不到this，此时导入路由的hook 此时这里的 useRoute返回的route = this.$route import { useRoute } from 'vue-router'; export default { setup() { const route = useRoute(); }, }; 同样的，想要获取 $router 对象，也需要导入路由hook，通过返回的router对象，使用原来 this.$router.push 方法 import { useRouter } from 'vue-router'; export default { setup() { const router = useRouter(); router.push(\"/xxx\") }, }; 获取vuex依旧是因为setup中获取不到this，此时导入vuex的hook 这里引入了computed、Vuex的mapState（一个对象，传入的属性是多个函数）简化模板中的数据简写 import { useStore, mapState } from 'vuex' import { computed } from 'vue' export default { setup() { const store = useStore(); const sCounter = computed(() => store.state.counter); // 除了一个一个computed声明，也可以使用mapState const storeStateFns = mapState(['name', 'age']); const storeState = {}; Object.keys(storeStateFns) .forEach(key => { // mapState里的函数调用时return this.$store.state.xxx，所以这里要处理this const fn = storeStateFns[key].bind({ $store: store }); storeState[key] = computed(fn); }) return { sCounter, ...storeState } }, }; nextTickimport { nextTick } from \"vue\"; export default { setup() { // 使用onUpdated的话也可以，但是onUpdated比较公用，任何DOM更新都会触发 nextTick(() => { //... }); }, }; vue的nextTick原理思路有点像node.js中事件循环的nextTick vue把watch的回调、组件更新触发的事件、生命周期的回调等任务，而任务全部被加入到微任务队列里面去！！！！ 而使用nextTick，就会让nextTick中的回调任务加入到微任务任务队列中 export function nextTick&lt;T = void>( this: T, fn?: (this: T) => void ): Promise&lt;void> { const p = currentFlushPromise || resolvedPromise return fn ? Promise.resolve().then(this ? fn.bind(this) : fn) : p } 5.废弃$children属性在 3.x 中，$children property 已被移除，且不再支持。如果你需要访问子组件实例，我们建议使用 $refs filters option我们建议用计算属性或方法代替过滤器，而不是使用过滤器。 迁移构建开关： FILTERS COMPILER_FILTERS router-link路由 router-link 的 tag 属性 因为现在可以直接再 router-link 中写入标签，当作slot使用 可选的第三个参数 next在之前的 Vue Router 版本中（当前2021年为4.x版本），也是可以使用 第三个参数 next 的。这是一个常见的错误来源，可以通过 RFC 来消除错误。然而，它仍然是被支持的，这意味着你可以向任何导航守卫传递第三个参数。在这种情况下，确保 next 在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。这里有一个在用户未能验证身份时重定向到/login的错误用例： // BAD router.beforeEach((to, from, next) => { if (to.name !== 'Login' &amp;&amp; !isAuthenticated) next({ name: 'Login' }) // 如果用户未能验证身份，则 `next` 会被调用两次 next() }) 下面是正确的版本: // GOOD router.beforeEach((to, from, next) => { if (to.name !== 'Login' &amp;&amp; !isAuthenticated) next({ name: 'Login' }) else next() }) 现在更多通过返回值来控制跳转（next） false：取消当前导航 不反悔/ undefined：默认导航 返回一个路由地址：可以是String，也可以是一个对象（包含path、params、query等信息），跳到该导航（把这个看成 this.$router.push(&quot;/home&quot;); 即可） 比如 router.beforeEach((to) => { if (to.path !== '/login') { const token = LocalCache.getCache('toekn') if (!token) { return '/login' } } }) Vue.extend在 Vue 2.x 中，Vue.extend 曾经被用于创建一个基于 Vue 构造函数的“子类”，其参数应为一个包含组件选项的对象。在 Vue 3.x 中，我们已经没有组件构造器的概念了。应该始终使用 createApp 这个全局 API 来挂载组件 v-on.native它原来是用于组件中原生事件的触发 原来的样子 而现在v-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。 因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。 （可以理解为直接用就好了，不用加native） &lt;my-component v-on:close=\"handleComponentEvent\" v-on:click=\"handleNativeClickEvent\" /> //MyComponent.vue export default { emits: ['close'] } 事件总线Vue3官方实例移除了 $on 、$off 、$once方法，所以不能像Vue2.x一样通过创建Vue实例来进行事件总线。如果我们希望继续使用事件总线，可以通过一些第三方的库，Vue3官方推荐 mitt或者tiny-emitter mitt库的使用 npm i mitt js文件封装 import mitt from 'mitt' const emitter = mitt(); export default emitter; 组件使用（直接发布订阅完事） import emitter from 'xxx.js' 事件(){ emitter.emit('事件名称', {a: 1, b: 2}) } import emitter from 'xxx.js' //创建初期直接监听发布 created(){ emitter.on('事件名称', data => { //.... })； emitter.on('*', (type, data) => { console.log(`如果是*则监听所有事件,事件类型：${type}，传递参数：${data}`); }) } mit事件监听取消 //全部一次性取消 emitter.all.clear(); //单个取消，函数需要定义 function onFoo() {} emitter.on('foo', onFoo); emitter.off('foo', onFoo);","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Vue3(下)","slug":"Vue3(下)","date":"2021-11-04T16:00:00.000Z","updated":"2022-08-27T13:07:00.499Z","comments":true,"path":"2021/11/05/vue3-xia/","link":"","permalink":"https://taylor12138.github.io/2021/11/05/vue3-xia/","excerpt":"","text":"6.Vue动画处理vue有个内置组件 transition 基本使用：使用name定义过渡类名，然后常常与v-if、v-show、动态组件进行搭配 官方： 可以给任何元素和组件添加进入/离开过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 基本使用（CSS）&lt;transition name=\"why\"> &lt;h2 v-if=\"isShow\">Hello World&lt;/h2> &lt;/transition> .why-enter-from, .why-leave-to { opacity: 0; } .why-enter-to, .why-leave-from { opacity: 1; } .why-enter-active, .why-leave-active { transition: opacity 2s ease; } class几个transition的类（我们可以通过name来定义前缀，比如name=”allen”，则类为allen-enter-from） v-enter-from：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。（插入时样式） v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。（插入ing样式，常存放动画） v-enter-to：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter-from 被移除)，在过渡/动画完成之后移除。（插入后样式） v-leave-from：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。（移除前样式） v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。（移除ing样式，常存放动画） v-leave-to：离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被删除)，在过渡/动画完成之后移除。（移除后样式） transition的几个props name - string 用于自动生成 CSS 过渡类名。例如：name: &#39;fade&#39; 将自动拓展为 .fade-enter，.fade-enter-active 等。 appear - boolean，是否在初始渲染时使用过渡。默认为 false。 mode - string 控制离开/进入过渡的时间序列。有效的模式有 &quot;out-in&quot; （先移除，再插入）和 &quot;in-out&quot;（先插入，再移除）；默认同时进行。 duration - number | { enter: number, leave: number }。指定过渡的持续时间，指定之后css动画里原来写好的时间则无效 css，指定 :css=&#39;false&#39;可以让css过渡属性失效，提高性能（用于只执行js动画） 第三方动画库animate.css官网：https://animate.style/ npm i animate.css --save 然后直接在main.js里面引入 import \"animate.css\"; 在官网搜寻自己想要的动画名称，并且在transition类中添加，比如 .allen-enter-active { animation: bounceInUp 1s linear } .allen-leave-active { animation: bounceInUp 1s linear reverse } gsap库一个JS动画库（vue官方有在用），官网：https://greensock.com/ 通过JavaScript为CSS属性，SVG、Canvas等设置动画，并且都是浏览器兼容的 npm i gsap 使用gsap库配合js钩子使用 methods: { enter(el, done) { console.log(\"enter\"); gsap.from(el, { scale: 0, x: 200, onComplete: done }) }, leave(el, done) { console.log(\"leave\"); gsap.to(el, { scale: 0, x: 200, onComplete: done }) } } gsap除了对元素（element）进行JS动画处理，也可以对某个普通对象，进行按照时间间隔逐步改变属性值 当前计数: {{showNumber.toFixed(0)}} import gsap from 'gsap'; export default { data() { return { counter: 0, showNumber: 0 } }, watch: { counter(newValue) { gsap.to(this, {duration: 1, showNumber: newValue}) } } } JS钩子transition内置组件除了可以使用CSS动画，还可以配合上JS动画 此时使用里面定义好的JS钩子即可（钩子作用分别查看字面意思即可， enter-cancelled和 leave-cancelled对应的是取消操作 ） 用的最多是enter和leave &lt;transition @before-enter=\"beforeEnter\" @enter=\"enter\" @after-enter=\"afterEnter\" @enter-cancelled=\"enterCancelled\" @before-leave=\"beforeLeave\" @leave=\"leave\" @after-leave=\"afterLeave\" @leave-cancelled=\"leaveCancelled\" :css=\"false\" > &lt;!-- ... --> &lt;/transition> 钩子函数可以选择带入参数： el：当前元素 done：当只用 JavaScript 过渡的时候，在 enter 和 leave 钩中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。 // ... methods: { beforeEnter(el) { // ... }, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter(el, done) { // ... done() }, afterEnter(el) { // ... }, enterCancelled(el) { // ... }, // -------- // 离开时 // -------- beforeLeave(el) { // ... }, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave(el, done) { // ... done() }, afterLeave(el) { // ... }, // leaveCancelled 只用于 v-show 中 leaveCancelled(el) { // ... } } 列表插入列表新增 / 删除元素的时候，可以模拟成v-if时，新增/ 删除 元素 只不过通过 transition-group 进行包裹 props： tag：将 transition-group变成 xx标签 不过，列表多出了其他元素，而添加 / 删除元素时影响到其他列表元素位置时，调整的动画该如何设置？ 我们可以使用 v-move的class来完成动画的设置，它会在元素改变位置的时候应用，和之前的名字一样，我们可以通过name定义前缀 添加 / 删除列表元素小案例 添加数字 删除数字 {{item}} export default { data() { return { numbers: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], numCounter: 10 } }, methods: { addNum() { this.numbers.splice(this.randomIndex(), 0, this.numCounter++) }, removeNum() { this.numbers.splice(this.randomIndex(), 1) }, randomIndex() { return Math.floor(Math.random() * this.numbers.length) } }, } .item { margin-right: 10px; display: inline-block; } .why-enter-from, .why-leave-to { opacity: 0; transform: translateY(30px); } .why-enter-active, .why-leave-active { transition: all 1s ease; } .why-leave-active { position: absolute; /*防止移除的过程中仍占据原来的位置，导致元素移动的动画不成功*/ } .why-move { transition: transform 1s ease; } 7.其他自定义指令代码的复用主要还是通过组件，但是在某些情况下，你需要对DOM元素进行底层操作，就可以用到自定义指令 自定义局部指令：组件通过directives选项 自定义全局指令：app的directives选项 案例：为组件自定义 v-focus 指令 export default { // 局部指令 directives:{ focus:{ mounted(el, bindings, vnode, preVnode) { el.focus(); }, } } } 若为全局指令则在main.js中定义（更常用） import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app'); // 全局指令 app.directive(\"focus\", { mounted(el, bindings, vnode, preVnode) { el.focus(); }, }) 自定义指令内部的生命周期属性： 名称 created beforeMount mounted beforeUpdate updated beforeUnmount unmounted 生命周期函数携带的参数 el：元素 bindings：一个对象，里面存储传入的参数、修饰符等 vnode虚拟节点 preVnode，指向上一个虚拟节点 teleport在某些情况下，我们并不想要将组建挂载在组件树上，而是移动到Vue app 以外的地方（我们有其他div#app的元素） teleport是Vue内置组件，类似于React的Portals 它有两个属性 to：指定将其中的内容移动到目标元素，可以使用选择器 disabled：是否禁用teleport的功能 自定义插件全局插件有个约定俗成的小规范：命名都加$, $开头 添加完毕之后，可以通过 this.命名来获取 但是setup比较麻烦，因为setup不能通过this拿到组件实例 export default { install(app) { app.config.globalProperties.$name = \"Allen\" } } 在main.js中导入 import { createApp } from 'vue' import App from './App.vue' import plugins_object from './plugins/plugins_object' const app = createApp(App) app.use(plugins_object); // 使用插件 /* 内部执行plugins_object.install(app) */ app.mount('#app'); 在Vue3中，use方法实际上是把插件添加进Set中，然后调用其install方法 如果没有install方法，而plugin本身就是一个方法，则调用plugin方法 use(plugin: Plugin, ...options: any[]) { if (installedPlugins.has(plugin)) { __DEV__ &amp;&amp; warn(`Plugin has already been applied to target app.`) } else if (plugin &amp;&amp; isFunction(plugin.install)) { installedPlugins.add(plugin) plugin.install(app, ...options) } else if (isFunction(plugin)) { installedPlugins.add(plugin) plugin(app, ...options) } else if (__DEV__) { warn( `A plugin must either be a function or an object with an \"install\" ` + `function.` ) } return app }, vue3源码相关三大核心 Complier模块，编译模板系统（tempplate -&gt; h函数可识别的形式） Runtime模块，称之为Renderer模块，真正的渲染模块（h函数可识别的形式 -&gt; 虚拟DOM -&gt; 真实DOM） Reactivity模块，响应式系统 element-plushttps://element-plus.gitee.io/zh-CN/ Element Plus，一套为开发者、设计师和产品经理准备的基于 Vue 3 的桌面端组件库（Element是针对vue2.x的） 如果是移动端的推荐使用 VantUI 使用： 方案一：直接全局引用 - &gt; 所有组件全部集成，组件全部进行了全局注册 优点：集成比较简单，可以直接使用 缺点：全部打包‘ // main.ts import { createApp } from 'vue' import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' import App from './App.vue' const app = createApp(App) app.use(ElementPlus) app.mount('#app') 方案二：按需引用 优点：包会比较小 缺点：引用麻烦 方案三：官网推荐的自动导入 8.双向绑定Proxy VS Object.defineProperty Vue2.x版本中的双向绑定不能检测到下标的变化，不存在的属性不能被拦截（其实也是因为 Object.defineProperty方法必须传入对象、属性参数），属性中还有属性嵌套还得递归；proxy可以劫持整个对象，并返回一个新对象，管你属性存不存在都可以拦截 响应式方面 性能得到很大提升 不用初始化的时候就递归遍历属性；响应式不区分数组和对象 修改对象： 使用 Object.defineProperty 我们修改原来的obj对象就触发拦截 使用proxy要修改代理对象，才触发拦截（即使在getter方法中 return target[key]，也不会触发循环调用 ） Proxy能观察的类型比defineProperty更加丰富，比如has、deleteProperty等 Proxy作为新标准将受到浏览器厂商的重点优化 more: 这里Proxy相对与原来Vue2.0的响应式的 “不管三七二十一，上来就给你判断对象 + 递归 ” 不一样，做了小优化，他在修改数据时并不是一上来就递归，而是先通过get方法获取，如果获取到的结果是一个对象，则再做一层代理，进行递归，然后再通过set修改 既然Proxy可以改属性 + 新增属性，那他怎么识别？通过 if 语句 + 对象.hasOwnProperty(属性) 判断，原来是否有这个属性 为什么以前不用Proxy？兼容性差。。。ie11就不兼容 代理模式代理模式（英语：Proxy Pattern）是程序设计中的一种设计模式。 当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少内存用量。典型作法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。 ProxyProxy代理Object 控制和修改Object的基本行为（覆盖对象的基本操作），比如属性调用、属性赋值、删除属性、方法调用等 target是被代理的对象，handler是一个对象，属性是各种控制或修改target基本行为的方法 你可以想象成proxy就是一个壳 const p = new Proxy(target, handler); handler里面的get()、set()和Object.defineProperty()的get方法、set方法有点像，重新定义了属性的读取、设置行为 get()拦截某个属性的读取操作。可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。 set()拦截某个属性的赋值操作。可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。 其实handler有13种方法 handler.getPrototypeOf() // 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。 handler.setPrototypeOf() // 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。 handler.isExtensible() // 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。 handler.preventExtensions() // 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。 handler.getOwnPropertyDescriptor() // 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, \"foo\") 时。 handler.defineProperty() // 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, \"foo\", {}) 时。 handler.has() // 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 \"foo\" in proxy 时。 handler.get() // 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。 handler.set() // 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。 handler.deleteProperty() // 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。 handler.ownKeys() // 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。 handler.apply() // 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。 handler.construct() // 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。 里面的方法一般都需要返回值 var obj = new Proxy({}, { get: function (target, propKey, receiver) { console.log(`getting ${propKey}!`); return Reflect.get(target, propKey, receiver); }, set: function (target, propKey, value, receiver) { console.log(`setting ${propKey}!`); return Reflect.set(...arguments); } }); 甚至你可以用proxy做缓存 服务端和客户端同步一个状态可能会出现问题，这很常见，在整个操作周期内，数据都有可能被改变，并且很难去掌握需要重新同步的时机。proxy提供了一种新的办法，可以让属性在必要的时候失效，所有的访问操作，都会被检查判断，是否返回缓存还是进行其他行为的响应。 Copyconst timeExpired = (target, ttl = 60) => { const created_at = Date.now(); const isExpired = () => (Date.now - created_at) > ttl * 1000; return new Proxy(tarvet, { get: (target, k) => isExpired() ? undefined : Reflect.get(target, k); }) } 上面的功能很简单，他在一定时间内正常返回访问的属性，当超出ttl时间后，会返回undefined。 Copylet timeExpired = ephemeral({ balance: 14.93 }, 10) console.log(bankAccount.balance) // 14.93 setTimeout(() => { console.log(bankAccount.balance) // undefined }, 10 * 1000) 上面的例子会输出undefined在十秒后，更多的骚操作还请自行斟酌。 Reflect通过Proxy的捕获器（handler），我们可以完成基于自己的参数重建原始操作，但是并非所有捕获器都像 get 一样那么简单，直接返回就行了，所以通过手动写码如法炮制的想法是不现实的，所以我们使用到了Reflect完成轻松重建，确保完成原有的行为，然后再部署额外的功能。 Reflect 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上，也就是说，从Reflect对象上可以拿到语言内部的方法。 Reflect修改某些Object方法的返回结果，让其变得更合理。 比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 上面两点表明 Reflect可能将成为日后替代 Object对象方法的新的王！ 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 // 老写法 'assign' in Object // true // 新写法 Reflect.has(Object, 'assign') // true Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 Proxy(target, { set: function(target, name, value, receiver) { var success = Reflect.set(target, name, value, receiver); if (success) { console.log('property ' + name + ' on ' + target + ' set to ' + value); } return success; } }); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。 个人认为：这样就形成了Proxy和Reflect的最佳搭配，既保证了原来（默认）的行为，又可以自己添加额外的行为 9.Vue3 + TS 项目搭建规范集成editorconfig配置editorconfig有助于为不同IDE编辑器上同一项目多人开发的编码风格（比如控制tab缩进空格数量等） 在根目录下新建一个 .editorconfig 文件 注意，默认情况下vscode不会读取这个文件，需要安装一个插件 EditorConfig for VScode # https://editorconfig.org root = true [*] #所有文件适用 charset = utf-8 #文字字符集啊uft-8 indent_style = space #缩进风格space indent_size = 2 #缩进大小 end_of_line = lf #控制换行类型lf、cr、crlf insert_final_newline = true #去除行首任意空白字符 trim_trailing_whitespace = true #始终在文件末尾插入一个新行 [*.md] insert_final_newline = false trim_trailing_whitespace = false 配置eslint推荐先在vscode安装一下eslint插件 然后可以在根目录下的.eslintrc.js文件查看eslint的规则配置 但是有时候出现我们自定义prettier配置（格式化）和我们的eslint并不兼容的场面，此时我们要安装两个库（如果在创建脚手架的时候有配置过eslint + prettier选项的话，则已经帮我们安装过了） npm i eslint-plugin-prettier eslint-config-prettier -D 然后在配置文件 .eslintrc.js 中的extends设置最后一行 extends: [ 'plugin:vue/vue3-essential', 'eslint:recommended', '@vue/typescript/recommended', '@vue/prettier', '@vue/prettier/@typescript-eslint', 'plugin:prettier/recomended' ] 若想关掉一些eslint检查，可以 rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', 'typescirpt-eslint/no-var-require': 'off' // 关闭对require引用的禁令 } 不同的开发环境在开发中，有时候我们需要根据不同的环境设置不同的环境变量，常见的有三种环境 开发环境：development 生产环境：production 测试环境：test 方法一： 为了让不同环境使用不同的变量，我们可以使用 process.env.NODE_ENV 这个值实际上是我们使用webapack的时候，通过它的DefinePlugin全局变量，根据环境注入不同的值，使得在不同环境下 process.env.NODE_ENV 的值分别是 ‘development’ 、’production’、’test’ 此时我们全局注入的变量通过 if-else 或者 switch 进行变化即可（比如 if(process.env.NODE_ENV === &#39;development&#39;) ） 方法二： 注意：此方法创建的变量名不能乱起，只有起固定格式的名字，才会被全局注入 官网注明：请注意，只有 NODE_ENV，BASE_URL 和以 VUE_APP_ 开头的变量将通过 webpack.DefinePlugin 静态地嵌入到客户端侧的代码中。这是为了避免意外公开机器上可能具有相同名称的私钥。 在项目根目录下新建三个文件，文件名分别是 .env.devlopment、.env.production、.env.test // .env.test VUE_APP_BASE_URL = &#39;&#39; VUE_APP_BASE_NAME = &#39;allen&#39;方案二此时在客户端侧代码中使用环境变量 只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。你可以在应用的代码中这样访问它们： console.log(process.env.VUE_APP_SECRET) Vuex配合TScreateStore可以传入一个泛型 变成 createStore&lt;T&gt; 这个泛型 规定了 state的类型 import { createStore } from 'vuex' interface IRootState { name: string age: number } export default createStore&lt;IRootState>({ state: () => { return { name: 'allen', age: 18 } }, mutations: {}, actions: {}, modules: {} }) // 使用 import { useStore } from 'vuex'; import {IRootState} from '@/store/types'; export default defineComponent({ setup() { const store = useStore&lt;IRootState>() return {} } }) 但是此时我们即使里面已经定义了一些模块，ts还是会给我们报错，比如我们的store里面有个login模块 但是使用的时候ts会报错 store.state.login.name 此时就表现了vuex对TS的支持非常差（4.x版本） 不过pinia对TS的支持就相对好一点，用法也和vuex相似 当然coderwhy老师还是有解决的方法，比如导出vuex的时候，写多一个函数进行导出 vuex模块使用（new）接口定义 import { ILoginState } from './login/types' export interface IRootState { name: string age: number } export interface IStoreType extends IRootState { login: ILoginState } 在store/index.ts文件中导出一个函数 import { createStore, Store, useStore } from 'vuex' import { IRootState, IStoreType } from './types' //.... //负责导出store（coderwhy老师的特殊处理） export function useMyStore(): Store&lt;IStoreType> { return useStore() } export default store 此时使用 import { defineComponent } from 'vue' import { useMyStore } from '@/store' export default defineComponent({ setup() { const store = useMyStore() console.log(store.state.login.name) //此时使用起来没问题！ return {} } }) vuex的modules模块封装 在ts使用vuex中module来封装模块的时候，需要导入的Module类型声明也有讲究 Module类型类型声明需要传入两个泛型 Module&lt;S, R&gt; S 为 模块中state的类型，R为根模块的state类型 遇到繁琐的接口定义百度一下：json to ts 会自动转换，把json转换成ts语法，直接帮你写好 但是遇到复杂的数据类型，嵌套，它的转换仍然是有问题的。此时就只能用any了 TS结合Vue3的props有时面对props传参的时候，我们需要特定类型来规范我们传入的参数，而单单靠props自身的type我们还不满足，此时我们可以使用 PropType &lt;script lang=\"ts\"> import { defineComponent, PropType } from 'vue' export default defineComponent({ props: { formItems: { type: Array as PropType&lt;string[]> } }, setup() { return {} } }) &lt;/script> 此时我们可以在泛型里面定义接口，也是可以的 但是众所周知，在定义默认值的时候，复杂数据类型要写成一个函数的形式（《Vue(上)》篇章有提及） 但是如果是vue3 + ts的话，规定要写成一个箭头函数（使用this时）","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"网站性能优化","slug":"网站性能优化","date":"2021-11-01T16:00:00.000Z","updated":"2022-10-07T08:04:02.246Z","comments":true,"path":"2021/11/02/wang-zhan-xing-neng-you-hua/","link":"","permalink":"https://taylor12138.github.io/2021/11/02/wang-zhan-xing-neng-you-hua/","excerpt":"","text":"1.网站性能优化概述我们通常的标量化 白屏 首屏 页面整体加载 页面可交互 功能交互响应 Steve Souders在《高性能网站建设指南》总结的12条提高性能的基本规则 尽量减少http请求 使用CDN 静态资源使用Cache 启用Gzip压缩 JavaScript脚本尽量放在页面底部 CSS样式表放在顶部 避免CSS表达式（也就是不要频繁动态改动CSS） 减少内联的CSS和JavaScript 减少DNS查询 精简JavaScript 避免重定向 删除重复脚本 2.白屏白屏时长我们可以从URL地址的输入 -&gt; 请求发出 -&gt; 页面渲染完成，之中找到优化的方案 DNS -&gt; TCP -&gt;服务端响应 -&gt; 客户端下载、解析、渲染显示页面 DNS LookupDNS的优化策略有很多 DNS缓存优化 DNS预加载策略 页面中资源域名的合理分配 稳定可靠的DNS服务器 客户端下载具体步骤 如果是Gzip包，先解压为HTML 解析HTML头部代码，下载相关的资源（CSS、JS等） 正常的网页绘制流程（render树的合成以及页面的绘制） 而在真实的构件中，浏览器会因为各种因素被阻断 JS代码会阻断DOM树的构造 浏览器必须等待样式表加载完成，采购件CSSOM树 Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。（却决于浏览器的策略） 从上述我们可以发现HTML中内联JS代码的恶劣性质。它最大的危害在于第三种，即DOM树构建过程中被JS阻塞，而JS被CSS阻塞，这导致了CSSOM树和DOM树同时（并行）构建的理想状态被打破 然而对以上的优化策略，我们可以着手于 优化HTML代码结构，缩短下载时间 + 解析速度 优化CSS文件和结构 合理放置JS代码 网上关于CSR首屏优化的方案链接https://github.com/BetaSu/fe-hunter/issues/4#issuecomment-1075856575 一、如何分析首屏加载CSR的性能？有三种方式进行分析： network（浏览器-&gt;DevTools） performance （浏览器-&gt;DevTools） lighthouse（浏览器-&gt;DevTools） sentry（第三方平台） webPageTest 更全面，更详细，更强大的页面分析具体怎么操作我就不赘述了，各位自行去看。 二、分析后如何找出CSR性能瓶颈？按照上面的5种方式来看吧 三、如何解决CSR性能瓶颈？从CSR方向来讲的话，基本就两个方向了 网络层面：从网络方面来讲，就是减少HTTP请求的次数，以及减小请求体积，这里就简单聊几点a). 将多次请求合并到一次请求（ajax、精灵图，文件合并等）b). 页面懒加载应该也可以算在这个方面。c). 缓存住一些不经常改动的文件或内容将请求拦截（service worker）b). 文件内容压缩e). 静态资源CDN也是方式之一f). 升级到 http2 渲染层面a). 骨架屏，起码能让用户有打开了网页的感觉b). 图片懒加载c). 防抖节流d). 代码层面的改善吧，很有可能是某些坏代码产生的 四、有没有其他渲染方案可以解决CSR当前问题，他的原理是什么？SSR。就是将框架代码提前在服务端跑一遍，不过一般除非对SEO要求比较高或者你们公司比较有钱，否则不太会去使用，因为比较占用服务器的资源。 3.页面整体加载完成又被称为PageLoad，顾名思义所有页面相关资源全部加载完成的时间，而其中这个时间点为我们熟知的“8s”原则 随后在2006年，一个来自Akamai的新研究，发表了新的观点：通常4s左右的平均加载时间，是用户可能会等待页面加载的最长时间。 尽早建立第三方连接对第三方域的服务器请求也会影响 LCP，尤其是当浏览器需要这些请求来在页面上显示关键内容的情况下。使用rel=&quot;preconnect&quot;来告知浏览器您的页面打算尽快建立连接。 &lt;link rel=\"preconnect\" href=\"https://example.com\" /> 您还可以使用dns-prefetch来更快地完成 DNS 查找。 &lt;link rel=\"dns-prefetch\" href=\"https://example.com\" /> 尽管两种提示的原理不同，但对于不支持preconnect的浏览器，可以考虑将dns-prefetch做为后备。 &lt;head> … &lt;link rel=\"preconnect\" href=\"https://example.com\" /> &lt;link rel=\"dns-prefetch\" href=\"https://example.com\" /> &lt;/head> 预加载重要资源 #有时，在某个 CSS 或 JavaScript 文件中声明或使用的重要资源可能会比您所期望的要晚一点被获取，例如深藏在应用程序众多 CSS 文件中的某个字体。 如果您知道某个特定资源应该被优先获取，请使用&lt;link rel=&quot;preload&quot;&gt;来更加及时地获取该资源。 多种类型的资源都可以进行预加载，但您应该首先侧重于预加载关键资产，例如字体、首屏图像或视频，以及关键路径 CSS 或 JavaScript。 &lt;link rel=\"preload\" as=\"script\" href=\"script.js\" /> &lt;link rel=\"preload\" as=\"style\" href=\"style.css\" /> &lt;link rel=\"preload\" as=\"image\" href=\"img.png\" /> &lt;link rel=\"preload\" as=\"video\" href=\"vid.webm\" type=\"video/webm\" /> &lt;link rel=\"preload\" href=\"font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin /> 4.加快首次渲染方案首屏渲染时render树的合成时长之一，DOM树与DOM节点数量息息相关，而如果使用 TextArea存放HTML代码，而浏览器解析的时候不会识别，不被当做DOM去解析，会让首屏渲染DOM树包含的节点大幅减少，从而提高首次渲染速度 在服务端：将一些特殊字符（&amp;之类的）进行HTMLEncode转义，在浏览器端，则需要在首屏区域处于可见状态时，将TextArea的HTML代码取出，将其恢复到DOM树进行渲染，这一行为在 《大型网站性能优化实战》中被称为延迟渲染 大规模内联关键 CSS你需要一个自动化系统，而不是对每个页面都这样做。仅内联 WordPress 主题主页的 CSS 是有意义的，因为它通常与其他页面是不同的样式表。通常会有一些插件/模块/包、一个关键版本或关键 CSS。这些包(packages)可能适用于你使用的任何 taskrunner 或是如 Grunt、Gulp、Webpack 或框架如 React、Angular、Vue，你还可以找到特定关于 WordPress 或 Drupal 的教程，甚至是手工编码的页面。他们将向页面发送一个无头(headless)浏览器，以确定哪些 CSS 对于不同大小的页面加载上是关键，并为你提供代码或将代码拆分为关键和非关键元素，以便可以适当地加载它们，举几个例子： Grunt: https://github.com/filamentgroup/grunt-criticalcss https://www.npmjs.com/package/grunt-critical-css https://github.com/bezoerb/grunt-critical Gulp: https://github.com/addyosmani/critical https://www.npmjs.com/package/gulp-critical-css Webpack: https://github.com/anthonygore/html-critical-webpack-plugin https://github.com/GoogleChromeLabs/critters https://github.com/anthonygore/html-critical-webpack-plugin https://www.npmjs.com/package/critical-css-webpack-plugin React: https://www.npmjs.com/package/react-critical-css https://github.com/addyosmani/critical-path-css-tools https://github.com/sergei-zelinsky/react-critical-css Angular: https://github.com/addyosmani/critical-path-angular-demo Vue: https://github.com/anthonygore/vue-cli-plugin-critical https://vuejsdevelopers.com/2017/07/24/critical-css-webpack/ Drupal: https://www.fourkitchens.com/blog/article/use-gulp-automate-your-critical-path-css/ WordPress: https://joe-watkins.io/javascript/inline-critical-css-with-wordpress/ https://wordpress.org/plugins/wp-criticalcss/ Hand-coded: https://www.sitelocity.com/critical-path-css-generator https://jonassebastianohlsson.com/criticalpathcssgenerator/ 预加载 Preload如果不打算内联关键 CSS，那么下一个最佳选择可以是使用预加载 Preload。预加载在加载早期提早获取请求，比平时更快地获取显示页面所需的基本资源。Preload 将预加载资源在浏览器优先级设置为高并异步加载它们，因此它们不会阻塞渲染，也适用于跨域 “新增内容：Chrome 中对于&lt;link rel=&quot;preload&quot;&gt;、预取(prefetch)及优先级专业提示：https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf” 5.测试性能工具YSlow性能检测插件，以firefox插件的形式 PageSpeed和YSlow类似的，Google的优化工具PageSpeed除了有网站的入口，也能以插件的形式在Firefox和Google上运行，也是基于基础性能优化实践规则分析代码，提供一系列页面优化建议 WebPagetest同样也使用和它们相似的一组最佳性能实践来分析网页，它通过浏览器访问，基于输入的Website URL，以及选择的国家城市、浏览器类型、网络带宽等信息，启动对应的远程服务器上的浏览器进行性能分析测试。（据官网介绍，他们提供的不同城市的性能分析测试，是通过真实的部署在对应城市的物理服务器来实现的，而不是通过其他类似代理或者虚拟机等方式模拟实现的） window.performance可以直接在控制台打印 window.performance，查看诸多的性能指标 EventCount：从网页打开到现在，执行的事件数量 memory：堆内存占用大小 timing：执行各阶段所处的时间戳 DNS查询耗时= domainLookupEnd - domainLookupStart TCP链接耗时= connectEnd - connectStart request请求耗时= responseEnd - responseStart 解析dom树耗时= domComplete - domInteractive 白屏时间= domloadng - fetchStart domready时间= domContentLoadedEventEnd - fetchStart onload时间= loadEventEnd - fetchStart chrome-devtool查看LCP： 在 Chrome 开发者工具中，执行以下步骤： Performance &gt; 勾选 “Screenshots” 点击 左上方一个“黑色圆点” LCP 会显示在时序图上 点击节点； 这是就是 LCP 的元素 查看动画帧数，每当你看到 FPS 上方的红色条，这意味着帧率下降如此之低，它可能会损害用户体验。一般来说，绿条越高，FPS 越高。 查看帧数 除此之外，还提供当前帧数FPS的查看 （点击右上角工具栏，找到More tools中的rendering，勾选上FPS meter） 6.性能指标Core Web Vitals （核心页面指标）是一种速度指标，是 Google 用于衡量用户体验的页面体验信号的一部分 以下是 Core Web Vitals 的三个组成部分及其衡量的内容： 最大内容绘制 (LCP) – 视觉负载 累积布局偏移 (CLS) – 视觉稳定性 首次输入延迟 (FID) – 交互性 性能指标之LCP and FCPLCP最大内容绘制 (LCP)：https://web.dev/lcp/#what-elements-are-considered 查看方法可以使用chrome的performance 优化LCP 越小越快，我们可以选择删除不必要的代码（对于我们自己项目后期维护也比较友好，或者交给打包工具tree shaking下），打包工具的压缩，我们对img的压缩 CDN分发和缓存的使用 资源加载的优先顺序考虑：图片懒加载、css预加载，SSR等 FCP首次内容绘制 (FCP)：https://web.dev/fcp/ 我们可以看到FCP实际上就是空白 -&gt; 骨架屏 -&gt; 第一张图/非空白的canvas/svg/文字的出现的时间点，这时候考验的就不是性能就不能怪图片了，主要考验的是js/css加载速度为了提供良好的用户体验，网站应该努力将首次内容绘制控制在1.8 秒或以内，而我们wapm实验端得到绿色，也就是“令人满意的FCP”应该控制在&lt; 1000（1s)范围内 CLSCLS 测量元素如何移动或页面布局的稳定性。 它考虑了内容的大小和移动的距离 FIDFirst Input Delay 可以理解为用户第一次与网页交互，（例如點擊連結、按鈕等等），瀏覽器實際上能夠回應此次互動的時間點 通常，输入延迟（或输入延迟）发生是因为浏览器的主线程忙于执行其他操作，因此它无法（尚未）响应用户。 可能发生这种情况的一个常见原因是浏览器正忙于解析并执行应用程序加载的大型JavaScript文件 / CSS文件。 虽然它正在这样做，它不能运行任何事件监听器，因为它加载的JavaScript可能会告诉它做其他事情。 较长的首次输入延迟通常发生在首次内容绘制 (FCP)和Time to Interactive 可交互时间 (TTI)之间，因为在此期间，页面已经渲染出部分内容，但交互性还尚不可靠。为了说明这种情况的发生缘由，我们在时间轴中加入了 FCP 和 TTI 您可能已经注意到 FCP 和 TTI 之间有相当长的一段时间（包括三段长任务），如果用户在这段时间内尝试与页面进行交互（例如单击一个链接），那么从浏览器接收到单击直至主线程能够响应之前就会有一段延迟。 因为浏览器正在运行任务的过程中，所以浏览器必须等到任务完成后才能对输入作出响应。浏览器必须等待的这段时间就是这位用户在该页面上体验到的 FID 值 FID重要性：首次输入延迟将会是用户对您网站响应度的第一印象，而第一印象对于塑造我们对网站质量和可靠性的整体印象至关重要。 除了最大的内容绘制(LCP) 和累积布局偏移(CLS)，首次输入延迟是谷歌在 2021 年夏季推出的页面体验更新中强调的三个核心 Web 要素之一。 由于 FID 是仅通过真实用户交互测量的统计数据，因此无法在实验室环境中复制。 然而，总阻塞时间 (TBT) 是一个衡量浏览器被阻塞时间的指标，因此可以近似地估计 FID。这就是为什么您会在 Semrush 的 Core Web Vitals 报告中看到 TBT 而不是 FID 的原因。 改善FID 減少JavaScript等網頁程式碼的運作時間 編排良好的主線程，能有效決定哪些元素率先載入，而避免過大而慢的代碼阻礙其他元素載入。 JavaScript任务会消耗大量的资源，会影响你的网站速度性能。为了解决这个问题，请删除它们或将长的任务分成小的、异步的任务。至少，一个任务应该在50毫秒以下。（长任务是主线程被阻塞超过 50 毫秒的任何任务。 ） 你可以使用setTimeout函数将长任务分成小任务，因为这将使主线程对用户输入的响应没有延迟。 檢查一下有沒有已經失效或不再用的編碼並刪除 減低網頁的請求數和檔案大小 適度壓縮圖像 減少主執行緒的工作 減低第三方程式碼的影響 检查长任务 上图是主线程的样子，Chrome 开发工具中 Performance 页签中的那些红色刻度线表示可能存在问题的地方。 通常在主线程上运行太多时间的任务就会被标记，每一个地方都是超出页面负荷的工作并且无法及时响应用户输入。 来源：https://web.dev/long-tasks-devtools 当任务正在运行时，页面无法响应用户输入，这是感受上的延迟。任务越长，用户经历的延迟就越长。任务与任务之间的中断是个机会，页面必须切换到用户输入的任务并响应他们想要的内容。 我们还可以通过chrome的Lighthouse 启动性能审计（但是建议在每次提交代码的时候审计一次不然等到包太大了，工程项目复杂化，很难看出代码哪里性能开始变差） 生成报告后，您可以向下滚动以深入了解 Lighthouse 的建议，这些建议将标记为机会和诊断。 通过诊断出来的 ‘’Avoid long main-thread tasks “ 找到长任务的发生点 7.红宝书最佳实践避免全局查找 function updateUI() { let imgs = document.getElementsBtTagName(\"img\"); for(let i = 0; i &lt; imgs.length; i++) { imgs[i].title = `${document.title} imge ${i}`; } let msg = document.getElementById(\"msg\"); msg.innerHTML = \"Update complete\"; } 这个地方三次引用了全局document对象，而for甚至要引用成百上千次，每次都要遍历作用域链，我们应该保存对document对象的引用，明显提升该函数的性能 function updateUI() { const doc = document; let imgs = doc.getElementsBtTagName(\"img\"); for(let i = 0; i &lt; imgs.length; i++) { imgs[i].title = `${doc.title} imge ${i}`; } let msg = doc.getElementById(\"msg\"); msg.innerHTML = \"Update complete\"; } 不使用with，他主要用途是减少代码量 function updateBody() { with(document.body) { console.log(tagName); } } 不使用eval 最悲观的情况是，如果出现了eval和with，所有的优化可能是无意义的，因此如果使用它们最简单的做法就是完全不做优化 减少属性查找的迭代次数，属性查找会增加访问对象属性的算法复杂度 下面是错误示范 let query = window.location.href.substring(window.location.href.indexOf(\"?\")) 下面是正确示范 const url = window.location.href; const query = url.substring(url.indexOf(\"?\")); 比之前省了33% 性能提升其他注意事项 原生方法很快，应该尽可能使用原生方法，而不是使用JavaScript写的方法。原生方法是使用C或者C++等编译型语言写的。因此比JavaScript写的方法要快得多。JavaScript经常被忽视的是Math对象上那些执行复杂数学运算的方法。这些方法总是比执行相同任务的JavaScript函数快得多，比如正弦、余弦等 switch语句很快 位操作很快 参考书籍 《大型网站性能优化实战》—周涛明、张荣华、张新兵 《JavaScript高级程序设计》 《你不知道的的JavaScript（上卷）》 提高你的网站速度","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Serverless","slug":"Serverless","date":"2021-10-23T16:00:00.000Z","updated":"2023-03-26T05:38:52.164Z","comments":true,"path":"2021/10/24/serverless/","link":"","permalink":"https://taylor12138.github.io/2021/10/24/serverless/","excerpt":"","text":"ServerlessServerless（无服务计算）是指构建和运行不需要服务器管理的应用程序和概念 无服务器计算是一种按需提供后端服务的方法。无服务器提供程序允许用户编写和部署代码，而不必担心底层基础结构。从无服务器供应商处获得后端服务的公司将根据其计算费用，而不必保留和支付固定数量的带宽或服务器数量，因为该服务是自动扩展的。请注意，尽管称为无服务器，但仍使用物理服务器，但开发人员无需了解它们。 目前行业可能更多处于容器Docker + Kubernetes，利用Iaas、Paas和Saas来快速搭建部署应用 Docker是一个平台，它主要是提供一些服务，任何一台装有docker的机器你都可以建立、发布、运行你的应用程序，使用docker很省钱省时。 简单的介绍Kubernetes。它就是一套成熟的商用服务编排解决方案。Kubernetes定位在Paas层，重点解决了微服务大规模部署时的服务编排问题。 精确定义化实际上，业界对Serverless尚无一致认可的定义，但是我相信大部分开发者在听到 Serverless时，会联想到Lambda，并且冒出“函数”、“按需（调用次数）收费”、“事件驱动”等关键词。确实当年刚刚诞生的Serverless就像下面可爱的“紫薯人”，紫色充满神秘感（当年刚推出的时候绝对是黑科技），让人印象深刻。 在《serverless-架构应用开发指南》的定义是： Serverless 架构是指大量依赖第三方服务（也叫做后端即服务，即“BaaS”）或暂存容器中运行的自定义代码（函数即服务，即“FaaS”）的应用程序，函数是无服务器架构中抽象语言运行时的最小单位。 按 AWS 官方对于 Serverless 的定义： 服务器架构是基于互联网的系统，其中应用开发不使用常规的服务进程。相反，它们仅依赖于第三方服务（例如AWS Lambda服务），客户端逻辑和服务托管远程过程调用的组合。”2 在一个基于 AWS 的 Serverless 应用里，应用的组成是： 网关 API Gateway 来接受和处理成千上万个并发 API 调用，包括流量管理、授权和访问控制、监控等 计算服务 Lambda 来进行代码相关的一切计算工作，诸如授权验证、请求、输出等等 基础设施管理 CloudFormation 来创建和配置 AWS 基础设施部署，诸如所使用的 S3 存储桶的名称等 静态存储 S3 作为前端代码和静态资源存放的地方 数据库 DynamoDB 来存储应用的数据 等等 Serverless 与 FaaS（函数即服务）通常被视为可以互换的术语，但这并不准确。Serverless 是一种抽象层次更高的架构模式，而“FaaS + BaaS”只是 Serverless 这种架构模式的一种实现。 而我自己更多的理解： 为Serverless并不是一定要使用云服务，而是一种依赖于按需依赖第三方服务的架构思想 特点 Serverless 是真正的按需使用，请求到来时才开始运行 开发者只需要专注于业务，按内存和时间算钱即可 降低启动成本（对于大公司而言，这些都是现成的基础设施。可对于新创企业来说，这都是一些启动成本。）、减少运营成本，实现快速上线 存在的问题： 不适合长时间运行应用（可以理解为长期租车的成本肯定比买车贵，但是你就少掉了一部分的维护成本。因此，这个问题实际上是一个值得深入计算的问题。） 完全依赖于第三方，可控性不强（云提供商可能对其组件的交互方式有着严格的限制，从而影响您系统的灵活性和定制能力。采用 BaaS 环境时，开发人员可能要为代码不受其控制的服务负责；并且如果决定要更换提供商，也可能需要升级系统以符合新供应商的规范，而这无疑会增加成本。） 缺乏调试和开发工具 历史2006 年 AWS 推出 EC2（Elastic Compute Cloud），作为第一代 IaaS（Infrastructure as a Service） PaaS（Platform as a Service）是构建在 IaaS 之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可，最早的一代是 Heroku。 历史上第一个 Serverless 平台可以追溯到 2006 年，名为 Zimki（该公司已倒闭），这个平台提供服务端 JavaScript 应用，虽然他们没有使用Serverless 这个名词，但是他们是第一个“按照实际调用付费”的平台。第一个使用 Serverless 名词的是 iron.io。 2006年AWS推出了IaaS的云计算，Google认为云计算不应该是IaaS这样的底层形态，所以在2008年推出了自己的云计算代表产品GAE（PaaS的具体产品） 到后来的PaaS产品比如Cloud Foundry，这类PaaS产品相对更实际一些，底层IaaS还是云厂商提供，上层提供一套应用管理生态，背后的思想还是不希望开发者通过IaaS这么底层的方式去使用云计算，而是从PaaS开始，不过它也不是Serverless化的，你还是要考虑服务器的维护、更新、扩展和容量规划等等。 随着容器技术的成熟，以及Serverless理念的进一步发展，PaaS和Serverless理念也开始融合，典型的产品代表就是阿里云在2019年推出的产品：SAE： 首先，它是一个PaaS，再具体一点说，是一个应用PaaS。这意味着大部分开发者使用起来都会非常自然，因为里面的概念你会非常熟悉，比如应用发布、重启、灰度、环境变量、配置管理等等。 同时，它也是Serverless化的。这意味着你不必再关心服务器，不用再申请机器，维护服务器，装一堆工具，而是按需使用，按分钟计费，结合强大的弹性能力（定时弹性、指标弹性）实现极致成本。 最后，得益于Docker为代表的容器技术的发展，SAE解决了经典PaaS的突出问题（各种限制和强绑定），依托于容器镜像，在上面可以跑任意的语言的应用 Faas and Baas FaaS（Function as a Service， 函数即服务） 意在无须自行管理服务器系统或自己的服务器应用程序，即可直接运行后端代码；它可以取代一些服务处理服务器（可能是物理计算机，但绝对需要运行某种应用程序），这样不仅不需要自行供应服务器，也不需要全时运行应用程序。 实质上就是一些运行函数的平台，比如AWS 的 Lambda、阿里云函数计算和腾讯云云函数等。 按照通俗的角度来说，就是花钱让别人的服务器，提供一个函数，帮你调用，并且将结果返回给你 BaaS（Backend as a Service，后端即服务）是指我们不再编写或管理所有服务端组件，可以使用领域通用的远程组件（而不是进程内的库）来提供服务 实质上是一些后端云服务，比如云数据库、对象存储、消息队列， 使用庞大的云可访问数据库生态系统（例如，Parse，Firebase），身份验证服务（例如，Auth0，AWS Cognito）等。利用 BaaS，可以极大简化我们的应用开发难度。 Serverless 则可以理解为运行在 FaaS 中，使用了 BaaS 的函数。 IaaS，PaaS，SaaS IaaS：基础设施服务，Infrastructure-as-a-service PaaS：平台服务，Platform-as-a-service SaaS：软件服务，Software-as-a-service 这三者的区别被IBM 的软件架构师 Albert Barron 曾经使用披萨作为比喻 设想你是一个餐饮业者，自己生产披萨，但是这样比较麻烦，因此你决定外包一部分工作，采用他人的服务。你有三个方案。 （1）方案一：IaaS IaaS 表示将由提供商通过云为您管理基础架构，包括实际的服务器、网络、虚拟化和存储。用户可通过应用编程接口（API） 或控制面板进行访问，并且基本上是租用基础架构。操作系统、应用和中间件等内容由用户管理，而提供商则提供硬件、网络、硬盘驱动器、存储和服务器，并负责处理中断、维修及硬件问题。 采用IaaS服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件 比喻：他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。 比如阿里云服务器之类的 （2）方案二：PaaS 使用 PaaS 环境的优势包括转移部分职责，如维护服务器、更新基础架构软件以及设置用于构建应用的自定义平台。PaaS 提供商可托管平台，并为正在运行的应用提供环境。 采用PaaS的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序 比喻：除了基础设施，他人还提供披萨饼皮；你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。 比如：网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。目前网上常说的中间件就是一种典型的PaaS服务 （3）方案三：SaaS SaaS 是指由提供商为您管理应用。提供商将负责处理软件更新、漏洞修复及其他常规软件维护工作，而您只用通过 Web 浏览器或 API 连接至软件。这样一来，您就无需在每台计算机上安装应用。 如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可 比喻：他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。 比如：平时使用的苹果手机云服务，网页中的一些云服务等。 从左到右，自己承担的工作量（上图蓝色部分）越来越少，IaaS &gt; PaaS &gt; SaaS。 SaaS：面向普通用户 PaaS：面向开发者 IaaS：面向底层开发者（云服务的最底层） 使用对于新手，可以优先选择了 Serverless 框架，GitHub: https://github.com/serverless/serverless。 npm install -g serverless 然后就是关于AWS用户账号的添加和权限的添加 然后生成访问密钥 ID 和 私有访问密钥。请妥善保存好。 然后导出证书，并使用 serverless depoy 保存到本地。 更多请看：(都是同一个作者) Serverless 应用开发指南：serverless 的 hello, world Serverless 应用开发指南： Node.js 编程返回动态 HTML Serverless 应用开发指南：API Gateway + S3 + AWS Lambda 打造 CRUD Serverless 应用开发指南：Serverless + Express 的 React 服务端渲染 …. Serverless 和前端前端经过了Ajax、Nodejs、React等技术迭代后，已经形成了相对成熟的技术体系，特别是Nodejs，使前端和服务端产生了联系。 前端和后端的分工发挥了各个的优点，但是在协作的过程中也一直存在一个问题，后端同学通常是面向领域和服务提供接口，但是前端是面向用户具体的数据接口，有时候一个简单的需求会因为两边的定义和联调搞半天。所以也诞生了BFF（Backends For Frontends）这样一层，谁使用谁开发，专门解决领域模型 - UI 模型的转换。 理想很美好，现实也很骨干，如果前端同学去做BFF这一层，发现要学习后端的DevOps、高可用、容量规划等等，这些其实是前端同学不想关心的，这种诉求在Serverless时代得到了很好的解决，由BFF变为了SFF（Serverless For Frontend）,让前端同学只要写几个 Function，其他都交给Serverless平台 类似的还有服务端渲染 SSR（Server Side Rendering），本来前后端分工后，后端只需要写接口，前端负责渲染，但是在SEO友好以及快速首屏渲染等需求背景下，有时候会用到服务端渲染的方案，同样，使用Serverless 前端同学又可以愉快的玩耍了。 参考文章： 《serverless-架构应用开发指南》 Serverless 应用开发指南：serverless 的 hello, world IaaS，PaaS，SaaS的区别（阮一峰） 6岁！是时候重新认识下Serverless了 你学BFF和Serverless了吗","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"排序算法","slug":"排序算法","date":"2021-10-16T06:32:38.586Z","updated":"2021-10-16T06:32:38.586Z","comments":true,"path":"2021/10/16/pai-xu-suan-fa/","link":"","permalink":"https://taylor12138.github.io/2021/10/16/pai-xu-suan-fa/","excerpt":"","text":"快速排序设置个关键字，将大的放在它后面，小的放在前面，分成两个子表，并且重复上述过程，直到每一个子表只有一个记录为止 const quickSort = function(arr){ if(arr.length &lt;= 0)return arr; const index = Math.floor(arr.length / 2); const key = arr.splice(index, 1)[0]; const left = []; const right = []; for(let i = 0; i &lt; arr.length; i++){ if(arr[i] &lt; key)left.push(arr[i]); else right.push(arr[i]); } return quickSort(left).concat([key], quickSort(right)); } console.log(quickSort([2, 5, 1, 9, 6, 1, 4])); console.log(['Jan', 'March', 'April', 'June'].splice(1, 1, 'Feb')); 1.不稳定排序 2.多用于顺序结构 3.时间复杂度O(nlog2 n)。 空间复杂度为O(log2 n), 最坏O(n). 最坏情况是逆序，或基本有序（顺序） 直接插入排序这里采用的是从后向前的比较方式，（从前向后其实也可以） 有点像打牌，抽牌，然后选择地方放好 function insertion(array) { checkArray(array); for (let i = 1; i &lt; array.length; i++) { for (let j = i - 1; j >= 0 &amp;&amp; array[j] > array[j + 1]; j--) swap(array, j, j + 1); } return array; } 1.稳定排序 2.适用于顺序表和链表 3.时间复杂度为O(n^2) 空间复杂度为O(1),只需要一个r[0] 优化插入排序变量覆盖 const insertSort = (arr, start = 0, end) => { end = end || arr.length; for(let i = start; i &lt; end; i++) { let e = arr[i]; let j; for(j = i; j > start &amp;&amp; arr[j - 1] > e; j --) arr[j] = arr[j-1]; arr[j] = e; } return; } 折半插入排序其实就是直接插入排序引入了折半的思想 //算法8.2 折半插入排序 #include &lt;iostream> using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表 void BInsertSort(SqList &amp;L){ //对顺序表L做折半插入排序 int i,j,low,high,m; for(i=2;i&lt;=L.length;++i) { L.r[0]=L.r[i]; //将待插入的记录暂存到监视哨中 low=1; high=i-1; //置查找区间初值 while(low&lt;=high) { //在r[low..high]中折半查找插入的位置 m=(low+high)/2; //折半 if(L.r[0].key&lt;L.r[m].key) high=m-1; //插入点在前一子表 else low=m+1; //插入点在后一子表 }//while for(j=i-1;j>=high+1;--j) L.r[j+1]=L.r[j]; //记录后移 L.r[high+1]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //for } //BInsertSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;\"请输入数据个数，不超过\"&lt;&lt;MAXSIZE&lt;&lt;\"个。\"&lt;&lt;endl; cin>>n; //输入个数 cout&lt;&lt;\"请输入待排序的数据：\\n\"; while(n>MAXSIZE) { cout&lt;&lt;\"个数超过上限，不能超过\"&lt;&lt;MAXSIZE&lt;&lt;\"，请重新输入\"&lt;&lt;endl; cin>>n; } for(i=1;i&lt;=n;i++) { cin>>L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); BInsertSort(L); cout&lt;&lt;\"排序后的结果为：\"&lt;&lt;endl; show(L); } 1.稳定排序 2.仅适用于顺序表 3.时间复杂度为O(n^2)，但是平均性能&gt;直接插入。 空间复杂度为O(1),只需要一个r[0] 希尔排序通过分组进行大浮动跳跃性排序，并且分组的形式是以设定的增量为基准 //算法8.3 希尔排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void ShellInsert(SqList &L,int dk) { //对顺序表L做一趟增量是dk的希尔插入排序 int i,j; for(i=dk+1;i","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"牛客personal note","slug":"牛客personal note","date":"2021-09-16T15:28:25.809Z","updated":"2021-09-16T15:28:25.809Z","comments":true,"path":"2021/09/16/niu-ke-personal-note/","link":"","permalink":"https://taylor12138.github.io/2021/09/16/niu-ke-personal-note/","excerpt":"","text":"小基础floor(x) 小于等于x的最大值整数（向下取整） ceil(x) 大于等于x的最小整数（向上取整）( #include&lt;math.h&gt; ) int 32位二进制 第一个是符号位正数为0，负数为1，后面是数值位 -2^31——2^31-1 long long 64位二进制 double 64位二进制 （float别用了，太垃圾了） ~ 取反 &gt;&gt;右移 &lt;&lt;左移 pow(a,b) a的b次方 一维前缀和拥有数组x和数组y，满足： y0=x0; y1=x0+x1; y2=x0+x1+x2; 即想要求某区间和，可用y数组来相减得到结果 枚举一一举例，不重复 先列举出（求第x数到第y数的和，先求数组所有和，直接减），（求四个点的位置，并且四个点组成正方形，先求四个点中的两个点，），（求一排树数量，部份树被整段移走（可能重叠），直接标记1，移走的树部分-1） 取尺法分L，R两个指针，求数组区域&lt;=s的连续数组的个数，&lt;s R右移， &gt;=s L右移 使用前提： 1.能够维护一个区间，保证这个区间能够获得答案。 2.维护的具体操作可以左边移动一位、右边移动一位。 3.区间的变化是连续的而不是跳跃的。问题1就是比较跳跃的，双指针比较好，问题2不能跳跃。 贪心算法局部最优解，然后发现局部最优=整体最优解 桶排序列出数组， 将数组分到有限数量的桶里，将数据对比，有则让数组对应的数据+1，每个桶再个别排序 ，然后依次输出 桶越多，时间效率就越高，而桶越多，空间就越大 这里有位大佬我觉得写得很好，外加动漫配图，可以看一下（简单桶排序） https://www.cnblogs.com/bqwzx/p/11029264.html 计数排序基数排序和计数排序都可以看做桶排序，计数排序的思路是开一个长度为 maxValue-minValue+1 的数组，进行分配+收集: 分配。扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1。 收集。扫描一遍计数器数组，按顺序把值收集起来。 计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序 ， 计数排序非常浪费空间 VECTORvector是一个不限制数组长度的数组 top()返回第一个元素 back()返回最后一个元素 erase（int index,int size）删除 vector a; 迭代器Iterator用于访问问一个容器内的数据的指针 vector:: iterator it; C++ STL的二分查找binary search 返回bool，是否存在 low_bound 返回可插入的最小位置的迭代器，即返回第一个符合条件的元素位置，low_bound(a,a+11,55), a[0]到a[10]找55，返回迭代器，可将结果 -a 得到它的下标 第一个&lt;=x的位置 upper_bound 返回可插入的最大位置的迭代器，即返回最后一个符合条件的元素位置 第一个&gt;x的位置","categories":[{"name":"personal","slug":"personal","permalink":"https://taylor12138.github.io/categories/personal/"}],"tags":[],"author":"Hello"},{"title":"React Fiber","slug":"React Fiber","date":"2021-09-14T16:00:00.000Z","updated":"2021-11-04T09:56:29.925Z","comments":true,"path":"2021/09/15/react-fiber/","link":"","permalink":"https://taylor12138.github.io/2021/09/15/react-fiber/","excerpt":"","text":"React FiberReact Fiber介绍进程（Process）和线程（Thread），在计算机科学中还有一个概念叫做Fiber，英文含义就是“纤维”，意指比Thread更细的线，也就是比线程(Thread)控制得更精密的并发处理机制。 然而虽然Fiber和React Fiber是两个不同的概念，但取名却有异曲同工之妙 而官方解释到：React Fiber是对核心算法的一次重新实现 React 实现了一个虚拟堆栈帧。实际上，这个所谓的虚拟堆栈帧本质上是建立了多个包含节点和指针的链表数据结构。每一个节点就是一个 fiber 基本单元，这个对象存储了一定的组件相关的数据域信息。而指针的指向，则是串联起整个 fibers 树。重新自定义堆栈带来显而易见的优点是，可以将堆栈保留在内存中，在需要执行的时候执行它们，这使得暂停遍历和停止堆栈递归成为可能。 所以我个人偏向理解fiber为一个工作单元（units of work） fiber对象主要属性一览 Fiber = { // 标识 fiber 类型的标签，详情参看下述 WorkTag tag: WorkTag, // 节点的连接 // 指向父节点 return: Fiber | null, // 指向子节点 child: Fiber | null, // 指向兄弟节点 sibling: Fiber | null, // 动态工作单元 // 在开始执行时设置 props 值 pendingProps: any, // 在结束时设置的 props 值 memoizedProps: any, // 当前 state memoizedState: any, // Effect 类型，详情查看以下 effectTag effectTag: SideEffectTag, // effect 节点指针，指向下一个 effect nextEffect: Fiber | null, // effect list 是单向链表，第一个 effect firstEffect: Fiber | null, // effect list 是单向链表，最后一个 effect lastEffect: Fiber | null, // 调度优先级相关 // work 的过期时间，可用于标识一个 work 优先级顺序，在2020年5月，调度优先级策略经历了比较大的重构。以expirationTime属性为代表的优先级模型被lane取代 expirationTime: ExpirationTime, this.lanes = NoLanes; this.childLanes = NoLanes; }; React Fiber出现缘由fiber出现之前的React -&gt; 当组件树很大的时候就会出现这种问题，因为更新过程是同步地一层组件套一层组件，逐渐深入的过程，在更新完所有组件之前不停止，而且很长时间不会返回。 因为JavaScript单线程的特点，每个同步任务不能耗时太长，不然就会让程序不会对其他输入作出相应，React的更新过程就是犯了这个禁忌，而React Fiber就是要改变现状。 比如 JS引擎解析JS代码 -&gt; 样式布局 -&gt; 样式绘制 当JS执行时间过长，超出了16.6ms（主流浏览器1000ms / 60帧），这次刷新就没有时间执行样式布局和样式绘制了。由此在同步工作而过程当中，可能无法绘制完全？！(图片源自卡佬的https://react.iamkasong.com/) 然而解决同步更新整个巨大的DOM的方案，就是分片操作（内心os：让我想起了cpu的时间分片） 把当前任务进行分片，每一个小片按照一定算法执行，这样子线程就不会被独占，让其他任务有可乘之机！ React Fiber把更新过程碎片化（分片数据结构维护的leader），每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。 React16架构React16架构可以分为三层（之前是只有两层，没有 Scheduler）： Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 Fiber包含三层含义： 作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。 作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的DOM节点等信息。 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。 React Fiber的影响先说一下React的渲染过程 Render阶段（1）Reconciliation Phase（Render阶段，低优先级）：React将更新应用于通过setState或render方法触发的组件，并确定需要在用户屏幕上做哪些更新–哪些节点需要插入，更新或删除（利用effectTag来标识，比如） // DOM需要插入到页面中 export const Placement = /* */ 0b00000000000010; // DOM需要更新 export const Update = /* */ 0b00000000000100; // DOM需要插入到页面中并更新 export const PlacementAndUpdate = /* */ 0b00000000000110; // DOM需要删除 export const Deletion = /* */ 0b00000000001000; 哪些组件需要调用其生命周期方法。（找出需要更新哪些DOM）最终的这些更新信息被保存在一个叫effect list的fiber 节点树上，然后在这个阶段创建出workInProgress Fiber Tree。 但是值得注意的是，首屏渲染时期，也就是mount时间段，reconcileChildren中调用的mountChildFibers不会为Fiber节点赋值effectTag，而是在 completeWork阶段当中创建 fiber.stateNode。因为首次渲染的时候毫无疑问整棵fiber树为空，则每个节点都会被赋值上，Placement effectTag，此时每个节点都会执行一次插入操作，效果是极低的，而只有rootFiber会赋值Placement effectTag 在新生命周期图中render阶段被标记为纯的、没有副作用的，可能会被React暂停、终止或者重新执行。也就是说，React会根据产生的任务的优先级，安排任务的调度（schedule）。利用类似requestIdleCallback的原理在浏览器空闲阶段进行更新计算，而不会阻塞动画，事件等的执行。 通俗来说，也就是讲我们想要做的操作，做什么任务，以及会调用到的生命周期方法作为信息保存在 fiber节点树上 并且一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断（比如用户交互的优先级 &gt; 数据请求），这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来。 Commit阶段（2）Commit Phase（Commit阶段，高优先级）：会遍历effect list，把所有更新都commit到DOM树上。在pre-commit阶段，主要是执行getSnapshotBeforeUpdate方法，可以获取当前DOM的快照（snap，详情可以收看新生命周期图中的 getSnapshotBeforeUpdate ），然后给需要卸载的组件执行componentWillUnmount方法。接着会把current fiber tree 替换为workInProgress fiber tree。最后执行DOM的插入、更新和删除（mutation阶段），给更新的组件执行componentDidUpdate，给插入的组件执行componentDidMount。 这一阶段无法终止（一鼓作气，再而衰，三而竭地更新DOM，never打断） 在 commit 阶段，work 执行总是同步的，这是因为在此阶段执行的工作将导致用户可见的更改。这就是为什么在 commit 阶段， React 需要一次性提交并完成这些工作的原因。 进入到commit阶段的时候，会遍历effect list 插入DOM -&gt; fiber节点上增加Placement的effect 更新DOM -&gt; fiber节点上增加Update的effect 删除DOM -&gt; fiber节点上增加Deletion的effect 更新Ref -&gt; fiber节点上增加Ref的effect useEffect回调执行 -&gt; fiber节点上增加Passive的effect 然后在render阶段 -&gt; commit阶段的时候，会传递一条effect链表，里面可能包含了Placement、Passive等 commit阶段处理链表上的每个effect commit阶段有三个小段（全程都在遍历effectList）： 1.beforeMutation阶段 处理DOM节点渲染/删除后的 autoFocus、blur 逻辑。 调用getSnapshotBeforeUpdate生命周期钩子。 调度useEffect。 2.mutation阶段 根据ContentReset effectTag重置文字节点 更新ref 根据effectTag分别进行DOM的处理，增删改DOM，执行useLayoutEffect hook的销毁函数，执行 componentWillUnmount生命周期函数 3.layout阶段 commitLayoutEffectOnFiber（调用生命周期钩子和hook相关操作） componentDidMount、ComponentDidUpdate 执行useLayoutEffect hook的回调 commitAttachRef（赋值 ref） 以上三个在以上三个子阶段都执行完毕后，异步调用我们的useEffect的回调 摘录自React文档effect 的执行时机 (opens new window)： 与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。 可见，useEffect异步执行的原因主要是防止同步执行时阻塞浏览器渲染。 渲染大致this.setState被触发 -&gt; （Render阶段）reconcile算法（diff算法），计算状态变化 -&gt; （Commit阶段）然后进入ReactDOM渲染器，将状态变化渲染在视图中。 这两个阶段可以帮助我们更加认清生命周期函数 调用ReactDOM.render（此时未进入ReactDOM渲染器，是Render阶段），会采用深度优先遍历创建fiber树（也就是虚拟DOM树），并且以深度优先遍历（从父到子，APP -&gt; P1 -&gt; C1 -&gt; C2 -&gt; P2）的形式调用它们的生命周期函数（constructor、render等） 进入Commit阶段后，从子节点回退（从子到父,C1-&gt; C2 -&gt; P1 -&gt; P2 -&gt; APP），执行生命周期函数（ComponentDidMount、CoponentDidUpdate等） 而其中Diff算法帮助我们决定该组件是否重新渲染/ 重新执行生命周期函数 （Vue的生命周期亦是如此。） React渲染后的结构首次渲染之后，React 会生成一个对应于 UI 渲染的 fiber 树，称之为 current 树，也就是刚才我们在render阶段所讲的，我们想要做的操作，做什么任务，以及会调用到的生命周期方法作为信息保存在 fiber节点树上。 当 React 遍历 current 树时，它会为每一个存在的 fiber 节点创建了一个替代节点，这些替代节点形成 workInProgress 树，后续的变更在workInProgress 树上执行，当 workInProgress 树被提交后将会在 commit 阶段的某一子阶段被替换成为 current 树。 每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。 多建一棵树是为了做缓存，保障构建和绘制的流畅性 Effect List React 采用DFS，在 render 阶段遍历 fiber 树时，把每一个有副作用的 fiber 筛选出来，最后构建生成一个只带副作用的 effect list 链表。 为什么有Effect List呢，因为Mount生命周期对应的是HooksDispatcherOnMount，里面有它自己的useState、useEffect；update生命周期对应的是HooksDispatcherOnUpdate，里面也有它自己的useState、useEffect，而其中他们的useEffect形成的链表就形成effect list 这里有从fiber树到Effect List构建过程的视频 https://www.bilibili.com/video/av48384879/ 借用React团队成员Dan Abramov的话：effectList相较于Fiber树，就像圣诞树上挂的那一串彩灯。 分片更新的影响这会导致啥? 一次更新分成多个分片，所以完全有可能一个更新任务还没完成，就被高优先级的任务打断，从而之前的工作作废。 因此如果你使用的是类式组件（带生命周期函数），你会发现：在React Fiber中，不再是这样了，第一阶段中的生命周期函数（render阶段的生命周期函数）在一次加载和更新过程中可能会被多次调用！ React Diff正常的完全对比算法是O(n^3) React对diff的三个限制（优化）： 只对比同层级节点 元素类型改变之后，将本身及其子孙一同销毁 通过key、prop保持diff的稳定性 看完之后感觉和Vue的差不多，但是由于fiber是单链表，所以好像不能和Vue一样使用双指针的优化方案 参考链接： https://zhuanlan.zhihu.com/p/26027085 https://zhuanlan.zhihu.com/p/179934120 https://react.iamkasong.com/","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JS内置对象和包装","slug":"JS内置对象和包装","date":"2021-08-31T16:00:00.000Z","updated":"2023-04-17T06:54:51.394Z","comments":true,"path":"2021/09/01/js-nei-zhi-dui-xiang-he-bao-zhuang/","link":"","permalink":"https://taylor12138.github.io/2021/09/01/js-nei-zhi-dui-xiang-he-bao-zhuang/","excerpt":"","text":"1.内置对象JavaScript中对象分为自定义对象，内置对象，浏览器对象，前两种属于ECMAScript；第三个浏览器对象是js特有的 Javascript提供了多个和内置对象：Math、Date、Array、String 可以通过MDN/W3C来查询内置对象的使用 MDN的网址：https://developer.mozilla.org/zh-CN/ （1）Math对象 方法 参数 效果 Math.abs(x) 一个数值 得到绝对值，并且会隐式转换比如’-1’ -&gt; 1, ‘pink -&gt; NAN’ Math.PI 圆周率 Math.floor(x) 一个数值 向下取整 Math.ceil(x) 一个数值 向上取整 Math.round(x) 一个数值 四舍五入 Math.max(value1[,value2, ...]) 一组数值 最大值, x为0或多个值。在 ECMASCript v3 之前，该方法只有两个参数。 Math.min(value1[,value2, ...) 一组数值 最小值，同上 Math.random() 返回一个浮点数, 伪随机数在范围从0到小于1 Math.sqrt(x) 一个数值 返回一个数的平方根 Math.pow(x, y) 两个数值 返回基数（x）的指数（y）次幂 //实现两个数之间的随机整数 Math.floor(Math.random()*(x_max-x_min+1))+x_min 函数 toFixed(n) 将数字舍入（四舍五入）到小数点后 n 位，并以字符串形式返回结果。如果后续还想再用该数字，记得转回number let num = 12.34; alert( num.toFixed(1) ); // \"12.3\" （2）Date对象是一个构造函数，可以使用new调用（但也可以直接调用其方法） 方法 效果 new Date() 返回一个标准时间（复杂的字符串结构） Date.now() 返回一个number，自 1970 年 1 月 1 日 00:00:00 (UTC) 到当前时间的毫秒数，H5新增 new Date(xx).getFullYear() 返回年份 new Date(xx).getMonth()+1 返回月份 new Date(xx).getDate() 返回日期 new Date(xx).getHours() 返回时 new Date(xx).getMinutes() 返回分 new Date(xx).getSeconds() 返回秒 new Date(xx).valueOf() 返回从1970年1月1日0时0分0秒（UTC，即协调世界时）到该日期的毫秒数。 new Date(xx).getTime() 同上 var date = new Date(); //无参数，返回当前系统的时间,复杂的字符串结构 //常用的两种时间写法 var date = new Date(2020, 10, 1); //指定固定日期 var date = new Date('2020-10-1 8:8:8'); var d=new Date().toLocaleTimeString() //本地时间把 Date 对象的时间部分转换为字符串 由于开发中时间戳转换为日期太过于常见，所以网上有直接封装好的（使用的是正则表达式）的函数，直接格式化即可 日期类转换到原始值能使用 toString() 注意：const date = new Date(&#39;2020-10-1 8:8:8&#39;);这种写法，会导致安卓端和ios端的时间上有所不同，并且有明显的差异！！最好以 const birthday = new Date(1995, 11, 17, 3, 24, 0);的形式进行命名 const date = new Date(&#39;2020/10/1 8:8:8&#39;);也可以，但是兼容性好象不如逗号分隔的形式 深究 1.该问题从表面上看，是Chrome浏览器和Safari对同一JavaScript代码片段解析不同造成 2.发现经过调查发现， iOS 上使用短横杠分割日期时，JS 引擎会自动以 ISO 8601 日期时间表示方法去解析这个字符串，但因为 ISO 8601 的标准格式为 YYYY-MM-DDTHH:mm:ss.sssZ（参考 ECMAScript Language Specification)，所以就导致了解析失败的情况出现。 3.对于 iOS 下的前端项目，无论是普通的网页项目还是小程序项目，都要小心处理 Date 字符串，它们使用 iOS 的 webkit 内核，所有都存在同样的兼容性问题。 平时我们看到的的是RFC2822 格式 ECMAScript基于ISO 8601 的标准格式为 YYYY-MM-DDTHH:mm:ss.sssZ 所以我们硬要写“-”，应该写为（北京时区是GMT+08:00，也就是本初子午线 + 8小时） new Date(&#39;2021-08-26T12:00:00+08:00&#39;) 官方推荐：因此最好还是手动解析日期字符串（在需要适应不同格式时库能起到很大帮助）。* 推荐的一个时间库：http://momentjs.cn/docs/ （3）Array对象填充数组 数组的每个槽位可以储存任意类型数据 var arr1 = new Array(2,3); //相当于[2,3]的数组 var arr = new Array(5).fill(); //创造一个数组长度为5的数组，但是此方法会自动往里面填undefined值，让数组最起码有值了！ var arr = new Array(5).fill(0);//也可以填写你想要的值，比如0 但是如果想创建一个用空对象填充的数组话，实际上我们在使用同一个 空对象 / 空数组进行提埃填充，这样会造成他们都是联动的，牵一发而动全身 let a = new Array(5).fill({}); console.log(a); // [{}, {}, {}, {}, {}] a[0].name = '张三'; console.log(a); // [{name: \"张三\"}, {name: \"张三\"}, {name: \"张三\"}, {name: \"张三\"}, {name: \"张三\"}] 但是可以使用这个方法创建二维数组（接收一个函数，用来对每个元素进行处理，将处理后的值放入返回的数组） const arr = Array.from(Array(n), () => Array(m).fill(0)); const arr2 = new Array(n).fill(0).map(() => new Array(m).fill(0)); //from的使用 console.log(Array.from('foo')); // expected output: Array [\"f\", \"o\", \"o\"] console.log(Array.from([1, 2, 3], x => x + x)); // expected output: Array [2, 4, 6] 删除 / 连接数组 arr.splice(2,1,\"William\"); //从index序号为2地开始，删除掉一个，并添加william元素 arr.concat(arrayX, arrayX, arryX) //concat()参数可以传入数组或者值。 // 它可以连接两个或多个数组 排序arr1.sort(function(a,b) { return a-b; //从小到大 }); //该排序可能是快排等结合的很优算法。升序 如果不加function则为按照字符串排序 arr.sort([compareFunction])，回影响到原来的数组 compareFunction 可选 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 firstEl 第一个用于比较的元素。 secondEl 第二个用于比较的元素。 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 V8排序策略排序策略大概是： 设要排序的元素个数是n： 当 n &lt;= 10 时，采用优化的插入排序 当 n &gt; 10 时，采用 三路快速排序 10 &lt; n &lt;= 1000, 采用中位数作为哨兵元素 n &gt; 1000, 每隔 200~215 个元素挑出一个元素，放到一个新数组，然后对它排序，找到中间位置的数，以此作为中位数 其他 方法 参数 效果 arr instanceof Array 检验是否为数组，是返回true，否则false Array.isArray(x); 数组 同上,H5新增,但这个效果好，防止多个不同版本的Array构造函数 arr.push(xx); n个元素 在数组末尾增加数组元素，返回结果是新数组的长度 arr.unshift(xx); n个元素 在数组开头增加数组元素，返回结果是新数组的长度 arr.pop(); 删除数组的最后一个元素 返回值为被删除的元素值 arr.shift(); 删除数组的第一个元素 返回值为被删除的元素值 arr.reverse() 翻转数组，返回颠倒后的数组，该方法会改变原数组。 arr.indexOf(xx) 1.查找的元素；2.查找开始处（可选） 返回该数组元素的索引号（第一个满足条件的索引号），找不到返回-1。 arr.includes(xx) 1.查找的元素；2.查找开始处（可选） 返回布尔值是否含有该元素，判断元素是否存在 arr.lastindexOf(xx) 1.查找的元素；2.查找开始处（可选，从此位置开始逆向查找） 返回该数组元素的索引号（最后一个满足条件的索引号），从后往前找，找不到返回-1。 arr.toString() 转换成字符串，逗号分隔 arr.join(x); 分隔符 用指定分隔符分割不同的数组元素，并转换成字符串 arr.splice(i, n, [x3, x4]) 1.开始下标；2.删除的元素个数；3.添加进数组的元素（可选，可以多个，添加的第一个为开始下标） 用于删除多组元素并且添加新元素，返回一个数组保存内容（此方法会改变原数组。） arr.slice([begin[, end]]) 1.提取起始处的索引，2.终止索引（不包含end） 返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（从 begin到 end-1 ，不包括end）；可以传入负数，这是从结尾开始截取。原始数组不会被改变。 arr.concat(value1[, value2[, ...[, valueN]]]) 可传入1个/多个数组或者值 用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 arr.from(.from(arrayLike[, mapFn[, thisArg]])); 想要转换成数组的伪数组对象或可迭代对象。 从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。 arr.flat() 直接扁平化多维数组 -&gt; 一维数组 arr.find(callback[,thisArg]) callback为每一项执行的函数，可以类比到forEach的callback，函数中返回true则返回该element 返回数组中满足条件的第一个元素的值，如果没有，返回undefined arr.findIndex() 同上 同上，找的是索引值 2.Object部分方法Object.createObject.create(proto[, propertiesObject]) proto必填参数，是新对象的原型对象。注意，如果这个参数是null，那新对象就彻彻底底是个空对象，没有继承Object.prototype上的任何属性和方法，如hasOwnProperty()、toString()等。 propertiesObject提供一系列附加功能，指明每个属性对应的特性 const person = { isHuman: false, printIntroduction: function () { console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`); } }; const me = Object.create(person); // me.__proto__ === person me.name = \"Matthew\"; // name属性被设置在新对象me上，而不是现有对象person上 me.isHuman = true; // 继承的属性可以被重写 me.printIntroduction(); // My name is Matthew. Am I human? true 使用 Object.create()实现完美继承机制 // 子类续承父类 Rectangle.prototype = Object.create(Shape.prototype); Rectangle.prototype.constructor = Rectangle; 手写Object.create() Object.mycreate = function(proto, properties) { function F() {}; F.prototype = proto; if(properties) { Object.defineProperties(F, properties); } return new F(); } /*其实也可以简化成 Object.mycreate = function(proto, properties) { function F() {}; F.prototype = proto; F.prototype.constructor = F; return new F(); } */ var hh = Object.mycreate({a: 11}, {mm: {value: 10}}); console.dir(hh); Object.keys(obj)Object.keys(obj) 参数 obj 要返回其枚举自身属性的对象。 返回值 一个表示给定对象的所有可枚举属性的字符串数组。 如果你想获取一个对象的所有属性,，甚至包括不可枚举的，请查看Object.getOwnPropertyNames。（红宝书） Object.is()Object.is()确定两个值是否相同。如果以下条件之一成立，则两个值相同： 两者 undefined 两者 null 两者true或两者false 相同长度的两个字符串以相同的顺序具有相同的字符 两者都是同一个对象（意味着两个值都引用了内存中的同一个对象） 数字和 两者 +0 两者 -0 两者 NaN 或两者都非零且两者都不是NaN且两者都具有相同的值 这是不一样根据等于 ==运算符。该 ==运营商应用各种强制转换双方（如果它们不是同一类型）测试相等（导致这种行为像以前一样 &quot;&quot; == false是true），但Object.is不强迫任何一个值。 这也不同于根据===运营商的平等 。Object.is()和之间的唯一区别在于===它们对带符号零和 NaN 的处理。例如，=== 运算符（和==运算符）将数值-0 和+0视为相等。此外，===运算符将 Number.NaN和NaN视为不相等。 console.log(Object.is(true, 1)); //false console.log(Object.is({}, {})); //false console.log(Object.is(\"2\", 2)); //false console.log(Object.is(+0, -0)); //false console.log(Object.is(+0, 0)); //false console.log(Object.is(-0, 0)); //false console.log(Object.is(NaN, NaN)); //true Object.assgin()Object.assign() 方法用于将所有可枚举属性的值从一个 或. 多个. 源对象分配到目标对象。它将返回目标对象。 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象(浅拷贝) const target = { a: 1, b: 2 }; const source = { b: 4, c: 5 }; const source2 = { d: 4, e: 5 }; const returnedTarget = Object.assign(target, source); console.log(target); // expected output: Object { a: 1, b: 4, c: 5 } console.log(returnedTarget); // expected output: Object { a: 1, b: 4, c: 5 } console.log(source); // expected output: Object { b: 4, c: 5 } console.log(Object.assign({}, source, source2, target)) //{ b: 4, c: 5, d: 4, e: 5, a: 1 } 对象和数组的属性名在对象中，属性名永远是字符串，如果你使用字符串以外的其他值作为属性名，它首先会被转化为一个字符串，即使是数字也不例外。虽然数组下标中使用的确实是数字，但是在对象属性命中数字会被转化为字符串，所以不要搞混对象和数组中数字的用法。 const obj = {}; obj[true] = \"foo\"; obj[3] = \"bar\"; obj[obj] = \"baz\"; console.log(obj[\"true\"]); //foo console.log(obj[\"3\"]); //bar console.log(obj[\"[object Object]\"]); //baz 对象属性存在性访问对象属性： const obj = { a: 2, }; console.log(\"a\" in obj); console.log(\"b\" in obj); console.log(obj.hasOwnProperty(\"a\")); console.log(obj.hasOwnProperty(\"b\")); in 操作符 会检查属性是否在对象 or 其 [[Prototype]] 原型链中，并且它可以在 for in循环中使用，也可以单独使用 hasOwnProperty 只会检查是否在对象中 3.String基本数据类型是没有属性和方法的，而对象才有属性和方法 var str = 'andy'; 但是str可以使用str.length,因为jshui把基本数据类型包装成复杂数据类型 var temp = new String('andy'); str = temp; temp = null; 字符串拼接 因为字符串不可变，所以每次str += i ，拼接字符串会开辟另外一个内存空间，字符串赋值同理 String方法 方法 参数 效果 str.indexOf(searchValue [, fromIndex]) 1.要被查找的字符串值；2.查找开始处（可选） 返回调用它的 String 对象中第一次出现的指定值的索引，从 fromIndex 处进行搜索。如果未找到该值，则返回 -1。 str.lastIndexOf(searchValue[, fromIndex]) 同上 返回调用String 对象的指定值最后一次出现的索引，在一个字符串中的指定位置 fromIndex处从后向前搜索。如果没找到这个特定值则返回-1 str.charAt(index) 索引值 charAt() 方法从一个字符串中返回指定的字符。 str.charCodeAt(index) 索引值 返回表示给定索引处的 UTF-16 代码单元（ASCII码） str[index] 同str.charAt，H5新增 `str.replace(regexp substr, newSubStr)` 1.一个正则值或者一个字符串 2.用于替换掉第一个参数在原字符串中的匹配部分的字符串 str.includes(searchString[, position]) 1.搜索的字符串 2.可选，从当前字符串的哪个索引位置开始搜寻子字符串 用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。 str.trim() 方法会从一个字符串的两端删除空白字符，它并不影响本身的字符串，它返回的是一个新的字符串 str.startsWith(xx) 要被查找的字符串值 用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 true 或 false。 str.endsWith() 同上 表示参数字符串是否以原字符串结尾，返回布尔值 str.repeat() 重复次数 将原字符串重复n次，返回一个新字符串 str.match(regexp) 一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 如果使用 g 标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。 如果未使用 g 标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。在这种情况下，返回的项目将具有如下所述的其他属性。 截取字符串（和concat一样，他们不会影响原来的字符串，只会返回提取到的原始新字符串值） 这三个方法在面对负值参数时又有三个不同的效果 str.substr(start,length); //start位置开始，length取的个数，省略length则默认取到最后 str.slice(start,end); //start开始，截取到end，但是end截取不到，省略end则默认取到最后 str.substring(start,end); //start开始，截取到end，end可以截取到,省略end则默认取到最后 arr.slice(start,end); //数组也有slice方法 数组对象转字符用join()，字符转数组用split var str = 'red, pink, blue'; console.log(str.spilt(',')); //用逗号分隔 var arr = [1, 2, 3]; console.log(arr.join(' ')); //用' '分隔 str.toUpperCase() 转换大写， str.toLowerCase() 转换小写 ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 4.内置对象和基本数据类型先看一看内置对象和基本数据类型的区别 var strPrimitive = \"I am string\";//一个字面量 typeof strPrimitive; // string strPrimitive instanceof String; // false var strObject = new String(\"I am string\");//一个String对象 typeof strPrimitive; // object strPrimitive instanceof String; // true 不过值得注意的是，一般我们说的转换只包含字符串和数值上（string and String，number and Number） null 和 undefined没有对应的构造形式，它们只有文字形式；相反，Date只有构造，没有文字形式。 对于Object、Array、Function、RegExp来说，无论是文字形式还是构造形式，他们都是对象，而不是字面量 而Error对象一般在抛出异常自动创建，也可以通过new的方式创建，一般都用不着 5.拆箱复杂 -&gt; 简单 复杂数据类型转简单数据类型，也就是和装箱相反的操作 调用 x.valueOf()，如果转换为基础类型，就返回转换的值 JavaScript调用valueOf方法将对象转换为原始值。你很少需要自己调用valueOf方法；当遇到要预期的原始值的对象时，JavaScript会自动调用它。 调用 x.toString()，如果转换为基础类型，就返回转换的值 toString() 方法返回一个表示该对象的字符串。 toString 、 valueOf 方法都是存在于Object.prototype 对象上 Symbol.toPrimitive Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。 入参：该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 &quot;number&quot;、&quot;string&quot; 和 &quot;default&quot; 中的任意一个。 const object1 = { [Symbol.toPrimitive](hint) { if (hint === 'number') { return 42; } return null; } }; 重写 Symbol.toPrimitive ，该方法在对象转原始类型时调用优先级最高。 let a = { valueOf() { return 0 }, toString() { return '1' }, [Symbol.toPrimitive]() { return 2 } } 1 + a // => 3 6.装箱其实也就是 简单数据类型 -&gt; 复杂数据类型（对应的引用类型的操作） 其中装箱又分为隐式装箱和显式装箱 隐式装箱const s1 = 'str'; const s2 = s1.substring(2); 实际上会创建一个String类型的实例，然后调用String原型的方法，调用方法后会被立即销毁 const s1 = new String('str'); const s2 = s1.substring(2); s1 = null; 因为它会在立即销毁，这也就解释了为啥仍然不能再基本数据类型上添加属性和方法 const s1 = 'str'; s1.job = 'engineer'; console.log(s1.job); // undefined 显式装箱别问，问就是直接装！ const name = new String('str'); // 直接new一个String的实例对象 此时可以直接添加属性和方法 var objStr = new String('str'); objStr.job = 'engineer'; console.log(objStr.job); // engineer 6.image图片加载 const image = new Image() image.onload = () => { console.log('加载完毕') } image.src = './texutre/img.png' 监听图片加载完成方法 const loadImage = (url) => new Promise((resolve, reject) => { const image = new Image(); image.crossOrigin = 'Anonymous'; image.src = url; image.onload = () => resolve(image); image.onerror = reject; });","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"CSS炫酷动画","slug":"CSS炫酷动画","date":"2021-08-30T16:00:00.000Z","updated":"2022-05-10T15:35:54.324Z","comments":true,"path":"2021/08/31/css-xuan-ku-dong-hua/","link":"","permalink":"https://taylor12138.github.io/2021/08/31/css-xuan-ku-dong-hua/","excerpt":"","text":"CSS瀑布流瀑布流优点：艺术性强，观赏性高 缺点：目的性差 方法一multi-column布局先了解以下几个属性 column-count: 设置共有几列 （把当前Block、containers、except、table、wrapper、boxes分成列拜访） column-width: 设置每列宽度，列数由总宽度与每列宽度计算得出 column-gap: 设置列与列之间的间距 demo样式： .container { column-count: 2; column-gap: 10px; padding: 10px; .item { //... img { //... } } } 缺点： multi-column布局（也就是上方的布局方法）会将其内的元素自动进行流动和平衡，尽可能保证每列的高度趋于相同，所以会将其内的文本阶段分布在两列内。 因此可能导致文本内容被切断 但是可以使用 break-inside中断这种平衡，保持每个元素的独立性 .container { column-count: 2; column-gap: 10px; padding: 10px; .item { break-inside: avoid; img { //... } } } 但还有缺点： 这种方式仅适用于数据固定不变的情况，对于滚动加载更多等可动态添加数据的情况就并不适用了。 方法二Grid布局首先要明确的grid布局中的一些属性 主要设置在父元素 display:设置为grid指明当前容器为Grid布局 grid-template-columns: 定义每一列的列宽 grid-template-rows: 定义每一行的行高 column-gap：用于设置列间距 grid-auto-rows：用来设置多余网格的行高 主要设置在子元素 grid-row-start：上边框所在的水平网格线 grid-row-end：下边框所在的水平网格线 grid-column-start：左边框所在的垂直网格线 grid-column-end：右边框所在的垂直网格线 以上四个属性的属性值为 auto | 网格线的自定义名称 | 网格线的索引值（从1开始） | span + 数字，表示边框跨域多少网格 由此，我们只需要不设置行高(grid-template-rows)，此时设置grid-auto-rows后，所有单元格的高度均为grid-auto-rows指定的值。将grid-auto-rows设置一个很小的值，比如10px，然后对其进行拉伸将其高度指定为真实高度，每一个单元格都做如下操作，那么瀑布流就实现了~ .container { display: grid; grid-template-columns: 1fr 1fr 1fr; // 分为3列 column-gap:5px; // 列间距5px grid-auto-rows: 10px; .item{ grid-row-start: auto; } } 方法三Flex布局使用flex，将容器分成固定数量等列，每列在添加flex布局，修改其 flex-direction即可实现 参考链接https://juejin.cn/post/6844904004720263176 CSS炫酷按钮&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;title>帅气的流光灯，想学吗？&lt;/title> &lt;style> *{ margin: 0; padding: 0; } body{background-color:#000;} .w{ width: 400px; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-100%); } p{ color: #fff; text-align: center; font-size: 40px; font-weight: bolder; } span{ color: #fff; text-align: center; display: block; } a{ text-decoration: none; position: absolute; /* left:50%; top:50%; transform: translate(-50%,-50%); */ font-size:24px; width: 400px; height: 100px; line-height: 100px; text-align: center; color: #fff; background: linear-gradient(90deg,#9370DB,#AFEEEE,#FFA500,#9370DB); /* background:linear-gradient(90deg,#03a9f4,#f441a5,#ffeb3b,#03a9f4); */ border-radius:50px; text-transform: uppercase; background-size: 400%; z-index: 1; } a::before{ content: \"\"; position: absolute; left:-5px; top: -5px; right: -5px; bottom: -5px; background: linear-gradient(90deg,#9370DB,#AFEEEE,#FFA500,#9370DB); /* background:linear-gradient(90deg,#03a9f4,#f441a5,#ffeb3b,#03a9f4); */ background-size:400%; border-radius:50px; filter: blur(20px); z-index: -1; } a:hover{ animation: sun 7s infinite; } a:hover::before{ animation: sun 7s infinite; } @keyframes sun { 100%{ background-position: -400% 0; } } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"w\"> &lt;p>流光灯&lt;/p> &lt;span>鼠标停在上面会动~想学吗&lt;/span> &lt;a href=\"javascript:;\">sunbutton&lt;/a> &lt;/div> &lt;/body> &lt;/html> 原文链接：https://blog.csdn.net/rainbow0518/article/details/106017086 CSS赛博朋克&lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>CSS实现赛博朋克风格按钮&lt;/title> &lt;/head> &lt;style> button, button::after { width: 300px; height: 86px; font-size: 40px; background: linear-gradient(45deg, transparent 5%, #FF013C 5%); border: 0; color: #fff; letter-spacing: 3px; line-height: 88px; box-shadow: 6px 0px 0px #00E6F6; outline: transparent; position: relative; } button::after { --slice-0: inset(50% 50% 50% 50%);//设置六个分片 --slice-1: inset(80% -6px 0 0); --slice-2: inset(50% -6px 30% 0); --slice-3: inset(10% -6px 85% 0); --slice-4: inset(40% -6px 43% 0); --slice-5: inset(80% -6px 5% 0); content: '立即加入'; display: block; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(45deg, transparent 3%, #00E6F6 3%, #00E6F6 5%, #FF013C 5%); text-shadow: -3px -3px 0px #F8F005, 3px 3px 0px #00E6F6; clip-path: var(--slice-0); } button:hover::after { animation: 1s glitch;//设置延时1秒，定义glitch变量在在里面设置动画 animation-timing-function: steps(2, end); } @keyframes glitch { 0% { clip-path: var(--slice-1); transform: translate(-20px, -10px); } 10% { clip-path: var(--slice-3); transform: translate(10px, 10px); } 20% { clip-path: var(--slice-1); transform: translate(-10px, 10px); } 30% { clip-path: var(--slice-3); transform: translate(0px, 5px); } 40% { clip-path: var(--slice-2); transform: translate(-5px, 0px); } 50% { clip-path: var(--slice-3); transform: translate(5px, 0px); } 60% { clip-path: var(--slice-4); transform: translate(5px, 10px); } 70% { clip-path: var(--slice-2); transform: translate(-10px, 10px); } 80% { clip-path: var(--slice-5); transform: translate(20px, -10px); } 90% { clip-path: var(--slice-1); transform: translate(-10px, 0px); } 100% { clip-path: var(--slice-1); transform: translate(0); } } &lt;/style> &lt;body> &lt;button>立即加入&lt;/button> &lt;/body> &lt;/html> 原文：https://blog.csdn.net/TBDBTUO/article/details/118070710 亦或者参考这个https://github.com/zxuqian/html-css-examples/tree/master/27-glitch-effect CSS数字滚动组件实质上更多的是js逻辑，css只是使用了transform: translateY https://juejin.cn/post/6995086139484799006","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Chrome的探索","slug":"Chrome的探索","date":"2021-08-21T16:00:00.000Z","updated":"2022-09-13T02:50:44.789Z","comments":true,"path":"2021/08/22/chrome-de-tan-suo/","link":"","permalink":"https://taylor12138.github.io/2021/08/22/chrome-de-tan-suo/","excerpt":"","text":"浏览器结构 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 呈现引擎：用于CSS格式化HTML内容和图片 Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。 Chrome渲染流程多进程一般一个应用对应 -&gt; 一个进程 开发一个浏览器，它可以是单进程多线程的应用，也可以是使用 IPC 通信的多进程应用。 Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程 chrome多进程的优点 某一渲染进程出问题不会影响其他进程 更为安全，在系统层面上限定了不同进程的权限 缺点：由于不同进程间的内存不共享，不同进程的内存常常需要包含相同的内容。（意思就是内存占用大呗） 如果 Chrome 运行在强大的硬件上，它会分割不同的服务到不同的进程，这样 Chrome 整体的运行会更加稳定，但是如果 Chrome 运行在资源贫瘠的设备上，这些服务又会合并到同一个进程中运行，这样可以节省内存 Site IsolationSite Isolation 机制允许在同一个 Tab 下的跨站 iframe 使用单独的进程来渲染，这样会更为安全。（相当于网页中内嵌iframe，使得进程之间保持独立性） chrome导航tab以外的工作也都是由Browser Process控制，而它对于导航栏，用不同的线程进行处理（这些线程包含在Browser Process中） UI thread ： 控制浏览器上的按钮及输入框； network thread: 处理网络请求，从网上获取数据； storage thread: 控制文件等的访问 导航栏输入关键字之后： UI thread 判断输入 -&gt; network thread 获取请求，执行DNS查询，建立TLS连接 -&gt; 根据相应的格式进行处理 -&gt; 触发Safe Browsing， 如果当前匹配到的是恶意站点，则会发出警告 -&gt; 一切准备就绪，network thread：我们数据ok了，UI thread：收到，然后UI thread找到一个render process进行网页渲染（所有的 JS 代码其实都由 renderer Process 控制的） -&gt; Browser Process 收到 renderer process 的渲染确认消息，页面加载开始，history tab 进行更新 渲染工作在Render Process中，包含以下线程 主线程 Main thread 工作线程 Worker thread 排版线程 Compositor thread 光栅线程 Raster thread 渲染过程： 主线程main thread构建DOM -&gt; 若期间存在 &lt;img&gt; &lt;link&gt; 等标签，则传递给Browser Process 的network thread进行下载 -&gt; 碰到&lt;script&gt; 标签会阻塞，除非带有defer或者async -&gt; 形成CSSOM树和DOM树再合成render树，计算布局、样式，也就是我们常见的layout和paint，最后合成帧，其中如果添加了 will-change CSS 属性的元素，会被看做单独的一层，（类似于CSS的缓存效果） chrome对事件的优化一般我们屏幕的刷新速率为 60fps，但是某些事件的触发量会不止这个值，出于优化的目的，Chrome 会合并连续的事件(如 wheel, mousewheel, mousemove, pointermove, touchmove )，并延迟到下一帧渲染时候执行 。 不过值得一提的是，那些非连续性的事件，也就是click之类的（毕竟你也点不了那么快），则会立即被触发 AMPAMP（加速移动页面）是一个由Google与Twitter合作开发的开源框架，它提供了一种直接的方式来创建轻量级的网页，以便用户即时使用，获得了极大改善的体验：内容更快，更具吸引力，更易于阅读。 AMP页面的3个核心组件AMP HTML：一个比常规HTML更精简的HTML版本，对可以使用的HTML标签有严格的规范 AMP JS：为了确保移动平台上的快速页面加载，AMP限制使用任何Javascript，唯一的例外是AMP脚本 AMP CDN：通常称为AMP缓存，AMP平台的一个关键组件是其基于代理的内容分发网络（CDN），可提供加速移动页面。 AMP的优缺点优点： 1、内容的加载速度非常快，用很好的移动体验感，提高了参与度和转化率。 2、通过移动搜索结果，可以在AMP轮播中突出显示内容。 3、减少服务器上的负载，因为AMP CDN缓存并响应大多数搜索结果。 缺点： 1、JavaScript有限制，用户无法自己创建，所以它可能很难编码。 2、没有集成插件，一些效果很难在页面中实现。 3、简化了HTML，css有限制，不能很好的自定义网站样式，大多是Google的默认格式。 参考链接https://zhuanlan.zhihu.com/p/47407398 参考链接https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work 参考链接https://zhuanlan.zhihu.com/p/139506473","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React-native(other)","slug":"React-native(other)","date":"2021-06-24T16:00:00.000Z","updated":"2022-08-10T12:45:05.319Z","comments":true,"path":"2021/06/25/react-native-other/","link":"","permalink":"https://taylor12138.github.io/2021/06/25/react-native-other/","excerpt":"","text":"4.移动端服务器部署&amp;注意事项安卓访问本地服务器地址为 10.0.2.2:端口号，我们平时浏览器访问服务器都是 localhost:端口号 关于React Native的调试1.使用谷歌浏览器来调试 使用谷歌浏览器即可 不能查看标签结构 不能查看网络请求 2.使用rn推荐的工具 react-native-debugger来调试 (老师推荐使用这种方式) 可以查看标签结构 不能查看网络请求 3.想要查看网络请求 找到项目的入口文件 index.js 加入以下代码即可 GLOBAL.XMLHttpRequest = GLOBAL.originalXMLHttpRequest || GLOBAL.XMLHttpRequest 移动端路由导航、导航栏可以用以下的react-navigation框架 react-native从开源至今，一直存在几个无法解决的毛病，偶尔就会复发让人隐隐作痛，提醒你用的不是原生，其中包括列表的复用问题，导航跳转不流畅的问题等等。 终于facebook坐不住了，在前一段时间开始推荐使用react-navigation，并且在0.44发布的时将之前一直存在的Navigator废弃了。 react-navigation是致力于解决导航卡顿，数据传递，Tabbar和navigator布局，支持redux。虽然现在功能还不完善，但基本是可以在项目中推荐使用的。 import { createAppContainer } from 'react-navigation'; import { createStackNavigator } from 'react-navigation-stack' React navigation的部分使用规范 页面跳转和转场动画 安装（在项目中使用） yarn add @react-navigation/native yarn add react-native-screens react-native-safe-area-context 如果您在 Mac 上为 iOS 开发，则需要安装 pod（通过Cocoapods）以完成链接。 npx pod-install ios react-native-screens包需要一个额外的配置步骤才能在 Android 设备上正常工作。编辑MainActivity.java位于android/app/src/main/java/&lt;your package name&gt;/MainActivity.java. 将以下代码添加到MainActivity类的主体中： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(null); } 并确保在此文件顶部添加导入语句： import android.os.Bundle; 安装 native stack、navigator library yarn add @react-navigation/native-stack 代码 import * as React from 'react'; import { Button, View, Text } from 'react-native'; import { NavigationContainer } from '@react-navigation/native'; import { createStackNavigator } from '@react-navigation/stack'; function HomeScreen({ navigation }) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}> &lt;Text>Home Screen&lt;/Text> &lt;Button title=\"Go to Details\" onPress={() => navigation.navigate('Details')} /> &lt;/View> ); } function DetailsScreen() { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}> &lt;Text>Details Screen&lt;/Text> &lt;/View> ); } const Stack = createStackNavigator(); function App() { return ( &lt;NavigationContainer> &lt;Stack.Navigator initialRouteName=\"Home\" screenOptions={{ headerShown: false, }}> &lt;Stack.Screen name=\"Home\" component={HomeScreen} /> &lt;Stack.Screen name=\"Details\" component={DetailsScreen} /> &lt;/Stack.Navigator> &lt;/NavigationContainer> ); } export default App; 路由要在 Stack.Navigator 中以Stack.Screen组件的格式进行存放 Screen的属性component属性直接放入路由组件 Navigator的属性headerMode=&quot;none&quot;隐藏页面路由的标题 后面属性改成 以下才能使用了，以上的 headerMode=&quot;none&quot; 不管用了（2022年） screenOptions={{ headerShown: false, }} 当然，可以和Vue脚手架一样，在src下新建一个 nav.js文件，专门用于存放路由，此时我们将上图代码放入这个nav.js文件（App改问Nav） 然后再App.js文件写入Nav组件即可 import React from 'react' import { View, Text } from 'react-native' import Nav from './src/nav' export default function App() { return ( &lt;View style={{ flex: 1 }}> &lt;Nav>&lt;/Nav> &lt;/View> ) } 可以在 createStackNavigator里一一放置组件，有点类似路由的作用； 官方解释：一次渲染一个屏幕并提供屏幕之间的转换。当一个新屏幕打开时，它被放置在堆栈的顶部 格式为 传入的第一个参数为组件 （以对象的形式） 路由名: {screen: 组件名, navigationOptions: 配置选择（也可以自定义title、tabBarLabel等）} 主页面使用了createStackNavigator，子组件就会默认传入this.props.navigation。 navigation用于跳转页面和获取导航信息 然后，我们就可以在组件内进行路由跳转 this.props.navigation.navigate(&#39;路由名&#39;)可进行跳转 (跳转到 Brief 页面 + 传入名为 ‘book’ 的参数 )，接收的 Brief页面可以通过 this.props.navigation.state.params.book进行获取 this.props.navigation.goBack() 返回 const {navigation} = this.props reutrn( &lt;TouchableOpacity onPress={() => { navigation.navigate('Brief', { book: item }) }}> &lt;/TouchableOpacity> &lt;TouchableOpacity onPress={() => { navigation.goBack()}> &lt;/TouchableOpacity> ) //app.js import { createAppContainer } from 'react-navigation'; import { createStackNavigator } from 'react-navigation-stack' //这里分别引入了4个页面组件 import BottomNavigator from './page/root/rootPage' import BriefPage from './page/brief/briefPage' import ImgPage from './page/brief/ImgPage' import ListPage from './page/cate/ListPage' const AppStack = createStackNavigator( { // 首页组件设置：从rootPage引入的并且命名为BottomNavigator BottomNavigator: { screen: BottomNavigator, navigationOptions: { headerShown: false, } }, Login: { screen: Login }, Register: { screen: Register }, Brief: { screen: BriefPage }, ImgPage: { screen: ImgPage }, ListPage: { screen: ListPage } }, { mode: 'modal', headerMode: 'none', } ); export default createAppContainer(AppStack); UI框架框架推荐 react-native-elements 下载 需要使用到图标 因此也需要安装 react-native-vector-icons yarn add react-native-elements react-native-vector-icons 或者 npm i react-native-elements react-native-vector-icons 引入和使用 import { Icon } from 'react-native-elements' &lt;Icon name='rowing' /> react-native-vector-icons 的其他使用（使用UI库的icon时需要进行配置） 编辑 android/app/build.gradle 添加以下配置 project.ext.vectoricons = [ iconFontNames: [ 'MaterialIcons.ttf', 'EvilIcons.ttf' ] // Name of the font files you want to copy ] //这个时自定义添加字体时才配置 apply from: \"../../node_modules./React-native-vector-icons/fonts.gradle\" //这个是一定要配置的 重启项目 添加代码 如 import FontAwesome5 from 'react-native-vector-icons/FontAwesome5'; const icon = &lt;FontAwesome5 name={'comments'} />; 关闭黄色警告粘贴到index.js文件下 console.ignoredYellowBox = ['Warning: BackAndroid is deprecated. Please use BackHandler instead.','source.uri should not be an empty string','Invalid props.style key']; console.disableYellowBox = true // 关闭全部黄色警告 渐变色容器react-native-linear-gradient 下载 yarn add react-native-linear-gradient npm i react-native-linear-gradient 简单使用 import LinearGradient from 'react-native-linear-gradient'; &lt;LinearGradient colors={['#4c669f', '#3b5998', '#192f6a']} style={styles.linearGradient}> &lt;Text style={styles.buttonText}> Sign in with Facebook &lt;/Text> &lt;/LinearGradient> var styles = StyleSheet.create({ linearGradient: { flex: 1, paddingLeft: 15, paddingRight: 15, borderRadius: 5 }, buttonText: { fontSize: 18, fontFamily: 'Gill Sans', textAlign: 'center', margin: 10, color: '#ffffff', backgroundColor: 'transparent', }, }); 验证码输入框react-native-confirmation-code-field 下载 yarn add react-native-confirmation-code-field npm i react-native-confirmation-code-field 代码 import React, {useState} from 'react'; import {SafeAreaView, Text, StyleSheet} from 'react-native'; import { CodeField, Cursor, useBlurOnFulfill, useClearByFocusCell, } from 'react-native-confirmation-code-field'; const styles = StyleSheet.create({ root: {flex: 1, padding: 20}, title: {textAlign: 'center', fontSize: 30}, codeFiledRoot: {marginTop: 20}, cell: { width: 40, height: 40, lineHeight: 38, fontSize: 24, borderWidth: 2, borderColor: '#00000030', textAlign: 'center', }, focusCell: { borderColor: '#000', }, }); //验证码格子个数 const CELL_COUNT = 6; const App = () => { const [value, setValue] = useState(''); const ref = useBlurOnFulfill({value, cellCount: CELL_COUNT}); const [props, getCellOnLayoutHandler] = useClearByFocusCell({ value, setValue, }); return ( &lt;SafeAreaView style={styles.root}> &lt;Text style={styles.title}>Verification&lt;/Text> &lt;CodeField ref={ref} {...props} value={value} onChangeText={setValue} cellCount={CELL_COUNT} rootStyle={styles.codeFiledRoot} keyboardType=\"number-pad\"//弹窗显示数组键盘 textContentType=\"oneTimeCode\" renderCell={({index, symbol, isFocused}) => ( &lt;Text key={index} style={[styles.cell, isFocused &amp;&amp; styles.focusCell]} onLayout={getCellOnLayoutHandler(index)}> {symbol || (isFocused ? &lt;Cursor /> : null)} &lt;/Text> )} /> &lt;/SafeAreaView> ); }; export default App; react-native SVG推荐(就是我们常用的阿里巴巴矢量图标) yarn add react-native-svg react-native-svg-uri 日期组件推荐react-native-datepiker 用于日期填写 yarn add react-native-datepicker 基本使用（放出基本使用的代码居然使得hexo本身命令startprocessing卡死。。。） 定位组件推荐使用 react-native-amap-geolocation 使用高德地图进行定位 高德地图组件 分别使用了两个功能，一个是AndroidSDK和一个web服务 申请 高度地图的key（可以在b站https://www.bilibili.com/video/BV1e5411L7VV?p=49 ） （这里我个人设置密钥库口令为taylor） 踩坑之路： 其中关于PackageName, 如果配置了 build.gradle 文件，PackageName 应该以 applicaionId 为准，防止 build.gradle 中的 applicationId 与 AndroidMainfest.xml 中的 PackageName 不同，导致 key 鉴权不过。 调试版本使用 debug.keystore，命令为：keytool -list -v -keystore debug.keystore 发布版本使用 apk 对应的 keystore，命令为：keytool -list -v -keystore 项目下的debug.keystore 手机端打开GPS，不然会没有权限 手动配置： 下载依赖 yarn add react-native-amap-geolocation 配置文件 编辑 android/settings.gradle，设置项目路径： （+ 号表示要新增） + include ':react-native-amap-geolocation' + project(':react-native-amap-geolocation').projectDir = new File(rootProject.projectDir, '../node_modules./React-native-amap-geolocation/lib/android') 编辑 android/app/build.gradle，新增依赖： dependencies { + implementation project(':react-native-amap-geolocation') } 编辑 MainApplication.java：（注意rn0.61之后的版本里面，我们不再需要配置这个，也就是0.61版本以上的不用配置） + import cn.qiuxiang.react.geolocation.AMapGeolocationPackage; public class MainApplication extends Application implements ReactApplication { @Override protected List&lt;ReactPackage> getPackages() { @SuppressWarnings(\"UnnecessaryLocalVariable\") List&lt;ReactPackage> packages = new PackageList(this).getPackages(); // Packages that cannot be autolinked yet can be added manually here, for example: + packages.add(new AMapGeolocationPackage()); return packages; } } 自动配置（舒服，懂的都懂，一般情况下 react-native link 即可完成配置，如果因特殊原因无法使用 react-native link 或 link 失败，则可参照以下步骤检查并进行手动配置。） react-native link react-native-amap-geolocation 基本使用 import { PermissionsAndroid, Platform } from \"react-native\"; import { init, Geolocation } from \"react-native-amap-geolocation\"; import axios from \"axios\"; class Geo { //初始化 async initGeo() { if (Platform.OS === \"android\") { await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION); } //这里要放置在高德地图上，放置的服务平台位android的key，初始化 await init({ ios: \"891d0cf9dfba7fd2e99b509640f46644\", android: \"891d0cf9dfba7fd2e99b509640f46644\" }); return Promise.resolve(); } //获取经纬度 async getCurrentPosition() { return new Promise((resolve, reject) => { console.log(\"开始定位\"); Geolocation.getCurrentPosition(({ coords }) => { resolve(coords); }, reject); }) } //获取地区信息 async getCityByLocation() { const { longitude, latitude } = await this.getCurrentPosition(); const res = await axios.get(\"https://restapi.amap.com/v3/geocode/regeo\", { // 这里的key对应的是高德地图上web端的key params: { location: `${longitude},${latitude}`, key: \"b63b60478b9fe5e0498c9a6913097056\", } }); return Promise.resolve(res.data); } } export default new Geo(); 此外，我们还可以配合react-native-picker方便在项目中使用 (给Input标签添加点击事件的效果，点击后可以弹出选择地点具体方位的事件，不过这里我还在项目中添加了citys.json文件才能进行选择) react-native-picker 自定义picker 安装 yarn add react-native-picker 或者 npm i react-native-picker --save 代码 import Picker from 'react-native-picker'; import CityJson from '../../../res/citys.json'//添加了citys.json文件 Picker.init({ pickerData: CityJson, //显示哪些城市的数据 selectedValue: [\"北京\", \"北京\"],//默认选择的数据 wheelFlex: [1, 1, 0], // 显示省和市 pickerConfirmBtnText: \"确定\", pickerCancelBtnText: \"取消\", pickerTitleText: \"选择城市\", onPickerConfirm: data => { // data = [广东，广州，天河] this.setState( { city: data[1] } ); } }); Picker.show(); 效果图： 5.Mobxmobx是react中的全局数据管理库，可以简单实现数据的跨组件共享，有点类似于vue中的vuex或者是react的redux，更像vuex，也有利用getter、setter收集组件的数据依赖 可以用在RN或者React网页开发等 Mobx VS redux 写法上更偏向于OOP 直接对复杂数据修改 并非单一store，而是多store redux默认以JavaScript原生对象形式存储，而Mobx用可观察对象 优缺点 学习成本呢小，面向对象，多TS友好（优） 过于自由，提供的约定比较少，容易导致团队开发风格不一统一（缺） 相关中间件少，逻辑层业务整合是个问题（缺） 使用步骤 安装依赖 mobx 核心库 mobx-react 方便在react中使用mobx技术的库 @babel/plugin-proposal-decorators 让 rn 项目支持 es7 的装饰器语法的库 yarn add mobx mobx-react @babel/plugin-proposal-decorators 在 babel.config.js添加以下配置 plugins: [ ['@babel/plugin-proposal-decorators', { 'legacy': true }] ] 新建文件 mobx\\index.js 用来存放 全局数据 @observable是es7装饰器的语法（使用到了Object.defineproperty） import { observable, action } from \"mobx\"; class RootStore { // observable 表示数据可监控 表示是全局数据 @observable name = \"hello\"; // action行为 表示 changeName是个可以修改全局共享数据的方法 @action changeName(name) { this.name = name; } } export default new RootStore(); 在根组件中挂载 通过 Provider 来挂载和传递，包裹在其中的组件可以拿到全局数据 import React, { Component } from 'react'; import { View} from 'react-native'; import rootStore from \"./mobx\"; import { Provider} from \"mobx-react\"; class Index extends Component { // 正常 render() { return ( &lt;View > &lt;Provider rootStore={rootStore} > &lt;Sub1>&lt;/Sub1> &lt;/Provider> &lt;/View> ); } } 组件中使用 import React, { Component } from 'react'; import { View, Text } from 'react-native'; import {inject,observer } from \"mobx-react\"; @inject(\"rootStore\") // 注入传入的属性用来获取 全局数据的 @observer // 当全局发生改变了 组件的重新渲染 从而显示最新的数据，有点类似setState class Sub1 extends Component { changeName = () => { // 修改全局数据 this.props.rootStore.changeName(Date.now()); } render() { console.log(this); return ( &lt;View>&lt;Text onPress={this.changeName}>{this.props.rootStore.name}&lt;/Text>&lt;/View> ); } } export default Index; react中使用mobxnpm i mobx@5 import React from 'react' import {observable, autorun} from 'mobx' // 对数据进行监听 const obNumber = observable.box(0) const obObject = observable({name: \"allen\"}) const obArr = observable([]) // 获取数据 console.log(obNumber.get()) console.log(obObject.name) //修改数据 obNumber.set(20) obObject.name = \"Mikasa\" // 第一次会自动执行，每次监听的数据（这里是obNumber） //发生改变都会回调该函数，有点像vue3的watchEffect autorun(() => { console.log(obNumber.get()); }) export default function test() { return ( &lt;div>test&lt;/div> ) } 项目中使用 在src下新建一个mobx目录 新建 store.js //store.js import {observable} from 'mobx' const store = observable({ isShow: true, list: [], cityName: 'beijing' }) export default store; 使用中通过useEffect绑定好 autorun 和 store某个值的改变即可，十分fast 如果开启了严格模式，在外面通过 store.fn()调用action来更改store中的状态即可 import { observable, configure, action } from 'mobx' //设置严格模式，必须通过actions的方式修改数据 configure({ enforceActions: 'always' }) const store = observable({ isShow: true, list: [], cityName: 'beijing', Show() { this.isShow = true }, Hide() { this.isShow = false } }, { // 标记两个方法是action，专门用来修改 Show: action, Hide: action }) export default store; create-react-app中支持ES7但是官方的写法仍然是按照上面RN用的哪那种方法一样的，所以我们可以自己定夺使用哪种方法 @observable name = \"hello\"; // action行为 表示 changeName是个可以修改全局共享数据的方法 @action changeName(name) { this.name = name; } 不过目前vscode和react项目并不支持这种@的es7语法，需要我们去进行设置： vscode的设置中勾中 experimentalDecorators 选项 然后安装依赖 npm i @babel/core @babel/plugin-proposal-decorators @babel/preset-env 根目录下创建 .babelrc文件 //.babelrc { \"presets\": [ \"@babel/preset-env\" ], \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", { \"legacy\": true } ] ] } 根目录下创建config-override.js const path = require('path') const { override, addDecoratorsLegacy } = require('customize-cra') function resolve(dir) { return path.join(__dirname, dir) } const customize = () => (config, env) => { config.resolve.alias['@'] = resolve('src') if (env === 'production') { config.externals = { 'react': 'React', 'react-dom': 'ReactDOM' } } return config }; module.exports = override(addDecoratorsLegacy(), customize()) 安装依赖 npm i customize-cra react-app-rewired 修改package.json ... \"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-app-rewired eject\" }, ... 6.RN &amp; FlutterRN 优点： RN的效率由于是将View编译成了原生View,所以效率上要比基于Cordova的HTML5高很多。 程序组件看起来就像原生组件（例如，iOS设备上的按钮看起来就像原生 iOS 按钮，Android 上也是如此） 以JS为编程语言 稳定性（上市 5 年以上） 缺点： 但是如果我们碰上了复杂的组件渲染结构比如我们渲染一个复杂的ListView,每一个小的控件,都是一个native的view,然后相互组合叠加.想想此时如果我们的list再需要滑动刷新,会有多少个对象需要渲染.所以也就有了前面所说的RN的列表方案不友好 React Native 使用桥接和原生元素，因此可能需要针对每个平台单独优化，它可能会使使用 React Native的应用程序开发时间更长。 Flutter 优点： 吸收了前两者的教训之后,在渲染技术上,选择了自己实现(GDI),由于有更好的可控性，所以在性能方面比RN更高一筹 共享域更广，我们可以使用相同的代码库将本机应用程序传送到五个操作系统：iOS、Android、Windows、macOS 和 Linux；以及针对 Firefox、Chrome、Safari 或 Edge 等浏览器的网络体验。Flutter 甚至可以嵌入到汽车、电视和智能家电中（谷歌官方说的） 缺点： 但是Dart是AOT编译的，Dart语言受众小，且Flutter的第三方库相对较少","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React-native","slug":"React-native","date":"2021-06-24T16:00:00.000Z","updated":"2022-03-04T09:35:15.759Z","comments":true,"path":"2021/06/25/react-native/","link":"","permalink":"https://taylor12138.github.io/2021/06/25/react-native/","excerpt":"","text":"1.React Native概述引入关于React Native一些人的评价 优点： 1.完全采用JavaScript 2.跨平台，Write Once, Run anywhere变得可能，尤其是Android和IOS两端 3.社区给力，React Native有着强大的社区，众多开发者提供了各种类型的组件（对比国内阿里系，看起来就是某个人的绩效） 缺点： 1.复杂的状态管理（让我想起里被redux支配的恐惧），即使你会使用React，但也觉得它的页面切换有点绕 2.创建新的原生组件复杂。如果要创建一个之前从未出现过的原生组件，不仅需要懂得Android开发，还得懂得IOS开发 安装依赖Node、JDK 和 Android Studio。 虽然你可以使用任何编辑器来开发应用（编写 js 代码），但你仍然必须安装 Android Studio 来获得编译 Android 应用所需的工具和环境。(记得JDK一定要装1.8版本的（2021年）！！！) 苹果公司目前只允许在 Mac 电脑上开发 iOS 应用。如果你没有 Mac 电脑，那么只能考虑使用沙盒环境，或者先开发 Android 应用了。 跟着官网搭建环境 https://reactnative.cn/docs/environment-setup 然后可以在vscode上运行命令创建react-native项目 npx react-native init AwesomeProject （使用 React Native 内建的命令行工具来创建一个名为”AwesomeProject”的新项目。这个命令行工具不需要安装，可以直接用 node 自带的npx命令来使用：） 亦或者通过 npx create-react-native-app 搭建项目 搭建项目的不同real diff between “create-react-native-app myproject” and “react-native init myproject” overflow上的回答： ( create-react-native-app“CRNA”) CLI 基于Expo构建项目模板，Expo是一个第三方工具包，允许您仅使用 JavaScript编写跨平台的 React Native 应用程序，并为让应用程序在真实设备上运行提供更流畅的工作流程。此外，Expo 提供对大量原生 API的访问，您通常需要库或自定义原生代码。 Expo 很棒，在理想情况下，它是大多数应用程序开发人员可能更喜欢使用的，但 Expo 的架构设置了一个不幸的限制：您无法编写自定义 Native Modules，或集成依赖于自定义 Native 代码的第三方库没有内置到Expo。这意味着你只能访问 React Native 和 Expo 提供的原生功能，而不能轻易扩展它。 相比之下，react-nativeCLI 的init命令创建一个简单的 React Native 应用程序模板，您可以修改原生 iOS 和 Android 项目。这种方法的缺点是您需要在您的计算机上设置本机 iOS 和 Android 构建链，并且开始开发和部署您的应用程序要麻烦得多。 幸运的是，Expo 提供了一种将 CRNA应用程序与其原生应用程序外壳分离的方法。这会将 CRNA 项目转换为类似于由 创建的普通项目的东西react-native init，但可以访问所有 Expo SDK 功能。 在实践中，对于大多数初学者和新项目来说，最好的方法是从 开始create-react-native-app，然后评估您以后是否需要分离。Expo提供了一个方便的指南来帮助做出这个决定。 而且也推荐装Yarn，它是Facebook提供的替代npm的工具，可以加速node模块的下载 npm install yarn -g // 使用npm全局安装yarn 检查是否安装成功 yarn -v 安卓模拟器不过听说Android studio本身自带的模拟器又卡又慢，附上模拟器推荐的网址 https://blog.csdn.net/huanhuan59/article/details/80281509 比如下载夜神模拟器，然后在目录的bin文件夹下（连接Android studio（夜神的端口号是62001）） nox_adb.exe connect 127.0.0.1:62001 之后连接就可以输入adb connect 127.0.0.1:62001命令连接上模拟器 adb connect 127.0.0.1:62001 踩坑之路：连接后运行 npx react-native run-android，给我报了No connected devices的错误，，而且我在连接adb的时候出现这种情况 这种情况下说明你的模拟器的adb版本太低，被杀死了(无语，研究了好久这个问题) 处理方式：先把你夜神模拟器中的nox_adb.exe删除，然后在你的SDK里面的platform-tools中找到adb.exe,把你的SDK里面的adb复制到夜神模拟器的bin中，记得要改名字（注意要把adb.exe改为nox_adb.exe） 真机 准备一台 Android 手机, 通过数据线 连接 到电脑，设置启用 USB调试 一般的手机在 设置 中可以直接找到 开发者选项 进行开启, 如果 找不到 , 就自行百度查一下 手机连接电脑成功后运行检测命令 adb devices , 如果有输出设备列表与 ID 相关的字符串就证明手机和电脑是连接成功了，如果没有显示设备号，则说明连接有问题，一定要保证手机和电脑是正常连接状态 下载投影工具scrcpy 解压之后，打开scrpy.exe即可 踩坑之路：使用小米手机安装RN的项目会报错：Task :app:installDebug FAILED 解决方法：先检查了一下开发者选项，USB调试、未知源 都是开启的； 然后发现 “启用MIUI优化”这一项是开启的，把它关掉（设置—-更多设置—-开发者选项—-启用MIUI优化 关闭） 确保你先运行了模拟器或者连接了真机，然后在你的项目目录中运行yarn android或者yarn react-native run-android： cd AwesomeProject yarn android # 或者 npm run android # 或者 yarn react-native run-android # 或者 npx react-native run-android 踩坑之路：Could not receive a message from the daemon 解决方法：关闭电脑的移动热点，问题即解决。 运行成功 项目目录介绍App.js：项目根组件 index.js：项目入口文件 _tests_：测试文件 app.json：配置文件 metro.config.js：facebook的工程构建工具 .prettierrc.js：控制代码格式化的风格 顺便推荐两个VScode常用的RN插件 Prettier - Code formatter（负责格式化）、React-Native snippets（快捷输入） jsx模板生成的快捷键（类式组件）： rnc jsx模板生成的快捷键（函数式组件）： rnf 2.React Native基本语法三个对象这里介绍三个对象 StyleSheet，我们建议使用StyleSheet.create来集中定义组件的样式，通过 create 另外定义style样式并且导入，里面的属性名要使用驼峰命名法 View，视图组件,相当于div标签，不能放文本，不能绑定点击事件 （点击事件必须由 TouchableOpacity替代 ） Text，文本组件，相当于p标签，文字一定要放在其中，支持绑定点击事件 numberOfLines属性，用于限制文本行数 ellipsizeMode属性，一行写不完，以 … 的形式省略 import React from 'react' import { StyleSheet, View, Text } from 'react-native' const App = () => { //空标签，它也可以实现fragment的效果 return ( &lt;> &lt;View style={styles.view}> &lt;Text>helloWorld&lt;/Text> &lt;/View> &lt;/> ) } // 定义对象样式 const styles = StyleSheet.create({ view: { height: 200, width: 200, backgroundColor: \"rgba(200, 255, 0, 0.5)\", color: 'red' //hello world不会变成红色 } }); export default App; React Native的样式RN的默认样式： flex布局 方向 flex-direction: column 在react-native中没有样式继承，每一个组件都要单独设置样式 单位不能加 &#39;px&#39;、&#39;vw&#39;、&#39;vh&#39;，不能使用fontSize: &#39;100px&#39;的形式，必须使用 fontSize: 100；但是可以加百分比 &#39;%&#39;，width:&quot;100%&quot; 既然不能加&#39;vw&#39;、&#39;vh&#39;，如何实现依据屏幕的宽度 / 高度？ import { Dimensions } from 'react-native'; const windowWidth = Dimensions.get('window').width; const windowHeight = Dimensions.get('window').height; transfrom的使用 &lt;Text style={{transfrom:[{translateY:300}, {scale:2}]}}>&lt;/Text> 安卓内部单位不是px，是dp。所以需要把px转变为安卓内部的dp。此时可以在src文件下新建一个utils文件夹，然后新建styleKits.js文件 //设计稿宽度 / 元素宽度 = 手机屏幕 / 手机中元素的宽度 //手机中元素的宽度 = 元素宽度 * 手机屏幕 / 设计稿宽度 //设计稿的宽度由美工决定，这里暂定为375 import { Dimensions } from \"react-native\" export const screenHeight = Dimensions.get('window').height; export const screenWidth = Dimensions.get('window').width; export const pxToDp = (elePx) => screenWidth * elePx / 375; 按照以上公式，当使用到样式（px）时，直接套用该方法即可 相对之前学习的React改动对于属性state、props的使用，和在React里面如出一辙（函数组件的state、ref还是使用Hook） 移动端的点击事件：onPress import React from \"react\"; import { View, Text } from \"react-native\"; //类式组件的state export default class MyComponent extends React.Component { state = { isHot: true } change = () => { const { isHot } = this.state; this.setState({ isHot: !isHot }) } render() { const { isHot } = this.state return ( &lt;View> &lt;Text onPress={this.change}>today is {isHot ? 'hot' : 'cold'}&lt;/Text> &lt;/View> ) } } 类式组件的props，直接 this.props.属性名使用 函数式组件的props const MyComponent = (props) => { const { name, sex, age } = props; return ( &lt;ul> &lt;li>性名：{name}&lt;/li> &lt;li>性别：{sex}&lt;/li> &lt;li>年龄：{age}&lt;/li> &lt;/ul> ) } 所以结论：其实没有什么改动，只是多了很多React Native带的移动端组件罢了 3.React Native组件TouchableOpacity(点击)TouchableOpacity，点击触摸时会反馈给用户一个透明度的变化，它是一个绑定点击事件的块级标签 有 activeOpacity属性，用于调节点击时的透明度 import {TouchableOpacity } from \"react-native\"; Text-Input(输入框)Text-Input组件时React native的内置组件，不需要额外安装 引入组件 import {TextInput } from \"react-native\"; 通过 onChangeText事件来获取输入框的值 Text-Input属性 属性名 值 描述 autoCapitalize “none”, “sentence”, “words”, “characters” 字母大写模式 autoCorrent bool 设置拼写自动修正功能，默认为开启(true) autoFocus bool 设置是否默认获取到焦点，默认为关闭(false) keyboardType “default”, “number-pad”, “decimal-pad”, “phone-pad” 等 键盘类型 returnKeyType “done”, “go”, “next”, “search”, “send” 键盘上返回键类型 placeholder string 占位符 underlineColorAndroid string 下划线颜色 secureTextEntry bool 设置是否为密码安全输入框 onChange function 监听方法,文本框内容发生改变回调方法 onChangeText function 监听方法，文本框内容发生改变回调方法，该方法会进行传递文本内容（也就是默认传入文本内容作为默认参数） onSubmitEditing function 监听方法，当编辑提交的时候回调方法（提交）。不过如果multiline={true}的时候，该属性就不生效 更多 Text-Input 属性可以查看这个页面https://blog.csdn.net/u014484863/article/details/51732074 案例： import React from \"react\"; import { View, Text, TextInput, TouchableOpacity } from \"react-native\"; export default () => { const [email, setEmail] = React.useState('') const [password, setPassword] = React.useState('') const [intro, setIntro] = React.useState('') // onChangeText默认传入文本内容作为默认参数 function handleEmail(text) { setEmail(text); } function handlePassword(text) { setPassword(text); } function handleIntro(text) { setIntro(text); } function register() { alert('email' + email + '\\npassword' + password + '\\nintro' + intro); } return ( &lt;> &lt;View> &lt;TextInput underlineColorAndroid=\"transparent\" placeholder=\"请输入邮箱\" placeholderTextColor=\"#ccc\" autoCapitalize=\"none\" keyboardType=\"email-address\" returnKeyType=\"next\" onChangeText={handleEmail} >&lt;/TextInput> &lt;TextInput onChangeText={handlePassword} placeholder=\"请输入密码\" secureTextEntry={true}>&lt;/TextInput> &lt;TextInput onChangeText={handleIntro} placeholder=\"请输入信息\">&lt;/TextInput> {/* 提交按钮 */} &lt;TouchableOpacity onPress={register}> &lt;Text>注册&lt;/Text> &lt;/TouchableOpacity> &lt;/View> &lt;/> ) } Image(图片)Image组件时React native的内置组件，不需要额外安装 引入组件 import {Image } from \"react-native\"; 其实还有2个组件推荐， ScrollView，用于滑动的操作 import {ScrollView } from \"react-native\"; 它实际上所做的就是将一系列不确定高度的子组件装进一个确定高度的容器（通过滚动操作） ImageBackground,相当于以前的 div + 背景图片，因为在RN当中，是不存在背景图片这个属性的 标签一定要配套商 style属性，不然会报错 （至少配套上）style={{}} import {ImageBackground } from \"react-native\"; &lt;ImageBackground source={...} style={{width:100%, height:100%}}> &lt;/ImageBackground> Image 常用属性 source 资源定位 使用网络图片要用 uri，且一定要设置宽高 如果配置类别名，直接和正常在js导入中使用别名的形式即可，不需要变成 ~@ 之类的 图片显示模式resizeMode contain（整体缩放）,按照正常的比例缩放到可以刚好放进来 cover不会变形(截屏)，放大图片至刚好覆盖住整个内容 stretch会变形（局部压缩），直接拉伸至设置的大小 blurRadius(模糊半径)：为图片添加一个指定半径的模糊滤镜。 案例 import React from \"react\"; import { Image, ScrollView } from \"react-native\"; export default () => { return ( &lt;> &lt;ScrollView> {/* 普通图片设置 */} &lt;Image source={require('./assets/1.png')}>&lt;/Image> {/* 网络图片设置,一定要设置宽高，不然不显示 */} &lt;Image style={{ margin: 10, width: 200, height: 200 }} source={{ uri: 'https://img2.baidu.com/it/u=3963436481,1344394108&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg' }}>&lt;/Image> &lt;Image style={{ margin: 10, width: 200, height: 200, resizeMode: 'contain' }} source={require('./assets/1.png')} >&lt;/Image> &lt;Image style={{ margin: 10, width: 200, height: 200, resizeMode: 'cover' }} source={require('./assets/1.png')} >&lt;/Image> &lt;Image style={{ margin: 10, width: 200, height: 200, resizeMode: 'stretch' }} source={require('./assets/1.png')} >&lt;/Image> &lt;/ScrollView> &lt;/> ) } 在 Android 上支持 GIF 和 WebP 格式图片 默认情况下 Android 是不支持 GIF 和 WebP 格式的。你需要在android/app/build.gradle文件中根据需要手动添加以下模块： dependencies { // 如果你需要支持Android4.0(API level 14)之前的版本 implementation 'com.facebook.fresco:animated-base-support:1.3.0' // 如果你需要支持GIF动图 implementation 'com.facebook.fresco:animated-gif:2.0.0' // 如果你需要支持WebP格式，包括WebP动图 implementation 'com.facebook.fresco:animated-webp:2.1.0' implementation 'com.facebook.fresco:webpsupport:2.0.0' // 如果只需要支持WebP格式而不需要动图 implementation 'com.facebook.fresco:webpsupport:2.0.0' } ActivityIndicator(加载)活动指示器组件，也可以叫它Loading，有一些比较耗时的操作，可能需要用户等待，那么可以使用活动指示器组件 ActivityIndicator告诉用户你需要等待（类似于一个圈圈在不停旋转） ActivityIndicator组件时React native的内置组件，不需要额外安装 常用属性 animating，是否显示转圈加载 color，滚轮的前景颜色 案例 import React, { Component } from \"react\"; import { TouchableOpacity, ActivityIndicator, Button } from \"react-native\"; export default class App extends Component { state = { animating: true } closeActivityIndicator = () => { this.setState({ animating: !this.state.animating }) } componentDidMount = () => this.closeActivityIndicator(); render() { const { animating } = this.state return ( &lt;> &lt;ActivityIndicator animating={animating} color=\"blue\" /> &lt;TouchableOpacity> &lt;Button onPress={this.closeActivityIndicator} title=\"切换显示loading\">&lt;/Button> &lt;/TouchableOpacity> &lt;/> ) } } Alert(提示框) React的弹窗组件，启动一个提示对话框，包含对应的标题和信息。你还可以指定一系列的按钮，点击对应的按钮会调用对应的 onPress 回调并且关闭提示框。默认情况下，对话框会仅有一个’确定’按钮。 iOS# 在 iOS 上你可以指定任意数量的按钮。每个按钮还都可以指定自己的样式，此外还可以指定提示的类别。参阅AlertButtonStyle来了解更多细节。 Android# 在 Android 上最多能指定三个按钮，这三个按钮分别具有“中间态”、“消极态”和“积极态”的概念： 如果你只指定一个按钮，则它具有“积极态”的属性（比如“确定”）；两个按钮，则分别是“消极态”和“积极态”（比如“取消”和“确定”）；三个按钮则意味着“中间态”、“消极态”和“积极态”（比如“稍候再说”，“取消”，“确定”）。 在 Android 上可以通过点击提示框的外面来取消提示框，但这一行为默认没有启用。你可以在Options额外参数来启用这一行为：{ cancelable: true }。 方法 alert() ：static alert(title, message?, buttons?, options?) 名称 类型 说明 title string Required The dialog’s title. Passing null or empty string will hide the title. message string An optional message that appears below the dialog’s title. buttons Buttons An optional array containg buttons configuration. options Options Android An optional Alert configuration for the Android. 案例 import React from \"react\"; import { Alert, TouchableOpacity, View, Text } from \"react-native\"; export default () => { const showAlert1 = () => Alert.alert(\"发送数据成功\") const showTip = () => Alert.alert(\"删除数据成功\") const showAlert2 = () => { // 传入内容，传入的数组对应不同的按钮，引发不同的事件 Alert.alert(\"警告\", '确认删除?', [ { text: '确认', onPress: () => showTip() }, { text: '取消', style: 'cancel' } ], //不能点击提示框的外面来取消提示框 { cancelable: false } ) } return ( &lt;> &lt;View style={{ alignItems: 'center' }}> &lt;TouchableOpacity onPress={showAlert1}> &lt;Text>发送&lt;/Text> &lt;/TouchableOpacity> &lt;TouchableOpacity onPress={showAlert2}> &lt;Text>删除&lt;/Text> &lt;/TouchableOpacity> &lt;/View> &lt;/> ) } Animating(动画)Animated是一个动画组件，旨在使动画变得流畅，强大并易于构建和维护。Animated侧重于输入和输出之间的声明性关系，以及两者之间的可配置变换，此外还提供了简单的 start/stop方法来控制基于时间的动画执行。 创建动画最基本的工作流程是先创建一个 Animated.Value ，将它连接到动画组件的一个或多个样式属性，然后使用Animated.timing()通过动画效果展示数据的变化： 常用属性： Value 驱动动画运行的一维标量值。一般使用new Animated.Value(0);来初始化。 常用方法： timing() 推动一个值按照一个缓动曲线而随时间变化。Easing模块定义了一大堆曲线，你也可以使用你自己的函数。 Config 参数有以下这些属性： duration: 动画的持续时间（毫秒）。默认值为 500. easing: 缓动函数。 默认为Easing.inOut(Easing.ease)。 delay: 开始动画前的延迟时间（毫秒）。默认为 0. isInteraction: 指定本动画是否在InteractionManager的队列中注册以影响其任务调度。默认值为 true。 useNativeDriver: 启用原生动画驱动。默认不启用(false)。 .start()方法用于开始一个动画 案例 import React from 'react' import { Animated, TouchableOpacity, StyleSheet } from 'react-native' export default () => { // 默认宽高 const animatedWidth = new Animated.Value(50) const animatedHeight = new Animated.Value(100) function animatedBox() { // 点击后，设置动画变化 Animated.timing(animatedWidth, { toValue: 200, //值到200 duration: 1000,//持续时间 useNativeDriver: false //不设置这个会有黄色的warn }).start() Animated.timing(animatedHeight, { toValue: 300, duration: 500, useNativeDriver: false }).start() } const animatedStyle = { width: animatedWidth, height: animatedHeight } return ( &lt;> &lt;TouchableOpacity onPress={animatedBox} style={styles.container}> &lt;Animated.View style={[styles.box, animatedStyle]}>&lt;/Animated.View> &lt;/TouchableOpacity> &lt;/> ) } const styles = StyleSheet.create({ container: { justifyContent: 'center', alignItems: 'center' }, box: { backgroundColor: 'blue', width: 50, height: 100 } }) Switch(开关)Switch是一个开关组件，一个“受控组件”（controlled component）。必须使用onValueChange回调来更新value属性以响应用户的操作。如果不更新value属性，组件只会按一开始给定的value值来渲染且保持不变，看上去就像完全点不动。 主要属性： onValueChange，切换开关回调的事件 value，开关指定的值 案例： import React, { useState } from 'react' import { View, Text, Switch } from 'react-native' export default () => { const label = { false: '关', true: '开' }; const [switchValue, setSwitchValue] = useState(true); const toggleSwitch = () => setSwitchValue(preState => !preState); return ( &lt;> &lt;View> &lt;Switch trackColor={{ false: \"#767577\", true: \"#81b0ff\" }} thumbColor={switchValue ? \"#f5dd4b\" : \"#f4f3f4\"} ios_backgroundColor=\"#3e3e3e\" onValueChange={toggleSwitch} value={switchValue}> &lt;/Switch> &lt;View>&lt;Text>当前状态是: {label[switchValue]}&lt;/Text>&lt;/View> &lt;/View> &lt;/> ) } StatusBar(状态栏)StatusBar组件是手机屏幕最上方的区域，包含运营商名称、网络情况、手机电池 可以通过它定制白天/夜晚 主题模式 由于StatusBar可以在任意视图中加载，可以放置多个且后加载的会覆盖先加载的。因此在配合导航器使用时，请务必考虑清楚StatusBar的放置顺序。 常用属性 barStyle，主题颜色，enum(‘default’, ‘light-content’, ‘dark-content’) hidden，隐藏显示 backgroundColor，状态栏的背景色，可以为transparent（透明）。 translucent，设置为true，配合backgroundColor: transparent可以把背景图片提上状态栏 animated，指定状态栏的变化是否应以动画形式呈现。目前支持这几种样式：backgroundColor, barStyle 和 hidden。 案例 import React, { useState } from 'react' import { Text, StatusBar, TouchableOpacity } from 'react-native' export default () => { const [hidden, sethidden] = useState(false) const [barStyle, setbarStyle] = useState('default'); const changeHidden = () => { sethidden(preState => !preState); } const changeBarStyle = () => { const temp = barStyle === 'light-content' ? 'dark-content' : 'light-content'; setbarStyle(temp); } return ( &lt;> &lt;StatusBar barStyle={barStyle} hidden={hidden}>&lt;/StatusBar> &lt;TouchableOpacity onPress={changeHidden}> &lt;Text>显示/隐藏&lt;/Text> &lt;/TouchableOpacity> &lt;TouchableOpacity onPress={changeBarStyle}> &lt;Text>改变主题颜色&lt;/Text> &lt;/TouchableOpacity> &lt;/> ) }","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"音频功能使用记录","slug":"音频功能使用记录","date":"2021-06-14T16:00:00.000Z","updated":"2022-05-29T06:46:39.551Z","comments":true,"path":"2021/06/15/yin-pin-gong-neng-shi-yong-ji-lu/","link":"","permalink":"https://taylor12138.github.io/2021/06/15/yin-pin-gong-neng-shi-yong-ji-lu/","excerpt":"","text":"1.音频录制利用插件进行网页内的音视频录制其实非常简单，只需要 chrome.tabCapture API 即可实现网页本身的音频录制，获取到的流数据我们需要针对音频数据进行采样，保证计算 HASH 的规则和数据库数据保持一致。 针对获取的 stream 流可以进行音频的转录采样，一般有三种处理方式： createScriptProcessor：此方法用于音频处理最为简单，但是此方法已经在 W3C 标准里标记为废弃。不建议使用 MediaRecorder：借助媒体 API 也可以完成音频的转录，但是没有办法做到精细处理。 AudioWorkletNode：用于替代 createScriptProcessor 进行音频处理，可以解决同步线程处理导致导致的对主线程的压力，同时可以按 bit 进行音频信号处理，这里也选择此种方式进行音频采样。 使用 WebAssembly 的时候需要遵循严格的 CSP 定义，对于 Chrome MV2 可以通过追加 &quot;content_security_policy&quot;:&quot;script-src &#39;self&#39; &#39;unsafe-eval&#39;;&quot; 进行声明解决。而在 MV3 中，由于更加严格的隐私及安全限制，但是可以使用沙盒环境下解决 CSP modifications for sandbox have no such new restrictions. —— Chrome插件开发文档 插件本身可以定义 sandbox 页面，这种页面虽然无法访问 web/chrome API，但是它可以运行一些所谓“不安全”的方法，例如 eval、new Function、WebAssembly.instantiate 等。所以可以借助沙盒页面进行 WASM 模块的加载及运行，将计算的结果（听歌识曲的）返回给主页面 https://zhuanlan.zhihu.com/p/509496365 2.vue-aplayer简单介绍为 Easy-to-use music player for Vue 2.x，一款基于Vue2.0的音乐播放器，传入相关的prop参数可进行自定义修改 因为在项目中使用到了，在这里记录相关的用法 安装npm install vue-aplayer --save 使用&lt;aplayer autoplay :music=\"{ title: 'secret base~君がくれたもの~', artist: 'Silent Siren', src: 'https://moeplayer.b0.upaiyun.com/aplayer/secretbase.mp3', pic: 'https://moeplayer.b0.upaiyun.com/aplayer/secretbase.jpg' }\" /> 实践&lt;aplayer :music=\"audio[0]\" :list=\"audio\" :showlrc=\"true\">&lt;/aplayer> Props（参数） 名称 类型 默认值 说明 music Object 必需 当前播放的音乐。 具体请看音乐信息 list Array [] 播放列表。如果 list 不是空数组，播放列表就会显示出来，即使 list 中只有一首歌并且它和 music 一样 mini Boolean false 迷你模式 float Boolean false 浮动模式。你可以在页面上随意拖放你的播放器 showLrc Boolean false 是否显示歌词 mutex Boolean true 是否在该播放器播放时暂停其他播放器 theme String &#39;#41b883&#39; 主题色。如果当前歌曲也设置了 theme 则以歌曲的为准 shuffle Boolean false 随机播放 repeat String &#39;no-repeat&#39; 轮播模式。值可以是 &#39;repeat-one&#39;（单曲循环）&#39;repeat-all&#39;（列表循环）或者 &#39;no-repeat&#39;（不循环）。为了好记，还可以使用对应的 &#39;music&#39; &#39;list&#39; &#39;none&#39; listMaxHeight String none 播放列表面板最大高度 listFolded Boolean false 默认收起播放列表 narrow DEPRECATED, 请使用 mini listmaxheight DEPRECATED, 请使用 listMaxHeight showlrc DEPRECATED, 请使用 showLrc 如果你是用的是 Vue@2.3.0+, 你可以在 music shuffle 和 repeat 上使用 .sync修饰符 将 Audio 属性作为 props从 v1.4.0 开始，我们选取了一些 &lt;audio&gt; 属性并将它们运用为 props（其实也就是上方props参数的拓展） 名称 类型 默认值 是否可变 说明 autoplay Boolean false false 自动播放。如果多个 mutex 播放器设置了 autoplay，只有第一个会自动播放 controls Boolean false true 显示原生 audio 元素（在播放器面板和播放列表面板之间） muted Boolean false true 静音 preload String none true The way to load music, can be ‘none’ ‘metadata’ or ‘auto’ volume Number 0.8 true 播放音量 muted 和 volume 也可以使用 .sync 修饰符，你可以利用这一点做一些自定义的控制 音乐信息对应props里面的music，当前播放音乐，music props 包含了当前播放歌曲的如下信息。 属性 默认值 说明 src 必需 音频文件的 URL title &#39;Untitled&#39; 歌曲名称 artist &#39;Unknown&#39; 演唱者 pic none 封面图片 URL lrc none LRC 歌词或者歌词文件的 URL theme none 歌曲的主题色，会覆盖播放器的主题色 url DEPRECATED, 请使用 src author DEPRECATED, 请使用 artist 实践： music: { // 当前播放的音乐 title: \"晴天\", artist: \"周杰伦\", src: require(\"@/assets/music/周杰伦 - 晴天.mp3\"), pic: require(\"...\"), // 封面图片 }, 事件从 v1.4.0 开始, Vue-APlayer 会抛出它内部的 &lt;audio&gt; 元素上触发的所有媒体事件. 你可以查阅 MDN 上的这张完整列表. 在 v1.4.0 以前, 我们有一些自定义事件，如 play pause canplay playing ended error, 它们现在已全部被废弃。 自适应主题色从 v1.3.0 开始, 如果你将一首歌的 theme 值设为 &#39;pic&#39;, Vue-APlayer 会从它的封面图片中提取颜色作为主题色. 你也可以直接将 Vue-APlayer 的 theme prop 设为 &#39;pic&#39;, 这样所有的歌曲都会使用自适应主题色 你只需将 color-thief 库加入页面中. 注意 color-thief 无法正常使用 npm 安装 也就是说我们只能导入，不能用npm装 &lt;!-- 或者你选择的其他 CDN --> &lt;script src=\"https://cdn.jsdelivr.net/npm/colorthief@2.0.2/src/color-thief.js\">&lt;/script> 查询更多可以看 https://github.com/SevenOutman/vue-aplayer/blob/develop/docs/README.zh-CN.md","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React(中)","slug":"React(中)","date":"2021-05-09T16:00:00.000Z","updated":"2023-05-22T04:44:31.645Z","comments":true,"path":"2021/05/10/react-zhong/","link":"","permalink":"https://taylor12138.github.io/2021/05/10/react-zhong/","excerpt":"","text":"6.React路由React和Vue一样，都是采取单页面富应用的方式配置网页（SPA），即单个页面通过路由的切换，展示不同的数据信息， 而且改变url，依然是页面不发生整体刷新（只做页面的局部刷新），对于if else、switch不同的地方在于，他们只转变组件，但是url路径没发生变化，而且他们无法定位到上一次浏览的页面，要重新在首页新打开 React-router有三种实现方式，分别对应三种平台 1.web 2.native 3.anwhere 分别对应 react-router-dom : 具体实现浏览器相关的路由监听和跳转 react-router-native : 具体实现RN相关的路由监听和跳转 react-router : 核心逻辑处理，提供一些公用的基类 在实际使用时，我们一般不需要引用react-router，而是直接用react-router-dom就行，因为它自已会去引用react-router。下面我们在项目里面引入react-router-dom。 针对Web的路由针对Web，我们使用的是react-router-dom，当前讲述的是react-router-dom@5，6.x版本截止到2022年2月份为止仍可以在issue上看到许多bug react的一个插件库 专门用来实现一个SPA应用 基于react的项目基本会用到这个库 脚手架并没有自动帮你下载 react-router-dom npm i react-router-dom@5 首先需要包裹路由，让单页面的所有组件使用统一路由，老师推荐的方式是直接在包裹在渲染APP组件那一块 StartBrowserRouter &amp; HashRouter BrowserRouter使用H5的history API，不兼容IE9以下版本；HashRouter使用URL的哈希值 HashRouter路径带 # 对于BrowserRouter，刷新后state参数能得以保存，但是HashRouter会丢失state参数 HashRouter可以解决一些关于路径问题（可以看路由嵌套小节的路径坑部分） import { BrowserRouter } from 'react-router-dom' //index.js ReactDOM.render( &lt;BrowserRouter> &lt;App /> &lt;/BrowserRouter>, document.querySelector('#root')) 在新建一个router文件，在其中的新建的index.js中引入 + 使用，之后再把这个路由组之间放到app组件即可 import React from 'react' import { BrowserRouter, Route } from 'react-router-dom' import Home from '@/views/home' import List from '@/views/list' export default function Router() { return ( &lt;div> &lt;BrowserRouter> &lt;Route path=\"/home\" component={Home}>&lt;/Route> &lt;Route path=\"/list\" component={List}>&lt;/Route> &lt;/BrowserRouter> &lt;/div> ) } 在Vue中是使用 &lt;router-link&gt;定向路由，而这里则是 &lt;Link to=\"/about\">About&lt;/Link> &lt;Link to=\"/home\">Home&lt;/Link> LinkNavLink 如果想要使得link标签点击完后有高亮效果，可以引入 + 使用 &lt;NavLink&gt;，实际上内部还是 &lt;link&gt;，只是你点击了哪一个 Link，就会自动给该 Link添加一个 样式，类名为active，当然也可以定义类名（使用activeClassName），自定义link标签点击后的样式 （在Vue中是通过定义Router实例LinkActiveClass属性进行自定义类名的） &lt;NavLink activeClassName=\"自定义类名\" to=\"/home\">Home&lt;/NavLink> Link的其他属性的补充 默认push方式进入路由，可以替换成replace：replace={true}，或者直接 &lt;Link replace to=\"/home\">Home&lt;/Link> 插槽 使用上述 NavLink、Link 方法来写路由链接时，有许多冗余的地方，比如多个NavLink使用相同类名、active类名时，有很高的重复性 &lt;NavLink activeClassName=\"自定义类名\" to=\"/home\">Home&lt;/NavLink> &lt;NavLink activeClassName=\"自定义类名\" to=\"/about\">About&lt;/NavLink> &lt;NavLink activeClassName=\"自定义类名\" to=\"/other\">Other&lt;/NavLink> 我们可以自己封装MyLink！(外加小插槽) 标签体内容的接收可以使用插槽，在子组件接收的props里，如果插槽有内容，则自动使用children属性进行接收 &lt;MyLink to=\"/about\" >About&lt;/MyLink> &lt;MyLink to=\"/home\" >Home&lt;/MyLink> 定义封装的子组件 export default class MyLink extends Component { render() { return ( &lt;div> &lt;NavLink className=\"list-group-item\" {...this.props}}>{this.props.children}&lt;/NavLink> &lt;/div> ) } } 实际上，不仅link标签可以以这种方式是用插槽，子组件都可以这样使用，这时父子组件插槽的通用方法 路由匹配模糊匹配和精确匹配 路由匹配遵从模糊匹配，比如下方link的to在匹配路由时，以 /home/a/b 进行匹配 ，Home组件依然能得到展示。 但是一定要按照顺序，比如link 的 to里为 /a/home/b就不可以 &lt;Link to=\"/about\">About&lt;/Link> &lt;Link to=\"/home/a/b\">Home&lt;/Link> &lt;Route path=\"/about\" component={About}>&lt;/Route> &lt;Route path=\"/home\" component={Home}>&lt;/Route> {/* 可以展示 */} 如果想要精准匹配（严格匹配），不要搞模糊匹配，则需要添加 exact 属性（但是这个属性在开发中少用，可能引发一些问题，比如不能开启二级路由，非要用到时才要用） &lt;Route exact path=\"/home\" component={Home}>&lt;/Route> 路由匹配 在进行路由注册时，我们不难发现，如果是进入 /home 路由，则Home、Other组件都会展示 这说明路由匹配完成后还会向下匹配，如果有很多路由，则会逐个匹配，导致效率不高 并且如果使用了 / 路径来重定向，由于模糊匹配，更是会让浏览器无论哪个地址都跳转到重定向的组件 &lt;Route path=\"/about\" component={About}>&lt;/Route> &lt;Route path=\"/home\" component={Home}>&lt;/Route> &lt;Route path=\"/home\" component={Other}>&lt;/Route> 我们可以使用 Switch，用Switch组件包裹所有注册路由，这时匹配到路由后就不会继续向下匹配 import {Switch} from 'react-router-dom'; &lt;Switch> &lt;Route path=\"/about\" component={About}>&lt;/Route> &lt;Route path=\"/home\" component={Home}>&lt;/Route> &lt;Route path=\"/home\" component={Other}>&lt;/Route> &lt;/Switch> 路由重定向 | 404import { Redirect } from 'react-router-dom' 默认网页对于每个路由都不匹配（没有点击Link进行路匹配时），此时我们可以使用 Redirect组件进行重定向，让默认网页跳转到某个路由（Redirect一般写在路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定路由） &lt;Switch> &lt;Route path=\"/home\" component={Home}>&lt;/Route> &lt;Route path=\"/list\" component={List}>&lt;/Route> &lt;Redirect to=\"/home\" /> {/* 谁都匹配不上了就去home */} &lt;/Switch> 如果要配合上用户胡乱写匹配的404页面，则此时 Redirect 最好开启精准匹配，不然无论如何都是会进入 Redirect 指定的路由组件当中去 &lt;Switch> &lt;Route path=\"/home\" component={Home}>&lt;/Route> &lt;Route path=\"/list\" component={List}>&lt;/Route> &lt;Redirect from=\"/\" to=\"/home\" exact /> &lt;Route component={NotFound}>&lt;/Route> &lt;/Switch> 路由嵌套路径坑 如果React直接在路径头嵌套，有可能导致引入文件路径也相对发生错误 &lt;Link to=\"/something/about\">About&lt;/Link> &lt;Link to=\"/something/home\">Home&lt;/Link> &lt;Route path=\"/something/about\" component={About}>&lt;/Route> &lt;Route path=\"/something/home\" component={Home}>&lt;/Route> 原本引入css样式的路径为 &lt;link rel=\"stylesheet\" href=\"./css/bootstrap.css\"> 在切换路由 + F5刷新后路径会随之更改 解决方法一： 改变路径，去掉当前路径 ./，直接 /是去到url的public目录下 &lt;link rel=\"stylesheet\" href=\"/css/bootstrap.css\"> 解决方法二：与上方同理 &lt;link rel=\"stylesheet\" href=\"%PUBLIC_URL%/css/bootstrap.css\"> 解决方法三：使用HashRouter 因为它有一个锚点 #，这样子发送请求时会忽略 #后面的相关哈希值（路由） 路由嵌套二级路由 和Vue一样，使用多重路由嵌套只需在路由组件里，再放置路由组件（Link + Route 组合），切记，这里和Vue一样，link里的to必须要写完整路径（带上父级路由），这样子计算子路由组件未显示，路由也能遵从模糊匹配至少展示一级路由的页面效果 比如在我们home组件内 {/* 这里需要给完整的路径， 不能直接to=\"/news\" */} &lt;MyLink to=\"/home/news\">News&lt;/MyLink> &lt;MyLink to=\"/home/messages\">Messages&lt;/MyLink> {/* 路由注册 */} &lt;Switch> &lt;Route path=\"/home/Messages\" component={Messages} /> &lt;Route path=\"/home/News\" component={News }/> &lt;Redirect to=\"/home/Messages\" /> &lt;/Switch> 但是实质上仍有一个bug，就是在url地址栏，单单输入一级路由的地址，就只会出现一级路由的组件，嵌套路由的组件全部消失 路由传参传递参数主要有两种类型：params和query（同Vue） params：需要在Route里进行声明（只有params才需要声明接收参数），然后在Link中跳转url的时候记得带上参数就好了 在Route通过/路径/:自定义参数名来声明 &lt;Route path=\"/home/Messages/Detail/:id/:title\" component={Detail} /> return ( &lt;div> &lt;ul> { messageArr.map(item => { return ( &lt;li key={item.id}> {/* 向路由组件传递params参数 */} &lt;Link to={`/home/Messages/Detail/${item.id}/${item.title}`}>{item.title}&lt;/Link> &lt;/li> ) }) } &lt;/ul> &lt;/div> ) 此时你查看子路由组件 Detail 的 props上接收的参数会有所变化，稍稍查看可得知，在this.props.match.params可找到你传递的参数 search传参 search传参的方式实际上也就是query参数 无需在Route里进行声明 messageArr.map(item => { return ( &lt;li key={item.id}> {/* 向路由组件传递search参数 */} &lt;Link to={`/home/messages/detail/?id=${item.id}&amp;title=${item.title}`}>{item.title}&lt;/Link> &lt;/li> ) }) 此时你查看子路由组件 Detail 的 props上接收的参数会有所变化，稍稍查看可得知，在this.props.location.search可找到你传递的参数 可是！ 但是参数的形式是 “?id=01&amp;titile=message1” 对于query参数 ：key=value&amp;key=value其实是一种叫urlencoded的编码形式 我们可以使用React脚手架帮我们下载好的库 querystring直接转换 import qs from 'querystring' qs.stringify(obj)//对象转urlencoded qs.parse(str)//urlencoded转对象 然后我们可以进行正式的格式转换了 const { search } = this.props.location; const { id, title } = qs.parse(search.slice(1)); //截取掉开头的\"?\" console.log(this.props, id, search); 会不会感觉有点像json和string的相互转换？： JSON.stringify(对象) JavaScript 值(对象或数组)转换为 JSON 字符串 JSON.parse(data) 字符转对象 state传参 这个是路由组件独有的状态，和一般组件里的state是不一样的 state传参你在url地址栏是看不到的，而params和search传参在地址栏可以看到明显的改变 无需在Route里进行声明 messageArr.map(item => { return ( &lt;li key={item.id}> {/* 向路由组件传递state参数 */} {/* to要写成一个对象的形式 */} &lt;Link to={{ pathname: '/home/messages/detail', state: { id: item.id, title: item.title } }}>{item.title}&lt;/Link> &lt;/li> ) }) （Maybe你会发现和Vue的query传参有点像？） 此时你查看子路由组件 Detail 的 props上接收的参数会有所变化，稍稍查看可得知，在this.props.location.state可找到你传递的参数 虽然使用state传参方式，刷新页面不会丢失参数（实际上是因为history对象帮你缓存了），但是如果你强行清除缓存，在接收时就会“不见了” 编程式路由替换link在不借助 Link的条件下进行路由切换，自己定义函数进行跳转切换，这种方式叫做编程式路由导航 感觉有点像Vue中对router-link原理的延伸 ：this.$router.push(&quot;/home&quot;); 记得编程式路由传参的时候，使用params的方式，Route要声明参数（上面路由传参部分有讲述到） //编程式路由导航 + params传参 replaceCheck = (id, title) => { return () => { this.props.history.replace(`/home/messages/detail/${id}/${title}`); } } //编程式路由导航 + query传参 pushcheck = (id, title) => { return () => { this.props.history.push(`/home/messages/detail?id=${id}&amp;title=${title}`); //this.props.history.push(\"/home/messages/detail?\", query: {id: id, title: title}); } } //编程式路由导航 + state传参 pushcheck = (id, title) => { return () => { this.props.history.push(`/home/messages/detail`, {id:id, title:title}); } } 同样的，如果想实现网页前进 + 后退功能；也可以使用 this.props.history.goForward()、this.props.history.goBack() 对于函数式组件，可以通过组件接收的props，通过 props.history.push()来跳转路由，还可以通过history Hook来跳转 V6之后是useNavigate import { useHistory } from 'react-router-dom' export default function Index(){ const history = useHistory(); const pushcheck = () => { return () => { history.push(`/home/messages/detail?id=${id}&amp;title=${title}`); } } } withRouter一般组件和路由组件 上方阐述的是路由组件的使用，他们有各自的不同之处 1.一般组件直接使用，路由组件通过路由 link切换，然后依靠路由（&lt;Route component=xxx&gt;）匹配决定渲染哪一个 2.一般组件如果父组件没传props，则收到空对象，路由组件默认会接收到props：history、location、match 3.传参方式不一样，一般组件直接属性传值，props接收，路由组件有三种传参方式 上方讲述了许多关于路由组件的api，但是这些都仅限于路由组件，如果想要在一般组件使用，可以使用到 withRouter withRouter(一般组件) 就会添加上路由组件身上特有的三个属性：history、location、match！ import { withRouter } from 'react-router-dom' class Header extends Component{ // } export default withRouter(Header); 路由守卫同vue，用于拦截每一次路由跳转之前的一次回调函数，使用方法： &lt;Route path=\"home\" render={() => &lt;Home />}>&lt;/Route> //实质上，这个写法和&lt;Route path=\"/home\" component={Home}>&lt;/Route>一样 此时，只需要我们在render的函数里写上自己需要的拦截逻辑即可 &lt;Route path=\"/\" render={() => 是否授权 ? (&lt;SandBox />) : (&lt;Redirect to=\"/login\" />); }>&lt;/Route> 但是此时传入的组件是被当做普通组件来使用，并不是路由组件（不会带上路由组件的api），我们可以通过render带的props参数放入组件中（或者在组件导出的时候直接报过withRouter），此时组件就可以使用路由组件的api了 &lt;Route path=\"home\" render={(props) => { 是否授权 ? &lt;Home {...props}/> : &lt;Redirect to=\"/login\"/> }>&lt;/Route> 在vue中，他有自己一套严格的路由拦截体系，但是在react只是这种简单的，实质上压根没有拦截这个概念 不过咋v6之后，可以直接传，不用render &lt;Route path=\":userId\" element={&lt;Profile animate={true} />} /> keep-alivereact中没有类似于vue router 的 keep alive功能，keep alive用于缓存之前页面打开的组件数据和内容 曾经有人在官方提过功能 issues ，但官方认为这个功能容易造成内存泄露 keep-alive的库推荐： 早期的react-keep-alive 原理： 使用React.createPortal API实现了这个效果。 缺点： 这个库存在断层现象，虽然可以缓存最后一次状态渲染结果，但是后面数据变化无法再进行数据驱动。而且是借助React.createPortal 借助实现 总体来说，react-keep-alive这个库比较重，实现原理也不难，就是笨重，断层，源码跳来跳去，真的理清楚了就好 现在：react-activation 原理 抽取children属性，再封装一次HOC高阶组件即可。 建议关注 React 18.x 中的官方实现 &lt;Offscreen /&gt; 参考：https://segmentfault.com/a/1190000023263395 参考：https://github.com/CJY0208 7.React UI库material-ui（国外） 官网：https://material-ui.com/zh/ GitHub：https://github.com/mui-org/material-ui ant-design（国内蚂蚁金服）（推荐） 官网：https://ant.design/index-cn GitHub：https://github.com/ant-design/ant-design 下载antd npm i antd --save 在引入的时候，不要忘记也要引入 antd/dist/antd.css（官网显示代码居然没有提示要引入css），不过最好要按需引入，import &#39;antd/dist/antd.css&#39;加载了全部的 antd 组件的样式 。 不过现在好像结合webpack的tree shaking，自动按需引入了，不用管 此时我们可以进入官网 -&gt; 文档-&gt; 在create-react-app -&gt;高级配置中使用进行查看（看不到就看3.x版本） 假如我只是用了Button组件 //引入Button组件 import { Button } from 'antd' import 'antd/dist/antd.css' Vue的话推荐使用element-UI库，后面反响不错，也出了react的UI 关于eject之后antd的主题颜色配置由于私自eject了，官网没有相关eject后的主题配置的代码，在网上翻来覆去，终于找到真正合适的文章 https://blog.csdn.net/f980815/article/details/109385835 对于React Native的按需导入，还得再babel.config.js进行配置 npm i ant-design/react-native module.exports = { presets: ['module:metro-react-native-babel-preset'], // 按需加载 \"plugins\": [ [\"import\", { libraryName: \"@ant-design/react-native\" }] // 与 Web 平台的区别是不需要设置 style ] }; 8.reduxredux是一个专门做状态管理的JS库（集中式管理） 它可以在React、Angular、Vue等项目中，但基本和React配合使用 作用：集中式管理react应用中多个组件共享状态 当需要大量共享可以使用，但是能不用就不用，毕竟是全局的东西 （实际上有点像Vuex，Vue人家就很少用这个，用自己内部的Vuex） 以上为redux原理图 redux三个核心概念 action 有同步action （sync）和异步action （async） 动作对象 包含两个属性： type：标识属性，值为字符串，唯一，必要属性 data：数据属性，任意类型，可选属性 reducer Reducers不仅能加工状态（加工状态那么部分有点像Vue里的mutations），还能初始化状态 加工时，根据旧的state和action，产生新的state纯函数 在初始化时，reducer得到的previousState、action分别为 undefined、type:&#39;@@init&#39; + 随机字符,data: 无 store 将state、action、reducer联系在一起的对象，负责对外暴露 基本使用初始化 npm i redux 新建一个redux文件夹 新建 store.js 新建一个处理xxx组件的 xxx-reducer.js 可选，新建一个处理xx组建的xxx-action.js 建立storestore.js是专门用于暴露一个store对象，整个一应用只有一个store对象，配合redux的createStore API 可以创建一个store对象 //store.js //createStore专门用于创建store对象 import { createStore } from 'redux' // 引入reducer import countReducer from './count_reducer' // 暴露store export default createStore(countReducer) createStore 第一个参数传入reducer 第二个参数可选，传入state的默认状态，当然state的默认值也可以通过给reducer的第一个参数赋值上默认值来确定 关于store的小bug由于全局状态store是保存在内存中的，如果刷新当前页面，则我们之前通过action调用reducer对store做的修改都从零开始 建立reducer这里我模拟一个处理count数据的reducer xxx_reducer.js是用于创建一个为Count组件服务的reducer，reducer的本质就是一个函数，reducer函数会接到两个参数，分别为：之前的对象preState、动作对象action // reducer用于最基本的数据处理，是一个纯函数，其实是为了diff算法 const initState = 0; //如果你要存多个数据，可以初始化成一个对象 export default function countReducer(preState = initState, action) { console.log(preState); const { type, data } = action; let newState = preState; switch (type) { case 'increment': return newState + data * 1; case 'decrement': return newState - data * 1; default: // 不加也不减，说明是初始化 return newState } } 在面对多人开发时，如果只用一个reducer，可能会堆积大量的状态，我们可以拆分reducer函数 import { combineReducers, createStore } from 'redux' import CityReducer from './reducer/CityReducer' import TabbarReducer from './reducer/TabbarReducer' const reducer = combineReducers({ CityReducer, TabbarReducer }) export default createStore(reducer) 而此时我们获取Store的时候，不能直接通过 getState，需要 console.log(store.getState().CityReducer) console.log(store.getState().TabbarReducer) 关于reducer的小bug 在redux底层会做一个判断，如果返回的东西，和之前的preState是一样的，那就不会进行页面更新。 注意redux的reducer必须是一个纯函数（纯函数的概念我在ES5篇章有提及到） 而对比vue，由于他用的是代理，所以复杂数据类型怎么改也不会影响到原来的数据 export default function personReducer(preState = initState, action) { const { type, data } = action; switch (type) { case ADD_PERSON: // 做了一个浅比较，返回的preState的地址值和之前的是一样的，那就不进行页面更新了 //错×：preState.unshift(data); return preState; return [data, ...preState] default: return preState; } } 所以可以在React、Redux里面，我们很少使用push、unshift这些数组方法，而且这样会导致函数不再是纯函数了。 关于store的更新// 引入store，用于获取redux中保存的状态 import store from '../redux/store' //可以直接获取store存储的数据 console.log(store.getState()) 这里我直接在组件内自定义increment函数模拟action向store发送更改 数据的类型type 和 传入的数据data increment = () => { const { value } = this.selectNumber; // dispatch传入type和data store.dispatch({ type: 'increment', data: value }); } 但是平时我们使用setState会自动帮我们调用一次render更新页面，但是store更新没有调用render 解决方法一：在组件内，在componentDidMount生命周期钩子后使用 redux 带的 subscribe API ，用于订阅状态更改，监听store数据的变化，发生变化则执行传入的回调函数（ this.setState({}) -&gt; render ） // DOM挂在完毕后，监听redux中状态的变化，只要变化就调用render componentDidMount() { store.subscribe(() => { //虚晃一枪，让它帮我们调用一次render（自己调用this.render不管用） //不过我感觉使用forceUpdate()好像也行 this.setState({}); }) } 如果是hook组件，则 useEffect(() => { const unSubscribe = store.subscribe(() => { setState(store.getState()) }) return () => { unSubscribe() } }, []) 但是这种订阅方式，必须让组件销毁时，将其也取消订阅，不然会重复订阅，因为store.subscribe不会随着组件被销毁而消失，而是默默保存在redux的内部订阅者数组中 store.subscribe会返回一个函数，该函数时取消订阅的（在类式组件中可以在 componentWillUnmount 中取消订阅 ） useEffect(() => { const unSubscribe = store.subscribe(() => {}) return () => { unSubscribe() } }, []) 解决方法二：对于整个组件，直接用redux 带的 subscribe API 进行包裹，（这里老师说有了diff算法，实际上整体性能影响不会特别大） //ReactDOM.render(&lt;App />, document.querySelector('#root')); store.subscribe(() => { ReactDOM.render(&lt;App />, document.querySelector('#root')) }) 解决方法三：使用react-redux 补充Action此时可以补充action提交修改：向store发送更改 数据的类型type 和 传入的数据data 在redux文件夹下创建xxx_action.js，导出action方法 export const createIncrementAction = data => ({ type: 'increment', data }); export const createdecrementAction = data => ({ type: 'decrement', data }); 然后可以直接在组件中导入 + 使用，可以像官方redux原理图一样，不需要自己来 向store发送更改 数据的类型type 和 传入的数据data 和Vue一样，开发时定义常量是减少错误的基本方法（实际上也是防止单词写错） 然后再组件中使用Action方法 import { createIncrementAction } from '../redux/count_action' increment = () => { const { value } = this.selectNumber; // dispatch为action传入参数 store.dispatch(createIncrementAction(value)); } async Actionaction可以为对象（type、data属性），也可以为函数 我们返回一个函数，把异步操作存放在这个函数里，再调用同步action（异步Action中一般都会调用一个同步action），由此形成一个异步操作， 因为store只认action作为一个对象来返回，此时我们需要用到一个中间件，让store愿意接收一个函数，并且调用它：（即使我们在异步action中写明了直接return对象，但是也由于异步的原因，函数体执行完毕了，直接返回一个undefined） 除了redux-thunk之外，redux-promise中间件也是一种实现异步action的方式，直接返回一个promise npm i redux-thunk 然后再store.js里 //store.js //applyMiddleware为store使用中间件的API import { createStore, applyMiddleware } from 'redux' // 引入reducer，thunk为接收函数式action必须的中间件 import Reducer from './reducer' import thunk from 'redux-thunk' // 暴露store， export default createStore(Reducer, applyMiddleware(thunk)) 然后在action.js这个文件里定义异步action（作为一个函数返回，经过中间件的处理，接收一个dispatch方法，可帮助你调用同文件下的同步action方法） export const asyncIncrement = (data) => { return (dispatch) => { setTimeout(() => { dispatch(createIncrementAction(data)) }, 1000); } } 在组件中使用： import store from '../redux/store' import {asyncIncrement } from '../redux/count_action' store.dispatch(asyncIncrement(value, 500)); 异步action：它不是一个必须的东西，实际上我们可以在自己的组件函数里定义异步操作，只是当你不想要把异步操作放在组件里是，可以使用以上异步action方法 redux-thunk原理 export default function thunkMiddleware({ dispatch, getState }) { return (next) => (action) => typeof action === \"function\" ? action(dispatch, getState) : next(action); } redux-sagaredux-saga解决异步actions问题 maybe看不惯了把原来作为对象的action变成了其他形式，于是后面出了一个redux-saga，其原理是使用了生成器（generator） 在saga中，全局监听和接收器使用Generator函数和saga自身一些辅助函数实现对整个流程的管控 npm i redux-saga 在redux下新建一个saga.js文件 import { take, fork, call, put } from \"redux-saga/effects\"; /* function* watchaSaga() { while (true) { //take监听组件 yield take(\"getList\"); //fork同步执行异步处理函数(非阻塞式) yield fork(GetList); } } */ //watchSaga另外一种写法 function* watchaSaga() { yield takeEvery(\"getList\", GetList) } function* GetList() { // 异步处理 //call函数发异步请求,传入一个返回值为promise对象的函数，阻塞式调用 let res = yield call(asyncGetList); // put函数发出新的action yield put({ type: \"changeList\", payload: res, }); } function asyncGetList() { return new Promise((res, rej) => { setTimeout(() => { res(\"返回结果\"); }, 2000); }); } export default watchaSaga; 此时在store.js中，嵌入中间件，并且在导出store之前调用watchSaga进行实时监听 import { createStore, applyMiddleware } from \"redux\"; import createSagaMiddleWare from \"redux-saga\"; import countReducer from \"./reducer\"; import watchSaga from \"./saga\"; // 和redux-thunk一样，都要套入中间件 const SagaMiddleWare = createSagaMiddleWare(); const store = createStore(countReducer, applyMiddleware(SagaMiddleWare)); SagaMiddleWare.run(watchSaga); export default store; 然后再reducer中照常监听dispatch传过来的type和payload interface IAction { type: string; payload?: any; } interface IPreState { isShow: boolean; list: string; } export default function countReducer( preState: IPreState = { isShow: true, list: \"\", }, action: IAction ) { const { type, payload } = action; let newState = preState; //... switch (type) { case \"changeList\": console.log(\"enter changelist\"); newState.list = payload; return newState; default: return preState; } } 最后在组件中使用时，直接dispatch在saga.js中监听的type store.dispatch({type: 'getList', payload: 'nothing'}) （大火看到redux-thunk的好了吧？。。） 小redux个人小小小版redux赏析 function createStore(reducer, initialState = {}) { //用于存放订阅者 const list = []; let state = reducer() | initialState; function subscribe(callback) { list.push(callback); } function dispatch(action) { reducer(state, action); for (let i in list) { list[i] &amp;&amp; list[i](); } } function getState() { return state } return { subscribe, dispatch, getState, }; } 9.react-reduxfacebook为了让开发人员更加舒服使用redux，开发了react-redux （其实我个人觉得可以理解为，react让组件和redux之间的交互多了一个中间人（套了个外壳）：container，使得我们以后都不需要关心订阅和取消订阅的问题） 可以看得出外面要了一层容器，防止UI组件直接对接redux components文件夹存放的是UI组件（不能使用任何的redux API，只负责页面的呈现） 我们要创建一个container的文件夹，然后新建一个容器组件，容器组件作为UI组件 和 react-redux的桥梁，不能直接rcc自定义组件，而是使用react-redux库创建。 npm i react-redux 连接UI连接UI组件的方式：新建一个containers文件夹，index.jsx文件 // 引入CountUI组件,CountUI组件为components文件夹下的自定义组件 import Count from '../../components/Count' // 引入connect用于连接UI组件和redux import { connect } from 'react-redux' // 使用connect()()创建并且暴露一个Count容器组件 export default connect()(Count) 亦或者在导出UI组件的时候，直接 import { connect } from 'react-redux' export default connect()(组件名) 连接store此时把原来引入UI组件替换成容器的自定义组件 连接store的方式：在app组件使用容器组件时，通过定义属性props方式对 Count 容器 传入store（之前是导入 store后 ，通过 store.getState()获取数据的 ） import React, { Component } from 'react' //import Count from './components/Count' //现在不需要在app.jsx文件里直接导入UI组件 import Count from './containers/Count' //而是需要导入container组件 import store from './redux/store' export default class App extends Component { render() { return ( &lt;div> &lt;Count store={store} /> &lt;/div> ) } } 优化 连接store的方式为 在组件中传入store作为props属性&lt;Count store={store}，如果多个容器组件，岂不是要一个一个传？不用，react-redux里有个 Provider组件，用 provider组件 将外壳app组件包裹住，则在整个应用里面，但凡需要store的容器组件，都会传过去 //总的index.js文件 import React from 'react' import ReactDOM from 'react-dom' import App from './App' import { Provider } from 'react-redux' import store from './redux/store' //此处使用Provider，使得APP的所有后代容器组件都能接收store ReactDOM.render( &lt;Provider store={store}> &lt;App /> &lt;/Provider>, document.querySelector('#root')); 此时我们在ui组件可以直接通过props接收 connect的第一个参数可以接收一个回调函数（mapDispatchToProps），回调函数则会传入store的数据作为参数，在回调函数返回值中，亦可以自定义一些props的参数 import { connect } from 'react-redux' function Index(props) { console.log(props.isShow) } export default connect((state) => { return { a: 1, isShow: state.TabbarReducer.show } })(Count) 容器和UI的交互由于容器组件的创建比较不走寻常路，所以它传递给子组件（UI组件）props的方式也有点不寻常 在连接UI组件时使用到的connect API，可以传入两个参数，并且得传两个函数（mapStateToProps函数、mapDispatchToProps函数）作为参数 。（在上方react-redux模型图可以看到第一个参数传状态，第二个参数传方法） mapStateToProps（函数） 1.mapStateToProps函数的返回值是一个对象2.作为状态(key: value 组合的对象)传递给UI组件3.通过props传入store，使得第一个参数的函数默认传入store的state状态作为参数（state = store.getState()） mapDispatchToProps（函数） 1.mapDispatchToProps函数的返回值是一个对象2.作为操作状态的方法（key: func 包含函数的对象）传递给UI组件3.通过props传入store，使得第二个参数的函数默认传入store的dispatch方法，直接使用dispatch告诉action你要执行的事件 //count组件的父容器的index文件 // 引入CountUI组件 import CountUI from '../../components/Count' // 引入connect用于连接UI组件和redux import { connect } from 'react-redux' // 引入redux中的action提交对状态的修改 import { createIncrementAction, asyncIncrement, createdecrementAction } from '../../redux/count_action' function mapStateToProps(state) { return { count: state } //假如state = 900,相当于正常父子组件传值 &lt;CountUI count={900}> } function mapDispatchToProps(dispatch) { return { increment: (number) => { dispatch(createIncrementAction(number)) }, decrement: (number) => { dispatch(createdecrementAction(number)) }, asyncIncrement: (number, time) => { dispatch(asyncIncrement(number, time)) } } } export default connect(mapStateToProps, mapDispatchToProps)(CountUI) 然后我们在子组件（UI组件），就可以直接通过props.xx获得传入的状态/修改状态的方法，对子组件进行操作修改 优化： .对于上述mapDispatchToProps 的精简写法： 在写mapDispatchToProps部分的时候，react-redux会帮你做一个自定分发的动作（自动dispatch） 也就是判断当前是否为action，如果是就自动跑分发dispatch的逻辑；如果不是按照以往的代码逻辑执行 export default connect( state => ({count:state}), //原本mapDispatchToProps函数变成一个对象（key: action） { increment: createIncrementAction, decrement: createdecrementAction, asyncIncrement: asyncIncrement, } )(CountUI) //ui组件中使用 const { count } = this.props; increment = () => { const value = parseInt(this.selectNumber.value); this.props.increment(value); } 我们自己对文件的优化： 由于每个UI组件为了对接redux存储的状态，都会多一个容器组件，导致文件量成倍增长。 所以我们可以自己把容器组件和UI组件写在同一个jsx文件里，对外暴露容器组件 react-redux原理connect是HOC，高阶组件 Provider组件，可以让容器组件拿到state，使用了context 小react-readux的connect function myConnect(mapStateToProps, mapDispatchToProps) { return (myComponent) => { return (props) => { return &lt;div> &lt;myComponent {...mapStateToProps} {...props} {...mapDispatchToProps}>&lt;/myComponent> &lt;/div> } } } 10.其他Redux DevTools这里顺便推荐一下redux的相关开发者工具：Redux DevTools（这个工具很顶阿！）（React的开发者工具React Developer Tools也推荐安装），在谷歌商店添加拓展插件即可 但是使用这个工具还得安装拓展库 npm i redux-devtools-extension 别忘了还要再store.js文件中导入 + 使用 可以在官网查看https://github.com/zalmoxisus/redux-devtools-extension 关于react-redux数据持久化，可以使用redux-persisthttps://github.com/rt2zz/redux-persist immutable除此之外，我在《JavaScript进阶ES5》中还提及到关于很适用于reducer纯函数系列的js库 immutable.js，它的实现原理是persistent data structure（持久化数据结构），也就是使用旧数据创建新数据时，保证旧数据同时可用且不变，同时避免了deepcopy把所有的节点都复制一遍带来的性能损耗，immutable使用了structural sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受他影响的父节点，则其他节点进行共享 具体使用 npm i immutable immutable对数组偏爱，可以直接让List当数组来使用，一般都可以调用数组上的所有方法，包括map、filter、shift之类的 import { Map, List } from 'immutable' const obj = { name: \"allen\", age: 18 } const arr = [] const oldImmuObj = Map(obj) //转化为一个不可变对象 const oldImmuArr = List(arr) //转化为一个不可变对象，数组用List，对象用Map const newImmuObj = oldImmuObj.set(\"name\", \"Mikasa\")//此时新值的改动不会影响到老的值 const newImmuArr = oldImmuArr.push(1)//数组直接改就好了 在 immutable这种不可变对象中，获取属性值可以使用 get方法直接获取 oldImmuObj.get(&quot;name&quot;) 不可变对象再转换回普通对象 oldImmuObj.toJS() 数组不可变对象转换回数组 oldImmuArr.toJS() 如果数据类型更加复杂了，还得往里面继续包裹，才能打造成那种拷贝后仍共享的结构 import { Map } from 'immutable' const a = Map({ name: \"allen\", hobbies:Map({ name: 'killing' }) }) 既然如此，每一次复杂数据类型都要包裹一次这么麻烦干嘛还要用它？有什么意义？ 比如上方的name给组件A使用，如果name发生改变，shouldComponentUpdate应该返回true；而hobbies给组件B用，通过自己写代码（用if语句）判断无变化，让shouldComponentUpdate返回false，避免了diff重复对比（不过我个人感觉这有点太忒麻烦。。。） 除了每一次对复杂数据类型使用 Map、List包裹，还能使用fromJS，直接深度遍历，一次性转换好 它的效果和使用Map、List一层一层包裹是一样的 import { fromJS } from 'immutable' const a = fromJS({ name: \"allen\", hobbies:{ name: 'killing' } }) 修改深层属性值的时候使用 setIn 方法 a.setIn([\"hobbies\", \"name\"], 'swimming') 修改数组的话是这样 arr.updateIn([\"favor\"], (list) => list.splice(index, 1)) 此时再结合reducer，这样的话react UI部分就不用修改了 export default function Reducer(preState = { name: \"allen\", hobbies:{ name: 'killing' } }, action) { const { type, data } = action; const newState = fromJS(preState) switch (type) { case \"changeHobbies\": return newState.setIn([\"hobbies\", \"name\"], 'swimming').toJS() default: return preState; } }","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Vue(下)","slug":"Vue(下)","date":"2021-03-21T16:00:00.000Z","updated":"2022-08-14T06:56:22.184Z","comments":true,"path":"2021/03/22/vue-xia/","link":"","permalink":"https://taylor12138.github.io/2021/03/22/vue-xia/","excerpt":"","text":"7.其他事件总线事件总线和vuex的作用很像，只不过vuex用于管理状态（变量），而事件总线用于管理事件，利用事件传参（感觉vuex有点面向受控组件，而eventbus面向非受控组件） 1.在main.js 文件中 创建一个新的Vue实例，以得到一个bus Vue.prototype.$bus = new Vue(); 2.发射 this.$bus.$emit(&#39;事件名&#39;[, 参数]) 3.接受 this.$bus.$on(&quot;事件名&quot;, 回调函数(参数)) 4.可以在deactivated里设置离开时不接受该事件的传递（取消全局事件监听）：this.$bus.$off(&quot;事件名&quot;, 接收时的回调函数(参数));，回调函数要和接收时发生的回调函数保持一致 provide / inject可以理解为祖父与孙子组件们的通信方法 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文（Context）特性很相似。 provide 选项（option）应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项（option）应该是： 一个字符串数组，或 一个对象，对象的 key 是本地的绑定名，value 是： 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或 一个对象，该对象的： from property 是在可用的注入内容中搜索用的 key (字符串或 Symbol) default property 是降级情况下使用的 value 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。 // 父级组件提供 'foo' var Provider = { provide: { foo: 'bar' }, //也支持写成一个函数，此时才可以使用this：provide(){ return { foo: 'bar' } } } // 子组件注入 'foo' var Child = { inject: ['foo'], created () { console.log(this.foo) // => \"bar\" } // ... } 既然不是响应式的，那如果用到需要响应式怎么办？！！ 常规做法 var Provider = { data(){ return { foo: 'bar' } }, provide: { fooProvide: this.fooFn // 传递一个引用类型函数过去 }, methods:{ fooFn() { return this.foo } } } 其他做法： 配合上计算属性computed var Provider = { provide() { return { length: computed(() => this.names.length).value; //computed返回的是一个ref对象，如果拿到值必须得.value } } } mixin（混入）Vue中相同逻辑的代码如何抽离？ 为了减少两个对象之间重复的代码，Vue官方提供了 minxin（较少类重复的代码可以用es6的继承） 全局混入 mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。 Vue.mixin({ beforeCreate() { // ...逻辑 // 这种方式会影响到每个组件的 beforeCreate 钩子函数 } }) 拓展组件的局部混入 var mixin = { created: function () { console.log(1) } } var vm = new Vue({ created: function () { console.log(2) }, mixins: [mixin] }) // => 1 // => 2 mixin合并规则： 比如Mixin对象中选项和组件对象中的选项发生冲突时 如果是data，则选择组件对象中的选项 如果是生命周期，则会把两者（生命周期函数）都放在一个数组里，等到合适的生命周期拿出来，都调用（都会执行） 如果是对象类型（比如methods、components、watch等），将被合并成一个对象 如果对象的key相同，则会选择组件对象的键值对 （理论上合并，都会执行，实际上有冲突还是选择组件对象） Vue插件机制插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制，一般有下面几种： 添加全局方法或者 property。如：vue-custom-element 添加全局资源：指令/过滤器/过渡等。如 vue-touch 通过全局混入来添加一些组件选项。如 vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router 而使用插件的操作，需要你在调用 new Vue之前实现 // 调用 `MyPlugin.install(Vue)` Vue.use(MyPlugin) new Vue({ // ...组件选项 }) Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。 而在use的时候（安装插件的时候），会调用install方法和vue混入机制 export function install (_Vue) { if (Vue &amp;&amp; _Vue === Vue) { if (process.env.NODE_ENV !== 'production') { console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) } return } Vue = _Vue applyMixin(Vue) } 在beforeCreate钩子函数前进行混入vuexInit（mixin） // 混入机制 Vue.mixin({ beforeCreate: vuexInit }); function vuexInit () { const options = this.$options // store injection if (options.store) { this.$store = typeof options.store === 'function' ? options.store() : options.store } else if (options.parent &amp;&amp; options.parent.$store) { this.$store = options.parent.$store } } 自定义插件正常情况下，我们都可以使用组件完成对应的模块功能，使用组件需要 1.在模板中引用 2.引入模块 3.组件的components中声明 但是如果想要在该组件完成固定功能，可能还需要 4.声明对应的data 5.写入对应的方法 6.组件之间传递变量 4、5、6步骤如果放在不同的组件使用一样的功能，可能要声明很多次，这时我们可以使用插件来简化（降低耦合）操作 下面以制作 Toast 自定义插件为例子（冒泡提示插件） 先建立toast组件 &lt;template> &lt;div class=\"toast\" v-show=\"isShow\"> {{ message }} &lt;/div> &lt;/template> &lt;script> export default { name: \"Toast\", data() { return { message: \"\", isShow: false, }; }, methods: { //duration时间间隔默认2s showMessage(message, duration = 2000) { this.message = message; this.isShow = true; setTimeout(() => { this.isShow = false; this.message = \"\"; }, duration); }, }, }; &lt;/script> &lt;style scoped> &lt;/style> 在toast组件的文件夹下，新建index.js文件 //引入toast组件 import Toast from \"./Toast\"; const obj = {}; // 可以选择传进来一个Vue，对Vue对象进行操作 obj.install = function (Vue) { // 1.创建组件构造器（在vue外面使用组件就要用到组件构造器） const toastConstructor = Vue.extend(Toast); // 2.使用new的方式创建组件对象 const toast = new toastConstructor(); // 3.将组件对象挂载到某元素上,和组件使用也一样，内部也调用了$mount()进行挂载 toast.$mount(document.createElement('div')); // 4.toast.$el 对应的就是 div document.body.appendChild(toast.$el); // 5.设置prototype之后，以后调用插件方法只需要$toast即可 Vue.prototype.$toast = toast; } export default obj 在全局的main.js中使用该插件 import toast from \"@/components/common/toast\" Vue.use(toast); 这时我们就可以再各个组件中直接使用该插件了（此时只需要执行以下代码，即可出现冒泡提示） this.$toast.showMessage(\"你想要输入的信息\", 2000); //2000为自定义的时间间隔 Vue.nextTick[Vue.nextTick( [callback, context] )] Vue中DOM更新是异步的，而nextTick在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 // 修改数据 vm.msg = 'Hello' // DOM 还没有更新 Vue.nextTick(function () { // DOM 更新了 }) // 作为一个 Promise 使用，如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise Vue.nextTick() .then(function () { // DOM 更新了 }) 主要应用：需要注意的是，在 created 和 mounted 阶段，如果需要操作渲染后的视图，也要使用 nextTick 方法。 官方文档说明： 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted vue图片懒加载可以使用vue-lazyload插件 $ npm i vue-lazyload -S （在main.js里）引用时可以传递一些想要的参数，比如加载前的图片显示等 import VueLazyload from 'vue-lazyload' Vue.use(VueLazyload) Vue.use(VueLazyload, { preLoad: 1.3, error: errorimage, loading: loadimage, attempt: 1 }) 安装和引用之后，将原来的 &lt;img :src=&quot;img.src&quot; &gt; –&gt; &lt;img v-lazy=&quot;img.src&quot; &gt;即可 Vue和React相同之处： React与Vue存在很多相似之处，例如他们都是JavaScript的UI框架，专注于创造前端的富应用。不同于早期的JavaScript框架“功能齐全”，Reat与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。 Vue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了’Virtual DOM’（虚拟DOM），如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM，这样可以减少开销；当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。 不同之处： React与Vue最大的不同是模板的编写。Vue鼓励你去写近似常规HTML的模板（template），写起来很接近标准HTML元素，只是多了一些属性，然后用类似于Angular风格的方法去动态输出内容；而React推荐你使用 JSX 来写模板，JSX只是JavaScript混合着XML语法，有部分人使用起来会觉得很畅快。值得一提的是，与React一样，Vue在技术上也支持render函数和JSX，但只是不是默认的而已 在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理，而Vue提供响应式的数据，当数据改动时，界面就会自动更新；React的数据使用state对象（状态）保存，在React中你需要使用setState()方法去更新状态 （我在观看视频老师对比React and Vue的时候看到的结果（虚拟DOM与DOM Diff 的原理，作者饥人谷，第二集））在测试插入10w个div标签的时候，DOM的原生渲染速度是大概2s；React的速度大概接近30s；Vue竟然是接近原生DOM，1s-3s 自我学习感受，React很多操作要比Vue麻烦（可能也是因为不熟练），学习React有扎实的JS基础要求 原生和框架详情可以见尤大大的答案https://www.zhihu.com/question/31809713/answer/53544875 Vue常见性能优化 不要把所有数据放在data，data的数据会增加 getter 和 setter，会收集对应的 watcher vue在v-for时给每项元素绑定事件需要用事件代理 SPA采用keep-alive 拆分组件，减少耦合度，提高维护度 合理分配 v-if 和 v-show key保证唯一性 Object.freeze 冻结数据 合理使用路由懒加载 尽量采用 runtime运行时版本 合理运用防抖节流 8.ElementElement，一套为开发者、设计师和产品经理准备的基于 Vue 的桌面端组件库 详情可以去官方文档进行学习 Element-ui 的validate方法validate() 是elment-ui封装好的用于对整个表单进行验证，若不传入回调函数，则会返回以promise =&gt; Function(callback : Function(boolean,obj))，当第一个参数位true，则校验通过 Element组件时样式修改的问题通常在vue组件样式中添加scoped，该组件样式只能够在本组件才能执行，这样我们就无法更改Element组件样式了。 如果我们取消了scoped的话，全局的样式有可能就会发生冲突。 解决方法是： 如果使用style修改样式，可以添加 &gt;&gt;&gt;的前缀 如果使用sass或者less修改样式，可以添加/deep/的前缀 思路提供：https://zhuanlan.zhihu.com/p/58942147 9.原理相关双向绑定Object.defineProperty( )的 get （读取属性值触发的函数）和 set（set就是在设置属性值触发的函数），所以Vue会根据数据变化，重新渲染到虚拟DOM，然后根据虚拟DOM，把真实DOM进行修改 Object.defineProperty(对象名, 属性名, desciptor) Object.defineProperty(obj, key, { set(newValue) { console.log(\"监听\" + key + \"改变\"); value = newValue; }, get() { console.log(\"获取\" + key + \"的值\"); return value; } }) Object.freeze()会阻止修改现有的 property，也意味着响应系统无法再追踪双向绑定变化。 当数据发生改变，Vue是如何通知哪一部分发生刷新？(set() {} 里面该如何进行操作？) 发布订阅者模式// 发布者类 class Dep { constructor() { // 用于存储订阅者的数组 this.subs = []; } // 增加订阅者方法 addSub(watcher) { this.subs.push(watcher); } // 调用之后，每个订阅者都会进行更新 notify(){ this.subs.forEach(item => { item.update() }) } } // 订阅者类 class Watcher { constructor(name) { this.name = name; } update(){ console.log(this.name, \"发生更新\"); } } const dep = new Dep(); const watcher1 = new Watcher(\"item1\"); const watcher2 = new Watcher(\"item2\"); const watcher3 = new Watcher(\"item3\"); dep.addSub(watcher1); dep.addSub(watcher2); dep.addSub(watcher3); dep.notify(); data中每一个属性，都添加一个发布者类（new 一个 发布者实例） 谁通过 get(){}对数据进行获取，则对其添加订阅者类（new 一个 订阅者实例），然后将订阅者push进发布者的subs数组中 当数据发生修改，即触发 set(){}函数，在里面使用notify： set(){ dep.notify(); } 让所有订阅者随之发生更新（调用了所有订阅者的update方法） （实际上watcher有很多种，正常的data属性的渲染页面watcher（下面这个）、computed的watcher、watch（用户自定义）的watcher） Observer：每个属性创建一个Dep对象（发布者），若data数据发生改动，则调用Dep对象的notify方法 Compile：解析el中的指令，每次使用到data的数据，就创建一个Watcher（订阅者），然后加入到该属性对应的发布者 Vue2.0双向绑定的缺点1.必须在 data 对象上存在才能让 Vue 将它转换为响应式的 var vm = new Vue({ data:{ a:1 } }) // `vm.a` 是响应式的 vm.b = 2 // `vm.b` 是非响应式的 2.若原来属性不存在，对象新增属性，Vue也检测不到 3.Vue 不能检测以下数组的变动： 1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue（但是Vue提供了API进行重写，还重写了数组方法） 2.当你修改数组的长度时，例如：vm.items.length = newLength 上述数组的改变无法检测得到，使用Vue.set()才能新增一个属性 实际上尤大已经回答了，是考虑到性能原因，才不用Object.defineProperty 对对象属性进行监听 4.还有个小缺陷，就是默认会递归，递归你data里的属性，可能导致性能不高 注意 2020年后 Vue3.0已经换成用proxy代理了 手写日常版发布订阅者模式class EventBus { map = {} //如果有人发布了该消息名type则进行回调 on(type, handler) { this.map[type] = (this.map[type] || []).concat(handler) } //发送消息 emit(type, data) { this.map[type] &amp;&amp; this.map[type].forEach(handler => handler(data)) } //取消订阅 off(type, handler) { if(this.map[type]) { if(!handler) { delete this.map[type] } else { let index = this.map[type].indexOf(handler) this.map[type].splice(index, 1) } } } } 或者 class EventBusClass { constructor() { this.eventMap = {}; } on(eventName, callback) { const cbs = this.eventMap[eventName] || []; if (cbs.indexOf(callback) === -1) { cbs.push(callback); } this.eventMap[eventName] = cbs; } off(eventName, callback = null) { const cbs = this.eventMap[eventName]; if (!cbs) return; if (callback) { const idx = cbs.indexOf(callback); if (idx !== -1) { cbs.splice(idx, 1); } this.eventMap[eventName] = cbs; } else { this.eventMap[eventName] = undefined; } } emit(eventName, ...args) { const cbs = this.eventMap[eventName] || []; if (!cbs) return; cbs.forEach((cb) => cb.apply(this, args)); } } const eventBus = new EventBus() eventBus.on('click:btn', data => { console.log(data) }) eventBus.emit('click:btn', {a: 1, b: 2}) eventBus.off('click:btn') eventBus.emit('click:btn', {a: 1, b: 2}) Vue原理小知识Vue检测数组中的变化 我们都知道数组有push、shift、pop这些方法 而Vue对data里数组的原型方法（prototype）进行了重写，__proto__指向新的原型对象， 通过原型链定义函数，这样的话我们就可以在其中设置响应式（原来的函数.apply + 调用更新视图方法 notify()） 然后，利用observer对数组里的每一项进行监控 Vue采用异步渲染 为何Vue采用异步渲染（数据）？ 防止一更改数据就更新视图 ，多个数据发生更改后，可以先过滤掉同一个订阅者（内置di，根据id过滤同一watcher，即不用导致watcher进行多次update），提高性能 虚拟DOMDOM实际操作是挺快的，任何基于DOM的库（Vue/React）都不可能操作DOM时比DOM快 虚拟DOM：一个能代表DOM树的对象，通常含有标签名、标签上属性、事件监听和子元素们，以及其它属性 在控制台上打印可以看得出它是一个对象，它对比真实DOM更加轻量级，使用 debugger可以在浏览器的 Sources 看得到它的属性对比真实DOM少得多，它最终会被Vue / React 转化为真实DOM，呈现在页面上 为什么虚拟DOM比真实DOM快？ 减少DOM操作：可以将多次DOM操作合并为一次操作，比如添加100个节点原来是一个一个添加，现在是一次性添加，减少浏览器回流 虚拟DOM借助DOM diff 可以把多余的操作省略掉，比如如果它发现有一些节点已经在页面里，就不选择更新，只更新不一样的部分（比如上面“虚拟DOM渲染特殊案例”提及到的） 跨平台，虚拟DOM不仅可以变成DOM，还可以变成小程序、ios应用、安卓应用，因为虚拟DOM本质上只是一个JS对象 （图片源自饥人谷） 创建虚拟DOM（原始方法）（分别对应React和Vue） （将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的） 虚拟DOM的缺点：需要额外创建函数，如createElement或h，但是有解决方法，如下：（通过babel、vue-loader转换） 现在创建DOM的方法： 虽然克服了虚拟DOM的缺点，但是新增了另外一个缺点，也就是严重依赖打包工具！！ 但其实当规模比较合理的时候，比如几千的时候，使用虚拟DOM是很好的，他可以通过算法优化很多多余的操作，但是当规模大到一定的程度，10w以上等等，在这个情况下原生DOM能保持稳定性，而React就崩了（我在Vue和React的对比里面提及到） DOM diffdiff就是一个函数，我们称之为patch； pathces= patch(oldVNode, newVNode)，分别对应旧节点和新节点，patches就是运行的DOM操作 把虚拟DOM想象成树型，让新的虚拟DOM和旧的虚拟DOM进行对比 只更新不一样的部分（比如上面“虚拟DOM渲染特殊案例”提及到的） Tree diff逐层对比，查看哪里需要更新；看节点（Element diff）/组件（Component diff），查看标签名/组件类型 若标签类型没变，只更新div对应的DOM属性，变了的话直接替换 / 删除 若没有发生替换或者删除的话，进入标签后代/深入组件 后继续做 Tree diff 递归 但DOM diff也有 bug 更新的时候，直接看第一个children， 把 hello -&gt; world，然后再删除掉原来的 span -&gt; world；而不是直接删除掉hello的children 所以我个人理解 优点就是：复用性提高； 缺点就是由于diff算法，导致了实际上比较简便的操作变得复杂了（可以使用key避免） 时间复杂度：两棵树的diff时间复杂度为O(n^3)，但是Vue优化了（双指针），O(n^3) -&gt; O(n)，即4个指针分别指向新节点头，新节点尾、旧节点头、旧节点尾，两两进行比较 虚拟DOM渲染特殊案例这里在输入input数据之后，再点击切换按钮，会出现另外一个input框内仍保留之前输入的数据的情况 这是因为Vue在进行DOM渲染的时候，会先把所有元素标签通过一个虚拟DOM（virtual DOM）放到内存里，然后再渲染到浏览器上；所以出于性能考虑，会尽可能复用已经存在的元素，而不是创建新元素；复用的时候对比每个层级，把修改之后的套在原来的元素上（比如属性类型，属性id等） 在以下的案例中，Vue内部会发现原来的input元素不再使用，直接作为else中的input来使用（类似于让现任穿前任的衣服） 也就是说，在第一个input输入字符，然后“切换类型”，转为第二个input后，你依旧可以看到刚才输入的字符 解决方法：增加key属性，作为唯一的标识，key不同不进行复用 &lt;input type=&quot;text&quot; placeholder=&quot;用户名&quot; key=&quot;username&quot;&gt; &lt;div id=\"app\"> &lt;div v-if=\"loginType\"> &lt;label for=\"email\">用户邮箱&lt;/label> &lt;input type=\"text\" placeholder=\"用户邮箱\"> &lt;/div> &lt;div v-else> &lt;label for=\"nickname\">用户名&lt;/label> &lt;input type=\"text\" placeholder=\"用户名\"> &lt;/div> &lt;button @click=\"loginType=!loginType\">切换类型&lt;/button> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { loginType: true } });","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"深入JavaScript内存","slug":"深入JavaScript内存","date":"2021-03-20T16:00:00.000Z","updated":"2023-03-28T09:06:47.023Z","comments":true,"path":"2021/03/21/shen-ru-javascript-nei-cun/","link":"","permalink":"https://taylor12138.github.io/2021/03/21/shen-ru-javascript-nei-cun/","excerpt":"","text":"内存概述内存也是有生命周期的，不管什么程序语言，一般可以按顺序分为三个周期： 分配期 分配所需要的内存 使用期 使用分配到的内存（读、写） 释放期 不需要时将其释放和归还 定义变量自动分配内存 绝大部分情况下也不需要手动释放内存 而我们程序员大多只需关注使用内存 内存泄漏当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用（或者由于设计错误）而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。 而内存泄漏也是造成应用程序OOM（内存严重不足）的罪魁祸首之一 内存泄露的问题其困难在于 1.编译器不能发现这些问题。 2.运行时才能捕获到这些错误，这些错误没有明显的症状，时隐时现。 3.对于手机等终端开发用户来说，尤为困难。 解决方法： 避免创建全局变量，开启严格模式 不能滥用闭包 清除没有用的DOM元素引用 (document.body.removeChild(DOM元素)) 定时器用完离开页面记得手动删除（clearInterval()） 使用Vue的时候，在页面销毁时记得对事件解绑，对EventBus进行解绑 beforeDestory () { window.removeEventListener('事件名', 接收时的回调函数(参数)) } destroyed () { this.$bus.$off(\"事件名\", 接收时的回调函数(参数)); } 在ES6 里可以使用 WeakMap、WeakSet JavaScript的垃圾回收机制（GC）标记清除算法设置一个根对象（root）（在Javascript里，根是全局对象）），然后垃圾回收器会定期从根（root）扫描内存中的对象，凡是能从根到达的对象，就是还需要用的，到达不了的进行标记，稍后回收 所有标记清除算法有两个阶段： 标记阶段 清除阶段 算法缺陷：无法从根对象查询到的对象都会被清除，垃圾收集完毕后会造成大量内存碎片，也就是造成内存空间不连续的问题（缺陷详情可以在下面的V8老生代垃圾回收机制查看） 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进 引用计数算法古老的垃圾回收算法，没那么常用了 原理是跟踪记录每个值被引用的次数，被引用一次，则count + 1（除了弱引用类型WeakMap、WeakSet） 垃圾回收程序下次运行的时候就会释放引用数为0的内存 它有很多计数问题，比如引用循环，对象A有一个指针指向对象B，而对象B也引用了A，他们的引用书永远不会变成0 V8的内存分代和回收算法Chrome 浏览器所使用的 V8 引擎就是采用的分代回收策略。这个和 Java 回收策略思想是一致的。目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（新生代young generation），少回收「持久对象区」（老生代 tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。 新生代中的对象存活时间较短的对象，老生代中的对象存活时间较长，或常驻内存的对象。 新生代新生代中的对象主要通过Scavenge算法进行垃圾回收 它将堆内存一分为二切开，让每一个空间成为一个semispace，而这两个空间中，一个处于使用中（From空间），另一个处于闲置状态（To空间）。由于新生代生命周期短，所以比较适合这个频繁对换 + 释放的算法 此时垃圾回收开始： 1.检查From空间中存活对象，然后复制到To空间中，而非存活对象空间会被释放掉，From空间和To空间的身份对换。 2.当一个对象多次复制之后依然存活，说明人家比较长寿，就会被迁移至老生代之中 3.To闲置空间内存占用超过25%，也会被迁移至老生代之中 老生代老生代使用的是标记清除法，活对象在新生代中只占叫小部分，死对象在老生代中只占较小部分，这是为什么采用标记清除算法的原因。 从上文我们也可以清楚标记清除法的缺陷问题（内存碎片问题，内存空间不连续） 此时如果需要分配一个大对象，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 为了解决碎片问题，标记整理被提出来。就是在对象被标记死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。 参考链接https://juejin.cn/post/6844903951742025736 减少垃圾回收对性能的影响：1.让垃圾回收尽量少地进行 2.避免内存泄露 提升性能避免JavaScript的先创建再补充的动态属性赋值，而是一次性声明所有属性，让实例们共享一个隐藏类 //错误示范❌ function Article(){ this.title = 'my name is title'; } let a1 = new Article(); let a2 = new Article(); a1.author = 'Allen'; //正确示范√ function Article(author){ this.title = 'my name is title'; this.name = author; } let a1 = new Article('Allen'); let a2 = new Article(); 由于JavaScript数组大小是动态可变的，，引擎会删除大小为100的数组，在创建一个新的大小为200的数组，垃圾回收程序看到这个删除操作，说不定看你对象更替速度那么快，就加快对你这里垃圾回收的频率，从而降低性能。要避免这种动态分配的操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作，不过，你必须事先想好这个数组有多大。 （实际上静态分配是优化的一种极端方式，如果你的应用程序被垃圾回收严重拖了后腿，可以利用它来提升性能，但这种情况并不多见，大多情况下，这都属于过早优化。） V8性能优化在 V8 引擎下，又引入了 TurboFan 编译器，他会在特定的情况下进行优化，将代码编译成执行效率更高的 Machine Code 然而什么情况下会转换成为machine code？ 1. function test(x) { return x + x } test(1) test(2) test(3) test(4) 以上函数被多次调用并且参数一直传入 number 类型，那么 V8 就会认为该段代码可以编译为 Machine Code，因为你固定了类型，不需要再执行很多判断逻辑了。 所以我们要尽可能保证传入类型一致 这也给我们带来了一个思考，这是不是也是使用 TypeScript 能够带来的好处之一 2. 另外，编译器还有个骚操作 Lazy-Compile，当函数没有被执行的时候，会对函数进行一次预解析，直到代码被执行以后才会被解析编译。然而有时候，我们的函数只需要被预解析一次，然后在调用的时候再被解析编译。但是对于这种函数马上就被调用的情况来说，预解析这个过程其实是多余的，那么有什么办法能够让代码不被预解析呢？ 立即执行函数 (function test(obj) { return x + x })() 但是不可能我们为了性能优化，给所有的函数都去套上括号，并且也不是所有函数都需要这样做。 缓存雪崩缓存雪崩就是指缓存由于某些原因（比如 宕机、cache服务挂了或者不响应），导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。 其实也可以解释为cache crash之后，牵一发而动全身，导致后端的各大区域接而无法进行服务而崩溃，全部拖死 前情提要：redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。 类似于： 1、redis集群彻底崩溃 2、缓存服务大量对redis的请求hang住，占用资源 3、缓存服务大量的请求打到源头服务去查询mysql，直接打死mysql 4、源头服务因为mysql被打死也崩溃，对源服务的请求也hang住，占用资源 5、缓存服务大量的资源全部耗费在访问redis和源服务无果，最后自己被拖死，无法提供服务 6、nginx无法访问缓存服务，redis和源服务，只能基于本地缓存提供服务，但是缓存过期后，没有数据提供 7、网站崩溃 产生原因1、例如 “缓存并发”，“缓存穿透”，“缓存颠簸” 等问题，这些问题也可能会被恶意攻击者所利用。 缓存穿透 指查询一个缓存和数据库都没有的数据，例如我们数据库的id都是从1开始自增的，如果传入的参数为-1或者特别大不存在的数据，就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存 缓存击穿 指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库 2、例如 某个时间点内，系统预加载的缓存周期性集中失效了，例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期。 解决方法：可以通过设置不同的过期时间，来错开缓存过期，从而避免缓存集中失效。 预防和解决 保证缓存层服务高可用性，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。 部署方式一：双机房部署，一套Redis Cluster，部分机器在一个机房，另一部分机器在另外一个机房。 部署方式二：双机房部署，两套Redis Cluster，两套Redis Cluster之间做一个数据同步。 Redis数据备份和恢复、快速缓存预热 对源服务访问进行 限流、资源隔离（熔断）、Stubbed 降级。 对缓存访问进行 资源隔离（熔断）、Fail Silent 降级 （降级：某些特殊情况下，在出现大量占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；降级的最终目的是保证核心服务可用，即使是有损的）","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"安全问题汇总","slug":"安全问题汇总","date":"2021-03-14T16:00:00.000Z","updated":"2022-07-17T07:54:56.965Z","comments":true,"path":"2021/03/15/an-quan-wen-ti-hui-zong/","link":"","permalink":"https://taylor12138.github.io/2021/03/15/an-quan-wen-ti-hui-zong/","excerpt":"","text":"1.XSS什么是XSSCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击，通过注入恶意脚本，，使之在用户浏览器上运行，然后利用这些恶意脚本，攻击者可以获取用户的敏感信息Cookie、SessionID等 web安全模型是基于同源策略的，但是XSS攻击通过诱使站点与预期内容一起提供恶意代码来绕过同源策略。这是一个巨大的问题，因为浏览器相信页面上显示的所有代码都是该页面安全来源的合法部分。 XSS 常见的注入方法： 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。 在标签的 href、src 等属性中，包含 javascript: (伪协议)等可执行代码。 等等。。。。 XSS攻击类型 存储型XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大 攻击者将恶意代码提交到目标网站数据库中 客户端最后从服务器得到的就是恶意代码，在浏览器执行的也是该恶意代码 恶意代码将用户数据发送至攻击者网站 反射型XSS（有点像那种色情小广告，点进去你就没了） 攻击者构建特殊URL，里面包含恶意代码 当用户打开此URL时，网站的服务端将恶意代码从中取出，并且拼接在HTML返回给浏览器（这应该属于后端渲染范围） 恶意代码被浏览器执行，然后将用户数据发送给攻击者网站 DOM型XSS（感觉和反射型XSS很像，只不过这个是属于JavaScript的安全漏洞（浏览器的DOM解析），反射型XSS时属于服务端的安全漏洞），所以防范DOM型XSS是前端的责任 同样的，攻击者构造特殊URL，其中包含恶意代码 用户打开后，浏览器解析，JavaScript取出URL然后执行 恶意代码被浏览器执行，然后将用户数据发送给攻击者网站 实际案例： &lt;a href\\=\"javascript:alert('xss')\"\\>click me&lt;/a\\> &lt;p onclick=\"alert('xss')\">this is a text&lt;/p> &lt;img src=\"xxx.com/test.jpg\" onerror=\"alert('xss')\"/> 甚至是CSS &lt;div style=\"background:url(javacript:alert('xss'))\"> 防范XSS常用的防范手段： httpOnly: 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。 输入过滤: 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。 转义 HTML: 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义（比如 将 &gt; 转译为 &amp;gt;） 添加白名单：对于显示富文本来说，以上方法可能会将需要的格式也过滤掉，这时我们可以添加白名单的方式，其实也就是对匹配到的字段进行处理 预防存储型XSS和反射型XSS攻击： 纯前端渲染（这样就不会拼接html返回了） 同上面常用的防范手段一样的转义html 预防DOM型XSS攻击 DOM型XSS攻击实际上是JavaScript代码本身不够严谨， .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。（尽量避免这种直接插入式的写法） Vue的 v-html也容易导致xss攻击（原理也是innerHTML），与此同时，v-html也会替换掉标签内部子元素，所以 v-html尽量别用 减少eval()的使用 添加白名单防范XSShttps://jsxss.com/zh/index.html 一个添加白名单进行过滤防范XSS攻击的工具，它的名字也叫做XSS 安装和使用 $ npm install xss --save node端使用 var xss = require('xss'); console.log(xss('&lt;a href=\"#\" onclick=\"alert(/xss/)\">click me&lt;/a>')); 浏览器端使用 console.log(filterXSS('&lt;a href=\"#\" onclick=\"alert(/xss/)\">click me&lt;/a>')); 当然除了XSS过滤工具，还有Sanitizer这个API，可以配置白名单，黑名单，但兼容性很差 1.5 CSP内容安全策略( CSP ) 内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS (en-US)) 和数据注入攻击等 通过第三方注入代码，浏览器无法识别哪个网站ok哪个网站不ok，而csp就是来定义HTTP 标头，它允许您创建受信任内容来源的允许列表，并指示浏览器仅执行或呈现来自这些来源的资源。即使攻击者可以找到注入脚本的漏洞，该脚本也不会匹配白名单，因此不会被执行。 CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。 使用（开启 CSP） 设置 HTTP Header 中的 Content-Security-Policy（有时你会看到一些关于X-Content-Security-Policy头部的提法, 那是旧版本，你无须再如此指定它） Content-Security-Policy: policy policy参数是一个包含了各种描述你的CSP策略指令的字符串。 使用案例： 示例 1 一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名) Content-Security-Policy: default-src &#39;self&#39;示例 2 一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同) Content-Security-Policy: default-src &#39;self&#39; *.trusted.com示例 3 一个线上银行网站的管理者想要确保网站的所有内容都要通过SSL方式获取，以避免攻击者窃听用户发出的请求。 Content-Security-Policy: default-src https://onlinebanking.jumbobank.com该服务器仅允许通过HTTPS方式并仅从onlinebanking.jumbobank.com域名来访问文档。 示例 4 Content-Security-Policy: script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https: 脚本：只信任当前域名 &lt;object&gt;标签：不信任任何URL，即不加载任何资源 样式表：只信任cdn.example.org和third-party.org 框架（frame）：必须使用HTTPS协议加载 其他资源：没有限制 每个限制选项可以设置以下几种值，这些值就构成了白名单。 主机名：example.org，https://example.com:443 路径名：example.org/resources/js/ 通配符：*.example.org，*://*.example.com:*（表示任意协议、任意子域名、任意端口） 协议名：https:、data: 关键字&#39;self&#39;：当前域名，需要加引号 关键字&#39;none&#39;：禁止加载任何外部资源，需要加引号 更多可以收看阮一峰老师的教程http://www.ruanyifeng.com/blog/2016/09/csp.html 在HTML的放到head区域设置 meta 标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 或者直接 &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src https://cdn.example.net; child-src 'none'; object-src 'none'\"> 这不能用于frame-ancestors、report-uri或sandbox。 各项政策示例： script-src它是一个指令，用于控制特定页面的一组与脚本相关的权限 Content-Security-Policy: script-src &#39;self&#39; https://apis.google.com虽然脚本资源是最明显的安全风险，但 CSP 提供了一组丰富的策略指令，可以对允许加载页面的资源进行相当精细的控制。 让我们快速浏览其余的资源指令。下面的列表代表了 2级指令的状态。 3 级规范已经发布，但在主要浏览器中基本上没有实现。 base-uri限制可以出现在页面&lt;base&gt;元素中的 URL。 child-src列出工作人员和嵌入框架内容的 URL。例如：child-src https://youtube.com将启用嵌入来自 YouTube 但不来自其他来源的视频。 connect-src限制您可以连接的来源（通过 XHR、WebSockets 和 EventSource）。 font-src指定可以提供网络字体的来源。谷歌的网络字体可以通过font-src https://themes.googleusercontent.com. form-action&lt;form&gt;列出从标签提交的有效端点。 frame-ancestors指定可以嵌入当前页面的来源。该指令适用于&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;标签。该指令不能在&lt;meta&gt;标签中使用，仅适用于非 HTML 资源。 frame-src在级别 2 中已弃用，但在级别 3 中恢复。如果不存在，它仍会child-src像以前一样回退。 img-src定义可以加载图像的来源。 media-src限制允许传送视频和音频的来源。 object-src允许控制 Flash 和其他插件。 ….. 默认情况下，指令是完全开放的。如果您没有为指令设置特定策略，比如说font-src，那么默认情况下，该指令的行为就像您指定*为有效源一样（例如，您可以从任何地方加载字体，没有限制）。 您可以通过指定default-src指令来覆盖此默认行为。该指令定义了您未指定的大多数指令的默认值。通常，这适用于任何以 . 结尾的指令-src。如果default-src设置为https://example.com，并且您未能指定font-src指令，那么您可以从 加载字体https://example.com，而其他任何地方都无法加载。我们仅script-src在前面的示例中指定，这意味着可以从任何来源加载图像、字体等。 更多可以看 https://web.dev/csp/（可惜要翻墙） 其他 您将在网络上的各种教程中看到X-WebKit-CSP和X-Content-Security-Policy标题。展望未来，您应该忽略这些带前缀的标头。现代浏览器（IE 除外）支持无前缀Content-Security-Policy标头。那是您应该使用的标题。 CSP对于内联代码有所限制，一般来说内联代码被认为是有害的：CSP 是基于允许列表来源的，因为这是一种指示浏览器将特定资源集视为可接受并拒绝其余资源的明确方式。然而，基于来源的白名单并不能解决 XSS 攻击带来的最大威胁：内联脚本注入。如果攻击者可以注入直接包含某些恶意负载 ( &lt;script&gt;sendMyDataToEvilDotCom()&lt;/script&gt;) 的脚本标记，则浏览器没有将其与合法的内联脚本标记区分开来的机制。CSP 通过完全禁止内联脚本解决了这个问题：这是唯一可以确定的方法。 比如以下代码 no！no！no！ &lt;script> function doAmazingThings() { alert('YOU AM AMAZING!'); } &lt;/script> &lt;button onclick='doAmazingThings();'>Am I amazing?&lt;/button> 如果不得不使用内联代码，CSP 级别 2 允许您使用加密随机数（使用一次的数字）或哈希将特定的内联脚本添加到允许列表，从而为内联脚本提供向后兼容性。虽然这可能很麻烦，但它在紧要关头很有用。（https://web.dev/csp/） 假设您运行一个银行网站，并希望确保只有您自己编写的那些资源可以被加载。在这种情况下，从绝对阻止所有内容的默认策略开始 ( default-src &#39;none&#39;)，然后从那里开始构建。 假设银行从位于的 CDN 加载所有图像、样式和脚本https://cdn.mybank.net，并通过 XHR 连接到https://api.mybank.com/以提取各种数据位。使用框架，但仅用于站点本地的页面（无第三方来源）。网站上没有 Flash，没有字体，没有额外内容。我们可以发送的最严格的 CSP 标头是这样的： Content-Security-Policy: default-src &#39;none&#39;; script-src https://cdn.mybank.net; style-src https://cdn.mybank.net; img-src https://cdn.mybank.net; connect-src https://api.mybank.com; child-src &#39;self&#39; 作用效果CSP 的主要目标是减少和报告 XSS 攻击 ，XSS 攻击利用了浏览器对于从服务器所获取的内容的信任 CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 2.CSRF什么是CSRFCSRF是一种跨站请求伪造，也被称为 one-click-attack 或者 session riding 下面的图源自这个大佬 ： https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html （随便点开，放心绝对不是XSS或者CSRF ，手动狗头） 触发条件： 用户登录并且信任网站A，并产生cookie 未登出A的情况下，访问网站B（此网站虽然是攻击网站，但是它可能是一个存在其他漏洞的可信任的经常被人访问的网站） （感觉通俗来讲就是，你在存放重要信息的网站A登录后，没有关闭 且 本地的cookie没有过期，登陆了另外一个（攻击）网站，它就会偷你的cookie，冒充你来操作你网站A的账号） 常见类型 Get类型的CSRF POST类型的CSRF 链接类型的CSRF，上面两种打开网页就中招，这种要点击的，比较low 再来一个生动的例子认识CSRF： 用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。 攻击者就可以在网页放一个表单，该表单提交src为http://www.bank.com/api/transfer，body为count=1000&amp;to=Tom。 倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了（此时cookie会根据path和domain发现当前访问域名和银行相同，则携带cookie信息），由此形成CSRF攻击 防御CSRF 验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差 Referer check：请求来源限制，即同源检测，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。 token：token 验证的 CSRF 防御机制是公认最合适的方案。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈，因为XSS攻击有可能泄露Token * - * 3.劫持DNS劫持 DNS ： 域名 -&gt; ip地址 ，进行域名解析的服务器 DNS劫持又称域名劫持,是指通过某些手段取得某域名的解析控制权，修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址。 DNS劫持其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了 案例 在查找本机系统是否缓存ip地址时，可能碰到黑客设置绑定好的解析ip（host文件），使得我们到达了一个错误的ip地址（本地DNS劫持）; 亦或者是像《巴西银行钓鱼事件》，黑客利用D-Link路由器的漏洞，更改对应的DNS配置，重新定向到黑客自己搭建的恶意DNS服务器上（DNS解析路径劫持） （DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在/etc/resolv.conf文件。） 防止DNS劫持 网络层面： 手动修改DNS 修改路由密码 应用层面： 安装杀毒软件，防御木马病毒和恶意软件；定期修改路由器管理账号密码和更新固件。 有点复杂，可以网上查询（泪。。） HTTP劫持 你DNS解析的域名的IP地址不变。在和网站交互过程中的劫持了你的请求。在网站发给你信息前就给你返回了请求。 HTTP劫持很好判断，当年正常访问一个无广告的页面时，页面上出现广告弹窗，八成就是运营商劫持了HTTP。 4.SQL注入攻击什么是SQL注入攻击sql作为一种解释型语言（数据库语言），在运行时是由一个运行时组件解释语言代码并执行其中包含的指令的语言。基于这种执行方式，产生了一系列叫做代码注入（code injection）的漏洞 程序员在web开发时，没有过滤敏感字符，绑定变量，导致攻击者可以通过sql灵活多变的语法，构造精心巧妙的语句，不择手段，达成目的，或者通过系统报错，返回对自己有用的信息。 个人感觉有点像XSS攻击，都是利用语言漏洞进行代码注入 类似于合成这种永真的语句，让黑客用户登陆成功 select * from users where username=&#39;&#39; or 1=1 防御SQL注入1、预编译，在SQL映射文件中尽量使用#指示符标识参数位置，避免使用$。 2、确认每种数据的类型，比如是数字，数据库则必须使用int类型来存储 3、规定数据长度，能在一定程度上防止sql注入 4、严格限制数据库权限，能最大程度减少sql注入的危害 5、避免直接响应一些sql异常信息，sql发生异常后，自定义异常进行响应 6、过滤参数中含有的一些数据库关键词 5.序列化反序列化漏洞简单来说，序列化可以理解为就是将对象转化为字节流，字节流中包括这个对象的数据和信息，序列化和反序列化便于类的持久保存，并且很利于网络传输 而在反序列化处理中，如果攻击者通过构建恶意输入，使得反序列化产生非预期的类或者对象，这个类或者对象就有可能带来任意代码的执行 所以这个问题的根源在于，字节流进行还原时，即用到ObjectInputStream在反序列化时，没有对生成的对象的类型做限制 6.DDos攻击DOS：Denial of Service，拒绝服务，通过占用网络资源让它应接不暇，从而拒绝正常业务流量的一种网络攻击方式 DDOS：Distributed denial of service，分布式拒绝服务，俗称群殴（单台设备攻击能力有限，但是成百上千设备同时攻击很猛） 发起攻击的网络（组成成百上千设备的攻击网络）称为僵尸网络 这个网络可以通过木马、蠕虫等感染大量设备从而获取僵尸网络（亦或者富人直接买就行了） DDos攻击可以出现在网络的很多层： 网络层：霸占服务器网络带宽资源，发送大量的IP协议数据包（比如ping工具，产生ICMP包），这种攻击方式也称为ICMP flood 除此之外还有 UDP flood 多损的招数： 反射攻击：伪造自身ip地址为攻击目标的地址，然后向大量第三方机器发送请求，然后让第三方机器回复的响应大量涌入攻击目标ip 放大攻击：一次DNS查询，返回的数据往往大于请求数据，根据带宽放大因子，一般60B的请求数据可以获得3000B的返回数据，此时再结合反射攻击，让DNS返回的数据响应到攻击地址上，更加BT（maybe，50倍的攻击效果） TCP flood，因为有三次握手，所以无法伪装ip RST洪水攻击，同样是利用TCP协议，一方可以发送RST数据强行切断连接，而不用四次挥手，此时我们让攻击设备不断尝试伪造各种ip地址，发送RST数据，进行盲打，此时有可能可以命中某位xx用户的连接 反击根治DDos攻击的方法： 网络设备检测ip，过滤掉伪装的ip地址 根据路由转发逻辑，过滤伪装ip 保守治疗： 使用CDN节点 流量清洗设备（有点像保镖），先自己来应答，如果是正常的流量就放行 7.重放攻击API重放攻击（Replay Attacks）又称重播攻击、回放攻击，这种攻击会不断恶意或欺诈性地重复一个有效的API请求。攻击者利用网络监听或者其他方式盗取API请求，进行一定的处理后，再把它重新发给认证服务器，是黑客常用的攻击方式之一。 百科： 重放攻击的基本原理就是把以前窃听到的数据原封不动地重新发送给接收方。很多时候，网络上传输的数据是加密过的，此时窃听者无法得到数据的准确意义。但如果他知道这些数据的作用，就可以在不知道数据内容的情况下通过再次发送这些数据达到愚弄接收端的目的。例如，有的系统会将鉴别信息进行简单加密后进行传输，这时攻击者虽然无法窃听密码，但他们却可以首先截取加密后的口令然后将其重放，从而利用这种方式进行有效的攻击。 小情景1.0：假设网上存款系统中，一条消息表示用户支取了一笔存款，攻击者完全可以多次发送这条消息而偷窃存款。 小情景2.0：A给B写了一封信，说：“老友，请给我转账100块吧！A敬上。” B照做了，然后有人（不一定是A)复制了一样的信和签名发给B，骗B再转账100块，这是重放攻击（replay attack）。 小情景3.0：一个电子商务网站，要求客户对电子订单签名以防止非授权用户下订单。攻击者如要冒充某位客户下订单，最好可以获得他的私钥，如果不成功，攻击者可以监听这位顾客的通信，将顾客以前发送的订单记录下来，然后他就可以直接将这些订单发给网站了。因为这些订单的确是合法客户签名过的，如果网站没有一种识别重放订单的机制，它就会不加犹豫地接收这些订单。 防御： (1)加随机数。该方法优点是认证双方不需要时间同步，双方记住使用过的随机数，如发现报文中有以前使用过的随机数，就认为是重放攻击。缺点是需要额外保存使用过的随机数，若记录的时间段较长，则保存和查询的开销较大。 (2)加时间戳 该方法优点是不用额外保存其他信息。缺点是认证双方需要准确的时间同步，同步越好，受攻击的可能性就越小 (3)加流水号，也就是双方在报文中添加一个逐步递增的整数，只要接收到一个不连续的流水号报文(太大或太小)，就认定有重放威胁。 8.SSHSecure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议 它的整个过程： （1）远程主机收到用户的登录请求，把自己的公钥发给用户。 （2）用户使用这个公钥，将登录密码加密后，发送回来。 （3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 其实也就是和https的非对称密钥一样，只不过它：不像https协议， SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。所以这个机制防止不了“中间人攻击” 解决办法 一、口令登录 第一次登录对方主机的时候，通过它提供的公钥指纹，去自己一一对应远程主机在网站上自己贴出来的公钥指纹，让我们自行核对 当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。 每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 二、公钥登录 先让用户将自己的公钥储存在远程主机上 远程主机发东西过来 -&gt; 用户用私钥加密后再发过去 -&gt; 远程主机用存储好的公钥解密 参考链接：阮一峰https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html 9.心脏出血漏洞wiki定义Heartbleed是OpenSSL加密库中的一个安全漏洞，它是传输层安全(TLS) 协议的广泛使用的实现，无论易受攻击的 OpenSSL 实例是作为 TLS 服务器还是客户端运行，都可以利用 Heartbleed。这是由于在 TLS心跳扩展的实现中输入验证不正确（由于缺少边界检查）造成的。[3]因此，该错误的名称源自heartbeat。[4]该漏洞被归类为缓冲区过度读取 , [5]可以读取的数据多于应允许的数据的情况。[6] 系统管理员经常很慢地修补他们的系统。截至 2014 年 5 月 20 日，在 800,000 个最受欢迎的启用 TLS 的网站中，仍有 1.5% 的网站容易受到 Heartbleed 的攻击。[9]截至 2014 年 6 月 21 日，309,197 台公共网络服务器仍然易受攻击。[10]截至 2017 年 1 月 23 日，根据Shodan的一份报告[11]，仍有近 180,000 台联网设备易受攻击。[12] [13]根据 shodan.io 对“vuln:cve-2014-0160”的搜索，截至 2017 年 7 月 6 日，该数字已降至 144,000 人。[14]截至 2019 年 7 月 11 日，Shodan 报告[15]91,063 台设备易受攻击。美国以 21,258 (23%) 位居第一，前 10 位国家有 56,537 (62%)，其余国家有 34,526 (38%)。该报告还按其他 10 个类别对设备进行了细分，例如组织（前 3 名是无线公司）、产品（Apache httpd、Nginx）或服务（HTTPS，81%）。 除 OpenSSL 之外的 TLS 实现，例如GnuTLS、Mozilla的网络安全服务和TLS 的 Windows 平台实现，都没有受到影响，因为缺陷存在于 OpenSSL 的 TLS 实现中，而不是协议本身。[16] 传播历史2012年3月14日，OpenSSL 1.0.1版发布，漏洞开始传播。心跳支持默认是启用的，这使受影响的版本易受攻击 实例：早在2014年，互联网安全协议OpenSSL被曝存在一个十分严重的安全漏洞。在黑客社区，它被命名为“心脏出血”，表明网络上出现了“致命内伤”。利用该漏洞，黑客可以获取约30%的https开头网址的用户登录账号密码，其中包括购物、网银、社交、门户等类型的知名网站。今天就为大家带来平台事件规则解读系列第四篇——震惊全球的“心脏出血”漏洞。 具体内容所谓心跳检测，就是建立一个 Client Hello 问询来检测对方服务器是不是正常在线 ，服务器发回 Server hello，表明正常树立SSL通讯。就像我们打电话时会问对方 “喂听得到吗？”一样。 每次问询都会附加一个问询的字符长度 pad length，bug 来了，如果这个 pad length 大于实际的长度，服务器仍是会回来相同规模的字符信息，于是形成了内存里信息的越界访问。 这是因为OpenSSL的心跳功能缺少了一个至关重要的安全维护手段：受影响的OpenSSL版本根据请求消息中的长度字段分配内存缓冲区，用于存储要返回的消息，而不考虑消息中有效载荷的实际长度。所以计算机接受心跳请求时从不检查该请求和它声称的内容是否一致。 就这样，每发起一个心跳，服务器就能泄露一点点数据（理论上最多泄露 64K），例如，正常的心跳请求可能会要求一方“返回4个字符的单词‘bird’”，那一方就返回“bird”；“心脏出血请求”（恶意的心跳请求）如“返回500个字符的单词‘bird’”会导致受害者返回“bird”，紧接着是恰储存在受害者活跃内存中的496个字符。这样，攻击者便可能会收到敏感数据，从而危及受害者其它安全通信的保密性。虽然攻击者能对返回的内存块大小有所控制，但却无法决定它的位置，因而不能指定要显示内容。 这些数据里可能包括用户的登录账号密码、电子邮件甚至是加密秘钥等信息，也可能并没有包含这些信息，但攻击者可以不断利用 “心跳”来获取更多的信息。就这样，服务器一点一点泄露越来越多的信息，就像是心脏慢慢在出血，心脏出血漏洞的名字由此而来。 漏洞出现的版本 heartbleed漏洞主要存在于有心跳机制的OpenSSL协议中。 IANA组织把开启心跳扩展机制的SSL数据包type类型定义为24（0x18）。 heartbleed漏洞主要存在于TLS和DTLS两种协议中，在含有heartbleed漏洞的OpenSSL协议中需要开启心跳扩展机制（beartbeat），而含有心跳扩展机制的TLS版本主要包含在0（0x0301），TLSv1.1（0x0302），TLSv1.2（0x0303）三种版本中。 heartbleed漏洞攻击主要由于攻击者构造异常的心跳数据包，即心跳包中的长度字段与后续的数据字段不相符合，来获取心跳数据所在的内存区域的后续数据。 参考： 心脏出血漏洞wiki 事件分析OPENSSL“心脏出血”漏洞 小错误引发大危机——心脏出血到底是什么？","categories":[{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"Hello"},{"title":"超文本传输协议new","slug":"超文本传输协议new","date":"2021-03-14T16:00:00.000Z","updated":"2023-05-30T17:04:29.373Z","comments":true,"path":"2021/03/15/chao-wen-ben-chuan-shu-xie-yi-new/","link":"","permalink":"https://taylor12138.github.io/2021/03/15/chao-wen-ben-chuan-shu-xie-yi-new/","excerpt":"","text":"1.http概述从计算机网络的学习我们了解到：HTTP协议[超文本传输协议]，协议详细规定了浏览器和万维网服务器之间相互通信的规则 http 2.0 使用二进制传输（二进制分帧），减少服务端压力，连接吞吐量更大，改善TCP拥塞状况，同时慢启动时间减少 多路复用，多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。 不同浏览器在http1或http1.1对请求的限制数量 压缩headers（最小数据量化） 支持server push（服务端推送），唯一一个需要开发者自己配置的功能，他可以对客户端的一个请求发送多个响应，实际上是还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。 比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。 而且它特有的缓存机制，使用场景如下，「如果客户端早已在缓存中有了一份 copy 怎么办？]，此时再推送就是浪费带宽。 这种情况下，HTTP/2 允许客户端通过 RESET_STREAM 主动取消 Push ，然而这样的话，原本可以用于更好方向的 Push 就白白的浪费掉数据往返的价值。 对此，一个推荐的解决方案是，客户端使用一个简洁的 Cache Digest 来告诉服务器，哪些东西已经在缓存，因此服务器也就会知道哪些是客户端所需要的，因为 Cache Digest 使用的是 Golumb Compressed Sets，浏览器客户端可以通过一个连接发送少于 1K 字节的 Packets 给服务端，通知哪些是已经在缓存中存在的； http/1处理减少请求的方式是线头阻塞（合并多个请求为一个请求），但实质上有一定的开销 下面我们阐述http 1.x版本的内容 http协议的特点 永远都是客户端发起请求，服务器回送响应 http协议是无状态的，但是在实际工作中，一些万维网网站希望能识别用户（给用户推销产品）=&gt;诞生了cookie小饼干，cookie是存储在用户主机的文本文件，记录一段时间内某用户的访问记录（不太敏感的数据） http采用TCP作为运输层协议，但是http协议本身是无连接的 （交换http报文之前不需要建立连接） http连接方式：持久连接（非流水线式（有点像停等协议）、流水线式（有点像GBN或SR协议，即后退N帧协议和选择重传协议））、非持久连接（每次传输都要三次握手） URL URL：统一资源定位器 URL和域名的区别域名，Domain Name，通常指一个网址的顶级域名。URL，website address，网页或网站的地址。 URL中包含了网站的域名.比如一个网址：www.cnblogs.com/gopark/p/8430916.html其中cnblogs.com是域名，cnblogs是网站名字，com是域名后缀；www.cnblogs.com代表一个二级域名，通常www被用来用为首页标识；https://www.cnblogs.com/gopark/p/8430916.html，这个则是一个完整的网站首页URL地址。https://，这是一个协议，是网站在网上传输的协议 URL和URI的区别： URI，统一资源标志符，表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行标识的。 URL是URI的一个子集，通俗地说，URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上 更加通俗：URI可以认为是一个编号,类似一个身份证号,用来标识其唯一性,而url既可以标识其具有唯一性,而且可以根据url找到资源的位置,这就是区别 输入url到网页呈现的过程： 域名解析 建立TCP连接 浏览器发送http请求 服务器返回响应 浏览器渲染页面 TCP断开连接 url编码过程 对于正常英语，使用ASCII编码方式 对于其他语言，Unicode编码方式，而我们常说的 UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。（阮一峰老师said） （更多可查看《计算机基础知识合集》的blog） encodeURIComponent()**encodeURIComponent()** 函数通过将一个，两个，三个或四个表示字符的 UTF-8 编码的转义序列替换某些字符的每个实例来编码 URI（对于由两个“代理”字符组成的字符而言，将仅是四个转义序列）。 // encodes characters such as ?,=,/,&amp;,: console.log(`?x=${encodeURIComponent('test?')}`); // expected output: \"?x=test%3F\" console.log(`?x=${encodeURIComponent('шеллы')}`); // expected output: \"?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\" http请求 GET：获取资源。get注重url获得的参数 数据格式：获得get请求的内容，它的内容是在url的? 之后的部分 长度限制：Get方法提交的数据大小长度并没有限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制；而这个长度限制，每个浏览器对应的限制都是不一样的。 POST：创建资源（带请求体）。post的信息放在Request body中（firefox浏览器除外） 数据格式：post回退时会再次提交请求；一般情况下，私密数据传输用POST + body就好 长度限制：理论上讲，POST是没有大小限制的。HTTP协议规范也没有进行大小限制，起限制作用的是服务器的处理程序的处理能力。 有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。 HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。 所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。 PUT：更新资源（带请求体） PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源） PATCH ： 是对 PUT 方法的补充，用来对已知资源进行局部更新 。比如使用PUT每次都要把更改后数据内容全部写上，而PATCH只需要写上更改部分的字段即可 DELETE：删除资源 CONNECT：方法建立一个到由目标资源标识的服务器的隧道。 OPTIONS：方法用于描述目标资源的通信选项。 HEAD： 只请求页面的首部。 请求报文： 1.行 第一部分是请求类型（GET、POST之类的） 第二部分是url的路径 第三部分是http协议的版本（目前使用最多的是1.1） 2.头（首部） 格式是值键对的形式 Host: atguigu.com Cookie: name=guigu Content-type = application/x-www-form-urlencoded User-Agent: chrome 83 3.空行 4.体 GET的话，请求体为空，POST的话，请求体可以不为空 响应报文 1.行 第一部分是http协议的版本（目前使用最多的是1.1） 第二部分是响应状态码 第三是响应状态字符串 2.头 （首部） 格式和请求头一样 3.空行 4.体 html的内容 Content-Type: 内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。 ContentType属性指定响应的 HTTP内容类型。如果未指定 ContentType，默认为TEXT/HTML。 常见的Content-Type有数百个，下面例举了一些 HTML文档标记：text/html;普通ASCII文档标记：text/html;JPEG图片标记：image/jpeg;GIF图片标记：image/gif;js文档标记：application/javascript;xml文件标记：application/xml;更多具体内容可参考《图解HTTP》 报文和实体 http报文和http实体是不同的概念，http报文类似于运输的箱子，http实体类似于箱子中的货物（个人感觉 实体 = 报文 - 行 - 除了实体首部字段的所有首部字段） 报文：网络中交换和传输的数据单元，即一次性要发送的数据块，包含了发送的完整数据信息 实体：作为请求和响应的有效载荷数据 http工作 地址解析，通过DNS解析域名,得主机的IP地址 封装http的请求数据包 封装成TCP包，建立TCP连接（三次握手） 客户端向服务器发送请求 服务器向客户端返回响应 关闭TCP连接（四次挥手） http only如果想要实现服务端设置cookie，返回时让客户端无法查看，可以使用 HttpOnly属性 （MDN：有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：Secure 属性和HttpOnly 属性。） HttpOnly = true 的话，那此Cookie 只能通过服务器端修改，Js 是操作不了的，对于 document.cookie 来说是透明的 此预防措施有助于缓解跨站点脚本（XSS） (en-US)攻击。 2.持久连接在http初始协议版本中，每进行一次http通信都要断开一次TCP连接，如果需要同时请求多个资源时就造成了无缘无故的TCP连接建立和断开，造成资源浪费，增加通信开销。 为了解决上述问题，http/1.1和http/1.0想出了持久连接的方法，其特点是只要一方没有明确提出断开，就保持TCP连接。在 http/1.1 中，所有的连接默认都是持久连接 比较新的轮询技术是Comet。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的HTTP持久连接也会消耗服务器资源。 客户端，请求头 Connection: Keep-Alive服务端，响应头 Connection: Keep-Alive在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 延伸出来的管线化持久连接使得管线化的方式成为可能，管线化技术出现后，不用等待即可发送下个请求 非管道化，完全串行执行，请求-&gt;响应-&gt;请求-&gt;响应…，后一个请求必须在前一个响应之后发送。 管道化，请求可以并行发出，但是响应必须串行返回。后一个响应必须在前一个响应之后。原因是，没有序号标明顺序，只能串行接收。 管道化请求的致命弱点: 会造成队头阻塞，前一个响应未及时返回，后面的响应被阻塞 请求必须是幂等请求，不能修改资源。因为，意外中断时候，客户端需要把未收到响应的请求重发，非幂等请求，会造成资源破坏。 由于这个原因，目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式。 无论是非管道化还是管道化，都会造成队头阻塞(请求阻塞)。 解决http队头阻塞的方法1. 并发TCP连接：一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。（浏览器一个域名采用6-8个TCP连接，并发HTTP请求）2. 域名分片：一个域名的并发 长连接数是一定的，比如上方说的6-8个，那我就多分几个域名（多个域名，可以建立更多的TCP连接，从而提高HTTP请求的并发） 3.HTTP2方式 http2使用一个域名单一TCP连接发送请求，请求包被二进制分帧，不同请求可以互相穿插，避免了http层面的请求队头阻塞。但是不能避免TCP层面的队头阻塞。 3.首部字段概述HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段。 在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。 结构 格式是值键对的形式 类型分为： 通用首部字段（请求和响应通用）Cache-Control、Connection等 请求首部字段（请求专用）Accept、Accept-Charset、Host（请求资源所在服务器）等 响应首部字段（响应专用）Accept-Ranges、Location（令客户端重定向至指定 URI）、Server（HTTP 服务器应用程序的信息）等 实体首部字段（通用，针对报文的实体部分）Allow、Content-Encoding等 4.响应状态码100：信息型状态响应码表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略. 101：HTTP **101 Switching Protocol**（协议切换）状态码表示服务器应客户端**升级协议**的请求对协议进行切换。 200：ok 201：代表成功的应答状态码，表示请求已经被成功处理，并且创建了新的资源，常规使用场景是作为 POST 、PUT请求的返回值 204：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。 206：客户端进行了范围请求，服务器成功执行部分get请求 301：永久重定向 第一次进入a.com，请求-&gt;b.com，以后每次进入a.com就不用请求直接去b.com（请求的资源已被永久分配了新的 URI） 302：临时重定向（暂时性转移） 每一次都会进入a.com，然后请求-&gt;b.com（请求的资源已被临时分配了新的 URI） 303：有点像302，只不过303提醒你应该使用get请求 304：自从上次请求后，请求的网页未修改过，所以没有响应主体部分 307：同302 400：报文存在语法错误 401：未授权，请求用户身份认证 403：服务器理解了请求但拒绝对其进行授权，被禁止，资源访问被服务器拒绝了 404：找不到 413：表示http请求实体太大。 500：内部错误 502：错误网关，从上游服务器收到无效响应，可能也是停机维护，或者服务器暂未开启， 503：服务器目前无法使用（由于超载或停机维护）通常，这只是暂时状态。（服务不可用） 504：网关超时 5.http缓存常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力。对于开发者来说，长久缓存复用重复不变的资源是性能优化的重要组成部分！！！ 浏览器第一次向一个web服务器发起http请求后，服务器会返回请求的资源，并且在响应头中添加一些有关缓存的字段（添加后浏览器才知道是否应该缓存资源）如： Cache-Control（控制浏览器是否可以缓存资源、强制缓存校验、缓存时间）（通用头部） no-cache：含义是不使用本地缓存，需要使用协商缓存，也就是先与服务器确认缓存是否可用。 no-store：禁用缓存。 public：表明其他用户也可使用缓存，适用于公共缓存服务器的情况。 private：表明只有特定用户才能使用缓存，适用于公共缓存服务器的情况 max-age：最大有效时间 Expires（与响应头中的 Date 对比）（实体头部） Expires 更多的是为了兼容旧浏览器（只支持 HTTP/1.0 的上古时代浏览器）的响应标头。 从 HTTP/1.1 以后就有了 Cache-Control 标头中的 max-age，设一个秒数；而是 Expires 设一个具体的时间点，显然 Expires 可能因为客户端与服务端时间不一致、或网络延迟导致过期时间不准确，并且 Cache-Control 能设的值更多也就更灵活。 Last-Modified（弱校验， 根据文件修改时间校验，可能内容未变，不精确）（实体头部） ETag（强校验，根据文件内容校验精确，这也是有了Last-modified还要有ETag的原因， 可以看作 Etag是last-Modifed的补充，但是检查时 Etag先检查 ）（响应头部） Date等等。 http缓存都是从第二次请求开始的。第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存（当ETag和Last-Modified同时存在时，服务器先会检查ETag，然后再检查Last-Modified），命中则返回304，否则服务器会返回新的资源 为什么有Last-Modified 还要有 ETag？ 考虑以下情况： 1.一些文件也许会周期性的更改,但是他的内容并不改变(仅仅改变的修改时间),这个时候,我们并不希望客户端认为这个文件被修改了,而重新 get2.某些文件修改非常频繁,比如在秒以下的时间内进行修改(比方说 1s 内修改了 N 次),If-Modified-Since能检查到的粒度时 s 级的,这种修改无法判断(或者说 UNIX 记录 MTIME只能精确到秒)3.某些服务器不能精确得到的文件的最后修改时间 强缓存 + 协商缓存之后浏览器再向该服务器请求该资源就可以视情况使用强缓存和协商缓存。 强缓存：（当前缓存未过期）浏览器直接从本地缓存中获取数据，不与服务器进行交互。 协商缓存：（当前缓存过期）浏览器发送请求到服务器，服务器判定是否可使用本地缓存。 联系与区别：两种缓存方式最终使用的都是本地缓存；前者无需与服务器交互，后者需要。 缓存过期策略1、设置 Cache-Control: max-age=1000 。响应头中的 Date 经过 1000s 过期（比起首部字段Expires，会优先处理s-maxage或max-age。）（Cache-ControlHTTP / 1.1通用头字段被用于为请求和响应缓存机制指定指令l）2、设置 Expires 。此时间与本地时间(响应头中的 Date )对比，小于本地时间表示过期，由于本地时钟与服务器时钟无法保持一致，导致比较不精确，也就是说如果修改了本地时间，可能会造成缓存失效。（http1.0时代，Pragma也是1.0时代的产物）3、如果以上均未设置，却设置了 Last-Modified ，浏览器隐式的设置资源过期时间为 (Date - Last-Modified) * 10% 缓存过期时间。 前端缓存图： 添加虚拟参数，避免命中缓存有时候我们可能并不需要命中缓存，比如这个问题，里面记录了关于第一个img在跨域缓存后，一直会报跨域的问题。 解决方法是添加虚拟参数，比如 const corsImageModified = new Image(); corsImageModified.crossOrigin = \"Anonymous\"; corsImageModified.src = url + \"?not-from-cache-please\"; 亦或者是 这将强制浏览器不使用以前的缓存图像，而是为图像发送新的GET请求，我们添加的 GET 参数无关紧要，只要生成的 URL 与初始（缓存）图像 URL 不同即可。 6.其他范围请求假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载，要实现该功能，这就要用到范围请求。（前提是上一次请求到这一次请求时间段内，下载对象没有发生改变） 当然，前提是服务器要支持范围请求，要支持这个功能，就必须加上这样一个响应头: Accept-Ranges: none 单一范围：我们可以请求资源的某一部分 多重范围：一次请求文档的多个部分 条件式范围：当（中断之后）重新开始请求更多资源片段的时候，必须确保自从上一个片段被接收之后该资源没有进行过修改。 HTTP代理代理有三个大功能 1.负载均衡 2.保障安全 3.缓存代理 Via首部字段：里存储着代理服务器名称，他们的顺序为HTTP 传输中报文传达的顺序。 X-Forwarded-For首部字段：它记录的是请求方的IP地址，但是这意味着每经过一个不同的代理，这个字段的名字都要变 但是这会产生两个问题: 意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。 在 HTTPS 通信加密的过程中，原始报文是不允许修改的。 由此产生了代理协议，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可: // PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口 PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222 GET / HTTP/1.1 ... 复制代码这样就可以解决X-Forwarded-For带来的问题了。 X-Real-IP首部字段：始终记录最初的客户端的IP 判断是否弱网环境// 判断是否为弱网环境 const isSlowNetwork = navigator.connection ? navigator.connection.saveData || (navigator.connection.type !== 'wifi' &amp;&amp; navigator.connection.type !== 'ethernet' &amp;&amp; /(2|3)g/.test(navigator.connection.effectiveType)) : false; 7.QUICQuic 全称 quick udp internet connection ，“快速 UDP 互联网连接”，也可以理解为http3.0 应用：速度更快、网络切换（wifi -&gt; nG）无感知等、弱网络环境better 对比http2.0： 减少了 TCP 三次握手及 TLS 握手时间。 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT，而QUIC由于建立在UDP的基础上，只需要0RTT即可完成安全握手。 改进的拥塞控制。 为啥你用UDP也能可靠啊？ TCP 使用ACK（确认），还有基于字节序号的 Sequence Number为了保证可靠性，而QUIC也有使用ACK（确认）并且以 Packet Number 代替了 TCP 的 sequence number； 传统TCP：超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。但是因为序列号一样，所以我们分不清这个 Ack 数据到底是原始请求的响应，还是重传请求的响应 QUIC 同样是一个可靠的协议，它使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题。 QUIC： 当Packet Number 发生了丢失，Packet Number 传递的数值（也就是那个Number）会不一样，因为他是按照严格递增的，此时就可以发现传送的失误了。（在RTO 发生后，可以精确判断Ack 数据是原始请求的响应，还是重传请求的响应） 但是仅仅靠 Packet Number 肯定是无法保证数据的顺序性和可靠性，此时又引入了 Stream Offset。 即一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖。但是 Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset 来保证应用数据的顺序。如错误! 未找到引用源。所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的 Offset 分别是 x 和 x+y。 假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。 还有可插拔、更多ACK块等 避免队头阻塞的多路复用。 TCP队头阻塞： TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。 QUIC的多路复用，也可以实现在一条 QUIC 连接上可以并发发送多个 HTTP 请求 （stream），但是stream之间没有相互依赖，这导致了彼此不会相互影响，极大程度消除了对头阻塞的影响； 并且QUIC 最基本的传输单元是 Packet，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞。 而对比QUIC，http2.0的多路复用会队头阻塞，本身强制使用的TLS协议也存在一个队头阻塞 连接迁移。 WIFI 和 4G 移动网络切换时， ip发生变化 -&gt; 重新建立TCP连接；而任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为 ID 来标识，继而上层业务逻辑感知不到变化 前向冗余纠错 QUIC的UDP优化相信已经在尝试应用QUIC/HTTP3的服务端开发者，或多或少都会经历UDP在内核方面的性能瓶颈问题，考虑到UDP是在近几年才随着QUIC和流媒体传输的场景的逐渐流行，才被逐渐广泛地应用起来，因此内核UDP在性能方面很难与优化了三十年的TCP相抗衡，同时内核的复杂性和通用性要求，也导致一些新的高性能修改难以被迅速接收。因此，在UDP性能优化方面，我们和龙蜥社区的Anolis内核团队联合做了一版bypass内核的用户态高性能udp收发方案。 QUIC参考链接 科普：QUIC协议原理分析 如何看待 HTTP/3 ？ 8.本地修改host目前先将本地的/etc/hosts 中配置本地预览地址（mac端通过sudo vim /etc/hosts 打开） # 127.0.0.1 都走成 t.baidu.163.com 127.0.0.1 t.baidu.163.com 来顶替目前跨域的问题 cat /etc/hosts 127.0.0.1 localhost 255.255.255.255 broadcasthost ::1 localhost 127.0.0.1 t.moyi.163.com 通过这个文件可以看到哪些域名对应哪些ip，哪些主机名对应哪些ip，通常情况下这个文件首先记录了本机的ip和主机名 一般情况下hosts文件的每行为一个主机，每行由三部分组成，每个部分由空格隔开，格式如下 ip地址 主机名/域名 （主机别名）","categories":[{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"Hello"},{"title":"超文本安全传输协议","slug":"超文本安全传输协议","date":"2021-03-14T16:00:00.000Z","updated":"2022-07-17T05:52:17.372Z","comments":true,"path":"2021/03/15/chao-wen-ben-an-quan-chuan-shu-xie-yi/","link":"","permalink":"https://taylor12138.github.io/2021/03/15/chao-wen-ben-an-quan-chuan-shu-xie-yi/","excerpt":"","text":"1.http和httpshttp：超文本传输协议，它是以一种明文的方式（传输是明文的），没有任何加密，如果我们在该网站输入登录密码等信息，发送请求到服务器时，如果有人在中途截取我们的信息，那我们的信息可能就暴露了，默认80 https：超文本传输安全协议，利用SSL/TLS来加密数据包。默认443，需要到 CA 申请证书，一般免费证书很少，需要交费，握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； 对称密钥：直接发密钥，之后的通信都用过这个密钥打开。它的弊端就是，可能被中间人拦截，这样中间人就可以获取到了密钥，就可以对传输的信息就行窥视和篡改。 非对称密钥（RSA）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密 但它的弊端就是，算法很慢 我们使用结合的方式！ 使用 非对称密钥（RSA） 发送 对称密钥，然后双方使用 对称密钥 进行通信 SSL协议这个协议简单来说就是提供数据安全和完整性的协议，简而言之，它是一项标准技术。比如我们访问了一个https网站，客户端和服务端会（握手阶段）如果某个网站受 SSL 证书保护，其相应的 URL 中会显示 HTTPS 先建立安全的连接通道，客户端先给出协议版本号 + 支持的加密方法 + 随机数等 确认信息后，服务器会生成一个加锁的箱子，但是这把锁有两把不一样的钥匙，一把留给服务器自己（私钥），一把提供给客户端（公钥） 服务器发送 — &gt; 未上锁的箱子 + （里面放着一份网站的证书（证书包括公钥和数字签）到 – &gt; 客户端（你访问的服务器没问题）） 客户端生成两把对称密钥，一把留给自己，然后把信息 + 另一把对称密钥放到箱子中，用钥匙锁上（只能用私钥开）发送 —&gt;服务器 然后服务器用另外一把钥匙（私钥）打开箱子，然后双方可以通过对称密钥通信了 在这个过程中，即使箱子被拦截了，也很难打开箱子 中间人攻击因为传输非对称密钥的时候，服务端发送的是公钥，，有可能被中间人拦截后进行篡改 这时我们就需要数字证书，确定服务端的身份，一定是服务端发送的，而数字证书类似于我们的公证处 这篇文章可以生动形象地了解到 https 的原理 https://juejin.cn/post/6844903504046211079 （而我们熟知的自动打卡，有些就是利用中间人攻击的原理（fiddler抓包），模拟客户端和服务端通信，当然，它也通过不了数字证书的校验，fiddler伪造的数字证书，是建立在我们手动信任的基础上） （所以连接陌生wifi、下载乱七八糟的软件，有可能会被装上乱七八糟的私发证书，从而出现中间人攻击） 数字证书 数字证书是什么东西?其实它就是一个 .crt 文件 数字证书是谁颁发的?由权威证书认证机构颁发，一般我们简称为 CA 机构 数字证书如何申请的： 服务器上生成一对公钥和私钥。然后将域名、申请者、公钥(注意不是私钥，私钥是无论如何也不能泄露的)等其他信息整合在一起，生成.csr 文件。 .csr文件发送给CA机构，收到申请后会验证申请者的组织和个人信息，然后 CA 就会使用散列算法对.csr里的明文信息先做一个HASH，得到一个信息摘要，再用 CA 自己的私钥对这个信息摘要进行加密，生成一串密文，密文即是所说的 签名 客户端(浏览器)向服务端发出请求，服务端返回证书给客户端。 客户端拿到证书后，把证书里的签名与及明文信息分别取出来，然后会用自身携带的CA机构的公钥去解密签名，然后信息摘要1，然后再对明文信息进行HASH，得到一个信息摘要2，对比信息摘要1 和信息摘要2，如果一样，说明证书是合法的，也就是证书里的公钥是正确的。 使用到的算法：摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。 目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。 SHA-1架构类似于MD5得散列函数，接受任意大小的输入，生成160位消息散列，容易受到碰撞攻击，这个算法已经不再安全 SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。这个算法目前被认为是安全的，还被应用于广泛领域比如PGP、比特币 参考：https://network.51cto.com/art/202010/628890.htm TLS协议它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本 对比SSL的增强内容： 更安全的MAC算法 更严密的警报 “灰色区域”规范更加明确定义 2.HSTSHTTP 严格传输安全( HSTS ) 是一种策略机制 维基百科： 有助于保护网站免受协议降级攻击[1]和cookie 劫持等中间人攻击。它允许Web 服务器声明Web 浏览器（或其他符合要求的用户代理）应仅使用HTTPS连接自动与其交互，该连接提供传输层安全性(TLS/SSL)，这与单独使用不安全的HTTP不同。HSTS 是IETF标准跟踪协议，在RFC 6797中指定 . 服务器通过名为“”的 HTTP 响应头字段将 HSTS 策略传达给用户代理Strict-Transport-Security。[1] HSTS 策略指定用户代理仅应以安全方式访问服务器的时间段。[2]使用 HSTS 的网站通常不接受明文 HTTP，要么拒绝通过 HTTP 的连接，要么系统地将用户重定向到 HTTPS（尽管规范没有要求）。这样做的结果是无法执行 TLS 的用户代理将无法连接到该站点。 特殊该保护仅在用户至少访问该网站一次后才适用，这依赖于首次使用的信任原则。此保护的工作方式是用户输入或选择指向指定 HTTP 的站点的URL，将自动升级到 HTTPS，而无需发出 HTTP 请求，从而防止发生 HTTP 中间人攻击。 也就是说，不幸的是，你第一次访问这个网站，你不受 HSTS 的保护。 如果网站向 HTTP 连接添加 HSTS 头，则该报头将被忽略。 这是因为攻击者可以在中间人攻击（man-in-the-middle attack）中删除或添加头部。 HSTS 报头不可信，除非它是通过 HTTPS 传递的。 MDN： **HTTP Strict Transport Security**（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过 HTTPS 访问当前资源，而不是HTTP。 语法Strict-Transport-Security: max-age=&lt;expire-time&gt; Strict-Transport-Security: max-age=&lt;expire-time&gt;; includeSubDomains Strict-Transport-Security: max-age=&lt;expire-time&gt;; preloadmax-age=&lt;expire-time&gt; 设置在浏览器收到这个请求后的秒的时间内凡是访问这个域名下的请求都使用 HTTPS 请求。 includeSubDomains 可选 如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。 preload 可选 查看 预加载 HSTS 获得详情。不是标准的一部分。 HSTS应用场景当你你想使用他们的免费 Wi-Fi。您是否注意到他们的 Wi-Fi 密码印在纸上并且从未更改过？ 一个恶毒的黑客在同一家酒店预订了房间。他们正在窃听通过这个不安全的无线网络的所有连接。 该黑客可以通过 HTTP 捕获任何仅依赖 301 重定向以从 HTTP 切换到 HTTPS 的网站的网络流量。这种方法为黑客提供了一个机会之窗，可以剥离您的 SSL 加密并窃取有价值的数据，或者更糟糕的是，提供一个虚假的登录门户页面。 这就是为什么您的网站必须使用 HTTP 严格传输安全而不是 HTTPS。获得 SSL 证书是远远不够的。 数据可能与商店或房屋中的实物一样有价值，因此将它们锁定和保护同样重要。挂锁您的网站有时是不够的，因为人们仍然会找到通过 http:// 访问您的网站的方法。HSTS 强制浏览器和应用程序连接使用 HTTPS（如果可用）。即使有人只是输入 www 或 http://。 设置从 http:// 到 https:// 的 301 重定向不足以完全保护您的域名。HTTP 的不安全重定向仍然存在机会之窗。 协议的支持保护才是有效的保护措施的 $ curl –head http://www.facebook.com HTTP/1.1 301 永久移动位置：https://www.facebook.com/ 黑客仍然能够捕获站点 cookie、会话 ID（通常作为 URL 参数发送）或强制重定向到看起来与您的网站完全相同的网络钓鱼站点。哎哟! 通过安装 Strict-Transport-Security 标头，坏人几乎不可能收集到任何信息！甚至没有你的瑜伽时间表！ $ curl –head https://www.facebook.com HTTP/1.1 200 OK Strict-Transport-Security: max-age=15552000; preload HSTS历史价值数十亿美元的公司 Google 于 2016 年 7 月 29 日正式推出了 HSTS 安全策略。 HSTS 项目最早于 2009 年起草。2015年 6 月 8 日，首席信息官托尼·斯科特 (Tony Scott)发出了一份备忘录 ，而早在 2015 年就一直在进行更强有力的努力。 HSTS 永久要求 您的网站必须具有有效的 SSL 证书。您可以在GlobalSign 的 SSL Checker 上检查您的 SSL 的有效性。 使用 301 永久重定向将所有 HTTP 链接重定向到 HTTPS。 您的 SSL 证书必须涵盖所有子域。考虑订购通配符证书。 在基域上为 HTTPS 请求提供 HSTS 标头。 Max-age 必须至少为 10886400 秒或 18 周。如上所述，争取两年的价值！ 如果您有 includeSubDomains 指令，则必须指定它们！ 必须指定预加载指令。 HSTS工作原理通常，当您在 Web 浏览器中输入 URL 时，您会跳过协议部分。 例如，你输入的是 www.acunetix.com，而不是 http://www.acunetix.com。 在这种情况下，浏览器假设你想使用 HTTP 协议，所以它在这个阶段发出一个 HTTP 请求 到 www.acunetix.com，同时，Web Server 会返回 301 状态码将请求重定向到 HTTPS 站点。 接下来浏览器使用 HTTPS 连接到 www.acunetix.com。 这时 HSTS 安全策略保护开始使用 HTTP 响应头： Strict-Transport-Security: max-age=31536000; includeSubDomains; preload 响应头的 Strict-Transport-Security 给浏览器提供了详细的说明。 从现在开始，每个连接到该网站及其子域的下一年（31536000秒）从这个头被接收的时刻起必须是一个 HTTPS 连接。 HTTP 连接是完全不允许的。 如果浏览器接收到使用 HTTP 加载资源的请求，则必须尝试使用 HTTPS 请求替代。 如果 HTTPS 不可用，则必须直接终止连接。 此外，如果证书无效，将阻止你建立连接。 通常来说，如果 HTTPS 证书无效（如：过期、自签名、由未知 CA 签名等），浏览器会显示一个可以规避的警告。 但是，如果站点有 HSTS，浏览器就不会让你绕过警告。 若要访问该站点，必须从浏览器内的 HSTS 列表中删除该站点。 https握手流程一个请求从零开始所需要经历的RTT 流程 消耗时间 总计 可否缓存 1. DNS 解析网站域名 1-RTT 可缓存（第一次之后） 2. 访问 HTTP 网页 TCP 握手 1-RTT 网站做了HSTS可忽略 3. HTTPS 重定向 302 1-RTT 网站做了HSTS可忽略 4. 访问 HTTPS 网页 TCP 握手 1-RTT 5. TLS 握手第一阶段 Say Hello 1-RTT 6. 【证书校验】CA 站点的 DNS 解析 1-RTT 可缓存（本地） 7. 【证书校验】CA 站点的 TCP 握手 1-RTT 可缓存（本地） 8. 【证书校验】请求 OCSP 验证 1-RTT 可缓存（本地） 9. TLS 握手第二阶段 加密 1-RTT 10. 第一个 HTTPS 请求 1-RTT 10-RTT 一般来说，比较积极的TCP在第三次握手的时候，已经顺便携带了数据，所以本来三次握手 =》 1.5RTT可以变成 1 RTT） 上面这 10 步是最最完整的流程，一般有各种缓存不会经历上面每一步。如果有各种缓存，并且有 HSTS 策略，所以用户每次访问网页都必须要经历的流程如下： 流程 消耗时间 总计 1. 访问 HTTPS 网页 TCP 握手 1-RTT 2. TLS 握手第一阶段 Say Hello 1-RTT 3. TLS 握手第二阶段 加密 1-RTT 4. 第一个 HTTPS 请求 1-RTT 4-RTT 除去 4 是无论如何都无法省掉的以外，剩下的就是 TCP 和 TLS 握手了。 TCP 想要减至 0-RTT，目前来看有点难。那 TLS 呢？目前 TLS 1.2 完整一次握手需要 2-RTT，能再减少一点么？答案是可以的。 TLS1.2握手流程缩减版在上方的 SSL协议 介绍过 第一个RTT： Client 发送一个 ClientHello 消息，Server 必须回应一个 ServerHello 消息或产生一个验证的错误并且使连接失败。 ClientHello 和 ServerHello 建立了如下的属性: 协议版本，会话 ID，密码套件，压缩算法。此外，产生并交换两个随机数: ClientHello.random 和 ServerHello.random。 根据密钥协商算法的不同，交换的信息顺序等细微差别都会存在些许 client、server的随机数是为了避免重放攻击 Server 会在 Certificate 消息中发送它自己的证书，如果它即将被认证。此外，如果需要的话，一个 ServerKeyExchange 消息会被发送(例如, 如果 Server 没有证书, 或者它的证书只用于签名，RSA 密码套件就不会出现 ServerKeyExchange 消息)。如果 Server 被认证过了，如果对于已选择的密码套件来说是合适的话，它可能会要求 Client 发送证书。接下来，Server 会发送 ServerHelloDone 消息，至此意味着握手的 hello 消息阶段完成 Server等待 Client 的响应 如果 Server 发送了一个 CertificateRequest 消息，Client 必须发送 Certificate 消息。现在 ClientKeyExchange 消息需要发送, 这个消息的内容取决于 ClientHello 和 ServerHello 之间选择的公钥算法。如果 Client 发送了一个带签名能力的证书, 则需要发送以一个数字签名的 CertificateVerify 消息，以显式验证证书中私钥的所有权。 一个非匿名的 Server 可以选择性地请求一个 Client 发送的证书 注: 一个匿名 Server 请求认证 Client 会产生一个致命的 handshake_failure 警告错误。 Client 证书的数据结构和 Server Certificate 是相同的。 第二个RTT 这时，Client 发送一个 ChangeCipherSpec 消息，并且复制 pending 的 Cipher Spec 到当前的 Cipher Spec 中. 然后 Client 在新算法, 密钥确定后立即发送 Finished 消息。作为回应，Server 会发送它自己的 ChangeCipherSpec 消息, 将 pending 的 Cipher Spec 转换为当前的 Cipher Spec，在新的 Cipher Spec 下发送 Finished 消息。这时，握手完成， Finished 消息是第一个被刚刚协商的算法，密钥和机密保护的消息。Finished 消息的接收者必须验证内容是正确的。一旦一方已经发送了 Finished 消息且接收并验证了对端发送的 Finished 消息，就可以在连接上开始发送和接收应用数据。 Finished 子消息的存在的意义：在所有的握手协议中，所有的子消息都没有加密和完整性保护，消息很容易篡改，改掉以后如果不检验，就会出现不安全的攻击。为了避免握手期间存在消息被篡改的情况，所以 Client 和 Server 都需要校验一下对方的 Finished 子消息。 如果中间人在握手期间把 ClientHello 的 TLS 最高支持版本修改为 TLS 1.0，企图回退攻击，利用 TLS 旧版本中的漏洞。Server 收到中间人的 ClientHello 并不知道是否存在篡改，于是也按照 TLS 1.0 去协商。握手进行到最后一步，校验 Finished 子消息的时候，校验不通过，因为 Client 原本发的 ClientHello 中 TLS 最高支持版本是 TLS 1.2，那么产生的 Finished 子消息的 verify_data 与 Server 拿到篡改后的 ClientHello 计算出来的 verify_data 肯定不同。至此也就发现了中间存在篡改，握手失败。 Client Server ClientHello --------> ServerHello Certificate* ServerKeyExchange* CertificateRequest* &lt;-------- ServerHelloDone Certificate* ClientKeyExchange CertificateVerify* [ChangeCipherSpec] Finished --------> [ChangeCipherSpec] &lt;-------- Finished Application Data &lt;-------> Application Data 证书类型 密钥交换算法 证书类型 RSA RSA_PSK 证书中包含 RSA 公钥，该公钥可以进行密码协商，也就是使用 RSA 密码协商算法；证书必须允许密钥用于加密(如果 key usage 扩展存在的话，则 keyEncipherment 位必须被设置，表示允许服务器公钥用于密码协商) 注:RSA_PSK 定义于 [TLSPSK] DHE_RSA ECDHE_RSA 证书中包含 RSA 公钥，可以使用 ECDHE 或者 DHE 进行密钥协商；证书必须允许密钥使用 Server 密钥交互消息中的签名机制和 hash 算法进行签名 (如果 key usage 扩展存在的话，digitalSignature 位必须设置，RSA 公钥就可以进行数字签名) 注: ECDHE_RSA定义于 [TLSECC] DHE_DSS 证书包含 DSA 公钥; 证书必须允许密钥用于使用将在 Server 密钥交换消息中使用的散列算法进行签名 DH_DSS DH_RSA 证书中包含 DSS 或 RSA 公钥，使用 Diffie-Hellman 进行密钥协商; 如果 key usage 扩展存在的话，keyAgreement 位必须设置，目前这种套件已经很少见了。 ECDH_ECDSA ECDH_RSA 证书包含 ECDSA 或 RSA 公钥，使用 ECDH-capable 进行密钥协商。由于是静态密钥协商算法，ECDH 的参数和公钥包含在证书中; 公钥必须使用一个能够被 Client 支持的曲线和点格式, 正如 [TLSECC] 中描述的那样。目前这种套件已经很少见了，因为 ECDH 不支持前向安全性 ECDHE_ECDSA 证书包含 ECDSA-capable 公钥，使用 ECDHE 算法协商预备主密钥; 证书必须允许密钥用于使用将在 Server 密钥交换消息中使用的散列算法进行签名;公钥必须使用一个能够被 Client 支持的曲线和点格式，Client 通过 Client Hello 消息中的 ec_point_formats 扩展指定支持的命名曲线，正如 [TLSECC] 中描述的那样。这是 TLS 1.2 中最安全，性能最高的密码套件。 如果 Client 提供了一个 “signature_algorithms” 扩展，则 Server 提供的所有证书必须由出现在这个扩展中的一个 hash/签名算法对进行签名。需要注意的是这意味着一个包含了一个签名算法密钥的证书应该被一个不同的签名算法签名(例如，RSA 密钥被 DSA 密钥签名)。这个与 TLS 1.1 不同，TLS 1.1 中要求算法是相同的。更进一步也说明了 DH_DSS，DH_RSA，ECDH_ECDSA，和 ECDH_RSA 套件的后半部分对应的公钥不会用来加密或者数字签名，没有存在的必要性，并且后半部分也不限制 CA 机构签发证书所选用的数字签名算法。固定的 DH 证书可以被出现在扩展中的任意 hash/签名算法对签名。DH_DSS，DH_RSA，ECDH_ECDSA，和 ECDH_RSA 是历史上的名称。 如果 Server 有多个证书, 它基于上述标准(此外其它的标准有:传输层端点，本地配置和偏好等)选择其中一个。如果 Server 只有一个证书，它应该尝试使这个证书符合这些标准。 需要注意的是有很多证书使用无法与 TLS 兼容的算法或算法组合。例如，一个使用 RSASSA-PSS 签名密钥的证书(在 SubjectPublicKeyInfo 中是 id-RSASSA-PSS OID)不能被使用因为 TLS 没有定义相应的签名算法。 正如密钥套件指定了用于 TLS 协议的新的密钥交换方法，它们也同样指定了证书格式和要求的编码的按键信息。 至此已经涉及到了 Client 签名算法、证书签名算法、密码套件、Server 公钥，这 4 者相互有关联，也有没有关系的。 Client 签名算法需要和证书签名算法相互匹配，如果 Client Hello 中的 signature_algorithms 扩展与证书链中的证书签名算法不匹配的话，结果是握手失败。 Server 公钥与证书签名算法无任何关系。证书中包含 Server 证书，证书签名算法对 Server 公钥进行签名，但是 Server 公钥的加密算法可以是 RSA 也可以是 ECDSA。 密码套件和 Server 公钥存在相互匹配的关系，因为密码套件中的身份验证算法指的就是 Server 公钥类型。 TLS 1.2 会话恢复当 Client 和 Server 决定复用之前的一个TLS连接会话时（走TLS握手缓存），需要以下流程： Client 使用需要恢复的当前会话的 ID 发送一个 ClientHello。Server 检查它的会话缓存以进行匹配。如果匹配成功，并且 Server 愿意在指定的会话状态下重建连接，它将会发送一个带有相同会话 ID 值的 ServerHello 消息。这时，Client 和 Server 必须都发送 ChangeCipherSpec 消息并且直接发送 Finished 消息。一旦重建立完成，Client 和 Server 可以开始交换应用层数据(见下面的流程图)。如果一个会话 ID 不匹配，Server 会产生一个新的会话 ID，然后 TLS Client 和 Server 需要进行一次完整的握手。 Session ID此时有两种方法可以恢复原来的session session ID session ticket Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过Session ID来区分不同的客户，通过这个Session ID，双方还可以重新使用已有的”对话密钥“，无需重新生成 基于 Session ID 的会话恢复 Session ID 的来源： 上次完全握手生成的 Session ID 使用另外一条连接的 Session ID 直接使用本次连接的 Session ID 基于 Session ID 的会话恢复的优点是: 减少网络延迟，握手耗时从 2-RTT -&gt; 1-RTT（client hello的时候就发了） 减少了 Client 和 Server 端的负载，减少了加密运算的 CPU 资源消耗 高兼容性 基于 Session ID 的会话恢复的缺点是: Server 存储会话信息，限制了 Server 的扩展能力。 分布式系统中，如果只是简单的在 Server 的内存中存储 Session Cache，那么多台机器的数据同步也是一个问题。（只能保留在一个服务器上） 基于 Session ID 会话恢复的流程如下： Client Server ClientHello --------&gt; ServerHello [ChangeCipherSpec] &lt;-------- Finished [ChangeCipherSpec] Finished --------&gt; Application Data &lt;-------&gt; Application DataSession Ticket 基于 Session Ticket 的会话恢复流程： 对于 Server 来说，解密 ticket 就可以得到主密钥，(注意这里和 SessionID 不同，有 Session ID 可以得到主密钥的信息) 其思想是服务器取出它的所有会话数据（状态）并进行加密 (密钥只有服务器知道)，再以票证的方式发回客户端。在接下来的连接中，客户端恢复会话时在 ClientHello 的扩展字段 session_ticket 中携带加密信息将票证提交回服务器，由服务器检查票证的完整性，解密其内容，再使用其中的信息恢复会话。 Session Ticket 的优点也就决定了它特别适合在以下场景中使用： 大型 HTTPS 网站，访问量非常大，在 Server 中存储 Session 信息需要消耗大量内存 HTTPS 网站所有者希望会话信息的生命周期能足够长，让 Client 尽量都使用简短握手的方式 HTTPS 网站所有者希望用户能跨地域跨主机访问 校验 SessionTicket 失败，那么握手会回退到完整握手。 如果 Client 在 ClientHello 中同时发送了 Session ID 和 SessionTicket TLS 扩展，SessionTicket 优先级高于 Session ID SessionTicket 会话恢复 Client Server ClientHello (SessionTicket extension) --------> ServerHello (empty SessionTicket extension) NewSessionTicket [ChangeCipherSpec] &lt;-------- Finished [ChangeCipherSpec] Finished --------> Application Data &lt;-------> Application Data Sever验证了客户端发送Finished消息后，通过”New session ticket”消息将session ticket发给客户端进行保存，服务器端就不再保存会话状态了，下图是这条消息所在的流程步骤： 客户端在下次发起会话时，就可以将Session Ticket放入client hello中，服务器收到后进行解密验证，并从ticket的内容中提取会话状态，用来恢复会话。 session ticket优点 可在其他服务器上使用，它原理上就是让xx的的请求一直粘连在机器A上，下次重连的时候，就把这个 Ticket 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。 缺点： 兼容性比不上session id 和session id一样，有安全风险 之前会话的master key是否泄密（Session Ticket: 加密后的session status信息，包含了master key），否则新的session key也不安全。 缺乏身份验证机制，无法防止中间人攻击。（需要证书认证来保证） TLS给出的方案是，恢复会话必须双方都同意，如果有一方认为会话不安全，就都需要重新走一遍完整的握手流程；另外客户端保存session ticket的有效期最长不要超过24小时； 如果对于sessionID和ticket还不太明白Session id： Session id是由服务器分配的，发给客户端让客户端保存，在客户端发起新会话时，会将这个ID在client hello中发给服务器，用来判断是否恢复之前的session。 服务器在缓存中查找该id，如果找到了，并且服务器愿意重建该会话的话，那么就会在Sever Hello消息中发送同样的session id 之后双方就可以开始用之前协商过的加密模式开始传输数据。 Session id是最传统的方式，它的主要问题是，会话状态保存在服务器端，当大量用户访问服务器时，服务器用来保存会话状态的空间占用就会很大，需要对保存时间，保存机制做优化。 session ticket： 服务器在获取到客户端的密钥协商参数，并生成session key之后，会将完整的会话状态(session status)进行加密，生成session ticket，注意，这个信息只有服务器才能够解密 Sever验证了客户端发送Finished消息后，通过”New session ticket”消息将session ticket发给客户端进行保存，服务器端就不再保存会话状态了，下图是这条消息所在的流程步骤： 客户端在下次发起会话时，就可以将Session Ticket放入client hello中，服务器收到后进行解密验证，并从ticket的内容中提取会话状态，用来恢复会话。 （你大概可以理解为，把会话内容加密后当成session凭证来使用了） PSK（pre_share_key）在TLS1.3中，引入新的session resumption机制代替了session id和ticket. 双方经过握手和密钥协商，和身份验证之后，生成对称的密钥session key。 在收到客户端的finished消息之后，服务器通过”new session ticket”消息，携带PSK发送给客户端，注意这条消息是使用session key加密的，这就保证了只有通信双方才能读取里面的信息。（实质上我个人理解就是非对称密钥保证安全性，然后使用原来的对称密钥保证便捷性） 只要证明了双方都持有相同的 PSK，就不再需要证书认证来证明双方的身份，这样看来，PSK 也算是一种身份认证机制。 服务器可能会发送多个new session ticket，包含不同的PSK； 在建立新会话时，客户端将PSK信息放入client Hello消息中发送给服务器，报文如下： 如果服务器验证了该PSK的真实性，则会在server hello中的pre_shared_key中将加密的PSK发送给客户端； 那么之前的PSK就会被用来生成新的session key，并开始加密传输数据，不需要再发送CA证书等验证消息了。 只要证明了双方都持有相同的PSK，不再需要证书认证，就可以证明双方的身份，因此，PSK也是一种身份认证机制。 Client Server ClientHello + key_share --------> ServerHello + key_share {EncryptedExtensions} {CertificateRequest*} {Certificate*} {CertificateVerify*} {Finished} &lt;-------- [Application Data*] {Certificate*} {CertificateVerify*} {Finished} --------> &lt;-------- [NewSessionTicket] [Application Data] &lt;-------> [Application Data] TLS1.3先简述一下 TLS 1.3 的一些优化和改进: 减少握手等待时间，将握手时间从 2-RTT 降低到 1-RTT，并且增加 0-RTT 模式。 删除 RSA 密钥协商方式，静态的 Diffie-Hellman 密码套件也被删除了。因为 RSA 不支持前向加密性。TLS 1.3 只支持 (EC)DHE 的密钥协商算法。删除了 RSA 的方式以后，能有效预防心脏出血的攻击。所有基于公钥的密钥交换算法现在都能提供前向安全。TLS 1.3 规范中只支持 5 种密钥套件，TLS13-AES-256-GCM-SHA384、TLS13-CHACHA20-POLY1305-SHA256、TLS13-AES-128-GCM-SHA256、TLS13-AES-128-CCM-8-SHA256、TLS13-AES-128-CCM-SHA256，隐藏了非对称加密密钥协商算法，因为默认都是椭圆曲线密钥协商。 删除对称加密中，分组加密和 MAC 导致的一些隐患。在 TLS1.3 之前的版本中，选择的是 MAC-then-Encrypt 方式。但是这种方式带来了一些漏洞，例如 BEAST，一系列填充 oracle 漏洞(Lucky 13 和 Lucky Microseconds)。CBC 模式和填充之间的交互也是 SSLv3 和一些 TLS 实现中广泛宣传的 POODLE 漏洞原因。在 TLS 1.3 中，已移除所有有安全隐患的密码和密码模式。你不能再使用 CBC 模式密码或不安全的流式密码，如 RC4 。TLS 1.3 中允许的唯一类型的对称加密是一种称为 AEAD（authenticated encryption with additional data）的新结构，它将加密性和完整性整合到一个无缝操作中。 在 TLS 1.3中，删除了 PKCS＃1 v1.5 的支持，而选择更新的设计 RSA-PSS，提高了安全性。认证方面通过非对称算法，例如，RSA, 椭圆曲线数字签名算法(ECDSA)，或 Edwards 曲线数字签名算法(EdDSA)完成，或通过一个对称的预共享密钥（PSK)。 在 TLS 1.2 的握手流程中，只有 ChangeCipherSpec 之后的消息会被加密，如 Finished 消息和 NewSessionTicket，其他的握手子消息不会加密。TLS 1.3 针对这个问题，对握手中大部分子消息全部进行加密处理。这样可以有效的预防 FREAK，LogJam 和 CurveSwap 这些降级攻击(降级攻击是中间人利用协商，强制使通信双方使用能被支持的最低强度的加密算法，从而暴力攻击计算出密钥，允许攻击者在握手时伪造 MAC)。在TLS 1.3中，这种类型的降级攻击是不可能的，因为服务器现在签署了整个握手，包括密码协商。 TLS 1.3 完全禁止重协商。 密钥导出函数被重新设计，由 TLS 1.2 的 PRF 算法改为更加安全的 HKDF 算法。 废除 Session ID 和 Session Ticket 会话恢复方式，统一通过 PSK 的方式进行会话恢复，并在 NewSessionTicket 消息中添加过期时间和用于混淆时间的偏移值。 我个人归纳为 减少握手等待时间，将握手时间从 2-RTT 降低到 1-RTT，并且增加 0-RTT 模式。 删除 RSA 密钥协商方式，预防心脏出血的攻击；删除对称加密中，分组加密和 MAC 导致的一些隐患；删除了 PKCS＃1 v1.5 的支持，而选择更新的设计 RSA-PSS，提高了安全性；对握手中大部分子消息全部进行加密处理。这样可以有效的预防 FREAK，LogJam 和 CurveSwap 这些降级攻击； 完全禁止重协商；重新设计密钥导出函数；总体来说都是提升安全性 废除 Session ID 和 Session Ticket 会话恢复方式，统一通过 PSK 的方式进行会话恢复，并在 NewSessionTicket 消息中添加过期时间和用于混淆时间的偏移值。 更加安全 4 种密钥协商在 TLS 1.3 中，存在 4 种密钥协商的方法: Client 支持的加密套件列表。密码套件里面中能体现出 Client 支持的 AEAD 算法或者 HKDF 哈希对。（TLS1.2已有） “supported_groups” 的扩展 和 “key_share“ 扩展。“supported_groups” 这个扩展表明了 Client 支持的 (EC)DHE groups，”key_share” 扩展表明了 Client 是否包含了一些或者全部的（EC）DHE共享。（TLS1.3新增，完整握手） “signature_algorithms” 签名算法和 “signature_algorithms_cert” 签名证书算法的扩展。”signature_algorithms” 这个扩展展示了 Client 可以支持了签名算法有哪些。”signature_algorithms_cert” 这个扩展展示了具体证书的签名算法。（TLS1.3新增，比第二种常用） “pre_shared_key“ 预共享密钥和 “psk_key_exchange_modes” 扩展。预共享密钥扩展包含了 Client 可以识别的对称密钥标识。”psk_key_exchange_modes” 扩展表明了可能可以和 psk 一起使用的密钥交换模式。（TLS1.3新增，PSK，0-RTT） 初次握手降低为1RTTTLS 1.3 之所以能比 TLS 1.2 完整握手减少 1-RTT 的原因就在 ClientHello 中就已经包含了 (EC)DHE 所需要的密钥参数， （是的，我有了个key_share，但是实际上我个人感觉只是减少了0.5RTT，只不过将剩下finish所需要的的0.5RTT应该是放到application Data exchange中了） 不需要像 TLS 1.2 中额外用第二次 RTT 来进行 DH 协商参数。在 TLS 1.3 的 ClientHello 的 Extension 中，带有 key_share 扩展，这个扩展中包含了 Client 所能支持的 (EC)DHE 算法的密钥参数。并且 Extension 中还会有 supported_groups 扩展，这个扩展表明了 Client 支持的用于密钥交换的命名组。按照优先级从高到低。 Client Server ClientHello + key_share --------> ServerHello + key_share {EncryptedExtensions} {CertificateRequest*} {Certificate*} {CertificateVerify*} {Finished} &lt;-------- [Application Data*] {Certificate*} {CertificateVerify*} {Finished} --------> &lt;-------- [NewSessionTicket] [Application Data] &lt;-------> [Application Data] 条件：在 ServerHello 的 Extension 中必须要有的这 2 个扩展，supported_versions、key_share(如果是 PSK 会话恢复方式，还必须包含 pre_shared_key)。 supported_versions 是 TLS 1.3 中必带的扩展，如果没有这个扩展，Server 会认为 Client 只能支持 TLS 1.2，于是接下来的握手会进行 TLS 1.2 的握手流程。 TLS1.3会话恢复TLS 1.3 在宣传的时候就以 0-RTT 为主，大家都会认为 TLS 1.3 再第二次握手的时候都是 0-RTT 的，包括网上一些分析的文章里面提到的最新的 PSK 密钥协商，PSK 密钥协商并非是 0-RTT 的。 TLS 1.3 再次握手其实是分两种：会话恢复模式、0-RTT 模式。非 0-RTT 的会话恢复模式和 TLS 1.2 在耗时上没有提升，都是 1-RTT，只不过比 TLS 1.2 更加安全了。只有在 0-RTT 的会话恢复模式下，TLS 1.3 才比 TLS 1.2 有提升。具体提升对比见下表: HTTP/2 + TLS 1.2 首次连接 HTTP/2 + TLS 1.2 会话恢复 HTTP/2 + TLS 1.3 首次连接 HTTP/2 + TLS 1.3 会话恢复 HTTP/2 + TLS 1.3 0-RTT DNS 解析 1-RTT 0-RTT 1-RTT 0-RTT 0-RTT TCP 握手 1-RTT 1-RTT 1-RTT 1-RTT 1-RTT TLS 握手 2-RTT 1-RTT 1-RTT 1-RTT 0-RTT HTTP 请求 1-RTT 1-RTT 1-RTT 1-RTT 1-RTT 总计 5-RTT 3-RTT 4-RTT 3-RTT 2-RTT Client Server Subsequent Handshake: ClientHello + key_share* + pre_shared_key --------> ServerHello + pre_shared_key + key_share* {EncryptedExtensions} {Finished} &lt;-------- [Application Data*] {Finished} --------> [Application Data] &lt;-------> [Application Data] 0RTT模式TLS 1.3 废除了之前的 Session ID 和 Session Ticket 的会话恢复的方式，统一成了 PSK 方式，使得原有会话恢复变的更加安全。但是 TLS 1.3 的会话恢复并没有降低 RTT，依旧停留在了 1-RTT。为了进一步降低延迟，于是提出了 0-RTT 的概念。0-RTT 能让用户有更快更顺滑更好的用户体验，在移动网络上更加明显。 TLS 1.3 的里程碑标志就是添加了 0-RTT 会话恢复模式。也就是说，当 client 和 server 共享一个 PSK（从外部获得或通过一个以前的握手获得）时，TLS 1.3 允许 client 在第一个发送出去的消息中携带数据（”early data”）。Client 使用这个 PSK 生成 client_early_traffic_secret 并用它加密 early data。Server 收到这个 ClientHello 之后，用 ClientHello 扩展中的 PSK 导出 client_early_traffic_secret 并用它解密 early data。 0-RTT 会话恢复模式如下： Client Server ClientHello + early_data + key_share* + psk_key_exchange_modes + pre_shared_key (Application Data*) --------> ServerHello + pre_shared_key + key_share* {EncryptedExtensions} + early_data* {Finished} &lt;-------- [Application Data*] (EndOfEarlyData) {Finished} --------> [Application Data] &lt;-------> [Application Data] 可以理解为此时为TLS1.3握手恢复，我们客户端服务端双方认证 + 携带PSK，我们客户端发送第一次请求时，直接携带PSK + 通过PSK加密的要发送的数据内容（early data） 想实现 0-RTT 也是有一些条件的，条件比较苛刻，如果条件有一条不满足，会话恢复都只能是 1-RTT 的 PSK 会话恢复模式。 0-RTT 的开启条件是： Server 在前一次完整握手中，发送了 NewSessionTicket，并且 Session ticket 中存在max_early_data_size 扩展表示愿意接受 early data。如果没有这个扩展，0-RTT 无法开启。 在 PSK 会话恢复的过程中，ClientHello 的扩展中配置了 early data 扩展，表示 Client 想要开启 0-RTT 模式。 Server 在 Encrypted Extensions 消息中携带了 early data 扩展表示同意读取 early data。0-RTT 模式开启成功。 只有同时满足了上面 3 个条件，才能开启 0-RTT 会话恢复模式。否则握手会是 1-RTT 的会话恢复模式。 注意：目前不少浏览器虽然支持 TLS 1.3 协议，但是还不支持发送 early data，所以它们也没法启用 0-RTT 模式的会话恢复。 而Server 想拒绝 Client 的 0-RTT 会话恢复，只要打破 3 个开启条件即可，可以： 拒绝 PSK。Server 在 ServerHello 中不加入 pre_shared_key 扩展，那么握手就会回退到完整握手，自然拒绝了 0-RTT。 只拒绝 early_data，接受 PSK。在 ServerHello 中，加入 pre_shared_key 扩展，但是EncryptedExtension 子消息中不加入 early_data 扩展。 0-RTT 存在安全性风险但是 0-RTT 存在安全性风险。0-RTT 数据安全性比其他类型的 TLS 数据要弱一些，特别是： 0-RTT 的数据是没有前向安全性的，它使用的是被提供的 PSK 中导出的密钥进行加密的。 在多个连接之间不能保证不存在重放攻击。普通的 TLS 1.3 1-RTT 数据为了防止重放攻击的保护方法是使用 server 下发的随机数，现在 0-RTT 不依赖于 ServerHello 消息，因此保护措施更差。如果数据与 TLS client 认证或与应用协议里一起验证，这一点安全性的考虑尤其重要。这个警告适用于任何使用 early_exporter_master_secret 的情况。（不依赖server hello了，所以没有随机数保证重放攻击的防御） TLS 1.3 0-RTT 中要预防重放攻击。预防 0-RTT 有 4 种措施： 第一个措施检查 PSK 中的过期时间，如果过期了，就不处理 early_data 中的请求，并且将握手降级到 1-RTT。 第二个措施是不允许非幂等性的请求出现在 0-RTT 中，如果出现了非幂等性的请求，Server 将会忽略不处理，GET 请求是幂等性的，但是也不能允许后面带参数，不带参数的 GET 请求才能允许。 第三个措施是，在请求头中记录 PSK binder 的值或者一个随机值，这个值能保证 0-RTT 的 early_data 全局唯一，这样就可以防止重放攻击。当收到 ClientHello 时，Server 首先验证 PSK binder。然后它会计算 expected_arrival_time，如果它在记录窗口之外，则拒绝 0-RTT，然后回到 1-RTT 握手。如果 expected_arrival_time 在窗口中，则 Server 检查它是否记录了匹配的 ClientHello。如果找到一个，它将使用 “illegal_parameter” alert 消息中止握手或接受 PSK 但拒绝 0-RTT。如果找不到匹配的 ClientHello，则它接受 0-RTT，然后只要 expected_arrival_time 在窗口内，就存储 ClientHello。Server 也可以实现具有误报的数据存储，例如布隆过滤器，在这种情况下，它们必须通过拒绝 0-RTT 来响应明显的重放，但绝不能中止握手。关于这一个措施，还可能存在多个 binder 的情况，如果是分布式系统，还会存在多个 zone 的问题，具体分析见笔者这篇文章 《TLS 1.3 0-RTT and Anti-Replay》。 第四个措施是，在数据库里面记录所有未完成有效的 ticket，使用一次就删除掉，如果产生重放攻击，那么这个 ticket 必然是数据库里面查不到的，那么就回退到完整握手。 参考： HTTPS 温故知新（三） —— 直观感受 TLS 握手流程(上) 当我们谈论HTTPS时，我们在谈什么(八) Session Ticket, Session ID 和 PSK HTTPS 温故知新（四） —— 直观感受 TLS 握手流程(下)","categories":[{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"Hello"},{"title":"服务器与部署","slug":"服务器与部署","date":"2021-03-07T16:00:00.000Z","updated":"2022-07-06T16:31:49.991Z","comments":true,"path":"2021/03/08/fu-wu-qi-yu-bu-shu/","link":"","permalink":"https://taylor12138.github.io/2021/03/08/fu-wu-qi-yu-bu-shu/","excerpt":"","text":"1.部署方式利用脚手架打包后得到dist文件 将自己电脑作为服务器，部署本地 ：window -&gt; 使用nginx或者tomcat 远程主机，进行部署：linux centos -&gt; nginx 如 注意 ：使用nginx时，关闭不用粗暴乱结束进程关闭，可能会产生一些关不掉等小bug，记得cmd进去nginx根目录下 nginx -s stop即可 在部署Vue、Node.js和MongoDB部署上给予一定帮助的网址：https://segmentfault.com/a/1190000022921908 使用react cli在宝塔部署前端项目的时候，需要在package.json中，设置homepage，不然找不到资源：https://blog.csdn.net/Sophie_U/article/details/80006723 里面关于后端部署部分，可以将依赖模块的绝对路径换成直接在后端项目下，使用终端 npm i 如果是使用腾讯云轻量级服务器+宝塔可以看这个https://cloud.tencent.com/document/product/1207/54078 部署时踩的坑： 面对404时，是找不到资源，在本地上可以运行，而部署到服务器上却出现了404，很有可能是api链接等没有写对，导致找不到真正的地址；部署后台项目的时候，我将异步请求的 axios baseURL 改成：自己的公网地址:端口号，实际上是只需改成：自己的公网地址就可以了，害我看了半天 面对网页直接404时，请查看nginx的配置有没有配对 面对502时，可能是服务器暂未开启 面对500时，是服务器发生内部错误，我看了半天的服务端代码，发现没错，实际上是请求的数据有一段时number类型，我测试的时候胡乱输入字符串，也会发生500错误 当我们获取的img 的src资源发生 403的时候，我们可以在html头部添加 &lt;meta name=\"referrer\" content=\"no-referrer\" /> https://segmentfault.com/a/1190000017896469 当服务器一直开不了时，可以查看在linux命令里查看pm2日志查找问题 pm2 logs 组件化有个缺点，就是，可能不能及时发现变量名，语法错误导致的结果出不来，已经卡住两次了，记住语法、变量名基本错误不能犯 关于定时任务（宝塔的计划任务，出现 line 4: node: command not found 的错误），解决方法：讲定时任务里面的shell脚本里添加以下操作： https://www.bt.cn/bbs/thread-10252-1-1.html https://github.com/Tammeny/blog/blob/master/source/_posts/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8CNodeJS.md 还有一些PM2任务管理器的一些操作符献上： pm2 start app.js # 启动app.js应用程序 pm2 list # 列表 PM2 启动的所有的应用程序 pm2 restart all # 重启所有应用 2.github actionsGitHub action产生的初衷是用于CI的，也就是持续集成。但我发现实际上很多GitHub上的项目，使用到GitHub actions 定时跑自己的脚本，比如签到类、每天自动做任务类的脚本（当然我还看到很多csdn的老哥使用它来哔哩哔哩签到投币等 0.0 ） github老哥的入门指南https://github.com/shfshanyue/you-dont-need-vps/blob/master/github-action-guide.md 与此同时，还可以使用linux命令 crontab命令定时执行脚本，实现以上功能 3.服务器软件 Web服务器：提供Web化服务，当下几乎所有服务器软件都可以成为Web服务器 Http服务器：侧重静态资源传输的支持 应用服务器：常被称作动态服务器 1.Nginx：http服务器，性能好、稳定好、一般放在最前面 2.Tengine：基于Nginx，加强和封装 3.Apache：静态服务器，性能不如Nginx，所以Nginx使用居多 4.IIS：微软阵营的Web服务器，只能运行在windows，http静态服务器 5.Tomcat：典型java应用服务器软件，动态服务器， 一般和Nginx这种静态服务器一起打配合 NginxNginx 是高性能的 HTTP 和反向代理的web服务器，处理高并发能力是十分强大的，能经受高负 载的考验,有报告表明能支持高达 50,000 个并发连接数。 正向代理 正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。（隐藏客户端） （一个很简单的例子：VPN） 简单一点：通过代理服务器来访问服务器的过程 就叫 正向代理。 需要在客户端配置代理服务器进行指定网站访问 正向代理的用途： （1）访问原来无法访问的资源，如Google （2） 可以做缓存，加速访问资源 （3）对客户端访问授权，上网进行认证 （4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问。 我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。（隐藏服务端） （一个个简单的例子：将用户的访问转发到服务器内网） 反向代理的作用： （1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 （2）负载均衡，通过反向代理服务器来优化网站的负载 实际上用一种通俗比喻来形容正反向代理，可以解说为正向代理为我国的海关关口，反向代理是目标国家（外国）的海关关口 负载均衡将原先请求集中到单个服务器上的 情况改为，中间经过一个负载均衡器，然后将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端 4.自建服务器借助serve库，能让某一指定文件夹（作为根目录）快速开启一台服务器 npm i serve -g 然后在自建的文件夹下开启服务器： serve 或者该目录下（“文件名”的文件作为根目录） serve 文件名 5.大前端大前端实际上就是所有前端的统称，大前端最大的特点在于一次开发，适配所有平台，实现代码复用，是一个web走向统一的时代。 是前端方向进阶，践行工程化、迈进全球化、深入组件化的过程 在node出现后，前端工程师可以暂时不依赖后端程序而运行自己的整体项目，从而实现先后端分离 大前端势必称为移动开发 &amp; Web前端的发展趋势，在学习原生的同时，前端人员也要学习Android 或 IOS 的原生开发技术，才能更好地融入大前端的圈子 跨平台跨多平台的方案有： H5+原生（Cordova、Ionic、微信小程序），这种模式又称为Hybrid开发 社区及资源丰富，缺点是性能不好 JavaScript开发+原生渲染 （React Native（FaceBook）、Weex（阿里）、Picasso（美团）、快应用） 性能相比H5提高很多；动态化较好，支持热更新 渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿 自绘UI+原生(Flutter） Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，避免对原生控件依赖而带来的限制及高昂的维护成本 不支持动态下发代码和热更新 增强版Web App(PWA) 等 现在很多大公司都加入了多端大战，自己公司分别研发多端跨平台统一框架 跨端优势 从开发者角度看： 降低开发成本（研发效率、代码重用、多平台支持） 快速开发原型 UI 一致性 从企业角度看： 支持多平台 触及更广的市场 降低前期成本 附上前端本人的照片（美人部分） RPCRPC是指远程过程调用，比如说服务器A上的项目调用服务器B上提供的函数和方法 rpc需要面临的问题 1.由于网络协议是基于二进制的，所以需要序列化和反序列化 2.解决通信、寻址等网络问题 6.CDN服务器为了缩短http请求的时间，我们应该把大量的静态资源放置的离用户近一点。 内容发布网络CDN（Content Delivery Networks）就是其中一种方式。CDN是一组分布在多个不同地理位置或网段的web服务器，用于更加有效的向用户发布内容。 CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。 大白话： 就是CDN是一堆服务器，其中一部分服务器分布在各个地点，被称为边缘节点， 源服务器把静态内容提前备份给边缘节点服务器（push）（主要是静态资源） 如果用户访问的时候边缘节点服务器没有对应资源，就会递归查询去查边缘节点的父节点服务器，一直没有就一直查询到源站，然后父节点从源站下载该资源（pull），父节点分发给刚才用户访问的边缘节点，下一次另外一个用户访问的时候，直接访问该边缘节点就可以直接访问到了 基本机制 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定； 通过在网络各处放置节点服务器，在现有的互联网基础之上构成一层智能虚拟网络； CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。选择的缓存服务器： 哪一台服务器距用户最近 哪一台有所需内容 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力 最简单的CDN网络由一个DNS服务器和几台缓存服务器组成 用户输入url -&gt; DNS域名解析 -&gt; 解析权交给CNAME指向的CDN专用DNS服务器。 用户向CDN的全局负载均衡设备发起内容URL访问请求 -&gt; 负载均衡器选择缓存服务器 -&gt; 返回该缓存服务器给用户 用户向缓存服务器发起请求，缓存服务器响应用户请求 一加一减 加速了网络请求，减少了网络带宽费用（网站主要根据网络带宽消耗向主机商支付费用） 安全：大量CDN节点的存在，可以有效地将攻击由中心化分散到CDN的边缘上，从而有效地阻止或者减小攻击造成的危害 应用场景 网站站点/应用加速： 站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器ECS，静态资源如各类型图片、html、css、js文件等，使用CDN服务器存储，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。 移动应用加速： 移动APP更新文件（apk文件）分发，移动APP内图片、页面、短视频、UGC等内容的优化加速分发。提供httpDNS服务，避免DNS劫持并获得实时精确的DNS解析结果，有效缩短用户访问时间，提升用户体验。 视音频点播/大文件下载分发加速； 视频直播加速； 值得注意 CDN是只对网站的某一个具体的域名加速，如果同一个网站有多个域名，则访客访问加入CDN的域名获得加速效果，访问未加入CDN的域名，或者直接访问IP地址，则无法获得CDN效果。 CDN对网站的访客完全透明，不需要访客手动选择要访问的镜像站点，保证了网站对访客的友好性。 CDN部署简单，对原站基本不做任何改动即可生效。 性能提高 比较不同服务等级license的差别（购买的vip等级） 避免全量发布新图片格式（no更换图片格式） 尽量对图片只新增不修改，有利于提高CDN命中率 CDN的性能问题一般和大量回源相关，可以通过细分监控来确定是由哪个域名引起的，通过监控的衰变时间点，确定项目发布是否会引起大量的回源，一般成熟的CDN是能够保障稳定性的 7.上线优化 &amp; 走查前端性能优化逃不开回到我们擅长的前端领域，当我们谈到性能优化时，总是逃不开几条金科玉律 减小包体积，包括对 HTML、CSS、JavaScript 代码的压缩等 减小 HTTP 请求，使用服务端 gzip 压缩 使用 Webpack、Rollup 等现代构建工具来抽离公共代码，Code Splitting 代码拆分等 上线走查清单 页面和资源( js 和 css )，是否gzip； cdn，开启缓存，缓存时间一般大于一个月； 资源文件类型（js 为 application/javascript，css 为 text/css）； 连接（html、js、css、图片）是否开启 http2； 页面显示正常； 接口请求正常（没有重复或多余的请求）； 首屏图片请求数量，是否使用懒加载； 图片大小，是否裁剪； 关注 wapm 性能指标(实验室)，如大图，大资源文件； 第三方依赖； 体验检查，如接口请求是否有过渡 loading，兜底的错误展示，隐藏的模块是否要提前请求数据； 参考文章https://zhuanlan.zhihu.com/p/28940451 参考书籍《大型网站性能优化实战》—周涛明、张荣华、张新兵","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"跨端相关","slug":"跨端相关","date":"2021-03-07T16:00:00.000Z","updated":"2022-08-21T09:17:36.521Z","comments":true,"path":"2021/03/08/kua-duan-xiang-guan/","link":"","permalink":"https://taylor12138.github.io/2021/03/08/kua-duan-xiang-guan/","excerpt":"","text":"1.webviewwebView是移动端(原生)提供的运行web的环境，它是一种嵌入式浏览器，原生应用可以用它来展示网络内容。可与页面JavaScript交互，实现混合开发。 webview渲染的作用是：webview可以内嵌在移动端，实现前端的混合式开发，大多数混合式开发框架都是基于webview模式进行二次开发的。webview可以直接使用html文件（网络上或本地assets中）作布局，可和JavaScript交互调用。webview是一个基于webkit的引擎。 所以webview是H5跨端常用方式 2.JSBridgeWeb端和Native可以类比于Client/Server模式，Web端调用原生接口时就如同Client向Server端发送一个请求类似，JSB在此充当类似于HTTP协议的角色。 H5 中的跨端通信称为 JSBridge，在进行一次 JSBridge 调用的时候会携带调用参数 ModuleId: 模块 ID MethodId: 方法 ID params: 参数 CallbackId: JS 回调名 ModuleId 和 MethodId 能定位到具体调用的原生方法，params 参数作为原生方法调用的参数，最后通过 CallbackId 回调 JS 的回调函数（我们可以自行脑补react中父子组件通过回调通信的方式） 在使用 H5 的情况下，Webview 是 JS 的执行引擎，同时 Webview 还是页面的渲染引擎。 实现JSBridge主要是两点： 将Native端原生接口封装成JavaScript接口 将Web端JavaScript接口封装成原生接口 Native to WebNative 调用 JS 比较简单，只要 H5 将 JS 方法暴露在 Window 上给 Native 调用即可。 JavaScript作为解释性语言，最大的一个特性就是可以随时随地地通过解释器执行一段JS代码，所以可以将拼接的JavaScript代码字符串，传入JS解析器执行就可以，JS解析器在这里就是webView。 Android 4.4之前只能用loadUrl来实现，并且无法执行回调 val jsCode = String.format(\"window.showWebDialog('%s')\", text) webView.loadUrl(\"javascript: \" + jsCode) Android 4.4之后提供了evaluateJavascript来执行JS代码，并且可以获取返回值执行回调； String jsCode = String.format(\"window.showWebDialog('%s')\", text); webView.evaluateJavascript(jsCode, new ValueCallback&lt;String>() { @Override public void onReceiveValue(String value) { //拿到返回值后进行处理 } }); Android 版本 API 特点 低于4.4 WebView.loadUrl 无法执行回调 高于4.4 WebView.evaluateJavascript 可以拿到 JS 执行完毕的返回值 iOS的UIWebView使用stringByEvaluatingJavaScriptFromString； NSString *jsStr = @\"执行的JS代码\"; [webView stringByEvaluatingJavaScriptFromString:jsStr]; iOS的WKWebView使用evaluateJavaScript； [webView evaluateJavaScript:@\"执行的JS代码\" completionHandler:^(id _Nullable response, NSError * _Nullable error) { }]; iOS 版本 API 特点 低于8.0 UIWebView.stringByEvaluatingJavaScriptFromString 无法执行回调 高于8.0 WKWebView.evaluateJavaScript 可以拿到 JS 执行完毕的返回值 Web to NativeJS调用native方法 方案 调用方法 速度 注意事项 注入api addJavascriptInterface 较快 Android &lt; 4.2 存在安全漏洞 url拦截 shouldOverrideUrlLoading 最慢 JS回调时机 onJsPrompt 较快 日志输出 console.log 最快 scheme://dddd （1）全局注入API也可以解释为在window注入native封装好的方法，前端通过 window.xxx调用， 将Native的相关接口注入到JS的Context（window）的对象中，一般来说这个对象内的方法名与Native相关方法名是相同的，Web端就可以直接在全局window下使用这个暴露的全局JS对象，进而调用原生端的方法。 1、 客户端定义js映射对象 具体有安卓 webview 的 addJavascriptInterface，iOS UIWebview 的 JSContext，iOS WKWebview 的 scriptMessageHandler。 public class AndroidToJS { // 定义JS需要调用的方法 // 被JS调用的方法必须加入@JavascriptInterface注解 @JavascriptInterface public void callAndroid(String msg){ Log.e(\"zw\",\"JS调用了Android的callAndroid()，msg : \" + msg); }} 2、注入js方法 webView.addJavascriptInterface(new AndroidToJS(),\"android\"); 3、前端调用 window.NativeBridge.callAndroid('hello'); 4、优缺点 优点：通信时间短，调用方便。 缺点：使用 webView.addJavascriptInterface 方法进行注入。此方法存在漏洞(安全隐患)，在 Android4.2 以上提供 @javascriptInterface 注解来规避该漏洞，但对于4.2以下版本则没有任何方法。所以使用该方法有一定的风险和兼容性问题。 （2）scheme拦截可以解释为，发请求，然后客户端拦截请求，调用方法 客户端和前端定义scheme规范，前端加载scheme，客户端会拦截scheme，如果scheme格式符合规范，客户端会解析scheme中的参数，获取对应的方法和参数名，然后调起客户端原生方法。 1、前端加载scheme 通过iframe.src发起一个请求，客户端webview能拦截这个请求，做相应的处理。 Web 端发出请求的方式非常多样，例如 &lt;a/&gt; 、iframe.src、location.href、ajax 等，但 &lt;a/&gt; 需要用户手动触发，location.href 可能会导致页面跳转，安卓端拦截 ajax 的能力有所欠缺，因此绝大多数拦截式实现方案均采用iframe 来发送请求。 var iframe = document.createElement('iframe'); iframe.style.width = '1px'; iframe.style.height = '1px'; iframe.style.display = 'none'; iframe.src = 'jsbridge://getNetwork?callback=networkInfo'; document.body.appendChild(iframe); // 100毫秒后移除 setTimeout(function() { iframe.remove(); }, 100)l 一个标准的 URL 由 &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;&lt;path&gt; 组成，相信大家都有过从微信或手机浏览器点击某个链接意外跳转到其他 App 的经历，如果有仔细留意过这些链接的 URL 你会发现目前主流 App 都有其专属的一个 scheme 来作为该应用的标识，例如微信的 URL scheme 就是 weixin://。 JSB 的实现借鉴这一思路，定制业务自身专属的一个 URL scheme 来作为 JSB 请求的标识，例如字节内部实现拦截式 JSB 的 SDK 中就定义了 bytedance:// 这样一个 scheme。 实际上这个跳转地址只是一个非法的不存在的url 2、android 重写shouldOverrideUrlLoading Native 拦截请求的钩子方法： 平台 API Android shouldOverrideUrlLoading iOS 8+ decidePolicyForNavigationAction iOS 8- shouldStartLoadWithRequest 在webview中重写shouldOverrideUrlLoading根据定义的scheme原则进行拦截 public boolean shouldOverrideUrlLoading(WebView view, String url) { if(isValidScheme()){ //拦截处理scheme return handleScheme() } return false; } 复制代码 3、优缺点 优点：兼容性好，安卓和 IOS 的各个版本都能支持此功能。 缺点：调用时延比较高 200 - 400ms，在安卓上表现明显；URL scheme 长度有限，内容过多可能会丢失字符；不支持同步返回结果，所有信息传送都需要调用 iframe 请求，使用 callback 得到返回的数据。 一部分问题（缺点）的解决 连续发送时消息丢失 以下代码： window.location.href = \"jsbridge://callNativeNslog?{\"data\": \"111\", \"cbName\": \"\"}\"; window.location.href = \"jsbridge://callNativeNslog?{\"data\": \"222\", \"cbName\": \"\"}\"; js 此时的诉求是在同一个运行逻辑内，快速的连续发送出 2 个通讯请求，用客户端自己 IDE 的 log，按顺序打印 111，222，那么实际结果是 222 的通讯消息根本收不到，直接会被系统抛弃丢掉。 缘由：由于 h5 的请求归根结底是一种模拟跳转，跳转这件事情上 webview 会有限制，当 h5 连续发送多条跳转的时候，webview 会直接过滤掉后发的跳转请求，所以第二个消息根本收不到，想要收到怎么办？js 里将第二条消息延时一下。 //发第一条消息 location.href = \"jsbridge://callNativeNslog?{\"data\": \"111\", \"cbName\": \"\"}\"; //延时发送第二条消息 setTimeout(500,function(){ location.href = \"jsbridge://callNativeNslog?{\"data\": \"222\", \"cbName\": \"\"}\"; }); 但这并不能保证此时是否有其余地方经过这种方式进行请求，为系统解决此问题，js 端能够封装一层队列，全部 js 代码调用消息都先进入队列并不马上发送，而后 h5 会周期性好比 500 毫秒，清空一次队列，保证在很快的时间内绝对不会连续发 2 次请求通讯。 （3）JS回调时机基本没用….因为以下方法ios都不支持，作了解就可以了 1、Confirm 客户端可以拦截confirm。iOS的UIWebview不支持（不过好像WKWebView 支持）。使用场景相对较多，不适合用来做jsb。 前端调用 window.confirm('dance://app.toast?title=hello') 2、alert 客户端可以拦截alert。iOS的UIWebview不支持。但是alert使用场景较多，不适合用来做jsb。 前端调用 window.alert('dance://app.toast?title=hello') 3、Prompt 客户端可以拦截prompt，参数同上。iOS的UIWebview不支持。可自定义返回值，多用于安卓jsb方案。 前端调用 const url = 'jsbridge://' + method + '?' + JSON.stringify(args); window.prompt(url) Android端拦截 / Java: 重载 onJsPrompt 方法，提取 prompt 内容判断是否需要拦截 class MyWebViewClient extends WebChromeClient { @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) { if (message.startsWith(\"bridge://\")) { // 解析 // 后面的 action 和参数，调用相关的函数 result.confirm(\"Yes!\"); } return true; } } webView.setWebViewClient(new MyWebViewClient()); （4）日志输出客户端可以拦截console.log，参数同上。安卓和iOS通用。 1、前端调用 console.log('dance://app.toast?title=hello') 2、Android端拦截 WebView.setWebChromeClient(new WebChromeClient() { public void onConsoleMessage(String message, int lineNumber, String sourceID) { return true; } }); 调用与回调跨端方法一般都不是单向的，一般调用完毕我们都需要执行回调啊、什么返回一个参数之类的，而执行 js 回调函数方式本质是 native 调用 h5 的 js 方法 但是由于调用方调用被调用方和调用方回调被调用方在代码层面都是同一个接口（你也可以了理解为同一个命名的方法），为了区分本次调用是 API 调用还是回调调用，sn 需要做区分，比如请求方带过去的 key 名叫 req_sn(callbackId)，回调带过去的叫 res_sn(responseId)。 以拦截式调用为例，发起带 req_sn 的请求前，如果有回调函数，会以 req_sn 的值为 key，把回调函数存到对应的回调函数列表。当接收到带有 res_sn 的调用后，会以 res_sn 的值为 key，从对应的回调函数列表取出回调函数，并以接收到的数据为参数，执行回调函数 分享一个JSBridgeAn iOS/OSX bridge for sending messages between Obj-C and JavaScript in UIWebViews/WebViews： Facebook Messenger Facebook Paper 等都有在使用 它把 JSB封装的就像是一个跨越两端的 EventEmitter https://github.com/marcuswestin/WebViewJavascriptBridge 3.RN跨端传统的jsb方案下，使用Webview 作为是 JS 的执行引擎，而在使用RN情况下，RN 团队选择了JSCore（JSCore 的对外接口是用 C 和 C++ 编写的，C++ 在 iOS 和安卓系统上也有良好的跨端运行的功能）作为执行引擎，用来跑react代码（JS代码加载和解析），自带的java层作为渲染引擎 Native 模块（客户端原生模块）在 Android 系统下是 Java 模块，JS 通过模块 ID（moduleID） 和方法 ID（methodID） 来进行调用 JavaScript 模块是由 JS 实现 以安卓为例，JS 环境中会维护一份所有 Native 模块的 moduleID 和 methodID 的映射 NativeModules，用来调用 Native 模块的时候查找对应 ID；Java 环境中也会维护一份 JavaScript 模块的映射 JSModuleRegistry，用来调用 JS 代码。而在实际的代码中，Native 模块和 JS 模块的通信需要通过中间层也就是 C++ 层的过渡，也就是说 Native 模块和 JS 模块实际上都只是在和 C++ 模块进行通信。 RN环境中会塞入4个api作为调用js的入口： callFunctionReturnFlushedQueue // 让 C++ 调用 JS 模块 invokeCallbackAndReturnFlushedQueue // 让 C++ 调用 JS 回调 flushedQueue // 清空 JS 任务队列 callFunctionReturnResultAndFlushedQueue // 让 C++ 调用 JS 模块并返回结果 JS 还在 global 中还设置了 __fbGenNativeModule 方法，用来给 C++ 调用后在 JS 环境生成 Java 模块的映射对象，也就是 NativeModules 模块。 数据结构类似于（跟实际的数据结构有偏差）： { \"Timing\": { \"moduleID\": \"1001\", \"method\": { \"createTimer\": { \"methodID\": \"10001\" } } } } 其中moduleID和methodID 会映射 native方法 同样的，C++ 通过 JSCore 的 JSObjectSetProperty 方法在 global 对象中塞入了几个 Native API，让 JS 能通过它们来调用 C++ 模块 nativeFlushQueueImmediate // 立即清空 JS 任务队列 nativeCallSyncHook // 同步调用 Native 方法 nativeRequire // 加载 Native 模块Java 跟 C++ 的互相调用通过 JNI，通过 JNI，C++ 层会暴露出来一些 API 来给 Java 层调用 参考： https://zhuanlan.zhihu.com/p/473710695 https://juejin.cn/post/7097845525587689486","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Vue(中)","slug":"Vue(中)","date":"2021-02-28T16:00:00.000Z","updated":"2022-03-04T06:44:08.066Z","comments":true,"path":"2021/03/01/vue-zhong/","link":"","permalink":"https://taylor12138.github.io/2021/03/01/vue-zhong/","excerpt":"","text":"4.Vue CLI在开发大型项目的时候，则必须使用到Vue CLI，CLI是Command-Line Interface ，翻译为命令行界面，俗称脚手架 使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置（终于不用自己配置webpack了！） Vue CLI 的使用前提：Node &amp; Webpack 安装脚手架（同时也自动装上vue）： npm install -g @vue/cli CLI 3+ 初始化 vue create my-project 但是我们这里也要使用cli 2 的功能所以还得 拉取 2.x模板 npm install -g @vue/cli-init CLI 2 初始化项目 vue init webpack my-project 现有的vue项目添加eslint vue add eslint CLI 2 初始化vue init webpack 项目名称，这个项目名称为创建最终项目文件夹名 然后会出现选项： 然后得到一个文件，可以查看 package.json 文件里的 script，得知相应的运行命令；下面对存放在里面的每个文件进行介绍 build、config（配置基础变量）存放webpack的配置区域 src 放置源代码区域 static 放置静态资源的区域，原封不动复制到dist文件夹里 .babelrc 关于转化为ES5的相关配置 部分配置的介绍关闭ESLint代码规范（可能不符合部分代码风格，比如不加分号，定义函数时函数名后空一格等） config -&gt; index.js -&gt; useEslint: false Runtime-only 和 Runtime + Compiler的不同之处在main.js里面 //runtime compiler new Vue({ el: '#app', components: { App }, template: '&lt;App/>' }) //runtime-only //直接render，跳过template部分 new Vue({ el: '#app', render: h => h(App) }) Runtime-only在实际公司开发中使用的比较多，性能更好，代码更少（不用处理template和ast， 它的 .vue文件由 webpack用到的loader：vue-template-compiler 解析成render， 也就是render(App) -&gt; 组件App的 template 替换掉绑定的元素 ） 实际上，Vue实例的template -&gt; 会保存在option里 -&gt; 进行parse解析成抽象语法树（ast）（描述了我们标签的详情数据情况） -&gt; compile编译成 render函数 -&gt; 翻译成虚拟DOM（virtual DOM） -&gt; 渲染成UI（真实DOM） 所以实际上compiler是处理 template部分和 ast部分 动态创建标签：createElement(&#39;标签&#39;, {标签属性}, [&#39;&#39;]), createElement(组件)也可以 //render函数的真身：(APP为组件对象) render: funciton(createElement) { return createElement(APP); } CLI 3与2版本有很大区别 基于webpack 4 打造 设计原则是“0配置”，移除根目录下的build、config 提供了vue ui 命令，提供了可视化配置，更加人性化 移除了static，新增了public，并且将index.html移动到public中，public类似于新的static 初始化后同样会出现初始化的配置选项 preset 预设：default是默认；manually select features是手动 feature特性：按空格选中/取消（Linter代码规范可以取消掉、Babel为支持es6以上语法 ） placing config配置的存放：config files 独立存放；package.json 放在package.json中 save prest：是否保存刚才配置好的预设 （如果想删除，则要找到.vuerc文件，进入后进行修改删除） CLI 3 的配置去哪里了？ -&gt; 启动配置服务器（可视化配置）： vue ui 导入当前项目脚手架的文件夹，然后可以在当前页面添加需要的插件，配置甚至运行等 如果真的要手动修改掉基础的配置，需要新建vue.config.js在当前项目目录下（原来build和Config文件的配置都放在node_modules里面了），在里面进行 module.exports = {}配置，到时会和原来的配置进行合并作为整体配置 想了解更多配置可以上 https://cli.vuejs.org/zh/config/ 查看 module.exports = { devServer: { //运行后默认打开浏览器 open: true } } CLI 4配置讲述一下cli 4 中配置新添加的选项 (*) Choose Vue version 是否要选择vue版本 (*) Babel (*) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex (*) CSS Pre-processors 是否要使用css预处理器，比如sass、less () Linter / Formatter es代码linter检查 ( ) Unit Testing 单元测试 ( ) E2E Testing 端到端测试 Use class-style component syntax? (y/N) 是否要使用class风格的component，我们一般是不怎么实用的，可以选择no Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? (Y/n) 是否要用babel编译ts，一般tsc、babel咱们选babel，因为babel带polyfill，会打上一些补丁 Pick a linter / formatter config: (Use arrow keys) ESLint with error prevention only 普通eslint ESLint + Airbnb config eslint+爱彼迎规范 ESLint + Standard config eslint+标准规范 ESLint + Prettier eslint+prettier格式化（cms项目中我用的是这个） TSLint (deprecated) Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys) 配置文件要存放哪种形式 In dedicated config files 单独文件 In package.json 放package.json 脚手架的模块化样式当style标签具有该scoped属性时，其CSS将作用域化当前组件的元素（实质上脚手架会处理加上data-v-xxxx的属性） 我们通常在vue.config.js配置路径别名 module.exports = { devServer: { //运行后默认打开浏览器 open: true }, //publicPath为部署的配置 publicPath: process.env.NODE_ENV === 'production' ? './' : '/', configureWebpack: { resolve: { // 配置别名,内部其实已经配置过一个，就是 '@':src // 在cli3以上版本，配置别名的值可以引用之前配置过的别名，如'@/assets',不过cli4好像这里用不了。。 alias: { 'assets': '@/assets', 'components': '@/components', 'view': '@/view' } } } } 但是该别名 @ 在css中无法直接使用，需要变成 ~@的形式；还有 img 标签的 src中，也需要 ~@的形式 运行项目根据配置的提示为 npm run serve 实质上会执行node_modules下面的bin目录的vue-cli-service文件夹下代码 里面的比如 const Service = require(../lib/Serive)也不要被欺骗了，并不是当前目录下的 ../，而是内部有一个软连接，会去找到真是代码所在的位置，执行真实的代码 5.Vue router前后端路由概述路由就是网络把信息从源地址传输到目的地址的活动，路由器主要维护一个映射表（ip地址和mac地址的映射关系） 后端渲染是将数据在后端处理生成html发给浏览器，前端渲染是通过ajax拿到数据，操作dom节点 渲染ui （相当于Node.js里的服务器渲染和客户端渲染） 1.后端路由（后端渲染）：服务器处理一个url映射一个页面，通过正则匹配，交给controller进行处理，然后生成html等数据返回前端 2.前后端分离（前端渲染）： 输入url 去静态服务器（前端服务器）里获取 html + css + js 浏览器执行JS代码 -&gt; JS代码中有API请求，去到API接口服务器（后端服务器）中获取数据 随着Ajax的出现，有了前后端分离的开发模式，前后端分离最大的优点就是责任清晰，分工明确，并且在移动端（IOS/Android）出现后，后端使用之前一套API即可 前端路由 在前后端分离中，静态资源服务器放了好几套的 HTML + CSS +JS，每个对应不同的页面 SPA页面（单页面富应用）：整个网站只有一个html页面（React、Vue） 而在前端路由中： 静态资源服务器只有一个html（甚至也只有一个CSS + 一个JS） 网页获取到静态资源后，由前端路由配置映射关系，一个路径对应一个组件（/home -&gt; Home.vue） 点击url，通过JS代码判断，从那个获取的一个静态资源里再抽取资源，然后显示出来（这里抽取的资源，再vue里，相当于一个url映射一个组件，一个组件对应一个网页） 改变url，依然是页面不发生整体刷新 url的hash 为了改变url，而让也页面不发生刷新，可以使用 url的hash 或者html5 的 history模式 Push：通过window.location.hash = &#39;xxx&#39;更改href，网页不会刷新（默认），也就是重定向（带有hash的前端路由，优点是兼容性高，缺点是URL带#号不好看） 继而此时我们可以通过 window.addEventListener(&quot;hashchange&quot;, fn) 监听hash改变时回调的事件 hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置； Push：也可以通过history.pushState({}, &#39;&#39;, &#39;xxx&#39;)更改href，进行重定向（history的前端路由，缺点是如果输入错误网址，真的会跑去和后端要数据，然后我们就会看到一个不好看的404页面，需要我们和后端调节说要他给我们提供一个我们提前给他的固定的html界面） 可以使用history.back()或者history.go(-1) 后退功能进行回退 Push，入栈顶，可回退 Replace：还可以通过 window.replace、 history.replaceState({}, &#39;&#39;, &#39;xxx&#39;)来更改，不可回退（替换掉原先栈顶的路由） 在Vue实例中使用 this.$router.back() 也可以实现回退 （源码上除了hash、history、其实还有一个abstract模式） vue-router关于url改动的问题 由于默认是使用hash改动url，如果想要改成Html5的history模式，则在router对象里利用mode属性进行修改 const router = new Router({ routes, mode: 'history', LinkActiveClass: 'active' //可以把router-link当前被选中（点击）的标签的类名，改为active }) 基本使用目前三大框架都有自己的路由实现：Angular的ngRouter、React的ReactRouter、Vue的vue-router 安装：(或者脚手架选择的时候，可以自动帮你安装路由，并且以下步骤不用实施) npm install vue-router --save 于src文件夹里创建 router文件夹 -&gt; index.js 1.通过Vue.use(插件)，来安装插件 （在vue内部执行了插件.install方法） 2.创建路由对象，routes属性用于配置路由和组件的映射关系 3.将router对象传入Vue实例当中 import Router from 'vue-router' import Vue from 'vue' Vue.use(Router); const routes = []; const router = new Router({ routes }) export default router; router 为 Vue的 路由属性，直接赋值即可 //main.js import Vue from 'vue' import App from './App' import router from './router' //自动找到该目录下的index文件 Vue.config.productionTip = false new Vue({ el: '#app', router, render: h => h(App) }) 使用 1.在components文件夹里新建组件 如： home.vue 和 about.vue，里面自己适配好template 和 script 2.在routes里编写映射关系，一个对象对应一个映射关系 3.可以通过 &quot;/:pathMatch(.*)&quot; 匹配找不到路径填补的组件（404 not found），而对于此时匹配不到时拿到的路径参数，通过 $route.params.patchMath拿到 url 中出现 path,则显示该对象里的组件component import Home from '../components/home' import About from '../components/about' const routes = [ { path: '/home', component: Home }, { path: '/about', component: About }, { path: '/:pathMatch(.*)', component: NotFound } ]; 3.通过&lt;router-link&gt;和&lt;router-view&gt;使用路由: vue-router模块源码中，注册了全局组件 RouterView 和 RouterLink 所以可以使用这两个标签 由于这里我们把Vue实例的渲染属性绑定了 App.vue 的组件对象，我们把&lt;router-link&gt;和&lt;router-view&gt;添加至 App.vue组件的template中使用 &lt;template> &lt;div id=\"app\"> &lt;!-- &lt;router-link >是Vuerouter已经注册的的内置标签，最终会被渲染成a标签 --> &lt;router-link to=\"/home\">首页&lt;/router-link> &lt;router-link to=\"/about\">关于&lt;/router-link> &lt;!-- &lt;router-view>是Vuerouter已经注册的，决定路由的页面渲染 --> &lt;router-view>&lt;/router-view> &lt;/div> &lt;/template> 配置首页 const routes = [ { path: '/', // redirect 重定向 redirect: '/home' } ]; router-link的其他属性的补充 to属性：写上路径，点击后则会把网页的url进行路径的改动，然后router-view就会根据这个路径渲染网页 tag属性：默认最终渲染为为 a 标签，tag=&quot;button&quot; 则渲染为button标签 replace属性：如果当前的router对象中mode属性为 ‘history’，增加该属性，则url的改变方法改为： history.replaceState() router-link的原理： &lt;template> &lt;div id=\"app\"> &lt;button @click=\"homeClick\">首页&lt;/button> &lt;button @click=\"aboutClick\">关于&lt;/button> &lt;router-view>&lt;/router-view> &lt;/div> &lt;/template> &lt;script> export default { name: \"App\", methods: { // 通过代码修改路径 // vue-router源码往所有组件里都添加了$router属性 // history的pushStatus， push => pushStatus // 但是连续点击会报错，可以试一试this.$router.push('home').catch(err => err) homeClick() { this.$router.push(\"/home\"); }, aboutClick() { this.$router.push(\"/about\"); }, }, }; &lt;/script> //选择hash的mode $router.push() --> HashHistory.push() --> History.transitionTo() --> History.updateRoute() --> {app._route = route} --> vm.render() 1 $router.push() //调用方法 2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶） //（其实也就是window.location.hash= XXX） 3 History.transitionTo() //监测更新，更新则调用History.updateRoute() 4 History.updateRoute() //更新路由 5 {app._route= route} //替换当前app路由 6 vm.render() //更新视图 路由name属性 路有记录独一无二的名称 它可以供给 keep-alive 的 Props使用，对名称进行匹配 const routes = [ { path: '/', name: 'home', redirect: '/home' }, ]; 此时可以通过this.$route获取 与此同时，当子路由进行路由嵌套 + 匹配是也需要对应这个name，一般建议name和路由路径名字保持一致比如 { path: '/home', name: \"home\" component: Home, children: [ { path: 'message', name: \"message\" component: HomeMessage } ] }, 获取路由列表 如果路由跳转出现问题，可以查看当前路由列表是否路由已经注册 此时可以使用API getRoutes getRoutes(): RouteRecord[] console.log(router.getRoutes()) 其他知识点动态路由 某些情况下，一个页面的path是不确定的，比如我希望我的路径是 /user/aaa 或 /user/bbb /user/:id 这种path和Component的匹配关系，我们称之为动态路由（也是路由传递数据的一种方式） 动态路由的绑定：新建一个user.vue文件，然后把vue文件映射到路由的js文件中（router的index.js） &lt;template> &lt;div> &lt;h2>用户界面&lt;/h2> &lt;h2>{{ userId }}&lt;/h2> &lt;/div> &lt;/template> &lt;script> export default { name: \"User\", computed: { // params是参数的意思 userId() { //这里的userId对应的是映射时的/:userId return this.$route.params.userId; }, }, }; &lt;/script> import User from '../components/user' const routes = [ { path: '/user/:userId', component: User } ]; 接着在大组件app.vue中使用该模板 &lt;router-link :to=\"'/user/' + userId\" tag=\"button\">用户&lt;/router-link> 或者利用事件进行跳转+传递params this.$router.push(\"/detail/\" + userId); 在app.vue导出的实例对象里添加相应的data属性： data() { return { userId: \"zhangsan\" }; }, 路由懒加载 由于打包时，除了其他一些文件，主要的部分丢存放于一个js当中，然后在请求静态资源服务器时，可能因为文件太大，导致第一次请求资源时（即那一个主要的js文件），花费过长的时间，可能在请求过程，浏览器出现短暂的空白。 vue搭建脚手架时，对js、css文件等进行了分包 npm run build /dist/static/js 文件中 app.xxx.js 是业务代码 、vendor.xxx.js是提供商/第三方包的源码、mainfest.xxx.js是为打包的代码做底层支撑（让浏览器识别ES6、commonJS语法等） 当打包构建应用时，JavaScript包会变得特别大，如果我们把不同路由由对应的组件分割成不同同代码块，然后当路由被访问时才加载对应组件，这样才会更加高效（采取一个路由打包一个js文件的方法，先向静态资源服务器请求当前最需要的js文件） 懒加载：用到时，再加载 于router文件夹的index.js中每个加载修改为函数的形式 // 懒加载 const Home = () => import('../components/home'); const About = () => import('../components/about'); const User = () => import('../components/user'); const routes = [ { path: '/', redirect: '/home' }, { path: '/home', component: Home }, { path: '/about', component: About }, { path: '/user/:userId', component: User } ]; 路由嵌套如果想要进行路由细分（比如进入 /home 之后，还想要在进入 /home/message ），则形成了路由嵌套 嵌套的实现： 创建相应的子组件，并且在路由映射中配置相应的子路由 在组件内部再次使用 &lt;router-view&gt;标签 以下操作作为例子进行路由嵌套 新建两个vue文件（用于嵌套在home路由上） 在路由的js文件中的routes数组里，每个对象都可以有一个children属性，里面可以保存嵌套的路由 const HomeNews = () => import('../components/HomeNews') const HomeMessage = () => import('../components/HomeMessage') { path: '/home', component: Home, children: [ { path: '', redirect: 'news' }, {// 子路由不需要加 '/' path: 'news', component: HomeNews }, { path: 'message', component: HomeMessage } ] }, 然后再home组件中添加 router-view 进行子路由页面渲染 &lt;template> &lt;div> &lt;h2>首页&lt;/h2> &lt;!-- 这里需要给完整的路径， 不能直接to=\"/news\" --> &lt;router-link to=\"/home/news\" tag=\"button\">新闻&lt;/router-link> &lt;router-link to=\"/home/message\" tag=\"button\">信息&lt;/router-link> &lt;router-view>&lt;/router-view> &lt;/div> &lt;/template> 参数传递从一个路由页面跳转到另外一个路由页面时，我们可能希望传递一些消息 传递参数主要有两种类型：params和query params类型：如动态路由的配置 /router/:参数名 传递方式：在配置路由映射时，path后面跟上响应的值进行接收声明 路由路径名/:参数名； 接着在组件的router-link的to属性添加参数进行传递 / 或者利用this.$router.push(&quot;/detail/&quot; + userId)进行进行跳转 当然传递多个参数还可以： 路由路径名/:参数名/路由路径名2/:参数名2 进行重叠 传递后形成的路径 /router/123， /router/abc等 子组件通过 this.$route.params.参数名获取参数 query类型： 正常路由配置方式 传递方式：对象中使用query的key作为传递方式 传递后形成的路径： /router?id=123, /router?id=abc 在总组件 app.vue 中进行配置 &lt;router-link :to=\"{ path: '/Profile', query: { name: 'Allen', age: 18, heigh: 1.88 } }\" tag=\"button\"> 档案&lt;/router-link> 或者利用事件进行跳转+传递query（router.push可以传入一个对象） 事件名(){ this.$router.push({ path:'/detail', query:{ name: 'Allen', age: 18, heigh: 1.88 } }) } 若想在子组件的template模板中中获取该参数，则使用 route.query进行获取（得到一个对象，里面存储参数） &lt;p>{{ $route.query }}&lt;/p> 总结：大量数据使用query，因为query传过去是对象 router和route 大前提：所有的组件都继承vue类的原型 vue-router源码往所有组件里都添加了$router属性（往vue的原型上加的，用的是vue.prototype在原型对象上添加） 所以在任何一个组件里，都可以使用 this.$router进行获取 前端路由使用history刷新页面时，router-link的原理中使用到 $router.push(&quot;路径&quot;)、$router.replace(&quot;路径&quot;)、$router.go(-1)，router对象为路由文件夹router中index.js导出的router对象（有点当作BOM的 history 使用内味儿了 ） 而 route 是当前活跃的路由，vue-router源码往所有组件里也添加了$route属性（往vue的原型上加的，用的是vue.prototype在原型对象上添加） 所以在任何一个组件里，都可以使用 this.$route进行获取 导航守卫在发生路由跳转时，我们有时需要去监听这个跳转事件，然后对网页进行相应的变化（比如网页标题的改变）；亦或者是进行拦截，让他跳转到登陆页面 / 注册页面 方法一：使用生命周期函数 vue的生命周期函数 created() {} 来定制，缺点：一个功能的实现需要在多个（甚至是每个）子组件上定义。 方法二：导航守卫 比如先给每个路由添加 元数据 meta （描述数据的数据） const routes = [ { path: '/home', component: Home, meta: { title: '首页' }, children: [ { path: '', redirect: 'news' }, {// 子路由不需要加 '/' path: 'news', component: HomeNews } ] } ] // 导航守卫 router.beforeEach(function (to, from, next) { //从from跳转到to， from和to都是Route类型 document.title = to.matched[0].meta.title; //有next才能实现路由跳转，一定要加上 next(); }) 我们可以通过this.$route获取meta的数据 也可以使用导航守卫，相当于axios的拦截器，这时可以使用to.meta.title获取，但是如果路由中使用了路由嵌套，还得格外注意使用 to.matched[0].meta.title获取，使用下标为0的进行获取，则当你未进行嵌套时，还能正常获取，因为确实是当前选定路由的第一个 next() 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。（从vue router4.x以后不推荐使用了，通过返回值控制跳转，详情见我的Vue3(上)文章） to：一个route对象，即将跳转到的路由对象 fro：一个route对象，跳转源头对象 守卫分类全局守卫： router.beforeEach((to, from, next) =&gt; {}) 全局前置守卫，是路由跳转之前进行的回调。每一个导航被触发时，被调用的总是全局前置守卫 用的最多，important！ router.beforeResolve((to, from, next) =&gt; {})，全局解析守卫，和 beforeEach类似，区别是导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，才被调用 router.afterEach((to, from) =&gt; {})，后置钩子， 不需要主动调用next函数，等待路由跳转结束后也会调用函数 路由独享守卫（写到路由里面） beforeEnter const router = new VueRouter({ routes: [ { path: '/play', component: Play, beforeEnter: (to, from, next) => {} } ] }) 组件内路由守卫 beforeRouteEnter(to, from, next) beforeRouteUpdate(to, from, next) beforeRouteLeave(to, from ,next) const Foo = { template: `...`, beforeRouteEnter (to, from, next) { // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 }, beforeRouteUpdate (to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` }, beforeRouteLeave (to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` } } 导航流程（官网） 导航被触发。 在失活的组件（from组件）里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件（to组件）里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。（进入导航） 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入（next传入一个参数，能拿到组件实例instance）。 keep-aliverouter-view也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存（比如实现功能：进入 /home ， 默认进入 /home/news，如果跳转到 /home/messgae 之后，再跳转到其他页面，此时回到 /home 可以直接进入上一次查看的页面/home/messgae，而不是默认页面/home/news） keep-alive 是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染，它的原理是避免组件被销毁（所以使用keep-alive之后，组件不会触发destoryed 钩子函数） 生命周期函数 activated 和 deactivated 只有在组件被保持了 keep-alive 时，才能被正常使用，这两个生命周期分别是重新进入 / 离开该缓存组件被触发 里面还有个 LRU （最近最久未用算法，同操作系统的LRU），缓存的太多超过max，就需要删除掉 SPA（单页面富应用）常用 kepp-alive，提高性能！ &lt;keep-alive> &lt;router-view>&lt;/router-view> &lt;/keep-alive> //home.vue的script部分 export default { name: \"home\", data() { return { path: \"/home/news\" }; }, // 使用组件内守卫记录离开时的路径信息，并且再用生命周期函数activated实现跳转 //activated为当前页面活跃状态的钩子函数 activated() { this.$router.push(this.path).catch((err) => {}); }, beforeRouteLeave(to, from, next) { this.path = this.$route.path; next(); }, }; keep-alive有两个非常重要的属性 include：字符串或正则表达，只有匹配的组件才会被缓存 exclude：字符串或正则表达，任何匹配的组件都不会被缓存 还有一个max属性 max：最多可以缓存多少个组件实例，一旦达到这个数字，那么缓存的最近没被访问的组件就会被销毁 注意：这里的 “,”不能加空格 &lt;!-- 使用keep-alive include=\"组件的name\" --> &lt;keep-alive include=\"home,User\"> &lt;router-view>&lt;/router-view> &lt;/keep-alive> 动态组件Component可以看成简易版路由组件 页面切换 &lt;!-- 方法一：v-if判断 --> &lt;template v-if=\"currentTab === 'home'\"> &lt;home /> &lt;/template> &lt;template v-else-if=\"currentTab === 'about'\"> &lt;about /> &lt;/template> &lt;template v-else-if=\"currentTab === 'category'\"> &lt;category /> &lt;/template> &lt;!-- 方法二：动态组件 --> &lt;component :is=\"currentTab\">&lt;/component> component就是vue的一个内置组件他有一个特殊的attribute：is is属性要注入 通过component函数注册的组件（全局注册） 一个组件对象的component对象里注册的组件（局部注册） 同样的，想要让动态组件保持切换之后不被销毁，可以使用 keep-alive内置组件进行包裹 &lt;keep-alive> &lt;component :is=\"currentTab\">&lt;/component> &lt;/keep-alive> 6.Vuex概念Vuex是一个转为Vue.js应用程序开发的状态管理模式 其实可以简单看成把需要多个组件共享的变量全部存储在一个对象里面（状态：变量），然后把这个对象放在顶层的Vue实例中，让其他组件一起使用（而且交给Vuex大管家来管理，其数据还是响应式的） 我们其实可以自己通过prototype封装共享的变量对象，但是做不到响应式 多界面共享的例子：用户登陆状态、用户名称头像、地理位置、购物车信息 单页面状态管理： View(视图template部分) -&gt; Actions(事件行为) -&gt; State(变量) -&gt; View 多页面状态管理：Vuex 原理 利用vue的插件机制，使用Vue.use(vuex)时，会调用vuex的install方法，装载vuex vuex是利用vue的mixin混入机制，在beforeCreate钩子前混入vuexInit方法，vuexInit方法实现了store注入vue组件实例，并注册了vuex store的引用属性$store 而其中的响应式，state是通过创建Vue实例的data来保存state，依旧是用到了发布监听的双向绑定，getters则是借助vue的计算属性computed实现数据实时监听 使用安装 npm install vuex --save 初始化 然后新建一个store文件夹，在里面创建 index.js 文件，以下步骤和创建router路由插件几乎相同 1.通过Vue.use(插件)，来安装插件 （在vue内部执行了插件.install方法） 2.创建store对象 3.将store对象传入Vue实例当中(在mian.js里面)，类似于添加了Vue.prototype.$store = store，但是却具有响应式能力 import Vuex from 'vuex' import Vue from 'vue' // 1.安装插件 Vue.use(Vuex) // 2.创建对象 const store = new Vuex.Store({ }) // 3.导出store对象 export default store //main.js import Vue from 'vue' import App from './App' import store from './store' Vue.config.productionTip = false new Vue({ el: '#app', store, render: h => h(App) }) ​ Vuex状态管理图 Devtools 是Vue开发的一个浏览器插件，用来记录每一次改变State 需要在浏览器上安装：可以去谷歌应用商店安装Vue.js devtools 插件 Vue官方不建议Components直接修改State ，但是官方允许Components直接修改Mutations Actions用于处理异步操作（Backend，也就是后端），Mutations一般都是存储同步操作 store对象内置属性： state：保存状态（变量），其他组件可以通过 $store.state.变量名进行获取（类似data） getters：类似于组件里的计算属性computed, 里面的函数默认可以传入state作为参数 mutations：定义修改状态的方法，里面的函数默认可以传入state作为参数（类似methods） actions：在里面处理异步操作 modules：用于划分模块 具体操作 const store = new Vuex.Store({ state: { counter: 10, }, mutations: { increment(state) { state.counter++; }, decrement(state) { state.counter--; }, actions:{}, getters: {}, modules:{} } }) 使用共享变量的组件，这时调用共享的方法Mutations需要用commit来提交 &lt;template> &lt;div id=\"app\"> &lt;h2>{{ $store.state.counter }}&lt;/h2> &lt;button @click=\"add\">+&lt;/button> &lt;button @click=\"sub\">-&lt;/button> &lt;/div> &lt;/template> &lt;script> export default { name: \"App\", methods: { add() { this.$store.commit(\"increment\"); }, sub() { this.$store.commit(\"decrement\"); }, }, }; &lt;/script> Vuex每个属性详解State单一状态树vuex推荐只创建一个Vuex.Store实例，若创建多个，日后不方便进行维护 单一状态树可以最直接地找到某个状态 辅助函数辅助函数 mapState的使用 除此之外，还有辅助函数 mapGetters、mapActions、mapMutations 等（大家的使用方式都一样的） 当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： // 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from 'vuex' export default { // ... computed: { fullName(){ return xxx; }, ...mapState({ // 箭头函数可使代码更简练 //count: state => state.count, // 传字符串参数 'count' 等同于 `state => state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } } 注意，得到的mapState是一个对象，而里面存储的是一个一个函数，因为计算属性的每一个属性都是一个函数（同样适用给mapGetters） 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 computed: mapState([ // 映射 this.count 为 store.state.count 'count' ]) 如果实在module中处理，可以通过传入 模块名 + state的属性名得到 computed: { ...mapState(\"home\", [\"homeCounter\"]); // 对应模块名 + 属性名 } ​ 使用getters时，还可以使用：mapGetters 辅助函数，它仅仅是将 store 中的 getter 映射到局部计算属性： 此时，我们便可以在子组件直接使用该数据：&lt;div&gt;&lt;/div&gt; import { mapGetters } from 'vuex' export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doubleCounter', 'doubleCountermore', 'add', // ... ]) } } 在子组件使用Actions时，也可以使用：mapActions 辅助函数，将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：（此时用 this.方法名即可调用） import { mapActions } from 'vuex' export default { // ... methods: { ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) } } Getters基本使用里面的函数默认可以传入state作为参数，但也可以默认传入 gatters 已有的数据（若传进来，第一个参数为state，第二个参数为getters）。如果要在组件中传入参数，则需要把返回的值改成返回一个函数 有点像computed const store = new Vuex.Store({ state: { counter: 10, }, getters: { doubleCounter(state) { return state.counter * state.counter; }, doubleCountermore(state, getters) { return getters.doubleCounter + 1; }, add(state, getters) { return num => { return getters.doubleCountermore + num } } }, }) &lt;h2>{{ $store.getters.doubleCounter }}&lt;/h2> &lt;h2>{{ $store.getters.add(10) }}&lt;/h2> Action基本使用Action类似于Mutation，但是是用来替代Mutation进行异步操作的（其实也可以来替代一些功能复杂的操作） 和Getter、Mutation不同，默认传入的参数不是state，而是 context：上下文，是一个和store实例均有相同方法的一个context对象 （包裹在Module里Actions的context则和最外层的store不一样，多了一个 rootState、rootGetters 属性 ） 但是也不支持在action里直接修改state，即不支持 context.state.info.name = ‘Mikasa’ 详情关系图可以看Vuex状态管理图，在action使用commit进行提交 -&gt; mutation 第二个参数可选，为传入的对象payload，类似mutation的payload 在组件中调用action的异步方法，使用 this.$store.dispatch(&quot;方法名&quot;[, 传入参数]); const store = new Vuex.Store({ state: { counter: 10, info: { name: 'Allen', age: 18, feature: '始祖巨人' } }, mutations: { update(state) { Vue.set(state.info, 'address', '帕拉迪亚岛') } }, actions: { aupdate(context, payload) { setTimeout(() => { context.commit('update');// 原来是在vue组件中 this.$store.commit console.log(payload); }, 1000); } }, }) //Vue对象的methods属性里 update() { this.$store.dispatch(\"aupdate\", \"我是payload\"); }, 使用Actions时可以返回一个Promise 当然，碰到了异步操作，且想要确认异步操作是否完成，少不了Promise的优雅加成： actions: { aupdate(context, payload) { return new Promise((resolve, reject) => { setTimeout(() => { context.commit('update'); console.log(payload); resolve(); }, 1000); }) } }, update() { this.$store .dispatch(\"aupdate\", \"我是payload\") .then(() => { console.log(\"执行成功！\"); }) .catch(() => { console.log(\"执行失败\"); }); }, Actions提交风格 除了上述的commit提交方式，Vue还提供了另外一种风格，它是包含type属性的对象，而传入的参数即使并不需要传递多个，但也需要（自动）变成一个对象 this.$store.dispatch({ type: \"aupdate\", // 这时传过来的num变成一个对象 num: num, }); 此时mutation传入的是对象，所以也要发生相应改变 const store = new Vuex.Store({ actions: { aupdate(constext, payload) { console.log(payload.num) } }, } Module基本使用store推荐state单一状态树、但是state里包含太多数据会显得十分臃肿 为此，Vuex允许我们讲store分割成模块（Module），每个模块拥有自己的state、mutation等 const store = new Vuex.Store({ modules: { a: { state: {}, mutations: {}, actions: {}, getters:{} }, b: { state: {}, mutations: {}, actions: {}, getters:{} } } }) 或者在store的外部定义 module对象，然后直接在store的modules里面引用就可以了 const moduleA = { state:{}, mutations:{} } const store = new Vuex.Store({ modules: { a:moduleA } }) 使用module注意事项： 在组件中使用模块的state数据： $store.state.模块名称.状态 &lt;h2>{{$store.state.a.name}}&lt;/h2> 组件中使用模块的mutation则使用方法和原来放在store里一样，在组件中直接this.$store.commit(事件类型)就可以了 getters也是也原来放在store里一样去使用；如果模块的getter想要使用到原来的store中的state，则此时模块的getter可以传入三个参数，分别是： 自身的state getters store的state store的getters const moduleA = { state: { name: 'Armin' }, getters: { fullname(state, getters, rootState, rootGetters) { return state.name + rootState.counter } } } 4.它的actions中 context.commit(&#39;函数&#39;);的形式 ，函数只能commit模块中mutations里面的函数 actions中的context里，包含 rootGetters、 rootState，可以获取当前module以上的根的state、getters actions中使用commit提交的时候（使用 namespaced: true的时候 ），可以附带第三个参数，{ root: true }，表示提交的是根root里面的mutations、actions。 actions: { aupdate(context, payload) { setTimeout(() => { context.commit('update', null, { root: true }); }, 1000); } }, 但是上述方法，比如使用getters、actions的时候，模块使用和原来的root使用没有区分，这样难以辨别事件源头，is not good 此时我们可以给模块增加属性：namespaced: true，此时模块就变得独立了(无法和原来的使用方法一样) const moduleA = { namespaced: true; //.... } &lt;!-- &lt;h2>{{ $store.getters[\"模块名/模块下getters的某属性名\"] }}&lt;/h2> --> &lt;h2>{{ $store.getters[\"home/doubleHomeCounter\"] }}&lt;/h2> methods:{ homeIncrement(){ this.$store.commit(\"home/increment\"); //模块名/模块下的mutation方法 this.$store.dispatch(\"home/actionIncrement\"); //模块名/模块下action方法 } } Mutation基本使用mutations作为Vuex的一个属性，但是包含的东西比较多 官方认可：Vuex的store状态的更新唯一方式：提交Mutation mutations里每个方法完成的事件尽量单一（也就是一个方法，不要有对于state的多种修改功能），方便跟踪Devtools的跟踪，可以选择放在Actions里，然后Action里的函数commit到不同的mutation函数对state修改 Mutation主要包括两部分： 字符串的事件类型 一个回调函数，该回调函数的第一个参数就是state 比如上述 使用 部分的例子中（代码放在了下方），increment为事件类型，(state) {state.counter++;}为回调函数 increment(state) { state.counter++; } 然后在组件中通过mutation更新进行使用 this.$store.commit(事件类型) mutations传参问题： 里面的函数默认可以传入state作为参数，第一个参数为state 第二个参数为外部传进来的参数（如果要传递多个参数，则我们可以以对象的形式进行传递），它有个专业名词叫 payload：载荷 const store = new Vuex.Store({ mutations: { increment(state) { state.counter++; }, incrementCount(state, payload) { state.counter += payload; } }, //组件的methods methods: { add() { this.$store.commit(\"increment\"); }, addCount(num) { this.$store.commit(\"incrementCount\", num); }, }, mutations提交风格 除了上述的commit提交方式，Vue还提供了另外一种风格，它是包含type属性的对象，而传入的参数即使并不需要传递多个，但也需要（自动）变成一个对象 this.$store.commit({ type: \"incrementCount\", // 这时传过来的num变成一个对象 num: num, }); 此时mutation传入的是对象，所以也要发生相应改变 const store = new Vuex.Store({ mutations: { incrementCount(state, payload) { state.counter += payload.num; } }, } Mutations常量类型 定义常量是减少错误的基本方法 在store文件夹里定义一个js文件，比如 mutation-type.js 用于存储常量名，然后在其他文件里用 import导入，用常量名以 [常量名]的形式 替代mutations里的函数名，然后引用mutation函数的时候，继续先import导入存储常量名的js文件，直接引用 this.$store.commit(常量名); 就可以了 虽然过程十分繁琐，但有利于项目开发后的维护找错 Mutation同步函数 通常情况下，Vuex要求我们Mutation中方法必须是同步方法 主要原因是我们使用devtools时，devtools可以帮助我们捕捉mutation的快照 但如果是异步操作，那devtools将不能很好的追踪到这个操作什么时候会被完成 Vuex响应式原理Vuex的store中的state是响应式的 state其中每个状态都有对应的 Dep -&gt; [Watcher]，监听变化 包括状态里对象的每个属性的变化 但这要求我们必须遵守Vuex对应的一些规则： 提前在store初始化所需的属性 当给state对象添加新属性时，使用下列方式： 方式一：使用Vue.set(obj, &#39;newProp&#39;, 123) 方式二：用新对象给旧对象重新赋值 这里和数组的响应原理一样，有一些数组方法也不是响应的，需要借助其他方法来进行响应处理（如 this.arr[0] = &#39;nothing&#39;; ） 删除属性的方式也相应改成使用 Vue.delete(obj, &#39;newProp&#39;)","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"git基本命令符","slug":"git基本命令符","date":"2021-02-28T16:00:00.000Z","updated":"2023-03-30T07:59:33.796Z","comments":true,"path":"2021/03/01/git-ji-ben-ming-ling-fu/","link":"","permalink":"https://taylor12138.github.io/2021/03/01/git-ji-ben-ming-ling-fu/","excerpt":"","text":"版本控制它是一种软件开发过程中，管理我们对文件、目录、或工程等内容的修改历史、方便我们查看更改历史记录，备份以便恢复以前的版本软件工程技术。简单来说就是用于管理多人协同开发项目的技术 SVN：集中式版本控制、所有版本存在服务器上，需要连网才能看到历史版本，服务器坏了可能导致数据丢失。工作时我们首先需要从中央服务器的到最新版本 Git：分布式版本控制，每个人都拥有全部的代码（可能有安全隐患），这样就可以在本地查看历史版本，可以离线在本地提交，只需练网时push到相应服务器即可。协同方式：A修改了代码、B也修改了代码，这时只需要你们两人之间把各自修改的代码推送给对方，即可看到对方修改 Git是目前（2021年）世界上最先进的分布式版本控制系统 Git启动Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多 Git CMD：Windows风格命令行 Git GUI：图形界面，不建议初学者使用 Git基本命令符config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system -&gt; global -&gt; local 底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件 查看系统config git config --system --list 查看当前用户（global）配置 git config --global --list 安装Git后必须执行的(不然提交不了项目)：设置用户名和邮箱 git config --global user.name \"taylor12138\" git config --global user.email \"277421392@qq.com\" 查看当前仓库配置信息 git config --local--list 基本理论Git本地有三个工作区域： 工作目录（Working Directory）：平时存放项目代码的地方（主要跟我们挂钩的两个区域之一） 暂存区（Stage/Index）：临时存放改动，事实上只是一个文件 资源库（Respository/Git Directory）：安全存放数据的位置，这里有提交到所有版本的数据 再加上远程仓库（Remote Directory）：托管代码的服务器（主要跟我们挂钩的两个区域之一） 忽略文件有时我们不想把某些文件也一并上传，比如前端项目中的 npm_modules 可以在 .gitignore文件下添加忽略的文件 *.txt #忽略所有.txt结尾的文件 !lib.txt #将lib.txt除外（不被忽略） /temp #仅忽略根目录下的TODO文件，不包括其他目录的temp文件 build/ #忽略build/目录下的所有文件 doc/*.txt #忽略doc/notes.txt但不包括doc/server/arch.txt github建立连接的方法方法1：在GitHub网站上新建仓库 然后拷贝仓库的地址，进行克隆下载到本地 把自己原来项目除了git文件的所有文件拷贝进下载的文件夹里（克隆下载的文件本身自带.git文件） 利用工具 进入新的文件夹 可以查看状态：（可以查看文件是否被跟踪） git status 一般git上传只需要 1 放入暂存区 git add . 2 提交到git本地仓库， -m是提交信息 git commit -m '描述' 比如：git commit -m &#39;feat(buyvip): 补充埋点路径参数&#39; 提交规范： 3 推送到远程 git push 方法2：将本地项目直接push，不用拷贝 创建一个全空的仓库 然后该项目有提示：git remote add orgin https://github.com/xxxxxxxx.git的指令 和 git push -u origin master指令 在项目的终端执行 git撤回操作如果只是add（暂存）或者commit（提交到本地仓库），可以使用 git reset HEAD HEAD 说明： HEAD 表示当前版本 HEAD^ 上一个版本 HEAD^^ 上上一个版本 HEAD^^^ 上上上一个版本 以此类推… 如果是已经推送到远程仓库了，需要进行回滚（reset或者revert） $ git revert HEAD $ git push origin master reset和revert都可以用来回滚代码。但他们是有区别的。 1、reset是彻底回退到指定的commit版本，该commit后的所有commit都将被清除；而revert仅是撤销指定commit的修改，并不影响后续的commit。 2、reset执行后不会产生记录，revert执行后会产生记录。 当然也可以不用revert，而是当前代码切到新的分支，比如feat/xxx，然后回到原来的分支， 使用 git reset我们需要找到回滚的commit，输入git reset –hard {commitId}，将本地文件回滚： git reset --hard d580ea7dab097d8ea6d658adbc7e9d57ef22669a 然后可以强行push上去 git push -f 此时我们拿到的时候会滚的旧代码，然后我们可以使用vscode自带的工具，拿到我们修改的部分，进行对比修改 回退到上个版本 + 提交： git reset --hard HEAD^ git push origin HEAD --force git stash暂存内容当git pull时，出现以下提示： 更新 07153c9..820f46d error: 您对下列文件的本地修改将被合并操作覆盖： 别人修改了文件并且提交PUSH,你也修改了此文件并且没有add和commit.然后你在pull时就会出现此提示。 如果不想舍弃对本地的修改： 就按照提示的操作一样：请在合并前提交或贮藏您的修改。 贮藏修改，就要用到git stash 先git stash，本地工作区备分，放入git栈中。然后，工作区内容恢复到仓库head最后一次提交的内容。 然后git pull. 最后，git stash pop,这个过程自动合并。如果成功，则自动此备分从git stash中删除。如果有冲突，则你需要手动解决冲突。然后git stash drop Git分支git branch #查看所有分支 git branch -r #查看远程分支 git branch dev #新建dev分支，但是现在仍停留在原分支 git branch -d dev #删除dev分支 git merge [branch] #合并指定分支到当前分支 如果多个分支并行执行，会导致代码并不冲突，也就是同时存在多个版本 一般来说master主分支非常稳定，用来发布新版本，工作一般在新建的dev分支上工作，等待dev分支稳定后才可合并到master主分支上 切换分支 git checkout “对应分支” git checkout - #切换到上一个分支 git checkout -b 命名(feat/v1.21) #新建分支feat/v1.21 此时我们可以push到新建的分支 git push --set-upstream origin feat/v1.21 Git提交错误Connection was reset in connection to github.com:443 解决方法： 1. git config --global http.sslVerify false 结果：失败 2. git config --global --unset http.proxy 结果：失败 3.cmd命令执行（可能是因为使用过vpn或者代理，关机时忘记关了。） ipconfig/flushdns 结果：失败 4.更改本地hosts文件，添加github的ip地址 结果：失败 5.：输入命令 git config --global http.proxy 127.0.0.1:7890 为全局的 git 项目都设置代理 git config --local http.proxy 127.0.0.1:7890 为某个 git 项目单独设置代理 结果：成功 git代码提交规范工具husky如果想要在提交之前（git commit），让eslint做一次 eslint fix，我们可以使用husky工具 你一可以他把看成一个关于git 的 eslint husky是一个git hook工具，可以帮助我们触发git 提交的各个阶段，pre-commit、commit-msg、pre-push 我们自己也可以在 ./git/hooks 新建文件，给予可执行权限，然后在pre-commit阶段执行某种操作 使用husky：使用自动配置命令 npx husky-init && npm install windows用户（powershell）可以换成 npx husky-init -and npm install pre-commit此时可以在.husky文件夹下的pre-commit文件下，写入eslint的fix命令（package.json中代码检查命令 npm run lint 之类的 ） 上面那个命令会执行以下三步操作 安装husky相关依赖（ npm i husky -D ） 项目目录下创建 .husky 文件夹（ npx husky install ） 在package.json中添加一个脚本 自动规范化提交格式commitizen，可以帮助我们自动生成规范的提交信息（上面所说到的commit规范） 使用： npm i commitizen -D 安装 cz-conventional-changelog并且进行初始化（自动帮我们在package.json中配置相关config） npx commitizen init cz-conventional-changelog --save-dev --save-exact 首先我们还是 git add . 然后我们提交代码的时候，不输入 git commit -m &#39;xxx&#39; ，而是输入以下命令即可 npx cz 限制提交（commit-msg）既然我们按照cz的规格来提交，但是并没有说不能使用原来的方法直接提交 此时我们可以是用 commitlint 来限制提交 安装 npm i @commitlint/config-conventional @commitlint/cli -D 在根目录创建 commitlint.config.js 文件，配置commitlint module.exports = { extends: ['@commitlint/config-conventional'] } 使用husky生成 commit-msg 文件，验证提交信息 npx husky add .husky/commit-msg \"npx --no-install commitlint --edit $1\" git配置ssh关于git管理时，配置多个账号（比如公司用一个，个人用一个） 指导一：Git 配置多账号（Mac） 指导二： github/gitlab同时管理多个ssh key 因为 If you’re using macOS Sierra 10.12.2 or later, you will need to modify your ~/.ssh/config file to automatically load keys into the ssh-agent and store passphrases in your keychain. 所以现在一般ssh中的config也需要配置，最好用第二个。","categories":[],"tags":[],"author":"Hello"},{"title":"js游戏框架合集","slug":"js游戏框架合集","date":"2021-02-28T16:00:00.000Z","updated":"2023-06-11T16:56:47.012Z","comments":true,"path":"2021/03/01/js-you-xi-kuang-jia-he-ji/","link":"","permalink":"https://taylor12138.github.io/2021/03/01/js-you-xi-kuang-jia-he-ji/","excerpt":"","text":"Cocos.js概述Cocos.js概述，主要源自chatgpt： Cocos.js 是一款基于 Cocos2d-x 引擎的 JavaScript 游戏开发框架，主要用于创建跨平台的移动端游戏。它结合了 Cocos2d-x 引擎的高性能和跨平台特性以及 JavaScript 语言的便捷性和灵活性。 Cocos2d-x 是一个成熟的开源游戏引擎，用 C++ 编写，支持多平台开发，包括 iOS、Android、Windows 等。Cocos.js 则是针对 JavaScript 开发者提供的一个封装层，使他们能够使用 JavaScript 语言进行游戏开发。 Cocos.js 提供了一系列的游戏开发工具和组件，包括场景管理、动画系统、精灵管理、物理引擎、UI 系统等，使开发者能够方便地构建游戏场景、处理用户输入、管理游戏对象等。此外，Cocos.js 还支持 JavaScript 的模块化开发，使开发者能够更好地组织和管理代码。 Cocos.js 的特点 跨平台支持：可以使用一套代码开发游戏，并在多个平台上运行，包括 iOS、Android、Windows 等。 高性能：Cocos2d-x 引擎具有优秀的性能表现，能够实现流畅的游戏体验。 JavaScript 开发：使用 JavaScript 语言进行开发，无需学习额外的编程语言。 丰富的功能：提供了丰富的游戏开发工具和组件，方便开发者构建各种类型的游戏。 社区支持：Cocos.js 拥有活跃的开发者社区，提供技术支持和资源分享。 Cocos Creator：是一个位于Cocos2d-x之上的GUI编辑器。它支持JavaScript， Creator 3.0 统一了 2D 与 3D 的开发工作流，进一步优化了性能，完善了品质 特性： Cocos2d-x：是游戏引擎。它支持c ++，JavaScript和Lua。2D 和 3D。 Cocos Creator官网：安装和启动 + 注册个人账户 然后再editor选项栏下载一个编辑器 然后我们可以在社区下载一些看起来很酷的项目(需要注意他对应的creator编辑器 版本) 然后打开项目后进行 预览和调试 进行查看 官方还提供了几个新手操作时间实例，可以看这里： Hello world! 快速上手：制作第一个游戏 整体上看和我们正常开发web 3d很像，比如创建场景，创建cube啊，只是这些从写代码转移到了gui界面 左上角负责gui部分，快速添加 / 删除 mesh 左下角负责编写代码，和我们正常的项目目录一样（添加脚本用typescript，且需要注意，Cocos Creator 中脚本名称就是组件的名称，这个命名是大小写敏感的！如果组件名称的大小写不正确，将无法正确通过名称使用组件！） 这对于一些简单的动画来说，无疑是福音 游戏库对比合集3D探索——Web 3D哪家强？（主要是threejs和Layabox） 案例合集cocos官网案例：https://docs.cocos.com/creator/manual/zh/cases-and-tutorials/","categories":[],"tags":[],"author":"Hello"},{"title":"babel","slug":"babel","date":"2021-02-06T16:00:00.000Z","updated":"2023-04-10T16:36:29.773Z","comments":true,"path":"2021/02/07/babel/","link":"","permalink":"https://taylor12138.github.io/2021/02/07/babel/","excerpt":"","text":"1.babel介绍小概 polyfill：polyfill主要抚平不同浏览器之间对js实现的差异，比如一些es6的语法，通过polyfill注入代码，使得es5也能正常运行api Core-js：它是JavaScript 标准库中最流行也最常用的polyfill core-js：包含所有polyfill（当然也可以仅引入部分特性的polyfill，比如： import 'core-js/features/array/from'; // &lt;- at the top of your entry point import 'core-js/features/array/flat'; // &lt;- at the top of your entry point import 'core-js/features/set'; // &lt;- at the top of your entry point import 'core-js/features/promise'; // &lt;- at the top of your entry point Array.from(new Set([1, 2, 3, 2, 1])); // => [1, 2, 3] [1, [2, 3], [4, [5]]].flat(2); // => [1, 2, 3, 4, 5] Promise.resolve(32).then(x => console.log(x)); // => 32 但是即使在这里部分引入的polyfill，依然会直接扩展到全局环境中 core-js-pure：不会把polyfill注入全局环境，但是在使用时需要单独引入polyfill的module core-js-bundle：编译打包好的版本，包含全部的polyfill特性，适合在浏览器里面通过script直接加载，前2个版本适合放构建工具 regenerator-runtime：用来转换 generator 和 async 函数，也是一个polyfill babel： 内部借助了corejs对代码添加polyfill 并且支持ES6的代码转换为ES5代码（class、箭头函数、properties） 支持jsx等编译转换 在babel7之前，babel专门提供了一个库叫babel/polyfill来做polyfill，在babel7之后，这个库被废弃了 babel的每一种转换处理都对应一个babel插件，但是plugin太多了，所以babel推出了presets，包含若干个plugin 自定义preset安装完对应plugin之后，新建一个my-preset.js module.exports = () => ({ plugins: [ ['@babel/plugin-transform-arrow-functions'], ['@babel/plugin-transform-classes', {spec: false}], ['@babel/plugin-transform-computed-properties'], ['@babel/plugin-proposal-object-rest-spread', {loose: true, useBuiltIns: true}] ] }); 然后在babel配置文件中导入 //babel.config.js const presets = [ './my-preset.js' ]; const plugins = [ ]; module.exports = {presets, plugins} webpack and babel如果希望将ES6语法转化成ES5语法，我们可以使用babel对应的loader，配置打包得到新的js文件 npm install -D babel-loader @babel/core @babel/preset-env @babel/core babel的核心工具 @babel/preset-env babel的预定义环境，包含大量实用babel plugin，还能根据browserslist进行配置，满足运行环境最低版本要求 融入了corejs，并且有对应的配置项进行适配，抛弃了传统的 @babel/polyfill 直接全量引入 @babel-loader babel在webpack中的加载器 其实还可以配置一个core-js，core-js用来使老版本的浏览器支持新版ES语法（比如老版本没有Promise，它会给你引进去coreJs库里的Promise函数），然后按需加载可以使用到的 core-js 部分 如果 @babel/core or @babel/plugin-transform-regenerator 版本 小于 7.18.0，你需要加载 regenerator runtime 来加载 core-js/stable， 如果 你用了 @babel/preset-env‘s useBuiltIns: &quot;usage&quot; option or @babel/plugin-transform-runtime. 则会自动加载 core-js/stable 2.配置在webpack.config.js中的配置 const path = require('path') module.exports = { entry: \"./src/index.ts\", output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js' }, module: { // 指定加载规则 rules: [ { //这里使用TypeScript test: /\\.ts$/,// test指定规则生效的文件,以ts结尾的图片 exclude: /node_modules/, use: [ { loader: \"babel-loader\", options: { presets: [ [ '@babel/preset-env', { // 要兼容的目标浏览器 targets: { \"chrome\": \"58\", \"ie\": \"8\" }, // corejs版本 \"corejs\": \"3\", // 使用corejs的方式，按需加载 \"useBuiltIns\": \"usage\" } ] ] } }, // 如果使用typescript的loader，要把ts-lodaer放下方，babel-loader放上方 // webpack从后往前执行，所以必须要先执行ts -> Js转换，再执行js兼容性的转换 'ts-loader' ], } ] }, } @babel/preset-env： useBuiltIns 默认false，不会有任何 polyfill 被添加进来 entry，需要我们手动针对项目入口文件处全局注入的core-js进行优化转换，但是只针对core-js@3版本 import \"core-js\"; //... usage，按需导入，效果比 entry 好（体积小，可以看 这里） corejs 安装完core-js后还需要在@babel-preset-env中指定其版本，如果开启useBuiltIns，默认为2.0版本，这里肯定要改成3.0+的，因为3.0的core-js改进很大。 当然，我们也可以在根目录下，创建一个babel.config.js / babel.config.json / .babelrc 将babel配置信息放在一个独立的文件中 //babel.config.js module.exports = { preset: { \"@babel/preset-env\" } } 然后在webpack.config.js里的rules里直接use babel-loader即可 你甚至可以在package.json里面写 { \"name\": \"my-package\", \"version\": \"1.0.0\", \"babel\": { \"presets\": [ ], \"plugins\": [ ] } } 3.transform-runtime(1)Babel 插入了辅助代码 Babel 在每个文件都插入了辅助代码，使代码体积过大！ Babel 对一些公共方法使用了非常小的辅助代码，比如 _extend，默认情况下会被添加到每一个需要它的文件中。 而transform-runtime插件可以把这些重复的辅助代码，转换成公共的函数进行引入 我们正常给应用全局环境注入polyfill，是没啥问题的，但是如果在开发一个独立的工具库项目，不确定它将会被其它人用到什么运行环境里面，那么前面那种扩展全局环境的polyfill就不是一个很好的方式，而transform-runtime会为你创造一个沙盒环境来运行当前代码 下面的配置禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 @babel/plugin-transform-runtime 并且使所有辅助代码从这里引用。 更多信息请查看 文档。 npm install --save-dev @babel/plugin-transform-runtime npm install --save @babel/runtime rules: [ // 'transform-runtime' 插件告诉 Babel // 要引用 runtime 来代替注入。 { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'], plugins: ['@babel/plugin-transform-runtime'] } } } ] 注意：如果同时开启plugin-transform-runtime和preset-env的polyfill，则会 rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env', { \"targets\": { ios: 8, android: 4.1 }, useBuiltIns: 'usage' } ], plugins: ['@babel/plugin-transform-runtime', { corejs: 3 }] } } } ] 然后对以下进行转换 Promise.resolve().finally(); 会出现 \"use strict\"; var _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\"); var _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\")); require(\"core-js/modules/es6.promise\"); require(\"core-js/modules/es6.object.to-string\"); require(\"core-js/modules/es7.promise.finally\"); _promise.default.resolve().finally(); require(&quot;core-js/modules/es6.promise&quot;); 和 var _promise = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/promise&quot;)); 这种重复的polyfill的存在，所以我们在开发时要关闭其中之一 options: { presets: ['@babel/preset-env'], plugins: ['@babel/plugin-transform-runtime'] } 或者 [ \"@babel/plugin-transform-runtime\", { corejs: false, regenerator: false } ] 最后注意： 它跟preset-env提供的polyfill适用的场景是完全不同，runtime适合开发库，preset-env适合开发application runtime与preset-env的polyfill不能同时启用 runtime的polyfill不判断目标运行环境（并不支持 targets 的配置） (2)箭头函数babel后部分浏览器仍然不支持箭头函数，是因为webpack5打包文件默认输出形式就是箭头函数，用以下配置解决即可 output: { filename: 'js/bundle.js', path: path.resolve(__dirname, 'dist'), environment: { arrowFunction: false } }, (3)babel优化影响打包效率的loader首当其冲必属 Babel 了 我们可以控制babel文件搜索范围，只转换指定文件夹下的代码，去除没必要转换的部分，比如node_modules module.exports = { module: { rules: [ { // js 文件才使用 babel test: /\\.js$/, loader: 'babel-loader', // 只在 src 文件夹下查找 include: [resolve('src')], // 不会去查找的路径 exclude: /node_modules/ } ] } } (4)babel原理babel就是从一种源代码转换为另外一种源代码，或者把babel看成一种编译器 https://juejin.cn/post/7078482623387402271#comment 参考文章： webpack官网 babel官网 babel详解","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"webpack(下)","slug":"webpack(下)","date":"2021-02-06T16:00:00.000Z","updated":"2023-04-13T02:43:29.802Z","comments":true,"path":"2021/02/07/webpack-xia/","link":"","permalink":"https://taylor12138.github.io/2021/02/07/webpack-xia/","excerpt":"","text":"5.关于webpackWebpack缩小体积原理将多个模块依赖，转变成单个静态资源（js、css、jpg、png） 打包，是指处理某些文件并将其输出为其他文件的能力。 entry: 编译入口 module: 模块，在 webpack 中，一切皆为模块，一个模块对应一个文件 Chunk: 代码块，一个 chunk 由多个模块组合而成，用于代码的合并与分割 Loader: 模块转换器，将非js模块转化为webpack能识别的js模块 Plugin: 扩展插件，在webpack运行的各个阶段，都会广播出去相对应的事件，插件可以监听到这些事件的发生，在特定的时机做相对应的事情 项目中使用的每个文件都是一个模块，在打包过程中，模块（module）会被合并成 chunk，chunk 合并成 chunk 组，并形成一个通过模块互相连接的图(ModuleGraph)。 那么如何通过以上来描述一个入口起点：在其内部，会创建一个只有一个 chunk 的 chunk 组。 所以chunk有两种形式 initial(初始化) 是入口起点的 main chunk。此 chunk 包含为入口起点指定的所有模块及其依赖项。 non-initial 是可以延迟加载的块。可能会出现在使用 动态导入(dynamic imports) 或者 SplitChunksPlugin 时。 然后loader是文件转换器（将webpack不能处理的模块转换成能处理的模块，也就是js模块）、plugin是功能拓展 我们也可以安装一个插件帮我们查看依赖图 npm i webpack-bundle-analyzer -D const { BundleAnalyzerPlugin } = require(\"webpack-bundle-analyzer\"); module.exports = (env) => { return { plugins: [ new BundleAnalyzerPlugin(), ], }; npx webpack serve 然后你就可以看到 Webpack构建流程 初始化参数：通过 yargs 解析 config 与 shell 中的配置项，从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数（options）初始化 Compiler 对象（实例化），加载所有配置的插件 compiler 可以理解为 webpack 编译的调度中心，它记录了完整的 webpack 环境信息 初始化时定义了很多钩子 class Compiler extends Tapable { constructor(context) { super(); this.hooks = { beforeCompile: new AsyncSeriesHook([\"params\"]), compile: new SyncHook([\"params\"]), afterCompile: new AsyncSeriesHook([\"compilation\"]), make: new AsyncParallelHook([\"compilation\"]), entryOption: new SyncBailHook([\"context\", \"entry\"]) // 定义了很多不同类型的钩子 }; // ... } } 调用compiler.run(callback);，开始构建，进入compile函数 run(callback) { const onCompiled = (err, compilation) => { this.hooks.done.callAsync(stats, err => { return finalCallback(null, stats); }); }; // 执行订阅了compiler.beforeRun钩子插件的回调 this.hooks.beforeRun.callAsync(this, err => { // 执行订阅了compiler.run钩子插件的回调 this.hooks.run.callAsync(this, err => { this.compile(onCompiled); }); }); } compiler.compile函数 compile(callback) { // 实例化核心工厂对象 const params = this.newCompilationParams(); // 执行订阅了compiler.beforeCompile钩子插件的回调 this.hooks.beforeCompile.callAsync(params, err => { // 执行订阅了compiler.compile钩子插件的回调 this.hooks.compile.call(params); // 创建此次编译的Compilation对象 const compilation = this.newCompilation(params); // 执行订阅了compiler.make钩子插件的回调 this.hooks.make.callAsync(compilation, err => { compilation.finish(err => { compilation.seal(err => { this.hooks.afterCompile.callAsync(compilation, err => { return callback(null, compilation); }); }) }) }) }) } 然后在创建Compilation对象实例，Compilation 对象是后续构建流程中最核心最重要的对象，它包含了一次构建过程中所有的数据。也就是说一次构建过程对应一个 Compilation 实例。在创建 Compilation 实例时会触发钩子 compilaiion 和 thisCompilation。 在Compilation对象中： modules 记录了所有解析后的模块 chunks 记录了所有chunk assets记录了所有要生成的文件 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：开始 modules 的生成阶段，进入make 钩子，执行真正的编译构建过程，从入口文件开始，构建模块，直到所有模块创建结束从入口文件出发 modules：一个依赖对象（Dependency）经过对应的工厂对象（Factory）创建之后，就能够生成对应的模块实例（Module）。 调用所有配置的 Loader 对模块进行翻译（在doBuild 调用了相应的 loaders，转换了部分的原本不可识别的语言） 调用Parser.parse方法，将JS解析为AST。解析成AST最大作用就是收集模块依赖关系 再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理（对每个模块所依赖的对象进行收集。） 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：触发compilation.seal方法，进入下一个阶段。（chunk生成阶段） 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 chunk内部的主要属性是_modules，用来记录包含的所有模块对象。所以要生成一个chunk，就先要找到它包含的所有modules。下面简述一下chunk的生成过程： 先把 entry 中对应的每个 module 都生成一个新的 chunk 遍历module.dependencies，将其依赖的模块也加入到上一步生成的chunk中 若某个module是动态引入的，为其创建一个新的chunk，接着遍历依赖 调用createChunkAssets，遍历chunk，来渲染每一个chunk生成代码 每个chunk的源码生成之后，会调用 emitAsset 将其存在 compilation.assets 中。当所有的 chunk 都渲染完成之后，assets 就是最终更要生成的文件列表。至此，compilation 的 seal 方法结束，也代表着 compilation 实例的所有工作到此也全部结束，意味着一次构建过程已经结束，接下来只有文件生成的步骤了。 在 Compiler 开始生成文件前，钩子 emit 会被执行，这是我们修改最终文件的最后一个机会，生成的在此之后，我们的文件就不能改动了。 webpack 会直接遍历 compilation.assets 生成所有文件，然后触发钩子done，结束构建流程。 流程参考：https://juejin.cn/post/6844904000169607175 webpakc管理模块之manifest一旦你的应用在浏览器中以 index.html 文件的形式被打开，一些 bundle 和应用需要的各种资源都需要用某种方式被加载与链接起来。在经过打包、压缩、为延迟加载而拆分为细小的 chunk 这些 webpack 优化 之后，你精心安排的 /src 目录的文件结构都已经不再存在。所以 webpack 如何管理所有所需模块之间的交互呢？这就是 manifest 数据用途的由来 当 compiler 开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合称为 “manifest”，当完成打包并发送到浏览器时，runtime 会通过 manifest 来解析和加载模块。无论你选择哪种 模块语法，那些 import 或 require 语句现在都已经转换为 __webpack_require__ 方法，此方法指向模块标识符(module identifier)。通过使用 manifest 中的数据，runtime 将能够检索这些标识符，找出每个标识符背后对应的模块。 问题所以，现在你应该对 webpack 在幕后工作有一点了解。“但是，这对我有什么影响呢？”，你可能会问。答案是大多数情况下没有。runtime 做完成这些工作：一旦你的应用程序加载到浏览器中，使用 manifest，然后所有内容将展现出魔幻般运行结果。然而，如果你决定通过使用浏览器缓存来改善项目的性能，理解这一过程将突然变得极为重要。 通过使用内容散列(content hash)作为 bundle 文件的名称，这样在文件内容修改时，会计算出新的 hash，浏览器会使用新的名称加载文件，从而使缓存无效。一旦你开始这样做，你会立即注意到一些有趣的行为。即使某些内容明显没有修改，某些 hash 还是会改变。这是因为，注入的 runtime 和 manifest 在每次构建后都会发生变化。 查看 管理输出 指南的 manifest 部分，了解如何提取 manifest，并阅读下面的指南，以了解更多长效缓存错综复杂之处。 Further Reading 分离 manifest 使用 webpack 提供可预测的长效缓存 缓存 Webpack对前端性能的优化 压缩代码，比如丑化JS代码，使得文件体积更小（UglifyJsPlugin、 ParallelUglifyPlugin） 利用CDN加速，修改资源路径 删除死代码 提取公共代码 Tree-shaking在webpack中开启tree-shaking，只要是“我”认为没有使用的代码，我就删掉 module.exports = (env) => { return { //... optimization: { //在生产环境下开启，会开启tree-shaking usedExports: true, }, }; }; webpack4默认没有直接进行tree-shaking，怕部分有副作用的文件会被忽略（比如全局样式引入），可以通古配置sideEffects进行更改，但是webpack5默认会进行 tree-shaking（智能tree-shaking，在不确定的情况下将导入的模块列为有副作用的） “side effect(副作用)” 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。 以下是个人根据情况修改副作用文件 //package.json { \"sideEffects\": false, //都没有副作用，可以删除任何你觉得不满的代码 } //package.json { \"sideEffects\": [\"*.css\"], //css文件的不能乱删，有副作用 } 不同环境下使用 开发环境下的配置 // webpack.config.js module.exports = { // ... mode: 'development', optimization: { usedExports: true, } }; 复制代码 生产环境下的配置 // webpack.config.js module.exports = { // ... mode: 'production', }; 复制代码 在生产环境下，Webpack 默认会添加 Tree Shaking 的配置，因此只需写一行 mode: ‘production’ 即可。 小总结通过sideEffects修改tree-shaking的方式 使用 ES2015 模块语法（即 import 和 export）。 确保没有编译器将您的 ES2015 模块语法转换为 CommonJS 的（顺带一提，这是现在常用的 @babel/preset-env 的默认行为，详细信息请参阅文档）。 在项目的 package.json 文件中，添加 &quot;sideEffects&quot; 属性。 使用 mode 为 &quot;production&quot; 的配置项以启用更多优化项，包括压缩代码与 tree shaking。 6.webpack热更新原理webpack模块热更新也就是HMR，Hot Module Replacement，它是指应用程序运行过程中，替换、添加、删除模块，而无需刷新整个页面 这里要注意的是热更新的时候，并没有自动刷新浏览器 不需要重新加载整个页面，可以保证某些应用程序的状态不丢失。 只更新需要变化的内容，节省开发时间 修改了css、js的源代码，便会立即在浏览器更新，相当于在浏览器开发者模式devtools中直接更改样式 使用：默认情况下 webpack-dev-server（也就是上方安装的搭建服务）已经支持了HMR，我们只需要开启即可。不开启则为live reloading，整个页面进行刷新 module.exports = { //... target: \"web\", //给web打包，或者值为node，则为node打包 devServer: { hot: true } }; 但是需要告诉webpack，哪些模块用到热更新，在webpack中需要配合module.hot进行使用. 但是像Vue、React等框架，他们有vue-loader、react-refresh等，可以做到开箱即用 还有一个热加载，也就是文件更新时，自动刷新我们的服务和页面 module.exports = { //... devServer: { liveReload: true //默认为true } }; HMR实际上是使用了一个插件：HotModuleReplacementPlugin,但是我们webpack5已经开箱即用了 HMR原理是webpack-dev-server会创建两个服务，提供静态资源服务的express、和Socket服务（net.Socket） HMR Socket Server是一个socket长连接： 使用express启动本地服务，当浏览器访问资源时对此做响应。 服务端和客户端使用websocket实现长连接 webpack监听源文件的变化，即当开发者保存文件时触发webpack的重新编译。 每次编译都会生成hash值、已改动模块的json文件、已改动模块代码的js文件 编译完成后通过socket向客户端推送当前编译的hash戳 客户端的websocket监听到有文件改动推送过来的hash戳，会和上一次对比 一致则走缓存 不一致则通过ajax和jsonp向服务端获取最新资源 使用内存文件系统去替换有修改的内容实现局部刷新 也可以理解为本地服务器和浏览器端形成一个完成的通信双方，进行socket通信 实现热更新 图片来自饿了么前端@知乎专栏 上图底部红色框内是服务端，而上面的橙色框是浏览器端。 绿色的方框是 webpack 代码控制的区域。蓝色方框是 webpack-dev-server 代码控制的区域，洋红色的方框是文件系统，文件修改后的变化就发生在这，而青色的方框是应用本身。 第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中，并且生成了一个 Hash值。 第二步，webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API （ compiler.watch() ）对代码变化进行监控，并且告诉 webpack，将代码打包到内存中（使用 webpack-dev-middleware 一个依赖库 memory-fs ）。 第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。 第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 Hash 值，后面的步骤根据这一 Hash 值来进行模块热替换。其中关于websocket的消息接收，是因为webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。 第五、六步，webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。 第七、八、九步，HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 Hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，以查看是否需要更新，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码（主要是因为JSONP获取的代码可以直接执行）。 而第 十 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。 最后一步，当 HMR 失败后，回退到 livereload 操作，也就是进行浏览器刷新来获取最新打包代码。 https://zhuanlan.zhihu.com/p/30669007 7.webpack打包库如果想要编写自己的库，供其他人使用，需要在webpack中配置 //webpack.config.js const path = require(\"path\"); module.exports = { mode: \"production\", entry: \"./src/index.js\", output: { path: path.join(__dirname, \"dist\"), filename: \"bundle.js\", //打包后的文件名 library: \"littleLib\", }, }; 当然，作为库的作者，希望自己的库能通过commonjs、script标签、amd、esmodule等形式进行引用 const path = require(\"path\"); module.exports = { //... experiments: { outputModule: true, //如果以es module的形式导出，则需要配置experiments.outputModule项,因为还是实验性的 }, output: { //... library: { type: \"module\", //以es module形式导出，不能设置名字 }, }, }; module.exports = { //... output: { //... library: { name: \"littleLib\", type: \"umd\", //支持运行在 CommonJS、AMD、Node.js 等环境中。 }, }, }; 中间插播小笑话 部分资料参考地址https://juejin.cn/post/6844903877771264013 8.webpack5模块联邦共享模块的方式： NPM 方式共享模块 对于项目 Home 与 Search，需要共享一个模块时，最常见的办法就是将其抽成通用依赖并分别安装在各自项目中。缺点是要走本地编译（需要更新npm包， npm install，再构建 + 发布，而且产物体积可能会偏大） 虽然 Monorepo 可以一定程度解决重复安装和修改困难的问题（依赖复用），但依然需要走本地编译，并且还要求所有的应用代码必须放到同一个仓库。 umd共享模块 将模块用 Webpack UMD 模式打包，并输出到其他项目中。这是非常普遍的模块共享方式 像这种 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\" /> &lt;link rel=\"icon\" type=\"image/svg+xml\" href=\"/src/favicon.svg\" /> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> &lt;title>Vite App&lt;/title> &lt;/head> &lt;body> &lt;div id=\"root\">&lt;/div> &lt;!-- 从 CDN 上引入第三方依赖的代码 --> &lt;script src=\"https://cdn.jsdelivr.net/npm/react@17.0.2/index.min.js\">&lt;script> &lt;script src=\"https://cdn.jsdelivr.net/npm/react-dom@17.0.2/index.min.js\">&lt;script> &lt;/body> &lt;/html> 但这种技术方案问题也很明显，就是包体积无法达到本地编译时的优化效果(全量引用)，且库之间容易冲突（库引入顺序）。 微前端共享模块 但是微前端会出现以下问题 1）子应用独立打包，模块更解耦，但无法抽取公共依赖等。 2）整体应用一起打包，很好解决上面的问题，但打包速度实在是太慢了，不具备水平扩展能力。 webpack5的模块联邦，是直接将原来的应用依赖的包（模块），直接引用于另外一个项目/应用，在模块联邦中，更注重项目与项目之间的引用（A用了B的xx模块，B用了C的xx模块），相对来说是mf 是去中心化的(其实也挺像npm包的感觉)，当然这种引用关系也可以运用到微前端这种突出主和子应用的关系中去 底层概念我们区分本地模块和远程模块。本地模块即为普通模块，是当前构建的一部分。远程模块不属于当前构建，并在运行时从所谓的容器加载。 加载远程模块被认为是异步操作。当使用远程模块时，这些异步操作将被放置在远程模块和入口之间的下一个 chunk 的加载操作中。如果没有 chunk 加载操作，就不能使用远程模块。 容器是由容器入口创建的，该入口暴露了对特定模块的异步访问。暴露的访问分为两个步骤： 加载模块（异步的） 执行模块（同步的） 微前端 让应用具备模块化输出能力，其实开辟了一种新的应用形态，即 “中心应用”，（其实也就是微前端）这个中心应用用于在线动态分发 Runtime 子模块，并不直接提供给用户使用 而在微前端领域，这个主应用就是应用中心，所有子应用都可以利用 Runtime 方式复用主应用的 Npm 包和模块，更好的集成到主应用中。 评论看到网上的一条评论： 这不就是一个包 构建一个全量umd +单独声明entry的umd +单独umd的entry/shared集合 嘛。。。 至于shared，和external没什么区别，只是可以构建时生成罢了。 其中shared部分也不能做构建优化，只能全量打包。 意义就是以前一个包一个入口引入所有内容，现在可以按需打包了。 比如antd可以在发布的时候每个组件打一个umd，再加上一个整体的runtime。 于是就形成了 1.umd引入 2.umd引入runtime+单独entry动态引入 但是要想选出来需要用的包组合成一个文件，只能重新打包。 而且使用2引入方式，必须用import()，否则网络延迟会阻塞渲染，相当于是requirejs的机制。微前端彼此间的依赖版本估计都是大相径庭的，很难直接去 share libaray 。 Service 的 share 可能更合适一些，比如从前将通用业务抽成 npm 包的方式，可以用这种方式代替了。 相较于整体打包，子项目单独发布叫“水平扩展”，不太合适吧。实践模块联邦本身是一个普通的 Webpack 插件 ModuleFederationPlugin，插件有几个重要参数： name 当前应用名称，需要全局唯一。 remotes 可以将其他项目的 name 映射到当前项目中（remote译为远程的） exposes 表示导出的模块，类似于export，只有在此申明的模块才可以作为远程依赖被使用，需要注意的key需要加上 ./。 shared 是非常重要的参数，制定了这个参数，可以让远程加载的模块对应依赖改为使用本地项目的 React 或 ReactDOM。 模块联邦的使用方式如下： 一共有三个微应用:lib-app、component-app、main-app，角色分别是： lib-appas remote,暴露了两个模块react和react-dom（公共react和react-dom） component-app as remote and host,依赖lib-app暴露的 react和react-dom ，暴露了一些组件供main-app消费 main-app as host,依赖lib-app和component-app 暴露lib-app模块//webpack.config.js module.exports = { //...省略 plugins: [ new ModuleFederationPlugin({ name: \"lib_app\", filename: \"remoteEntry.js\", exposes: { \"./react\":\"react\", \"./react-dom\":\"react-dom\" } }) ], //...省略 } 编译后的结果： 除去生成的map文件，有四个文件：main.js、remoteEntry.js、...react_index.js、...react-dom_index.js； 第一个是本项目的入口文件（该项目只是暴露接口，所以该文件为空） 第二个是远程入口文件，其他webpack构建使用、访问本项目暴露的模块时，须通过它来加载 第三个和第四个是暴露的模块，供其他项目消费(使用) component-app的配置依赖lib-app,暴露三个模块组件Button、Dialog、Logo //webpack.config.js module.exports = { //...省略 plugins:[ new ModuleFederationPlugin({ name: \"component_app\", filename: \"remoteEntry.js\", exposes: { \"./Button\":\"./src/Button.jsx\", \"./Dialog\":\"./src/Dialog.jsx\", \"./Logo\":\"./src/Logo.jsx\" }, remotes:{ \"lib-app\":\"lib_app@http://localhost:3000/remoteEntry.js\" } }), ] } 然后在三个组件内使用引入的remote（lib-app） //Dialog.jsx import React from 'lib-app/react'; export default class Dialog extends React.Component { //... } export default class Button extends React.Component { //... } export default class Logo extends React.Component { //... } main-app配置main-app依赖两个项目lib-app、component-app。 ///webpack.config.js module.exports = { //省略... plugins: [ new ModuleFederationPlugin({ name: \"main_app\", remotes:{ \"lib-app\":\"lib_app@http://localhost:3000/remoteEntry.js\", \"component-app\":\"component_app@http://localhost:3001/remoteEntry.js\" }, }), new HtmlWebpackPlugin({ template: \"./public/index.html\", }) ] //省略... }; 由于需要等待基础模块加载完毕，所以需要配置懒加载入口bootstrap.js. webpack打包入口文件 import(\"./bootstrap.js\") bootstrap.js import App from './App.jsx' import ReactDOM from 'lib-app/react-dom'; import React from 'lib-app/react' ReactDOM.render(&lt;App />, document.getElementById(\"app\")); 根组件App.jsx import React from 'lib-app/react'; import Button from 'component-app/Button' import Dialog from 'component-app/Dialog' import Logo from 'component-app/Logo' export default class App extends React.Component{ //... } 下载脚本网上扒过源码，下载脚本本质也是通过jsonp的形式下载 通过webpack_require.l(url, errorHandler, chunkName)下载脚本： /* webpack/runtime/load script */ (() => { var inProgress = {}; var dataWebpackPrefix = 'webpack5-demo:'; // loadScript function to load a script via script tag __webpack_require__.l = (url, done, key) => { if (inProgress[url]) { inProgress[url].push(done); return; } var script, needAttach; if (key !== undefined) { var scripts = document.getElementsByTagName('script'); for (var i = 0; i &lt; scripts.length; i++) { var s = scripts[i]; if ( s.getAttribute('src') == url || s.getAttribute('data-webpack') == dataWebpackPrefix + key ) { script = s; break; } } } if (!script) { needAttach = true; // 创建 script 标签 script = document.createElement('script'); script.charset = 'utf-8'; script.timeout = 120; if (__webpack_require__.nc) { script.setAttribute('nonce', __webpack_require__.nc); } script.setAttribute('data-webpack', dataWebpackPrefix + key); // 设置 src = 'http://127.0.0.1:2001/examples_app1_say_js.bundle.js' script.src = url; // 到这远程脚本 examples_app1_say_js.bundle.js 应该就开始下载了 } inProgress[url] = [done]; var onScriptComplete = (prev, event) => { // avoid mem leaks in IE. script.onerror = script.onload = null; clearTimeout(timeout); var doneFns = inProgress[url]; delete inProgress[url]; script.parentNode &amp;&amp; script.parentNode.removeChild(script); doneFns &amp;&amp; doneFns.forEach((fn) => fn(event)); if (prev) return prev(event); }; var timeout = setTimeout( onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000 ); script.onerror = onScriptComplete.bind(null, script.onerror); script.onload = onScriptComplete.bind(null, script.onload); needAttach &amp;&amp; document.head.appendChild(script); }; })(); 开始感觉有点类似以前通过 cdn 引入第三方js库的感觉 一些其他问题shared版本问题： 正确做法 const { dependencies } = require(\"./package.json\"); ... shared: { ...dependencies, react: { singleton: true, requiredVersion: dependencies[\"react\"], }, \"react-dom\": { singleton: true, requiredVersion: dependencies[\"react-dom\"], }, }, 参考： 微前端实践–webpack5模块联邦 精读《Webpack5 新特性 - 模块联邦》","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"webpack(上)","slug":"webpack(上)","date":"2021-02-06T16:00:00.000Z","updated":"2023-05-17T06:41:33.940Z","comments":true,"path":"2021/02/07/webpack-shang/","link":"","permalink":"https://taylor12138.github.io/2021/02/07/webpack-shang/","excerpt":"","text":"1.Webpack概述Bundler 是能够通过 import/export 将很多 JavaScript 文件，打包成一个/几个文件的工具 webpack是一个现代的JavaScript应用的静态模块打包工具（依赖于node环境），是目前最流行的bundler 它可以帮你把AMD、CMD、CommonJS、ES6的一些模块化编写方式，转化为— &gt; 浏览器可以识别的模块化方案 而且不仅仅JS文件，CSS文件、图片文件等在Webpack也会被当成模块来使用 打包后生成一个文件夹，在服务器进行部署即可 历史在打包工具未出现之前，我们引入第三方库，要在html下面的script一一引入 然后我们自己项目的业务代码也得在script中一一引入（在第三方库script下方引入，毕竟js是从上到下一一加载的） 浏览器加载一个大脚本，要比加载多个小脚本，性能更好。 除了麻烦之外，还有其他问题：作用域问题、文件大小问题（可以使用nodejs模块方案解决）、文件引用顺序问题（webpack帮你解决！）、可读性差、维护性弱等 出现grunt和gule 往后先出现了grunt和gule这两个打包工具 grunt、gule使用IIFE的形式解决作用域问题（立即执行函数） var res = (function(){ return { name:'allen' } }()) console.loh(res.name) 三者都是前端构建工具，grunt和gulp在早期比较流行，而webpack是现在的主流。 grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。 webpack基于入口，webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。 模块拓展 出现了nodejs，模块方案得以解决，但是浏览器上并不能运行node，在早期我们使用的是requirejs库，调用库的方法，让浏览器可以使用nodejs（webpack） 后面ES6之后，支持了浏览器端的模块加载，多了一种实现模块加载的方案（vite使用） 起步安装 npm i webpack webpack-cli -g https://webpack.docschina.org/guides/getting-started/ &lt;- 看这里 注意：全局安装webpack在多人开发模式下会有版本风险，建议本地安装即可 若只想执行本目录下node_modules的webpack版本可以使用 npx webpack 这种在package.json的script里（脚本），设置 \"script\": { \"build\": \"webpack\" } 执行 npm run build即可 入口、打包文件的存放： 新建两个文件夹，src放置开发的源码，dist放置之后打包的文件 方法一：（全局安装webpack）webpack在打包的时候，会查看你有没有依赖其他文件，所以给一个入口文件(main.js或者index.js)就好了 webpack ./src/入口文件.js ./dist/打包后文件名.js 这时在html文件内用script引用打包后的js文件即可 方法二：指定option 执行以下代码可以帮助查看webapck一些相关命令 npx webpack --help 模式为生产模式，入口为 ./src/index.js npx webpack --entry ./src/index.js --mode production此时会自动在目录下生产dist文件存放打包好的js文件 方法三：新建一个 webpack.config.js，配置入口 entry和出口 output，output推荐用对象的形式来写 const path = require('path'); module.exports = { entry: './src/main.js', output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js' //打包后的文件名 } } 由于要依赖node的核心模块path以动态获得output的绝对路径，这里先进行npm初始化，得到package.json包， 这时在命令窗口直接输入 npx webpack 或者用映射来运行：（更推荐，因为它会优先在本地找依赖包，而不是全局找依赖包，全局依赖包可能因为版本原因导致代码报错） 在package.json文件中的 script 配置 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"npx webpack\" }, 然后再命令窗口输入 npm run build 一些webpack设置module.exports = { /*设置模式，可以去官网查看，其实这个模式代表webpack帮你调了很多配置 1.development，开发阶段 2.production，打包上线阶段 */ mode: \"development\", //设置source-map，简历js映射文件（类似于我们在vue3中调试源码的行为），方便调试代码错误时 devtool: \"source-map\", entry: './src/main.js', output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js' //打包后的文件名 clean: true, // 在生成文件之前清空 output 目录 }, library: 'myLib', //如果要打包的是自己创建的方法库，请配置上library } 打包成库打包成库记得要配置上library module.exports = { //... output: { path: path.resolve(__dirname, 'dist'), filename: 'webpack-numbers.js', library: \"webpackNumbers\", }, } 但是此时只能作为esm模块被使用，只能通过被 script 标签引用而发挥作用，它不能运行在 CommonJS、AMD、Node.js 等环境中。 作为一个库作者，我们希望它能够兼容不同的环境 我们更新 output.library 配置项，将其 type 设置为 &#39;umd&#39;： const path = require('path'); module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'webpack-numbers.js', - library: 'webpackNumbers', + library: { + name: 'webpackNumbers', + type: 'umd', + }, }, }; type类型： &quot;var&quot; | &quot;module&quot; | &quot;assign&quot; | &quot;assign-properties&quot; | &quot;this&quot; | &quot;window&quot; | &quot;self&quot; | &quot;global&quot; | &quot;commonjs&quot; | &quot;commonjs2&quot; | &quot;commonjs-module&quot; | &quot;commonjs-static&quot; | &quot;amd&quot; | &quot;amd-require&quot; | &quot;umd&quot; | &quot;umd2&quot; | &quot;jsonp&quot; | &quot;system&quot; | string 输出 ES 模块(module)。请确保事先启用 experiments.outputModule。 source-map关于webpack.config.js配置中devtool的设置，默认值为 eval（最好性能） 模式 详情 eval 每个module会封装到eval，包裹起来执行，并在末尾追加注释 //@sourceURL source-map 生成一个SourceMap文件 hidden-source-map 同source-map，但是不会在bundle末尾追加注释（即无法锁定源文件发生错误的行数） inline-source-map 生成一个DataURL形式的SourceMap文件 eval-source-map 每个module都会通过eval执行，并生成一个DataURL形式的SourceMap文件 cheap-source-map 生成一个没有列信息（column-mapping）的SourceMap文件，但是有行信息，不包含loader的sourcemap（比如babel后无法显示真正对应的行数），可以减少source-map文件大小 cheap-module-source-map 生成一个没有列信息（column-mapping）的SourceMap文件，但是有行信息，同时loader的sourcemap也被简化为只包含对应行 但是要注意的是，生产环境我们一般不会开启source-map 通过bundle和sourcemap文件，可以反编译出源码，也就是说线上产物yousourcemap文件的话，就意味着又暴露代码的风险 source-map文件体积相对比较大，而我们生产环境当然更加追求更轻量级更小的包 Loader和Pluginloader类似于一个转换器，plugin相对webpack本身的拓展，类似于一个拓展器 不同的作用 Loader可以实现让Webpack加载和解析除了JavaScript以外的能力。 Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。 2.Loader(前言：你已经是一个成熟的webpack了，应该学会自己安装loader！！！) webpack主要用来处理我们js代码，进行模块化开发，并且自动处理js之间的依赖关系 但是在开发中，我们不仅仅有基本的js代码需要处理，也需要加载css、图片，包括一些高级的将ES6转化为ES5代码，或者TypeScript转化为ES5代码，将scss、less转化为css，css兼容低版本的等等 对于webpack本身能力来说，对于这些转化是不支持的，这时我们需要用到loader。 注意：在use选项中，loader的放置顺序需要注意下，是从下往上的，比如style-loader一定要比css-loader后执行，所以style-loader放上面，css-loader放下面 1.通过npm安装需要使用的loader 2.在webpack.config.js的module关键字下进行配置（根据官网给的配置信息填充就可以了） 处理CSS文件这里举一个CSS文件打包的例子，需要配置 style-loader （负责将导出的样式添加到DOM（用于生效））和 css-loader（负责加载并解析import的CSS文件（用于加载）） npm install --save-dev style-loader css-loader module.exports = { module: { rules: [ { test: /\\.css$/i, use: [\"style-loader\", \"css-loader\"], }, ], }, }; 处理图片（在webpack5里面，url-loader和file-loader不再使用） 当CSS要使用 background-image的url导入图片时，可以安装 file-loader并且在webpack.config.js中配置，用于加载图片 若想要在html中设置某元素的src，我们不应该直接根据当前图片距离我们的路径进行字符串设置，而是应该由打包的思想，引入模块来连接它们之间的关系 module: { // 指定加载规则 rules: [ { test: /\\.(jpe?g|png|gif|svg)/ use: \"file-loader\" } ] } import Image from '../img/xx.jpg' imgEl.src = Image; 在使用到图片的场景时，也可以使用对应的图片url-loader 关于url的loader中配置的option选项有一个limit 可以进行设置： limit: 8192, 当加载的图片小于这个limit时，会将图片编译成base64字符串形式 若大于limit，则还需要安装一个loader，即file-loader模块进行加载，从入口js文件打包会得到一张随机命名（32位的哈希值）的图片于dist文件夹中。（安装后并不需要配置file-loader） （如果没有安装HtmlWebpackPlugin插件，我们index.html（想要加载到的页面）在dist文件外面，这时就还需要在webpack的配置文件里的output中，添加publicPath:&#39;dist/&#39;，这样以后涉及到url的路径，都会自动添加上 &#39;dist/&#39;） 但是真实开发中对打包的图片命名有一定要求，我们可以在url-loader的配置option里面，增加其他属性 命名规范：https://v4.webpack.js.org/loaders/file-loader/#n options: { limit: 8192, name: 'img/[name].[hash:8].[ext]', // 按照这个规范进行命名，ext是拓展名，打包的时候放到 //output: \"img\" 上方没有“img/”的时候可以写，输出到打包文件夹下img文件里 }, 资源模块 （替代以往部分loader）上述说道webpack5开始，我们可以直接使用资源模块类型（asset module type）来替代以上处理图片、其他资源的loader 注意！不用下载loader了！！也就是说是内置的 基本介绍 asset/resource，发送一个文件并导出url（替代file-loader），直接一个图片（png、jpg）的url去使用，打包后会出现在dist文件夹下 import imgSrc from \"../asset/1.jpg\"; const img = document.createElement(\"img\"); img.src = imgSrc; asset/inline，导出一个资源URI（替代url-loader，通过Rule.parser.dataUrlCondition.maxSize 选项来修改此limit），比如svg之类的，在打包之后不会出现在dist文件夹中 import mySvg from \"../asset/1.svg\"; const img = document.createElement(\"img\"); img.src = mySvg; asset/source，导出资源的源代码（替代raw-loader），比如txt文件，通过import导入时可以txt文本内容 import Txt from \"../asset/1.txt\"; const div = document.createElement(\"div\"); div.textContent = Txt asset，在导出data URI和发送一个单独的文件之间自动选择，可以当成是asset/resource、asset/inline之间进行自动选择，之前通过url-loader，并且通过配置资源体积限制实现。 实际上是根据图片大小进行选择，小则inline、大则resource 还可以自己设置这个大小 rules: [ { test: /\\.jpg/, type: \"asset\", parser: { dataUrlCondition: { maxSize: 4 * 1024 * 1024 //大于4M时才使用resource } } } ] 具体配置方法//webpack.config.js module.exports = { module: { // 指定加载规则 rules: [ { test: /\\.(jpe?g|png|gif|svg)/, type: \"asset/resource\" } ] } }; 但是经过打包处理之后，资源都是直接放在dist里面，看起来比较杂乱 方法一：在webpack配置文件的output option中定义 assetModuleFilename output: { path: path.join(__dirname, \"dist\"), filename: \"bundle.js\", //打包后的文件名， clean: true, assetModuleFilename: \"imges/[contenthash][ext]\", //根据文件内容，生成一个哈希字符串，然后拓展名使用[ext]来生成原来文件的拓展名 }, 方法二（高于方法一优先级）：在使用资源模块中配置rules时，顺便配置generator rules: [ { test: /\\.(jpe?g|png|gif|svg)/, type: \"asset/resource\", generator: { filename: \"images/test.png\", }, }, ], 加载icon字体rules: [ { test: /\\.(woff|woff2|eot|ttf|otf)/, type: \"asset/resource\", }, ], 处理Vue引入Vue.js 首先在项目中使用Vue.js，需要先通过npm安装Vue npm install vue --save 但是，vue在最终构建发布版本时，会构建两类版本，分别是 runtime-only 代码中不能有任何的template runtime-compiler 代码中可以有template。（此版本需要在webpack.config.js中配置信息，此时在module配置项的下方添加：） resolve: { // 别名,让vue结尾的指向一个具体的文件夹的文件 // 默认指向'vue/dist/vue.runtime.js' alias: { 'vue$': 'vue/dist/vue.esm.js' } } 如果想要通过vue文件分离组件和主要的main.js文件时，会是使用到vue文件 这时需要安装 vue-loader（负责加载，如果是Vue3则安装 vue-loader@next ） 和 @vue/complier-sfc-D（负责编译） 老样子在module的 rules 添加配置信息（这里没use@vue/complier-sfc-D是因为vue-loader内部已经use了） test: /\\.vue$/, use: ['vue-loader'] 但是Vue Loader v15 现在需要配合一个 webpack 插件才能正确使用： // webpack.config.js const VueLoaderPlugin = require('vue-loader/lib/plugin') module.exports = { // ... plugins: [ new VueLoaderPlugin() ] } PostCSS工具PostCSS是一个通过JavaScript转换样式的工具，这个工具可以帮助我们进行一些CSS的适配，比如添加浏览器前缀、css样式重置等。 使用： 查找PostCSS在构建工具中的拓展、入webpack的postcss-loader 选择并添加你需要的PostCSS相关插件 使用webpack.config.js 亦或者 新建一个postcss.config.js进行配置都可 比如比较好用的插件 autoprefixer，自动获取浏览器的流行度和能支持的属性，并且根据这些数据帮我们自动为CSS添加前缀处理，使用Can I Use的数据来决定哪些前缀是需要的，将最新的css语法转化为大多数浏览器都能理解的语法； 并且在postcss的基础上加autoprefixer，可以自动为不同的目标浏览器添加样式前缀，解决的是浏览器兼容性的问题 npm install --save-dev autoprefixer module.exports = { module: { rules: [ { test: /\\.css$/i, use: [ 'style-loader', { loader: 'css-loader', options: { importLoaders: 1 }, }, { loader: 'postcss-loader', options: { postcssOptions: { plugins: [ [ 'autoprefixer', { // 选项 }, ], ], }, }, }, ], }, ], }, }; postcss-preset-env，它可以帮助我们将一些现代的CSS特型转化大多浏览器都认识的CSS，并且根据目标浏览器或运行时的环境添加所需polyfill，也包括会自动帮我们添加autoprefixer npm i -D postcss postcss-loader postcss-preset-env Autoprefixer 使用Browserslist，因此您可以使用类似的查询指定您想要在项目中定位的浏览器&gt; 5% （请参阅最佳实践）。 提供浏览器的最佳方式是.browserslistrc在您的项目根目录中添加一个文件，或者通过browserslist向您的package.json. 我们建议使用这些选项而不是将选项传递给 Autoprefixer，以便配置可以与其他工具共享，例如babel-preset-env和 Stylelint。 有关查询、浏览器名称、配置格式和默认值，请参阅Browserslist 文档。 优化的LoaderHappyPack：受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况，然而HappyLoader可以将Loader单行转换为并行 eslint-loader：通过 ESLint 检查 JavaScript 代码（This loader has been deprecated. Please use eslint-webpack-plugin） EslintWebpackPlugin：应用于webpack5的eslint 打开 webpack 文件缓存调试日志的方法tools: { webpackChain: (chain) => { chain.merge({ infrastructureLogging: { level: 'verbose', colors: true, debug: /webpack\\.cache/, } }); } } 3.pluginplugin是插件的意思，通常用于对某个现有架构进行扩展 使用： 1.通过npm安装需要的插件（但是有些插件webpack已经内置了） 2.然后在webpack.config.js中的plugins进行配置 下面举一个加入版权的插件的例子 // webpack.config.js const webpack = require('webpack'); module.exports = { // ... plugins: [ new webpack.BannerPlugin('最终版权归Hello所有') ] } HtmlWebpackPlugin真是发布项目时，发布的是dist文件夹中的内容，但是打包的时候并没有将html文件也打包进dist文件夹中， 此时我们需要用到HtmlWebpackPlugin插件，它会自动生成一个index.html文件（可以按照指定模板来生成），并且将打包后的js文件，自动通过script标签插入到body中 1.安装插件 npm install html-webpack-plugin --save-dev 2.使用插件，在webpack.config.js中使配置信息 // webpack.config.js const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { // ... plugins: [ new HtmlWebpackPlugin() ] } 此时生成的html文件的body内还没有根元素绑定Vue，我们可以给个模板，模板里有我们理想的存放好的标签，让它根据模板生成该 div元素 new HtmlWebpackPlugin({ // 寻找当前目录下的index.html, 根据这个生成模板（定义title之类的），可以参考Vue的脚手架搭建时下面放置的模板html template: './index.html', //默认将打包文件放在head，可以设置放在html的body里面 inject:'body', //如果打包多个html文件来引入不同的script包，则定义filename来区分打包输入html filename: 'index.html' }) 多入口entry通过不同的entry文件打包多个html文件 一个项目中保存了多个 HTML 模版，不同的模版有不同的入口，并且有各自的 router、store 等； 不仅可以打包出不同 HTML，而且开发的时候也可以顺利进行调试； 不同入口的文件可以引用同一份组件、图片等资源，也可以引用不同的资源； 综上所述，你可以理解为要写多个页面，但是页面之间要复用组件、函数等 plugins:[ new HtmlWebpackPlugin({ //如果打包多个html文件来引入不同的script包，则定义filename来区分打包输入html filename: 'index.html', chunks:['main'] }), new HtmlWebpackPlugin({ template: './index.html', filename: 'index2.html', chunks:['main2', 'lodash'] }) ], entry: { main: { import: \"./src/index.js\", dependOn: \"lodash\", }, main2: { import: \"./src/another-bundle.js\", dependOn: \"lodash\", }, lodash: \"lodash\", }, DefinePlugin全局变量webpack内部有一个DefinePlugin，可以直接通过以下方式进行获取，然后在webpack.config.js里面获取设置全局变量 const { DefinePlugin } = require(\"webpack\") js压缩的pluginwebpack v5 开箱即带有最新版本的 terser-webpack-plugin。如果你使用的是 webpack v5 或更高版本，同时希望自定义配置，那么仍需要安装 terser-webpack-plugin。如果使用 webpack v4，则必须安装 terser-webpack-plugin v4 的版本。 首先，你需要安装 terser-webpack-plugin： $ npm install terser-webpack-plugin --save-dev 然后将插件添加到你的 webpack 配置文件中。例如： webpack.config.js const TerserPlugin = require(\"terser-webpack-plugin\"); module.exports = { optimization: { minimize: true, minimizer: [new TerserPlugin()], }, }; 除此之外，还有其他比较有用的压缩插件 extract-text-webpack-plugin 用于将 CSS 从主应用程序中分离 optimize-css-assets-webpack-plugin 压缩提取出的css，解决extract-text-webpack-plugin CSS重复问题 CommonsChunkPlugin 将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用 MiniCssExtractPlugin 注意⚠️：仅支持webpack5以上 抽出style代码 使用style-loader 和 css-loader进行转换得到的代码，是直接放置在html中的，要想放置在另外一个文件，然后让打包后的html进行link引用，需要安装： mini-css-extract-plugin（需要webpack5以上版本） npm i mini-css-extract-plugin -D 因为style-loader是将导出的样式添加到DOM，此时假如我们使用了style-loader，需要我们 手动删除掉 const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); module.exports = { plugins: [new MiniCssExtractPlugin({ filename:'styles/[contenthash].css' //打包时自动生成styles文件夹，并且根据文件内容，生成一个hash名称的css文件存放其中 })], module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, \"css-loader\"], }, ], }, }; css压缩的plugin我们还需要先把mode改为production，并且安装了MiniCssExtractPlugin module.exports = { mode: \"production\", } 安装 npm i css-minimizer-webpack-plugin -D const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); module.exports = { module: { rules: [ { test: /.s?css$/, use: [MiniCssExtractPlugin.loader, \"css-loader\", \"sass-loader\"], }, ], }, optimization: { minimizer: [ // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`），将下一行取消注释 // `...`, new CssMinimizerPlugin(), ], }, plugins: [new MiniCssExtractPlugin()], }; 注意，如果在optimization中配置了css的压缩，则js默认的webpack自带terser插件压缩效果失效，需要同样在optimization中重新配置 首先下载terser npm i terser-webpack-plugin -D 在webpack配置项中使用 const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\"); const TerserPlugin = require(\"terser-webpack-plugin\"); module.exports = { //... optimization: { minimizer: [ // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`），将下一行取消注释 // `...`, new CssMinimizerPlugin(), new TerserPlugin(), ], }, }; 此时通过修改mode，即可看到测试环境development没压缩代码、production下代码压缩了","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"webpack(中)","slug":"webpack(中)","date":"2021-02-06T16:00:00.000Z","updated":"2023-04-17T09:27:31.293Z","comments":true,"path":"2021/02/07/webpack-zhong/","link":"","permalink":"https://taylor12138.github.io/2021/02/07/webpack-zhong/","excerpt":"","text":"4.其他webpack开发环境的开发模式1. watch模式该模式下，webpack会实时侦测我们的js文件变化，在webpack依赖图的所有文件，只要有一个发生了更新，那么代码将被重新编译 但如果使用下方搭建服务，则没必要开启这个watch模式，因为服务内置了热更新 开启方法： \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"watch\": \"webpack --watch\", \"build\": \"webpack\" }, 但是需要我们人工刷新一下浏览器 2.dev-server模式为了让webpack提供开发时服务，可以装载webpack-dev-server搭建本地服务器，它内部使用了express框架 实际上Vue、React脚手架搭建完毕后，呈现的页面都用到了这个本地服务器 npm install webpack-dev-server -D 在webpack.config.js里配置（这里有多个入口） module.exports = { mode: 'development', entry: { index: './src/index.js', print: './src/print.js', }, devtool: 'inline-source-map', + devServer: { + static: './dist', + }, plugins: [ new HtmlWebpackPlugin({ title: 'Development', }), ], output: { filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist'), clean: true, }, + optimization: { + runtimeChunk: 'single', + }, }; 因为在这个示例中单个 HTML 页面有多个入口，所以添加了 optimization.runtimeChunk: &#39;single&#39; 配置。没有这个配置的话，我们可能会遇到 这个问题。 查看 代码分割 章节获取更多细节。 从那个问题的官网中也可以看到公共依赖的实例对象，可能会被实例化多次，接而失去状态的同步，为了保持实例的共享（状态同步），需要配置optimization.runtimeChunk为&quot;single&quot;，默认情况下它是禁用的，但记录在Webpack 的代码拆分指南中。 当然你也可以配详细一点 再推荐一个copyWebpackPlugin，帮助你把资源在webpack打包的时候，也放进去 var path = require('path'); module.exports = { //... devServer: { static: path.resolve(__dirname, './dist'),//指向当前服务的物理路径 /* contentBase为：在webpack给我们打包的资源中找不到时，再去查找的地址，是一个额外的文件地址 一般用于在开发时段不想使用copyWebpackPlugin，避免打包的时候速度太慢 开发阶段：contentBase 打包阶段：copyWebpackPlugin，然后放到服务器中 */ contentBase: path.resolve(__dirname, './dist'), // inline是否实时监听 inline:true, host: 0.0.0.0, //设置地址，默认localhost compress: true, //是否开启gzip压缩资源,默认true port: 9000, //端口号设置 open: true, //自动打开浏览器 proxy: { //和React配置代理的原理相同,仅限测试环境下跨域解决方案 '/api': { target: 'http://localhost:3000', pathRewrite: { '^/api': '' }, }, '/api2': 'http://localhost:3000', }, headers: { 'X-Access-Token': 'abc123' //设置 }, https: true, //将服务器设置为https，但是需要配置一些证书 historyApiFallback: true, //一般vue、react脚手架都会配置，用于SPA时如果输入未配置的路由，可以用某个页面替代任何404的静态资源请求 devMiddleware:{ writeToDisk: true //每次启动服务的同时，也会进行打包 } } }; 此时还可以和起步配置 npm run build 一样顺便在package.json文件的script中增加 &quot;dev&quot;:&quot;webpack-dev-server&quot; / &quot;serve&quot;: &quot;webpack serve&quot; 或者是 &quot;dev&quot;:&quot;npx webpack-dev-server&quot; / &quot;serve&quot;: &quot;npx webpack serve&quot; 这时候运行起来就直接 npm run dev即可 模块热更新原理： 实际上webpack是有进行打包的，但所有的产物文件都默认不会写到磁盘，而是放到内存中，所以没做文件输出，此时我们就算删除掉dist文件，服务还是照常进行，毕竟放进了内存 3.middleware模式webpack-dev-middleware webpack-dev-middleware 是一个封装器(wrapper)，它可以把 webpack 处理过的文件发送到一个 server。webpack-dev-server 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义设置。下面是一个 webpack-dev-middleware 配合 express server 的示例。 在官网上可以继续查看使用方法，可以理解为webpack的中间件node运行模式，直接运行node webpack的resolve配置（模块解析相关）在webpack.config.js中配置，用于解析 module.exports = { //... resolve: { //默认配置好的后缀名处理,导包的时候不同添加以下后缀名，可以自动识别，当然你也可以自己添加 extensions: [\".js\", \".json\", \".mjs\"], //配置别名 alias alias: { \"js\": path.resolve(__dirname, \"./src/js\"); } } }; 生产/开发时配置文件分离开发时依赖的配置文件和发布时依赖的配置文件进行分离 新建一个config文件夹 -&gt; 新建一个 base.config.js文件 (公共的配置放在base里) 、prod.config.js文件（放置生产时的配置）和dev.config.js（放置开发时的配置） 这里还需要安装merge，用于合并公共配置和生产/开发配置 npm i webpack-merge@4.1.5 --save-dev 然后分别在prod.config.js文件 和dev.config.js 写好各自的配置 const {merge} = require('webpack-merge'); const baseConfig = require('./base.config'); // 合并导出 module.exports = merge(baseConfig, { //各自配置 }); 最后在package.json配置文件中，修改 原来运行webpack 和 运行webpack服务器的 键位 改为 ： \"build\": \"webpack --config ./config/prod.config.js\", \"dev\": \"webpack-dev-server --config ./config/dev.config.js\" --config 缩写为 -c 这里如果打包后文件出现不是在原来的目录，可以检查一下base.config.js文件的 output出口，进行修改 代码分离方式（代码分块）方式一：在entry配置多入口 注意：在导入多个入口文件之后，输出文件的filename则不能固定死，毕竟是生成了多个打包文件 module.exports = { entry: { index: \"./src/index.js\", another: \"./src/another-bundle.js\", }, output: { path: path.join(__dirname, \"dist\"), filename: \"[name].bundle.js\",, //让输出的文件根据自己本身entry的key命名 }, } 打包之后我们可以看到有 index.bundle.js、another-bundle.bundle.js两个打包文件出来 缺点：通用的包如果使用了之后，都会分别打到chunk里面，造成代码重复+大量(重复打包问题) 方式二：防止重复 仍需要在entry进行配置，但是相对于第一种可以把公共代码抽离成chunk module.exports = { entry: { index: { import: \"./src/index.js\", dependOn: \"shared\", }, another: { import: \"./src/another-bundle.js\", dependOn: \"shared\", }, shared: \"lodash\", //当两个模块中有lodash时，就会自动抽离出来，并且取名shared这个chunk }, output: { path: path.join(__dirname, \"dist\"), filename: \"[name].bundle.js\", }, optimization: { runtimeChunk: 'single', }, } 此时会多打包一个 shared.bundle.js文件放置公共代码 其他关于 optimization: {runtimeChunk: &#39;single&#39;}的好处 可以在 dev-server模式 、runtimeChunk优化中查看 其实还有一个webpack的内置插件，也是类似的防止重复功能 split-chunks-Plugin 这个插件也可以将我们模块依赖的公共代码抽离成单独的chunks（自动抽离公共代码，good！） module.exports = { entry: { index: \"./src/index.js\", another: \"./src/another-bundle.js\", }, output: { path: path.join(__dirname, \"dist\"), filename: \"[name].bundle.js\", //让输出的文件根据自己本身entry的key命名 }, optimization: { splitChunks: { chunks: \"all\", }, }, } 此方法对于有动态导入需求，也同样适用防止重复地进行代码抽离，然后打包（动态导入即下方的懒加载导入） 懒加载export const add = (x, y) => { return x + y; }; export const minus = (x, y) => { return x - y; }; const button = document.createElement(\"button\"); button.textContent = \"点击执行加法运算\"; button.addEventListener(\"click\", () => { import(\"./async-math\").then(({ add }) => { console.log(add(4, 5)); }); }); document.body.appendChild(button) 以上是在技术概念上“懒加载”它。问题是加载这个包并不需要用户的交互 - 意思是每次加载页面的时候都会请求它。这样做并没有对我们有很多帮助，还会对性能产生负面影响。 我们试试不同的做法。我们增加一个交互，当用户点击按钮的时候用 console 打印一些文字。但是会等到第一次交互的时候再加载那个代码块（print.js） project webpack-demo |- package.json |- package-lock.json |- webpack.config.js |- /dist |- /src |- index.js + |- print.js |- /node_modules src/print.js console.log( 'The print.js module has loaded! See the network tab in dev tools...' ); export default () => { console.log('Button Clicked: Here\\'s \"some text\"!'); }; src/index.js + import _ from 'lodash'; + - async function getComponent() { + function component() { const element = document.createElement('div'); - const _ = await import(/* webpackChunkName: \"lodash\" */ 'lodash'); + const button = document.createElement('button'); + const br = document.createElement('br'); + button.innerHTML = 'Click me and look at the console!'; element.innerHTML = _.join(['Hello', 'webpack'], ' '); + element.appendChild(br); + element.appendChild(button); + + // Note that because a network request is involved, some indication + // of loading would need to be shown in a production-level site/app. + button.onclick = e => import(/* webpackChunkName: \"print\" */ './print').then(module => { + const print = module.default; + + print(); + }); return element; } - getComponent().then(component => { - document.body.appendChild(component); - }); + document.body.appendChild(component()); Warning注意当调用 ES6 模块的 import() 方法（引入模块）时，必须指向模块的 .default 值，因为它才是 promise 被处理后返回的实际的 module 对象。 异步加载的原理： import(chunkId) =&gt; __webpack_require__.e(chunkId) 将相关的请求回调存入 installedChunks。 // import(chunkId) => __webpack_require__.e(chunkId) __webpack_require__.e = function(chunkId) { return new Promise((resolve, reject) => { var script = document.createElement('script'); script.src = jsonpScriptSrc(chunkId); var onScriptComplete = function(event) { // ... }; var timeout = setTimeout(function() { onScriptComplete({ type: 'timeout', target: script }); }, 120000); script.onerror = script.onload = onScriptComplete; document.head.appendChild(script); }); }; 预获取使用预获取导入js文件时，会在html地head上多一个新的link，叫做rel prefetch 他对比懒加载的意义在于 懒加载是：用到 -&gt; 加载预获取是：网络空闲 - &gt; 加载 在webpack中使用：（使用上方的一个button例子进行示范, webpackChunkName用于自定义webpack动态导入的包名） const button = document.createElement(\"button\"); button.textContent = \"点击执行加法运算\"; button.addEventListener(\"click\", () => { import(/*webpackChunkName: 'math', webpackPrefetch: true*/ \"./async-math\").then(({ add }) => { console.log(add(4, 5)); }); }); document.body.appendChild(button) 外部扩展(Externals)externals 配置选项提供了「从输出的 bundle 中排除依赖」的方法 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。 例如，从 CDN 引入 jQuery，而不是把它打包： index.html（打包的模板html要进行配置） &lt;script src=\"https://code.jquery.com/jquery-3.1.0.js\" integrity=\"sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=\" crossorigin=\"anonymous\" >&lt;/script> webpack.config.js module.exports = { //... //key的名字要和包名一致 externals: { jquery: 'jQuery', }, }; 这样就剥离了那些不需要改动的依赖模块，换句话，下面展示的代码还可以正常运行： import $ from 'jquery'; $('.my-element').animate(/* ... */); 亦或者这样配置 module.exports = { //... externalsType: 'script', externals: { jquery: [ 'https://code.jquery.com/jquery-3.1.0.js', 'jQuery' ], }, }; 缓存产生的问题问题所在如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。 我们可以通过替换 output.filename 中的 substitutions 设置，来定义输出文件的名称。webpack 提供了一种使用称为 substitution(可替换模板字符串) 的方式，通过带括号字符串来模板化文件名。其中，[contenthash] substitution 将根据资源内容创建出唯一 hash。当资源内容发生变化时，[contenthash] 也会发生变化。 //webpack.config.js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: './src/index.js', plugins: [ new HtmlWebpackPlugin({ title: 'Caching', }), ], output: { -- filename: 'bundle.js', ++ filename: '[name].[contenthash].js', path: path.resolve(__dirname, 'dist'), clean: true, }, }; 使用此配置，然后运行我们的 build script npm run build，产生以下输出： ... Asset Size Chunks Chunk Names main.7e2c49a622975ebd9b7e.js 544 kB 0 [emitted] [big] main index.html 197 bytes [emitted] ... 可以看到，bundle 的名称是它内容（通过 hash）的映射。如果我们不做修改，然后再次运行构建，我们以为文件名会保持不变。 然而!!!!!!!，如果我们真的运行，可能会发现情况并非如此： ... Asset Size Chunks Chunk Names main.205199ab45963f6a62ec.js 544 kB 0 [emitted] [big] main index.html 197 bytes [emitted] ... 这也是因为 webpack 在入口 chunk 中，包含了某些 boilerplate(引导模板)，特别是 runtime 和 manifest。 runtimeChunk优化正如我们在 代码分离 中所学到的，SplitChunksPlugin 可以用于将模块分离到单独的 bundle 中。webpack 还提供了一个优化功能，可使用 optimization.runtimeChunk 选项 将 runtime 代码拆分为一个单独的 chunk。将其设置为 single 来为所有 chunk 创建一个 runtime bundle： webpack.config.js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: './src/index.js', plugins: [ new HtmlWebpackPlugin({ title: 'Caching', }), ], output: { filename: '[name].[contenthash].js', path: path.resolve(__dirname, 'dist'), clean: true, }, + optimization: { + runtimeChunk: 'single', + }, }; 再次构建，然后查看提取出来的 runtime bundle： Hash: 82c9c385607b2150fab2 Version: webpack 4.12.0 Time: 3027ms Asset Size Chunks Chunk Names runtime.cc17ae2a94ec771e9221.js 1.42 KiB 0 [emitted] runtime main.e81de2cf758ada72f306.js 69.5 KiB 1 [emitted] main index.html 275 bytes [emitted] [1] (webpack)/buildin/module.js 497 bytes {1} [built] [2] (webpack)/buildin/global.js 489 bytes {1} [built] [3] ./src/index.js 309 bytes {1} [built] + 1 hidden module 将第三方库(library)（例如 lodash 或 react）提取到单独的 vendor chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用 client 的长效缓存机制，命中缓存来消除请求，并减少向 server 获取资源，同时还能保证 client 代码和 server 代码版本一致。 这可以通过使用 SplitChunksPlugin 示例 2 中演示的 SplitChunksPlugin 插件的 cacheGroups 选项来实现。我们在 optimization.splitChunks 添加如下 cacheGroups 参数并构建： webpack.config.js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: './src/index.js', plugins: [ new HtmlWebpackPlugin({ title: 'Caching', }), ], output: { filename: '[name].[contenthash].js', path: path.resolve(__dirname, 'dist'), clean: true, }, optimization: { runtimeChunk: 'single', + splitChunks: { + cacheGroups: { + vendor: { + test: /[\\\\/]node_modules[\\\\/]/, + name: 'vendors', + chunks: 'all', + }, + }, + }, }, }; 再次构建，然后查看新的 vendor bundle： ... Asset Size Chunks Chunk Names runtime.cc17ae2a94ec771e9221.js 1.42 KiB 0 [emitted] runtime vendors.a42c3ca0d742766d7a28.js 69.4 KiB 1 [emitted] vendors main.abf44fedb7d11d4312d7.js 240 bytes 2 [emitted] main index.html 353 bytes [emitted] ... 现在，我们可以看到 main 不再含有来自 node_modules 目录的 vendor 代码，并且体积减少到 240 bytes！ 模块标识符(module identifier)在项目中再添加一个模块 print.js： project webpack-demo |- package.json |- package-lock.json |- webpack.config.js |- /dist |- /src |- index.js + |- print.js |- /node_modules print.js + export default function print(text) { + console.log(text); + }; src/index.js import _ from 'lodash'; + import Print from './print'; function component() { const element = document.createElement('div'); // lodash 是由当前 script 脚本 import 进来的 element.innerHTML = _.join(['Hello', 'webpack'], ' '); + element.onclick = Print.bind(null, 'Hello webpack!'); return element; } document.body.appendChild(component()); 再次运行构建，然后我们期望的是，只有 main bundle 的 hash 发生变化，然而…… ... Asset Size Chunks Chunk Names runtime.1400d5af64fc1b7b3a45.js 5.85 kB 0 [emitted] runtime vendor.a7561fb0e9a071baadb9.js 541 kB 1 [emitted] [big] vendor main.b746e3eb72875af2caa9.js 1.22 kB 2 [emitted] main index.html 352 bytes [emitted] ... ……我们可以看到这三个文件的 hash 都变化了。这是因为每个 module.id 会默认地基于解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变。简要概括： main bundle 会随着自身的新增内容的修改，而发生变化。 vendor bundle 会随着自身的 module.id 的变化，而发生变化。 manifest runtime 会因为现在包含一个新模块的引用，而发生变化。 第一个和最后一个都是符合预期的行为，vendor hash 发生变化是我们要修复的。我们将 optimization.moduleIds 设置为 &#39;deterministic&#39;： webpack.config.js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: './src/index.js', plugins: [ new HtmlWebpackPlugin({ title: 'Caching', }), ], output: { filename: '[name].[contenthash].js', path: path.resolve(__dirname, 'dist'), clean: true, }, optimization: { + moduleIds: 'deterministic', runtimeChunk: 'single', splitChunks: { cacheGroups: { vendor: { test: /[\\\\/]node_modules[\\\\/]/, name: 'vendors', chunks: 'all', }, }, }, }, }; 现在，不论是否添加任何新的本地依赖，对于前后两次构建，vendor hash 都应该保持一致： ... Asset Size Chunks Chunk Names main.216e852f60c8829c2289.js 340 bytes 0 [emitted] main vendors.55e79e5927a639d21a1b.js 69.5 KiB 1 [emitted] vendors runtime.725a1a51ede5ae0cfde0.js 1.42 KiB 2 [emitted] runtime index.html 353 bytes [emitted] Entrypoint main = runtime.725a1a51ede5ae0cfde0.js vendors.55e79e5927a639d21a1b.js main.216e852f60c8829c2289.js ... 然后，修改 src/index.js，临时移除额外的依赖： src/index.js import _ from 'lodash'; - import Print from './print'; + // import Print from './print'; function component() { const element = document.createElement('div'); // lodash 是由当前 script 脚本 import 进来的 element.innerHTML = _.join(['Hello', 'webpack'], ' '); - element.onclick = Print.bind(null, 'Hello webpack!'); + // element.onclick = Print.bind(null, 'Hello webpack!'); return element; } document.body.appendChild(component()); 最后，再次运行我们的构建： ... Asset Size Chunks Chunk Names main.ad717f2466ce655fff5c.js 274 bytes 0 [emitted] main vendors.55e79e5927a639d21a1b.js 69.5 KiB 1 [emitted] vendors runtime.725a1a51ede5ae0cfde0.js 1.42 KiB 2 [emitted] runtime index.html 353 bytes [emitted] Entrypoint main = runtime.725a1a51ede5ae0cfde0.js vendors.55e79e5927a639d21a1b.js main.ad717f2466ce655fff5c.js ... 我们可以看到，这两次构建中，vendor bundle 文件名称，都是 55e79e5927a639d21a1b。 提高解析速度解析 以下步骤可以提高解析速度： 减少 resolve.modules, resolve.extensions, resolve.mainFiles, resolve.descriptionFiles 中条目数量，因为他们会增加文件系统调用的次数。 如果你不使用 symlinks（例如 npm link 或者 yarn link），可以设置 resolve.symlinks: false。 如果你使用自定义 resolve plugin 规则，并且没有指定 context 上下文，可以设置 resolve.cacheWithContext: false。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Vue(上)","slug":"Vue(上)","date":"2021-01-31T16:00:00.000Z","updated":"2022-07-06T16:46:01.071Z","comments":true,"path":"2021/02/01/vue-shang/","link":"","permalink":"https://taylor12138.github.io/2021/02/01/vue-shang/","excerpt":"","text":"1.邂逅VUEvue是一个渐进式框架，这意味着可以作为你应用的一部分嵌入其中，对项目一点点进行重构，响应式：界面随着数据随时发生改变 以前JS原始编写的方法：命令式编程； Vue编写方法：声明式编程 vue全家桶：Core + Vue-router + Vuex Vue特点： 解耦视图和数据 可复用组件 前端路由技术 状态管理 虚拟DOM 引入vue $ npm install vue 体验： &lt;div id=\"app\"> &lt;ul> &lt;li v-for='item in message'>{{item}}&lt;/li> &lt;/ul> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { message: ['i', 'wanna', 'be', 'with', 'you'] } }) &lt;/script> Vue和MVVM前提请记住：在官方文档中写道，虽然Vue并没有完全遵循MVVM模型，但是Vue的设计也受到了它的启发，因此在文档中经常会使用VM这个变量名表示Vue的实例。 Vue可以通过ref可以拿到dom对象，通过ref直接去操作视图。这一点上，违背了MVVM。 MVVM 模式顾名思义即 Model-View-ViewModel 模式，最标志性的特性就是 数据绑定 ，操作数据 = 操作视图，操作DOM 以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。 Model 层: 仅仅关注数据本身，对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步 View 层:作为视图模板存在（template）， 数据绑定的声明、 指令的声明、 事件绑定的声明。 ViewModel 层（vue）:把 View 需要的数据暴露，并为 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责 VM（Virtual DOM）除了提高性能，最大的优势还是在于： 将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。 同样的，通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。 实现组件的高度抽象化 MVVM是MVC的改进版，MVC中的M就是单纯的从网络获取回来的数据模型，V指的我们的视图界面，而C就是我们的ViewController。 MVC的通信方式时单向的，view -&gt; controller -&gt; model -&gt; view 控制器（Controller）- 控制器是模型和视图之间的纽带，接收View传来的用户事件并且传递给Model，同时利用从Model传来的最新模型控制更新View. ViewModel充当了一个UI适配器的角色，也就是说View中每个UI元素都应该在ViewModel找到与之对应的属性。除此之外，从Controller抽离出来的与UI有关的逻辑都放在了ViewModel中，这样就减轻了Controller的负担。 MVC缺点： 不适合小、中型项目 增加结构、实现复杂性 视图（view）和控制器（controller）过于紧密的连接 视图（view）对模式数据的低效访问 一般的高级界面工具或构造器不支持该模式 face的Flux架构就有点像MVC，可以参考一下千锋教育老师的图（redux只是flux的其中一种实现方式） 2.基础语法Vue对象传入的option： el：决定Vue对象挂载在哪个元素上 data：存储数据，类型为对象或者函数 methods: 用于在Vue对象中定义方法 在官网中还有一些其他的option 在开发中在对象/类里面定义的叫方法（method），独立出来作用全局的称为函数（function） 双括号语法被称之为mustache语法，八字胡 &lt;!-- item和message分别为data中的字符串 --> &lt;li>{{item + '' + message}}，hello&lt;/li> &lt;!-- counter为data中的数字 --> &lt;li>{{counter * 2}}&lt;/li> &lt;!-- 得到getNumber函数返回值 --> &lt;li>{{getNumber()}}&lt;/li> Vue的生命周期在创建Vue对象的时候，内部会一步一步做出一系列复杂的事情/操作，而在做每一系列事情的过程当中，如果中间穿插 created、mounted、updated、destroyed等生命周期钩子函数它会指示你（它会内部自动执行，不需要手动调用），目前做到事情的哪一步。 生命周期，更聪明的排序 而当软件体积不断增大时，代码逻辑可能会像高速公路上的车辆一样，如果毫无秩序，每一辆车都想以最快的速度通过，反而会导致所有车辆停滞不前，造成拥堵。 拆分生命周期的一个重要目的就是将这些核心功能的优先级进行排序，黄金原则就是尽可能快的让用户最关心的界面先渲染出来 生命周期就是一个对象（如vue)从声明到使用到销毁的各个阶段，为了开发方便框架会在每个阶段的节点上定义一个特定函数，这个特定函数就是生命周期函数，也叫钩子函数 官网附有生命周期示意图 还有keep-alive独有的 activated 和 deactivated created -&gt; mounted -&gt; activated 父子组件生命周期 父 beforeCreate - &gt; 父 created -&gt;父 beforeMount -&gt;子 beforeCreate-&gt; 子 created-&gt; 子 beforeMount-&gt; 子 mounted-&gt; 父 mounted 父组件更新：父 beforeUpdate-&gt; 父 updated 子组件更新：父 beforeUpdate-&gt;子beforeUpdate -&gt; 子 updated -&gt;父updated 组件的调用 先父后子，渲染完成顺序先子后父 组件销毁 先父后子，销毁完成 先子后父 即便如此，官网提示你：注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick 关于 destory：在大多数场景中你不应该调用这个方法。最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期。 V-指令v-once 只会在第一次渲染数据，随后数据发生改变，元素内的数据不会再发生改变，阻止了响应式，可以添加在标签属性上 &lt;h2 v-once>{{message}}&lt;/h2> v-html 类似于JS原生里的innerHTML，可以添加在标签属性上 &lt;h2 v-html=\"数据名称\">&lt;/h2> v-pre 进行原封不动的解析，可以添加在标签属性上 &lt;!-- 页面得到结果{{message}} --> &lt;h2 v-pre>{{message}}&lt;/h2>` v-cloak 为了防止用户加载页面时，加载JavaScript卡住，导致页面显示源码 ‘‘ ，添加 &lt;h2 v-cloak>{{message}}&lt;/h2> 等到Vue对该元素进行解析渲染，页面中才会显示该元素（原理使用了display: none） v-bind 使用{{值}}可以将Vue的数据插入元素内容中，但是如果想让Vue的数据动态绑定元素标签属性中的值（比如img的src，a标签的href）,可以使用v-bind。v-bind还有一个对应的语法糖 :（简写方式），方式如下 &lt;a v-bind:href=\"bdurl\">baidu&lt;/a> &lt;a :href=\"bdurl\">baidu&lt;/a> 如果使用别人写好的组件，传入批量的props时（子组件中的props对象的每个属性都声明好了），直接写一个对象，然后 v-bind=&quot;对象名&quot;即可 与此同时v-bind也可以动态绑定class属性值，但是它动态绑定class属性的重大意义在于可以写入对象，以键-值的形式，通过布尔值修改，来动态修改元素是否使用该类（在标签上还可以再自定义添加上自带的class，不参与动态绑定变化） 其实动态绑定class还可以采用数组语法，只不过目前用的比较少了 &lt;div id=\"app\"> &lt;ul> &lt;li v-for=\"(item, index) in movies\" @click=\"colorch(index)\" :class=\"{active: index === iscolor}\">{{item}}&lt;/li> &lt;/ul> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { movies: ['batman', 'superman', 'spiderman'], iscolor: -1 }, methods: { colorch: function (index) { this.iscolor = index; } } }) v-bind还能动态绑定元素style样式的某个的单个属性，但是添加的时候注意，vue的语法中最好采用驼峰命名法，而且属性值外加单引号&#39;&#39; &lt;h2 :style=\"{fontSize: '100px'}\">{{message}}&lt;/h2> 注意，绑定属性名的时候，不能用驼峰命名法，可能html不能正确识别，如果要用的话，则属性名要发生改动：:topImages -&gt;改成-&gt; :top-images=&quot;xxx&quot; 在以对向形式绑定类名时，不能用 -，驼峰命名也不能奏效，可以使用 &lt;div :class=\" { 'tip': item.type === 3, 'my-msg': item.type === 1, 'other-msg': item.type === 2, }\" > 除此之外，连属性名也可以动态决定，只需要加一个中括号即可 &lt;div id=\"app\"> &lt;/div> &lt;template id=\"my-app\"> &lt;div :[name]=\"active\">hello&lt;/div> &lt;/template> &lt;script> const app = new Vue({ template: '#my-app', data() { return { name: 'hello', active: 'act' } } }).$mount(\"#app\") &lt;/script> 若要传入多个动态属性，直接给 v-bind赋值即可 &lt;template id=\"my-app\"> &lt;div v-bind=\"info\">hello&lt;/div> &lt;!-- &lt;div name=\"allen\" age=12>hello&lt;/div> --> &lt;/template> &lt;script> const app = new Vue({ template: '#my-app', data() { return { info: { name: 'allen', age: 12 } } } }).$mount(\"#app\") computed计算属性Vue对象的option之一,当成属性去使用，不用加()进行函数调用，计算属性不像methods会被多次调用，它只会被调用一次（因此效率相对于methods更高），内部对计算属性做了缓存（有点React的useMemo内味了~） &lt;div id=\"app\"> &lt;h2>{{fullname}}&lt;/h2> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { firstname: 'Lebron', lastname: 'James' }, computed: { fullname: function () { //fullname() {} 也可以 return this.firstname + ' ' + this.lastname; } } }) &lt;/script> 实际上计算属性一般只使用了它本身的get方法，而它的完整写法为： fullname: { set: function () { //一般情况下，我们不希望计算属性使用set方法,这样的话它就变成了一个只读属性 }, get:function() { return this.firstname + '' + this.lastname; } } Computed 默认调用的是get方法 不能传参，想要传递参数得用set设置好，再用get取 watch属性watch也是属于组件中的属性（和data，props，methods等并列），对应一个对象类型，里面存放函数方法，这些函数适用于监听某些data中属性的改变。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 函数命名方式：data中的属性名(改变后的值[, 改变前的值]){} watch:{ // 监听data中message的改变 message(){ console.log(\"hello\"); } //相当于message:function(){console.log(\"hello\")} //亦或者是拿到新旧的值 //message(newVal, oldVal) {} } 除了传入函数外，其实watch里面传的是键值对，值除了函数还可以包含两个参数 immediate：组件加载（首次渲染完成）立即触发回调函数执行， deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用（内部实际上是通过递归取值，然后进行逐个监听），而computed不需要deep，是因为它是从模板双括号取值，即使用JSON.stringfy()把对象的值一次性取出来 因为是递归，比较耗性能，尽量不要采用 但是deep有个bug，传入newVal、oldVal参数的时候，如果是内部的属性值发生改变，使得oldVal和newVal仍然是指向同一个地址，此时oldVal === newVal。 当然，官方也做过说明 注意：当变更（不是替换）对象或数组并使用 deep 选项时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变更之前值的副本。 watch: { message: { //使用deep、immediate参数时，对应的函数名必须为handler handler(newVal, oldVal) { console.log(oldVal) console.log(newVal) }, deep: true immediate: true } } 甚至watch还有vm.$watch的用法 data(){ return { info: { name: \"allen\" } } } //在create生命周期中 created(){ const unwatch = this.$watch(\"info\", function(newVal, oldVal) { console.log(newVal, oldVal); }, { deep: true, immediate: true }) } computed和watch computed： 支持缓存，只有依赖数据发生改变时才会重新计算 不支持异步，当computed内有异步操作时无效，无法监听数据的变化 如果一个属性是由其他属性计算而来的，且一对一或者多对一，则一般用computed watch： 不支持缓存，数据变化则会直接触发相应操作 支持异步 监听的函数接收两个参数，第一个参数是最新的值（newValue）；第二个参数是输入之前的值（oldValue） 可以监听具体到数据的某个属性（对象） 缓存实现原理：new watcher -&gt; 这里有个dirty属性，默认为true - &gt; 求值计算，然后dirty = false -&gt; 当依赖数据再次发生改变时 dirty = true 事件监听v-on 绑定事件监听器，缩写（语法糖）为 @ ，类似于jQuery的 on 事件处理，绑定多个事件可以使用对象的形式 &lt;button @click=\"increment\">+&lt;/button> &lt;button v-on=\"{click: btnClick, mousemove: mouseMove}\">-&lt;/button> 正常情况下，函数如果需要传递参数，然而你没有传递，则函数形参为undefined v-on参数问题： 如果该方法不需要传递参数，则方法后面的()可以不用添加 但是如果方法本身是需要一个参数的，但是传进来的时候没有加 ()，（如@click=”decrement”），则Vue会将浏览器中生成的事件对象Event作为参数，传入方法中 方法定义时，我们需要event对象，同时又需要其他参数时，在html标签内的方法括号中只添加参数 + $event &lt;button @click=\"cclick(123, $event)\">call&lt;/button> methods: { cclick(number, event) { console.log(number, event); } } v-on修饰符 @事件名.stop阻止事件冒泡：相当于原生的e.stopPropagation() &lt;div @click=\"cclick\"> &lt;button @click.stop=\"cclick\">call&lt;/button> &lt;/div> @事件名.prevent阻止默认事件 =&gt; 相当于原生的 e.preventDefault(); @事件名.{keyCode | ketAlias} 从键盘特定键位触发回调（ @keyup.enter=&quot;xxx&quot; ） @事件名.native 监听根元素原生事件（在组件中使用） &lt;Compon_test @click=&quot;() =&gt; {}&quot;&gt;&lt;Compon_test&gt; =&gt; Compon_test.$on(&#39;click&#39;, () =&gt; {}) Compon_test.$emit(&#39;click&#39;) &lt;Compon_test @click.native=&quot;() =&gt; {}&quot;&gt;&lt;Compon_test&gt; =&gt; Compon_test.addEventListener @事件名.once 只触发一次回调 条件判断 + 循环遍历v-if=&quot;布尔值(或vue对象中存储的变量)&quot;来决定元素标签是否显示出来 v-if 可以搭配 v-else 来决定显示哪一些元素标签 &lt;h2 v-if=\"score>=90\">优秀&lt;/h2> &lt;h2 v-else-if=\"socre>=80\">良好&lt;/h2> &lt;h2 v-else-if=\"socre>=60\">及格&lt;/h2> &lt;h2 v-else>不及格&lt;/h2> v-show决定一个元素是否渲染出来（用法和 v-if相似），只是 v-show控制结点的display，而v-if是删除/创建节点 当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。 有时候我们并不想为了使用 v-if不得不在外层包裹一层div，但是我们可能并不像在结构上发生更改，我们可以使用 template来替代，有种类似于React中 Fragment 或者 &lt;&gt;空标签的效果 v-for也支持 template外层嵌套 但是 v-show 并不支持 template v-for遍历数组/对象 遍历过程额外获取数组索引值使用 v-for=&quot;(item, index) in 数组名&quot; 遍历过程额外获取对象属性名使用 v-for=&quot;(value, key) in info&quot; （如果只有value,，则遍历对象每个属性的属性值） 遍历过程额外获取对象属性名，数组索引值使用 &quot;(value, key, index) in info&quot; （如果只有value,，则遍历对象每个属性的属性值） &lt;ul> &lt;li v-for=\"item in strs\">{{item}}&lt;/li> &lt;li v-for=\"(item, index) in strs\">{{index}}.{{item}}&lt;/li> &lt;li v-for=\"value in info\">{{value}}&lt;/li> &lt;li v-for=\"(value, key) in info\">{{key}}:{{value}}&lt;/li> &lt;li v-for=\"(value, key, index) in info\">{{index}}.{{key}}:{{value}}&lt;/li> &lt;/ul> 你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法： &lt;div v-for=\"item of items\">&lt;/div> 官方推荐我们使用 v-for的时候，给元素或组件添加上 key属性（能更好的复用，提高增删时的性能，高效更新虚拟DOM），并且此时key属性绑定为item或者 item.id 比较好，能形成一一对应（也可以是item对象中的id）。这时候就可以唯一标识元素或组件，用diff算法正确识别节点，找到正确位置插入/删除节点。 如果key用index，是不可以的，因为index，即下标，会随着DOM元素的位置而改变，导致key = “index”，加了和没加一样！！ 如果item不是字符串、数字之类的，也不推荐使用 原因：没有key会像操作顺序表（或者数组）一样操作改变位置及之后所有数据，有key就会像链表一样断链后链接，只进行一次操作 &lt;li v-for=\"item in strs\" :key=\"item\">{{item}}&lt;/li> v-for and v-if 由于v-for的优先级是大于v-if的，当 v-for遍历出来后再每次都v-if进行判断比较消耗性能， 所以建议把v-if放在外层（比如直接放在template模板上） 哪些数组的方法是响应式的： 和对象不同的是，有些数组方法使用后Vue的页面不会及时响应 实际上这个响应式最好记的就是数组方法 看他是否真的改变原数组，而不是返回一个新数组（或者通过官方文档查看它是否为被包裹过的方法） // 1.push this.arr.push('David'); // 2.pop 删除数组中最后一个元素 this.arr.pop(); //3.shift 删除数组第一个元素 this.arr.shift(); //4.unshift 数组最前面添加元素 this.arr.unshift('David', 'Eason'); // 5.splice 用于删除多组元素且添加数据 // splice(开始位置, 删除个数, ...要添加的元素) this.arr.splice(1, 0, 'David'); // 6.sort this.arr.sort(); // 7.reverse this.arr.reverse(); 通过索引值修改数组元素并不会向页面及时响应结果： //修改对象用splice或者 Vue.set(修改对象, 索引值, 修改后的值) this.arr[0] = 'nothing'; Methods注意事项 注意 不应该使用箭头函数来定义method函数（例如plus: () =&gt; this.a++）。理由是箭头函数 绑定了父级作用域的上下文，所以this将不会按照期望指向组件实例，this将会是父级的作用域（可能是window），this.a将会是undefined 这里和React是相反的，React就是要使用箭头函数来绑定组件实例； 而Vue用普通函数，而Vue并没有像React一样创建自己的内部作用域（类or函数），所以此时箭头函数却向上查找，绑定了父级作用域（在Vue3.x内部实质上是使用 bind绑定 instance.proxy ）！可以理解为以下的例子 var a = 1; var foo = { a: 2, bar: function () { return this.a; } bad: () => { return this.a //箭头函数导致this永远绑定了父级作用域window } }; 过滤器filtersVue对象的option之一,当成属性去使用，调用需要在元素标签中添加 {{传入的参数 | 过滤器函数名}}可以把过滤器简单理解为一种格式化，比如时间，数字等等；它的实际效果和methods调用函数方法也差不多，只是编写样式更易懂、简洁 &lt;td>{{book.price | Price_str}}&lt;/td> 过滤器里面一般存函数，参数为过滤的数据 //toFixed为保留两位小数 filters: { Price_str(price) { return '$' + price.toFixed(2); } } V-modelv-model也常常被用来实现表单（input、checkbox、select、textarea）和数据的双向绑定 v-model如果用在普通div上，只能用来作数据绑定功能（无事件功能、实际上div不支持 v-model，但是组件就可以 ） &lt;input type=\"text\" v-model=\"message\"> {{message}} //在Vue对象中的data data: { message: 'nothing' } 利用 v-model实现单选框互绑 &lt;!-- 添加v-model之后，radio的input不需要加name属性来互斥radio（单选框） --> &lt;label for=\"male\"> &lt;input type=\"radio\" id=\"male\" value=\"male\" v-model=\"sex\">男♂ &lt;/label> &lt;label for=\"female\"> &lt;input type=\"radio\" id=\"female\" value=\"female\" v-model=\"sex\">女♀ &lt;/label> &lt;h2>你选择的性别是：{{sex}}&lt;/h2> v-model其实是是一个语法糖，两个指令的结合 v-bind绑定data数据 + v-on绑定input事件改变data数据 &lt;input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\"> &lt;h2> {{message}}&lt;/h2> 如果是要再多选框checkbox、选项select、单选radio的时候使用 v-model需要在input上赋予value值（hobbies是一个数组） &lt;div>你的爱好：&lt;/div> &lt;label for=\"basketball\"> basketball &lt;input type=\"checkbox\" id=\"basketball\" v-model=\"hobbies\" value=\"basketball\"> &lt;/label> &lt;label for=\"tennis\"> tennis &lt;input type=\"checkbox\" id=\"tennis\" v-model=\"hobbies\" value=\"tennis\"> &lt;/label> &lt;label for=\"soccer\"> soccer &lt;input type=\"checkbox\" id=\"soccer\" v-model=\"hobbies\" value=\"soccer\"> &lt;/label> &lt;h2>{{hobbies}}&lt;/h2> v-model还有修饰符 lazy、number、trim &lt;!-- 修饰符lazy 使用之后使得input事件变得类似于change事件，等到用户输入完字符，敲回车/失去焦点才会修改数据 --> &lt;!-- &lt;input type=\"text\" @change=\"message = $event.target.value\"> --> &lt;input type=\"text\" v-model.lazy=\"message\"> &lt;!-- 修饰符number v-model默认给data赋值时，都是赋值为string类型，增加number修饰符可改变v-model赋值类型--> &lt;input type=\"text\" v-model.number=\"age\"> &lt;!-- 修饰符trim，v-model默认给data赋值时剥除两边空格 --> &lt;input type=\"text\" v-model.trim=\"name\"> 由于默认 v-model是 data数据 + input事件，我们可以在源码上自定义 v-model 自定义组件上使用 自定义 v-model ： &lt;el-checkbox v-model=\"check\">&lt;/el-checkbox> //全局注册组件 Vue.component('el-checkbox', { template:`&lt;input type=\"checkbox\" :checked=\"check\" @change=\"$emit('change', $event.target.checked)>\"` //model属性,服务于v-model model:{ prop:'check', //更改默认value名字 event:'change' //更改默认方法名,input事件改为change事件 }, props:{ check:Boolean } }) 原生标签上使用自定义 v-model const VueTemplateCompiler = require('vue-template-compiler'); const ele = VueTemplateCompiler.compiler('&lt;input v-model=\"value\"/>'); /** with(this) { return _c('input', { //_c createElement directives:[{ //directives是对输入框的配置 name:\"model\", rawName:\"v-model\" vale:(value), expression:\"value\" }], domProps:{ \"value\":(value) //这里value是默认，可以自定义为check }, on:{ \"input\":function($event) { //这里的默认input可以自定义为change if($event.target.composing) return; value = $event.target.value } } }) } **/ el和template同时有el和template，则将template里的模板，直接把el绑定的元素替换掉 name属性给每个组件最好加上一个name属性，很多功能的匹配都是依赖这个name，比如内置组件keep-alive的include属性匹配就是首先检查组件的name选项 name: 组件名 官方介绍 类型：string 详情： 允许组件模板递归地调用自身。注意，组件在全局用 app.component 注册时，全局 ID 自动作为组件的 name。 指定 name 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 vue-devtools，未命名组件将显示成 &lt;AnonymousComponent&gt;，这很没有语义。通过提供 name 选项，可以获得更有语义信息的组件树。 3.组件化开发组件化开发思想即把页面拆分成一个个小的功能块，每个功能完成属于自己那部分的独立功能，分而治之 组件使用三个步骤 创建组件构造器 Vue.extend()，通常我们在创建组件构造器时会传入template作为自定义模板 注册组件 Vue.component(自定义组件标签名, 组件构造器对象) 注意：定义的标签必须小写 使用组件 必须在Vue的实例范围内使用组件，即使用该组件时，必须把标签放在Vue绑定的标签内 最终内部调用 $mount()进行挂载 实际上可以把组件构造器对象看成一个类，使用的过程看成创建一个实例，在哪个组件中使用了即在哪个组件中创建了一个实例 &lt;div id=\"app\"> &lt;!-- 3.使用组件 --> &lt;!-- 比如这里绑定了id为app的块元素，则该自定义标签可以在该块内使用 --> &lt;my-cpn> &lt;/my-cpn> &lt;/div> &lt;script> // 1.创建组件构造器对象 const cpnConstructor = Vue.extend({ // 模板 template: `&lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div>` }); // 2.注册组件 // 严重注意：定义的标签必须小写 Vue.component('my-cpn', cpnConstructor); const app = new Vue({el: '#app'}); &lt;/script> 注意：在父组件中使用子组件不能使用 v-on 监听原生事件，必须添加 native修饰符，才能进行监听 &lt;div> &lt;back-top @click.native=\"backClick\">&lt;/back-top> &lt;/div> 获取组件内的元素，需要用到 $el，所有组件都有一个元素 $el 用于获取组件中的元素，比如获取 组件 的 offsetTop console.log(this.$refs.tabControl.$el.offsetTop;) 组件命名官方： 在字符串模板或单个文件组件中定义组件时，定义组件名的方式有两种： 使用 kebab-case app.component('my-component-name', { /* ... */ }) 当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 &lt;my-component-name&gt;。 使用-pascalcase使用 PascalCase app.component('MyComponentName', { /* ... */ }) 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 &lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。 但实际上大写命名再Vue中不推荐（符合W3C的规范），反而React中使用的就是这种大写命名 组件分类全局注册&amp;局部注册：上面的例子为注册全局组件，意味着可以再多个Vue实例下使用 以下的例子为局部注册组件（局部注册组件自定义标签名不支持 -） Vue对象中的components属性来注册局部组件,在开发过程用的最多的还是局部组件 const app = new Vue({ el: '#app', components: { //自定义组件标签名:组件构造器对象 my_cpn: cpnConstructor } }); 父组件和子组件 在组件构造器(组件二)中对另外一个组件(组件一)进行注册（components{}），这样的好处是可以在组件二模板里面,使用组件一,这样子就形成了父子组件的关系 父组件模板的所有东西都会在父级作用域进行编译，子组件模板的所有东西都会在子级作用域进行编译 注意: 在模板中，子组件的标签一定要写在父组件的DIV里面，因为定义模板时一般要有一个外层包裹的根元素（一般使用div） &lt;div id=\"app\"> &lt;cpn2>&lt;/cpn2> &lt;/div> &lt;script> //子组件,子组件要比父组件先创立 const cpnConstructor = Vue.extend({ template: ` &lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div> ` }); //父组件 const cpnConstructor2 = Vue.extend({ template: ` &lt;div> &lt;h2>模板2内容&lt;/h2> &lt;cpn1>&lt;/cpn1> &lt;/div> `, components: { cpn1: cpnConstructor } }); // root组件 const app = new Vue({ el: '#app', components: { cpn2: cpnConstructor2 } }); &lt;/script> 组件语法糖Vue为了简化组件使用的过程，提供了创建 + 注册合并的语法糖，直接适用对象替代extend步骤 //创建+注册全局组件语法糖 Vue.component('mycpn', { template: ` &lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div> ` }) //创建+注册局部组件语法糖 const app = new Vue({ el: '#app', components: { mycpn2: { template: ` &lt;div> &lt;h2>模板2内容&lt;/h2> &lt;/div> ` } } }); 组件模板的分离写法 为了使结构更加清晰，最好将html分离出来写，这里有两个组件模板分离的写法 1.script标签，注意类型必须是text/x-template（但是现在比较少使用了） 2.使用template标签 &lt;template id=\"cpn\"> &lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div> &lt;/template> &lt;script> Vue.component('mycpn', { template: '#cpn' }) &lt;/script> 组件的数据访问组件的data 组件内部不能直接访问Vue实例里的数据，包括data，methods等 组件是一个单独功能模块的封装，也有属于自己的data属性（其实可以把Vue实例也看成一个特殊的组件，组件在自己的标签里只能访问自己的data），当然也有自己的methods属性 但是！！：和Vue的data不同的是，组件自己的data必须用函数写（methods不用），然后再返回一个实例对象 组件中的data写成一个函数，数据以创立新一个对象的函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，（因为函数会创建自己的作用域）类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。（同一个组件标签名用的是同一个组件构造器对象） 而单纯的写成对象形式，就使得所有组件实例在使用的时候直接引用同一个对象，导致共用了一份data，就会造成一个改变，全都会发生改变的局面。 &lt;template id=\"cpn\"> &lt;div> &lt;h2>{{str}}&lt;/h2> &lt;/div> &lt;/template> &lt;script> Vue.component('mycpn', { template: '#cpn', data() { return { str: 'hello world' } } }) &lt;/script> 父子组件的通信 父组件传给子组件：子组件通过props方法接受数据; （外加 v-bind属性传值）Vue实例的data -&gt; 子组件的props数组中某个变量名进行接收，当作数据来使用，然后在渲染到template模板中（mustache语法） 子组件传给父组件：$emit方法（自定义事件）传递参数 在真实开发中，Vue实例和子组件的通信也可以当作父组件和子组件的通信来看 父组件传子组件父组件传递给子组件实例： &lt;div id=\"app\"> &lt;mycpn :smovies=\"movies\" :smessage=\"message\">&lt;/mycpn> &lt;/div> &lt;template id=\"cpn\"> &lt;div> &lt;ul> &lt;li v-for=\"item in smovies\">{{item}}&lt;/li> &lt;/ul> &lt;h2>{{smessage}}&lt;/h2> &lt;/div> &lt;/template> &lt;script> // 父组件传子组件 props const app = new Vue({ el: '#app', data: { movies: ['ironman', 'batman', 'spiderman'], message: 'hello world' }, components: { mycpn: { template: '#cpn', props: ['smovies', 'smessage'] } } }); &lt;/script> 注意：props定义的属性名同样不要使用驼峰标识，因为HTML属性不支持大写（自定义组件名也是不要大写）（非要用大写则在html里时，将对应的大写前加 -，这样的话大写转小写） 对于通过props从父组件传递过来的值最好不要直接修改，而是在子组件的data创建数据，以传递过来的值对其进行赋值，然后想修改的手再在data的数据中修改 prop的赋值方式 // props: ['smovies', 'smessage'] // 这种对象写法还可以指定每个 prop 的值类型,甚至提供默认值,必传值,更常用 // 但是props里属性为对象或者数组时,默认值（default）属性必须是一个函数 // props:{ // smovies:Array, // smessage:String // } props: { smovies: { type: Array, default() { return [] } }, smessage: { type: String, default: 'nothing', require: false // 使用该子组件的时候,是否必须要给这个smessage属性赋值 } } 非props的属性 当我们传递组建的某一个属性时，该属性没有定义对应的props或者emits时，就称之为非Props的Attribute 常见的包括style、class、id属性等 而当组件有根节点时，非Props的Attribute将自动添加到根节点的Attribute中 当然，也可以在组件里添加一个option：inheritAttrs: false，根节点将不会再继承这个非props属性 禁用的实际情况 禁用attribute继承常见情况是需要将attribute应用于根元素之外的其它元素 我们可以通过$attrs来访问所有非props的attribute &lt;template> &lt;div> &lt;h2 :class=\"$attrs.class\">hello world&lt;/h2> &lt;h2>hello world&lt;/h2> &lt;/div> &lt;/template> 子组件传父组件 流程： 1.子组件通过$emit()触发事件，子组件发送出去一个事件 this.$emit(事件名称, [传递参数]),是自定义事件 2.父组件通过 v-on监听子组件事件 &lt;!-- 父模板 --> &lt;div id=\"app\"> &lt;!-- 父组件需要使用事件监听 v-on 进行监听，然后自己在methods定义相对应的处理函数就可以了 --> &lt;!-- v-on不仅可以监听DOM事件，还可以监听组件之间的事件 --> &lt;mycpn v-on:Bigclick=\"FatherListener\">&lt;/mycpn> &lt;/div> &lt;!-- 子模版 --> &lt;template id=\"cpn\"> &lt;div> &lt;ul> &lt;li v-for=\"item in categories\" @click=\"itemclick(item)\">{{item.name}}&lt;/li> &lt;/ul> &lt;/div> &lt;/template> &lt;script> const app = new Vue({ el: '#app', components: { mycpn = { template: '#cpn', data() { return { categories: [ { id: 1, name: \"热门推荐\" }, { id: 1, name: \"手机数码\" }, { id: 1, name: \"家用家电\" }, { id: 1, name: \"电脑办公\" }, ] } }, methods: { itemclick(item) { this.$emit('Bigclick', item); } }, } }, methods: { //基本的事件默认传入event，但是子组件传来的事件，如果附带上参数，则如果父组件处理的函数自带传来的参数 FatherListener(item) { console.log(\"hello\", item); } } }); &lt;/script> 父子组件对象操作上面的组件数据访问我们已经提到了父子组件相互通信的方法（子组件传子组件信息给父组件，父组件传父组件的信息给子组件），但有时我们想直接访问组件（父组件获取子组件信息），而不是当子组件触发某个事件时，将子组件数据传给父组件再进行操作 父组件想要访问子组件：使用 $children 或者 $refs 子组件访问父组件：使用 $parent 父组件想要访问子组件： 但是真实开发中，我们不会通过$children去拿子组件对象进行操作，这是因为当使用$children[索引号]的方式拿取数据，当Vue绑定的标签内在中间新插入新子组件，会导致拿到的是新子组件的数据 所以用$refs比较多，无论Vue绑定的标签内是否有子组件，this.$ref 都默认为空 &lt;!-- 对应的html标签 --> &lt;div id=\"app\"> &lt;cpn> &lt;/cpn> &lt;cpn ref=\"cpn2\"> &lt;/cpn> &lt;button @click=\"btnClick\">打印子组件信息&lt;/button> &lt;/div> //子组件信息 cpn: { template: '#cpn', data() { return { name: 'Allen' } }, methods: { showMessage() { console.log('nothing'); } } } //Vue的mothods中的方法： btnClick() { // 1.$children // 调用Vue绑定的标签内第一个子组件的方法showMessage() this.$children[0].showMessage(); console.log(this.$children[0].name); // 2.$ref,在标签上加属性：ref=\"cpn2\",此时this.$ref不再为空 console.log(this.$refs.cpn2); } 使用前要注意：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。 ref如果绑定在组件中，那么通过 this.refs.ref绑定的名称获取到的是一个组件对象 ref如果绑定在元素中，那么通过 this.refs.ref绑定的名称获取到的是一个元素对象（此时ref的功能不是用于父组件获取子组件的数据，而是组件自己内部想要在某个地方获取到自己的某个标签（元素），这样有较高安全性，因为类名可能会重复，到时候项目开发时通过类名的获取，不一定能够准确获取目标） 子组件想要访问父组件：（开发中不建议用，因为引用了外部组件的数据，还是父组件的数据，这样会导致独立性、可复用性降低，有较大耦合性）$parent 如果想访问根组件数据用 $root //cpn的methods中： methods: { btn_click() { console.log(this.$parent); } } 插槽slot组件的插槽也是为了让封装的组件更具有扩展性（使用同一组件但能自定义特色风格） 抽取共性，预留不同 在组件（模板）中增加 &lt;slot&gt;&lt;/slot&gt;，然后在html上使用组件时，往中间添加的标签/文字，都会放在template模板中slot标签内 推荐使用 div标签先将 slot包起来再使用 &lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;，可以避免很多bug &lt;!-- 组件cpn的模板中添加： --> &lt;div> &lt;h2>我是子组件&lt;/h2> &lt;p>这是子组件的段落&lt;/p> &lt;!-- 同时也可以定义一个默认值，这里没有传入则插槽内默认显示一个button --> &lt;slot>&lt;button>按钮&lt;/button>&lt;/slot> &lt;/div> &lt;!-- 使用插槽进行替换 --> &lt;cpn>&lt;button>其他&lt;/button> &lt;/cpn> 具名插槽 应用：如果有多个插槽且想要替换掉指定的插槽 一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名字“default”。 注意 v-slot 只能添加在 &lt;template&gt; 上 &lt;!-- 组件cpn的模板中添加： --> &lt;div> &lt;slot name=\"left\">&lt;span>左边&lt;/span>&lt;/slot> &lt;slot name=\"mid\">&lt;span>中间&lt;/span>&lt;/slot> &lt;slot name=\"right\">&lt;span>右边&lt;/span>&lt;/slot> &lt;/div> &lt;!-- 如果是在&lt;template>上的话，可以使用新版的 v-slot了 --> &lt;!-- 替换掉name为mid的插槽--> &lt;cpn> &lt;template v-slot:mid> &lt;!-- &lt;template #mid>--> &lt;span>nothing&lt;/span> &lt;/template> &lt;/cpn> 旧版本的：&lt;div slot=&quot;插槽名&quot;&gt;首页&lt;/div&gt; vue2.6新增： 还有动态插槽名的用法，可以官网查看一下 v-slot语法糖：# 作用域插槽 大前提：父组件模板的所有东西都会在父级作用域进行编译，子组件模板的所有东西都会在子级作用域进行编译 当前需求：想办法在父组件的作用域拿到子组件的数据，然后再在父组件做一个插槽填充（这里不能使用$refs因为，还没渲染完毕，在初始渲染的时候你不能用$refs进行访问） 也就是说，普通插槽的渲染位置在父组件里面，将父组件渲染的结果直接替换到 slot中； 而作用域插槽的渲染位置是在子组件里面，所以这里就产生了作用域的不同 多个插槽写法：v-slot:插槽名=”数据调用方法名”， 首先在子组件模板中的 &lt;slot&gt;&lt;/slot&gt;查找中添加自定义属性，自定义属性=”想要绑定的数据名” &lt;!-- 子组件--> &lt;!-- 注意：:data属性名这里可以随便改自己喜欢的名字，但是必须要小写，v-slot的也是一样要注意小写 --> &lt;slot :data=\"pLanguages\"> &lt;ul> &lt;li v-for=\"item in pLanguages\">{{item}}&lt;/li> &lt;/ul> &lt;/slot> Vue里支持通过template，来拿到刚才的data属性，使用 v-slot:&quot;插槽具名&quot;=&quot;自定义插槽 prop 的对象&quot;；获取子组件通过属性传递过来的数据，然后通过 自定义插槽 prop 的对象.子组件自定义属性名调用子组件的数据 &lt;!-- 在html中使用组件 --> &lt;cpn> &lt;!-- &lt;span v-for=\"item in pLanguages\">{{item}}&lt;/span> 错误，不可以直接获取--> &lt;!-- 如果插槽有具名，则写成&lt;template v-slot:\"具名\"=\"slotProps\"> --> &lt;template v-slot=\"slotProps\"> &lt;span v-for=\"item in slotProps.data\">{{item}} - &lt;/span> &lt;/template> &lt;/cpn> 为什么要使用异步组件大前提： 在webpack中，如果想要让webpack单独分包，也就是将导入的组件/文件在打包后不要合并，而是单独分一个chunk-哈希值.js出来，则只需要我们在导入的时候通过 import('xxxxx.js').then(res => res.函数名); 的形式进行使用时，则webapck会帮我们额外生成chunk来打包该文件（利用的是import函数得到一个异步promise的原理） 如果组件功能多，打包的结果（app.js）会变大，我们可以采用异步的方式来加载组件，主要依赖于 import 异步组件 （async component）一定是一个函数，新版本提供了对象的写法 components:{ AddCustomerSchedule:(resolve) => import(\"../components/AddCustomer\") } Vue.component('async-example', function (resolve, reject) { setTimeout(function () { // 向 `resolve` 回调传递组件定义 resolve({ template: '&lt;div>I am async!&lt;/div>' }) }, 1000) })","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Express","slug":"Express","date":"2021-01-30T16:00:00.000Z","updated":"2022-05-04T12:37:32.421Z","comments":true,"path":"2021/01/31/express/","link":"","permalink":"https://taylor12138.github.io/2021/01/31/express/","excerpt":"","text":"Express框架基于Node.js平台快速、开放、极简的Web开发框架，高度封装了http模块 （截至在2021/4/18，在GitHub上， express：52.7k star； koa：31k star； Hapi：13.2k star，express占领榜首，最高活跃度） 安装：用VScode打开文件目录，然后在该目录下右键-&gt;在集成终端打开-&gt;输入命令 npm init --yes 进行初始化，创建一个package.json文件-&gt; npm i express --save 安装框架 -&gt; 在js中输入 它！： 封装API，让开发者更关注于业务代码的开发 有一定的流程和标准 基本使用1.http.createServer((req, res) =&gt; {}) =&gt; express() 创建服务器 2.if (url.parse(req.url, true).pathname === 路径){} =&gt; app.get(路径, fn) 判断路径进行处理 3.app.use(&#39;public&#39;, express.static(&#39;./public/&#39;)); 处理公开目录，当以/public/开头的时候，去./public/目录中查找对应的资源，如 http://127.0.0.1:5208/public/404.html，直接进行访问（常用） 第一个参数其实是别名，app.use(&#39;a&#39;, express.static(&#39;./public/&#39;)); 处理公开目录，当以/a/开头的时候，去./public/目录中查找对应的资源，如 http://127.0.0.1:5208/a/404.html，直接进行访问 如果省略第一个参数：app.use(express.static(&#39;./public/&#39;))，则可以在原始网页网址+资源名称，如 http://127.0.0.1:5208/404.html，直接进行访问 4.url.parse(req.url, true).query=&gt; req.query 原来的get获取url ? 后的参数的方法的改变（只能拿get请求的参数） 模板对象：在Express中，模板引擎的使用有更好的方式res.render(‘文件名’, {模板对象})，可以自己尝试看art-template官方文档，让它们结合使用 5.express不需要 res.end()结尾来结束响应，而且它还提供了res.send(JSON.stringify(对象)) =&gt; res.json() 自动帮你把json对象转换成字符串，然后发送给浏览器 // 引包 var express = require('express'); // 创建服务器，相当于原来的http.createServer() var app = express(); //当服务器收到get请求 '/' 的时候，执行回调函数 // 不用再设置http头部文件，并且不用设置charset=utf-8:防止中文乱码，它会根据你的语言更改language //内置处理有不认识的路径时，自动发404 app.get('/', function (req, res) { res.send('Hello, world!'); }) app.get('/about', function (req, res) { //拿出get请求参数：在Express中可以直接通过req.query来获取查询字符串参数 //http://127.0.0.1:5208/about?a=1&amp;b=2 console.log(req.query); res.send('你好！！!'); }) // 公开指定目录（处理静态资源public那块） // 之后你就可以通过public的方式访问public目录的所有资源了 // 替代了原来判断路径+读文件+end结束的过程 app.use('/notebook/', express.static('./notebook/')); // 相当于server.listen app.listen(5208, () => { console.log('app is running at port!'); }) 然后继续右键在集成终端打开-&gt;输入命令 node 该js的文件名 这里的 app.get(&#39;/&#39;,(request, response) 中的 / 是路径（当然可以写成/路径名 之类的），当客户端浏览器向服务器发送请求时，如果url的路径，也就是请求行的第二部分，它的路径对应该路径的话，就会执行这个回调函数里面的 代码，并且由response做出响应 以上步骤来简单构建一个服务端，提供ajax使用 express的response方法一览 基本路由服务器中get和post部分相当于路由表，帮你映射关系： app .get('/login', callback) .get('xxx', callback) .post('yyyy', callback) 配置art-template模板引擎在官方文档可以看得到Express配合使用的安装导航：https://aui.github.io/art-template/ npm install --save art-template npm install --save express-art-template 注意：Express有个约定，把所有视图文件都放在views目录之中，如果想要修改，则app.set(&#39;views&#39;, render函数的默认路径) 然后 app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;)) 第一个参数表示当渲染以.art结尾的文件时，使用art-template模板引擎；express-art-template专门用在Express中把art-template整合，且express-art-template依赖了art-template 而这时就可以使用模板引擎的render了 app.engine('html', require('express-art-template')); app.get('/', (req, res) => { //去找views目录下的404.html res.render('404.html'); }) 接而根据导航一步一步指引，进行操作就行了 重定向注意：服务端重定向对异步请求是无效的（表单的异步提交），异步请求的重定向只能在客户端里面实现，可以在ajax的success里使用 window.location.href = '/' 原来是 res.statusCode = 302; res.setHeader('Location', '/'); //响应头的Loacation路径设置为 '/' 即首页 res.end(); 现在： res.redirect('/'); Express获取表单POST请求体数据当以post请求/post的时候，执行指定函数，获取数据的表单form添加 action=路径, method=&quot;POST&quot; 这样的话我们就可以利用不同的方法，让一个请求路径使用多次 app.post('/post', (req, res) => { // 1.获取表单post数据 // 2.处理 // 3.发送响应 }); 因为express内置没有获取表单post的api，所以需要借助第三方插件，在官网-&gt;资源-&gt;body-parser 官网现在已经有了获取表单post的API express.json，基于body-parser 注意：express4不再支持body-parser 如果仍想使用，可以npm install express@3 安装 npm install --save body-parser 然后跟着官网指示一步一步进行配置 配置body-parser，则会在request请求对象上多出一个body属性，然后此时我们可以使用req.body获取表单post请求体数据了 //引包 var bodyParser = require('body-parser'); //配置post插件body-parser // parse application/x-www-form-urlencoded app.use(bodyParser.urlencoded({ extended: false })); // parse application/json app.use(bodyParser.json()); app.post('/post', (req, res) => { // 1.获取表单post数据 // 2.处理 // 3.发送响应 console.log(req.body); //get使用的是req.query }); body-parser被弃用后我们可以直接使用express自带的 app.use(express.urlencoded({ extended: false })) app.use(express.json()) 定制404页面在挂载路由app.use(router);之后增加 app.use(function(req, res) =&gt; {})处理404页面，所有未处理的请求路径都会跑到这里 express操作cookie不需要任何第三方的库 app.get('/send', (req, res) => { const value = { name: 'Allen', sex: '男', age: 18 } res.cookie('message', JSON.stringify(value)) res.cookie('msg2', JSON.stringify(value), {maxAge: 1000 * 30}) //在搞一个30秒过期的的cookie }) 然后当服务端读取客户端携带过来的cookie需要用到一个库cookie-parser npm i cookie-parser const cookieParser = require('cookie-parser') app.use(cookieParser()) app.get('/receive', (req, res) => { console.log(req.cookies) const {message} = req.cookies; let a = JSON.parse(message.name) }) 除了生成cookie，还能删除掉cookie app.get('/delete', (req, res) => { //第一种删除方法 res.cookie('message', '', {maxAge: 0}) //第二种删除方法： //res.clearCookie('message') }) express使用sessionnpm i express-session const session = require('express-session') app.use(session({ name: 'userid', //设置cookie的key，默认为connect.sid secret: 'mistoryQianMing', //参与加密的字符串（又俗称签名），加密cookie传输的字段 saveUninitialized: false, //是否在存储内容之前创建对话，意思就是当我直接正常请求/访问时是否也给我开session //false：除非执行了req.session.xx = xxx逻辑再给我存 resave: true, //每次请求时，强制重新保存session，即使他们没变化（稳妥） cookie: { httpOnly: true, //开启之后前端无法通过js操作cookie maxAge: 1000 * 30 //cookie过期时间 } })) tip： saveUninitialized： 强制将“未初始化”的会话保存到存储中。当一个会话是新的但未被修改时，它是未初始化的。选择false对于实现登录会话、减少服务器存储使用或遵守在设置 cookie 之前需要许可的法律很有用。选择false还有助于解决竞争条件，即客户端在没有会话的情况下发出多个并行请求。 默认值为true，但不推荐使用默认值，因为默认值将来会更改。请研究此设置并选择适合您的用例的设置。 此时我们在某个请求中执行以下步骤 为此次请求开辟一个session空间 将客户端和服务端产生的对话数据存入session会话空间 获取session id 将session 存入id 然后返回cookie 但是以上步骤都一步搞定！ //这里的_id是使用mongoDB存储数据时，会自动生成的，这里的逻辑是通过用户名密码在数据库查找匹配的data，然后用_id来充当session id，当然你也可以换成其他的，或者自己写个id //session._id这个是变量名，可以随便取名 app.get('/send', (req, res) => { req.session._id = data._id.toString() }) 当服务端通过客户端返回的session id验证会话消息时 获取cookie携带过来的session id 根据session id 匹配session，此时我们可以根据匹配结果，要么使用匹配到的数据，要么就去让客户端重新登录 //这里我们当时存放了session._id，所以用_id去取 app.get('/receive', (req, res) => { const { _id } = req.session //req携带过来的cookie：{key: userid, value: 经过加密的session id} //根据_id对数据库进行查找操作。。。 }) 如果是配合mongodb，则需要下载(这一步是配合session持久化的，不需要持久化可不用) npm i connect-mongo //导入的是一个函数，此时传参session传过去，做session持久化 const MongoStore = require(\"connect-mongo\")(session); app.use(session({ //... store: new MongoStore({ //往sessions_container数据库里存储，然后保存在sessions集合里 url: \"mongodb://localhost:27017/sessions_container\", touchAfter: 24 * 3600, //修改频率（例如24小时内只更新一次）,防止过度访问数据库造成压力 }), })) crud案例先初始化 npm init -y 装express：npm i -S express 建2个文件夹，分别为views和public 装模板引擎：npm install --save art-template express-art-template 装bootstrap的css：npm i -S bootstrap 外部备上一个index.html、db.json(用于存储数据) 将app.js作为执行的js文件，而router.js作为辅佐的路由js文件，并将其引入app.js，student.js作为增删改查封装的api 请求方法 请求路径 get参数 post参数 备注 get /students 渲染页面 get /students/new 渲染添加学生 post /students/new name、age、color、hobbies 处理添加学生请求 get /students/edit id 渲染编辑页面 post /students/edit id、name、age、color、hobbies 处理编辑请求 get /students/delete id 处理删除请求 //app.js var express = require('express'); var router = require('./router.js'); var bodyParser = require('body-parser'); var app = express(); // 一定要在挂载路由之前配置好模板引擎和bodyParser app.engine('html', require('express-art-template')); app.use(bodyParser.urlencoded({ extended: false })); app.use(bodyParser.json()); app.use('/node_modules/', express.static('./node_modules/')); app.use('/public/', express.static('./public/')); //挂载路由 app.use(router); //这里可以设置一个定制404页面，所有未处理的请求路径都会跑到这里 //app.use(function(req, res) => {}) app.listen(5208, () => { console.log('5208 is running!!...'); }) express提供了一种更好的方式，专门用来包装路由 1.创建一个路由容器，可以把它看成我们的小型app 2.把路由都挂载到router容器中 3.在我们的router中，也可以通过 router.use(中间件)来使用我们的中间件 //处理路由的router.js文件 var fs = require('fs'); var express = require('express'); var Student = require('./student.js'); //这样也不方便模块化 // module.exports = function (app) { // app.get('/students', (req, res) => { // }); // } var router = express.Router(); router.get('/students', (req, res) => { Student.find((err, data) => { if (err) { return res.status(500).send('Service err 500'); } // 进行数据渲染 res.render('index.html', { fruits: [ '苹果', '雪梨', '西瓜' ], students: data }); }) }); router.get('/students/new', (req, res) => { res.render('new.html'); }); router.post('/students/new', (req, res) => { // 1.获取表单数据 // 2.处理,将数据保存与db.json中，用于持久化,即将db.json读取处理啊，转对象，往对象中push数据，再转回字符串，再把字符串写入文件 // 3.发送响应 var student = req.body; Student.save(student, (err) => { if (err) { return res.status(500).send('Service err 500'); } res.redirect('/students'); }) }); router.get('/students/edit', (req, res) => { // 1.在客户端处理链接问题，使用&lt;a href=\"/students/edit?id={{ $value.id }}\"> // 2.获取编辑的学生id // 3.渲染编辑页面 Student.findById(parseInt(req.query.id), (err, student) => { if (err) { return res.status(500).send('Service err 500'); } res.render('eidt.html', { student: student }) }) }); router.post('/students/edit', (req, res) => { Student.updateById(req.body, function (err) { if (err) { return res.status(500).send('Service err 500'); } res.redirect('/students'); }) }); router.get('/students/delete', (req, res) => { // 获取删除的id // 根据id，进行删除，然后发送响应 Student.remove(req.query.id, function (err) { if (err) { return res.status(500).send('Service err 500'); } res.redirect('/students'); }) }); // 3.导出 module.exports = router; student.js用于纯粹对文件封装增删改查功能 只处理数据，不关心业务 node的奥义所在：封装异步api //student.js var fs = require('fs'); var dbPath = './db.json'; //1.获取学生列表 // callback的第一个参数是err，第二个参数是结果 exports.find = function (callback) { //readFile 的第二个参数是可选的，传入utf8则按照utf-8编码转成正常字符 fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 callback(null, JSON.parse(data).students); }) }; // 根据id获取学生对象 exports.findById = function (id, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 var students = JSON.parse(data).students; student = students.find((item, index) => { return item.id === parseInt(id); }); callback(null, student); }) } //2.保存学生 exports.save = function (student, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 var students = JSON.parse(data).students; // 处理id唯一性问题 student.id = students[students.length - 1].id + 1; students.push(student); // JavaScript 值(对象或数组)转换为 JSON 字符串 var ret = JSON.stringify({ students: students }); ReRead(dbPath, ret, err, callback); }) }; //3.更新学生 exports.updateById = function (student, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 先把number类型的三个值从string转number student.id = parseInt(student.id); student.age = parseInt(student.age); student.color = parseInt(student.color); // 字符串转对象 var students = JSON.parse(data).students; // 使用ES6的find方法找到id对应的对象 var stu = students.find((item) => item.id === student.id); // 遍历拷贝对象 for (let key in student) { stu[key] = student[key]; } // JavaScript 值(对象或数组)转换为 JSON 字符串 var ret = JSON.stringify({ students: students }); ReRead(dbPath, ret, err, callback); }) }; //4.删除学生 exports.remove = function (id, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 var students = JSON.parse(data).students; // 获取要删除的id对象的下标 var deleteId = students.findIndex((item) => item.id === parseInt(id)); // 删除该id的对象 students.splice(deleteId, 1); var ret = JSON.stringify({ students: students }); ReRead(dbPath, ret, err, callback); }) }; // 重新读入的api function ReRead(dbPath, ret, err, callback) { fs.writeFile(dbPath, ret, (err) => { if (err) { return callback(err); } // 成功为null callback(null); }); } 关于Expresscookie和Session在express中，默认不支持Session和Cookie session是基于cookie实现的 但是我们可以使用大三方中间件：express-session来解决 npm install express-session 配置： var session = require('express-session'); app.use(session({ //配置加密字符串 secret: 'keyboard cat', resave: false, //无论你是否适用session,我都给你分配一把钥匙 saveUninitialized: true })); 添加session数据：req.session.foo = &#39;xxx&#39; 访问session数据：req.session.foo 这时候，服务器只需要调用req.session.xx就可以使用session保存的数据了 中间件使用express框架、一些其他的API之后，传进来的req和res经过了一些中间件（函数方法），使得req和res内部拥有了一些属性，可以直接使用req.body、req.query、req.session 等，并且在挂载路由后，在路由的js文件中，不用再次引用（require）这些api方法，同样可以使用req.body、req.query、req.session 等属性（其实也可以理解为，req、res等参数传进来路由器js文件时，已经被赋予以上属性，页面不用关心参数从中间件得到的属性，而是要关心是否需要引包才能使用方法） 中间件本身就是一个方法，它有三个参数：request、response、next（使用下一个中间件） 如果一个请求进入中间件，不调用next则会停留在当前中间件，调用了next后继续向后找到第一个匹配的中间件（平常我们看到很多组件好像没有next，其实已经吧next封装好了） 与ES6的Generator中的next()类似 在express中，对中间件有几种分类： （1）不关心请求路径和请求方法的中间件，也就是任何请求都会进入这个中间件 app.use(function(req, res, next)) （2）关心请求路径的中间件，以’/xxx’开头，需要匹配才会进入此中间件，如果不匹配自动跳过，去下一个中间件 app.use(&#39;/xx&#39;, function(req, res, next)) （3）严格匹配请求方法和请求路径的中间件 app.get() app.post() //127.0.0.1:5208/b app.use(function (req, res, next) { console.log(1); next(); }); app.use('/a', function (req, res, next) { console.log('a'); }); app.use('/b', function (req, res, next) { console.log('b'); }); app.use(function (req, res, next) { console.log(3); }); //输出: 1 b 上方为错误的代码，没有调用next，导致停顿在中间件中 下方利用next处理发生错误： //当调用next的时候，如果传递了参数，则直接往后找到带有四个参数的应用程序级别中间件 //if (err) { // next(err) // } //中间件要放到最后，搭配404处理一起使用 app.use(function (req, res, next) { res.render('404.html') }); app.use(function (err, req, res, next) { res.status(500).send(err.message) }); express实现中间件机制前提： express函数调用返回一个app实例 在express函数内部定义一个数组来存储中间件函数（队列数组） constructor() { // 存放中间件的列表 this.routes = { all: [],// 通用的中间件 get: [],// get请求的中间件 post: [],// post请求的中间件 }; } 在express函数内部定义一个app函数 在app函数的内部定义一个变量i保存执行的中间件的位置。 在app函数中定义一个next方法，这个方法通过i值自增调用中间件 在app函数内部调用next 在app函数上定义一个use方法，这个方法可以将中间件函数push进中间件数组中。 一个小案例加深中间件的作用和印象 function middlewareA(req, res, next) { console.log('middlewareA before next()'); next(); console.log('middlewareA after next()'); } function middlewareB(req, res, next) { console.log('middlewareB before next()'); next(); console.log('middlewareB after next()'); } function middlewareC(req, res, next) { console.log('middlewareC before next()'); next(); console.log('middlewareC after next()'); } app.use(middlewareA); app.use(middlewareB); app.use(middlewareC); 执行：A开始 -&gt; B开始 -&gt; C开始 -&gt; C结束 -&gt; B结束 -&gt; A结束 其实也可以以异步调用的方式看待中间件的执行顺序 const fn = async (ctx, next) => { console.log(1); await next(); console.log(2); }","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"NPM小解","slug":"NPM小解","date":"2021-01-30T16:00:00.000Z","updated":"2023-06-12T08:53:52.458Z","comments":true,"path":"2021/01/31/npm-xiao-jie/","link":"","permalink":"https://taylor12138.github.io/2021/01/31/npm-xiao-jie/","excerpt":"","text":"1.Nodejs的包通俗来说，单个js文件算一个模块，放在一个文件夹里就是一个包了 CommonJS 的包规范由包结构和包描述两个部分组成 包结构：用于组织包中的各种文件 ​ -package.json 描述文件 （important） ​ -bin 可执行二进制文件 ​ -lib js代码 ​ -doc 文档 ​ -test 单元测试 包描述文件（上面的那个-package.json 描述文件）：描述包的相关信息，以供外部读取分析。它用于表达非代码相关信息，是一个json格式的文件，实际上加载包时使用的原则是：node_modules/express/package.json main, 而且它其中保存着十分重要的第三方包依赖项信息（dependencies） 并且建议每个项目里带一个（有且只有一个）package.json文件npm init npm init -y 里面的-y就是yes的意思，在init的时候省去了敲回车的步骤，生成的默认的package.json 2.package.jon解析（杂碎）npm包命名： 若包名称中存在一些符号，将符号去除后不得与现有包名重复 例如：由于react-native已经存在，react.native、reactnative都不可以再创建。 如果你的包名与现有的包名太相近导致你不能发布这个包，那么推荐将这个包发布到你的作用域下。 例如：用户名 conard，那么作用域为 @conard，发布的包可以是@conard/react。 main属性： main 属性可以指定程序的主入口文件 { \"main\": \"lib/index.js\", } script属性 scripts 用于配置一些脚本命令的缩写 package.json和package-lock.jsonnpm 5以前是不会有package-lock.json这个文件的 npm 5 以后才加入 从安装上看，npm都会生成或更新package-lock.json这个文件 npm 5 版本以后的安装包，不用加–save添加依赖，它会自动保存依赖 它会自动创建或者更新package-lock.json package-lock.json里面保存的是node_modules所有包的依赖，包括依赖的包里package.json所依赖的包名（套娃） 因此重新npm install时速度会有所提升 从文件上看 lock是用来锁定版本的，如果当前项目依赖了1.1版本，但是重新npm install 其实会给你下载最新版本，而不是1.1 而package-lock.json的另一个作用就是锁定版本号，防止自动升级最新版 lock的 lockfileVersion lockfileVersion 字段来指定的 lock 格式的版本 npm5之后设置为1， 以前的 lock 格式仍然支持并被识别为版本 0 。 而后来从 NPM 7 发布以来，一个新的 package-lock.json 文件被重新生成为不同的结构。从 lockfileVersion 1 到 2，从而兼容npm 6用户，并且不再忽略 yarn.lock 符号\"@music/mobile-toast\": \"～2.1.13\", \"@music/mobile-url\": \"^4.0.6\", 1.^插入符号 他将会把当前库的版本更新到当前主版本（也就是第一位数字）中最新的版本。放到我们的例子中就是：”axios”: “^0.18.0”, 这个库会去匹配0.x.x中最新的版本，但是他不会自动更新到1.0.0。 2.波浪符号 他会更新到当前次版本号（也就是中间的那位数字）中最新的版本。放到我们的例子中就是：”cross-env”: “5.2.0”，这个库会去匹配更新到5.2.x的最新版本，如果出了一个新的版本为5.3.0，则不会自动升级。波浪符号是曾经npm安装时候的默认符号，现在已经变为了插入符号。 NPM命令基础（Node Package Manager） CommonJS包规范时理论，NPM是其中一种实践，是Node包管理器 对于Node而言，NPM帮助其完成第三方模块的发布，安装和依赖（A-&gt;B-&gt;C，下载C直接A, B也下），借助NPM，Node与第三方模块之间形成良好的一个生态系统（安装了node以后，自带安装npm） 在cmd命令行窗口： npm -v 查看版本 （或者包名 --version） npm 帮助说明 npm search 包名 搜索包 npm why xxx --long 查看当前项目对xxx包的依赖关系 安装 npm install 下载当前项目所依赖的包（根据package.json配置里的依赖下载） npm install 包名 / npm i 包名 当前目录安装包（可以先创建一个文件夹）（尾部加--save，则为生产环境时依赖，则添加到当前package.json的依赖里） 如果尾部加 --save-dev则为开发时依赖 npm install 包名 -g 全局模式安装包（一般都是计算机里的工具） 如果本身电脑上有该包，则直接 npm install 包名则会直接下载最新版本 删除 npm remove 包名 / npm r 包名 删除包 （这个好像是旧版的） npm uninstall 模块：删除模块，但不删除模块留在package.json中的对应信息 npm uninstall 模块 --save 删除模块，同时删除模块留在package.json中dependencies下的对应信息 npm uninstall 模块 --save-dev 删除模块，同时删除模块留在package.json中devDependencies下的对应信息 查看包版本npm view &lt;pkg&gt; version 查看包版本npm view &lt;pkg&gt; versions 查看包更多历史版本 npm i module_name -S = &gt; npm install module_name --save 写入到 dependencies 对象 npm i module_name -D =&gt; npm install module_name --save-dev 写入到 devDependencies 对象 npm i module_name -g 全局安装 npm i module_name@latest 安装最新版本镜像源通过 npm config set 进行npm的配置 比如配置镜像源 npm config set 包名:registry 配置的网址 # 指定 包名 走 配置的网址写的镜像源查看当前源 npm config list npm5以后的–save在版本 5 之前，NPM 只是node_modules默认安装了一个包。当您尝试为您的应用程序/模块安装依赖项时，您需要先安装它们，然后将它们（连同适当的版本号）添加到dependencies您的package.json. 该--save选项指示 NPM 自动将包包含在dependencies您的部分中package.json，从而为您节省了额外的步骤。 此外，还有一些补充选项--save-dev，--save-optional它们分别将包保存在devDependencies和下optionalDependencies。这在安装仅开发包（如grunt测试库）时很有用。 但是 5级以上更新： 从npm 5.0.0开始，已安装的模块默认添加为依赖项，因此--save不再需要该选项。其他保存选项仍然存在，并列在.npm install npm 5以后的install早期：npm 处理依赖的方式简单粗暴，以递归的形式，严格按照 package.json 结构以及子依赖包的 package.json 结构将依赖安装到他们各自的 node_modules 中。直到有子依赖包不在依赖其他模块。 这样子层级结构会比较明显， 但是！如果不同模块引用的是同一个模块，则会产生大量冗杂 在 Windows 系统中，文件路径最大长度为260个字符，嵌套层级过深可能导致不可预知的问题。 中期（npm3）：选择扁平化的结构，无论是直接依赖还是子孙依赖，都放在node_modules当中，而此时模块的搜索模式为： 在当前模块路径下搜索 在当前模块 node_modules 路径下搜素 在上级模块的 node_modules 路径下搜索 但是：当安装到相同模块时，判断已安装的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 node_modules 下安装该模块。 这使得放置顺序则决定了 总node_modules 的依赖结构 然后就会出现（buffer2依赖 base64-js1.0.3，buffer依赖 base64-js@1.0.2 ） 假如没有依赖了 base64-js@1.0.1，出现两种情况 也就是说，如果依赖不同版本，有可能导致依赖结构的不确定性，而这种不确定性可能会给程序带来不可预知的问题。 后期：为了解决 npm install 的不确定性问题，在 npm 5.x 版本新增了 package-lock.json 文件，而安装方式还沿用了 npm 3.x 的扁平化的方式。 package-lock.json 的作用是锁定依赖结构，即只要你目录下有 package-lock.json 文件，那么你每次执行 npm install 后生成的 node_modules 目录结构一定是完全相同、一一对应的。 并且， package-lock.json 中已经缓存了每个包的具体版本和下载链接，不需要再去远程仓库进行查询，然后直接进入文件完整性校验环节，减少了大量网络请求。 但是仍然存在部分缺陷 平铺式的算法的复杂性，以及Phantom（所以项目中可以非法访问没有声明过依赖的包，因为该包可能是作为依赖的依赖）、性能和安全问题 npm i 的流程所以总结起来 npm i 的流程是： 检查.npmrc 文件（npm running cnfiguration, 即npm运行时配置文件），从项目级的 .npmrc -&gt; 用户级的.npmrc -&gt; 全局的 .npmrc （有点DNS查询的感觉 检查有没有lock文件， 有lock文件，检查 package.json 中的依赖版本是否和 package-lock.json 中的依赖有冲突 有冲突的话在merge conflicts的阶段，只需要从主分支中checkout去package-lock.json，再以此为基础，重新安装新分支中需要的依赖。 git checkout dev -- package-lock.json; 这样让npm自动的去维护package-lock.json。 或者团队合作中，做merge操作的人可以通过查看package.json的变更知道新安装了哪些依赖包，来重新安装， 没冲突直接走缓存流程 没有lock文件，则： 从 npm 远程仓库获取包信息 根据 package.json构建依赖树，构建过程： 构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在 node_modules 根目录。 当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 node_modules 下放置该模块。 注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包 进入缓存流程 将包解压到 node_modules 生成 lock 文件 缓存在执行 npm install 或 npm update命令下载依赖后，除了将依赖包安装在node_modules 目录下外，还会在本地的缓存目录缓存一份。 缓存流程： 在缓存中依次查找依赖树中的每个包 不存在缓存： 从 npm 远程仓库下载包 校验包的完整性 校验不通过： 重新下载 校验通过： 将下载的包复制到 npm 缓存目录 将下载的包按照依赖结构解压到 node_modules 存在缓存：将缓存按照依赖结构解压到 node_modules 被讨厌了的npmNPM Clients That Are Better Than The Original npm72020年10月13日是npm CLI团队的快乐星期二，经过几个月的努力，npm CLI团队正式发布了 npm@7.0.0。 工作区（重复安装问题）：它支持在一个顶级的根包中管理多个包（Yarn和Pnpm以相同的名称实现类似的功能）。它是什么？你可以将它视为在预定义和通用上下文内的项目之间共享软件包的一种方式。，但是并不是说软件包是完全通用的，或者所有内容都要放进同一个下载位置。这个方案确实可以解决一遍又一遍地复制模块的麻烦，还能让你控制我们的模块要共享给哪些项目。 有了工作区以后，你就可以明确地告诉 NPM，你的程序包将存放在何处。并且由于新版客户端可以感知工作区，因此它会正确安装依赖项，而不会复制那些通用的依赖。 同级项依赖：在之前的版本(npm v6)中，npm默认不安装同级项依赖，这使得开发人员不得不自己安装和管理同级项依赖关系（比如React15和React16）。而现在，NPM 现在将完成开发人员的工作并帮助后者决定是否应该安装该对等依赖项 同级依赖： 这里就简单介绍一下：对等依赖项和普通的依赖项几乎没什么区别，它们并没有定义一个严格的要求，而是声明： 你的软件包与另一个模块的特定版本兼容。 如果该模块已经安装并且是正确的版本，则不要执行任何操作。 如果找不到该模块或版本存在冲突，则向开发人员显示一条消息，警告他们这一事实，此外什么也不做。 Package-lock v2和对yarn.lock的支持 其他： npm现在使用了 package.export，而不再使用 require() npx 的重写，下载已经可以使用 npm exec 了 npm audit 的输出在人可读和 --json 输出方式上都有所改变。它不再使用表格来显示漏洞，vuln count也不再是将树上的每一个节点相乘。 现在默认情况下，npm ls 仅显示顶级软件包 参考链接：https://blog.bitsrc.io/npm-7-this-is-what-i-call-an-update-de17a34ab787 其他的选择NPM Clients That Are Better Than The Original 3.管理Node版本可以使用nvm进行包管理，随时切换node版本 // 设置 node 安装源 nvm node_mirror https://npm.taobao.org/mirrors/node/ nvm npm_mirror https://npm.taobao.org/mirrors/npm/ // 安装版本 nvm install latest // 使用指定版本 nvm use v17.0.0 // 查看系统存在的 node 版本 nvm list // 卸载指定 node 版本 nvm uninstall 17.0.0 可以参考以下文章 https://blog.csdn.net/weixin_44582077/article/details/110237056 4.NPXnpx是一个工具，npm v5.2.0引入的一条命令（npx），一个npm包执行器，指在提高从npm注册表使用软件包时的体验 ，npm使得它非常容易地安装和管理托管在注册表上的依赖项，npx使得使用CLI工具和其他托管在注册表。它大大简化了一些事情。 实质上 npx 执行的是 node_module/.bin/ 下面包的命令 主要特点： 临时安装可执行依赖包，不用全局安装，不用担心长期的污染。 可以执行依赖包中的命令，安装完成自动运行。 （比如使用React时，我们使用npm） npm i -g create-react-app create-react-app 项目名称 使用npx npx create-react-app 项目名称 自动加载node_modules中依赖包，不用指定$PATH。 可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。（-p参数用于指定 npx 所要安装的模块） npx -p node@8 npm run build 甚至可以 利用 npx 可以下载模块这个特点，可以指定某个版本的 Node 运行脚本。它的窍门就是使用 npm 的 node 模块。 $ npx node@0.12.8 -v v0.12.8 上面命令会使用 0.12.8 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。 某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。 5.PNMP截至2021/11/5, GitHub的Star数量为13.4k，目前Vue、微软、字节都有在使用 下载同yarn： npm install -g pnpm 从结果上来看，它具有以下优势： 安装速度块 依赖解析。 仓库中没有的依赖都被识别并获取到仓库。 目录结构计算。 node_modules 目录结构是根据依赖计算出来的。 链接依赖项。 所有以前安装过的依赖项都会直接从仓库中获取并链接到 node_modules。 极其简洁的node_modules目录（非扁平的 node_modules） 能极大的降低磁盘空间的占用：使用 npm 时，依赖每次被不同的项目使用，都会重复安装一次。 而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中，所以： 如果你用到了某依赖项的不同版本，只会将不同版本间有差异的文件添加到仓库。 例如，如果某个包有100个文件，而它的新版本只改变了其中1个文件。那么 pnpm update 时只会向存储中心额外添加1个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。 所有文件都会存储在硬盘上的某一位置。 当软件包被被安装时，包里的文件会硬链接到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。 对monorepo支持 Monorepo 可以一定程度解决重复安装和修改困难的问题，但需要走本地编译 安全性高，项目无法非法访问未声明的依赖（比如项目A依赖B包，B包依赖C包，此时是项目A无法使用C包） 符号链接和硬链接 pnpm 使用符号链接和硬链接（Hard Link），它会在全局的 store 目录里存储项目 node_modules 文件的 hard links 一个硬链接是一个目录条目，一个名字与关联文件的文件系统（文件别名）。所有基于目录的文件系统必须至少有一个硬链接，为每个文件提供原始名称 硬链接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的 只有删除了源文件和所有对应的硬链接文件，文件实体才会被删除 一个优势例子来源于知乎 Pnpm: 最先进的包管理工具 例如项目里面有个 1MB 的依赖 a，在 pnpm 中，看上去这个 a 依赖同时占用了 1MB 的 node_modules 目录以及全局 store 目录 1MB 的空间(加起来是 2MB)，但因为 hard link 的机制使得两个目录下相同的 1MB 空间能从两个不同位置进行寻址，因此实际上这个 a 依赖只用占用 1MB 的空间，而不是 2MB。 软链接 符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式（文件路径指向）。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。 不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。 软、硬链接最根本的区别原理上，硬链接和源文件的inode节点号相同，两者互为硬链接。软连接和源文件的inode节点号不同，进而指向的block也不同，软连接block中存放了源文件的路径名。 实际上，硬链接和源文件是同一份文件，而软连接是独立的文件，类似于快捷方式，存储着源文件的位置信息便于指向。 源文件 -&gt; 物理硬盘一个区块 硬链接 -&gt; 物理硬盘一个区块 软链接 -&gt; 源文件路径也就是说，删除源文件，不影响硬链接的访问，但是软连接实际上保存了一个源文件的访问路径，所以会影响软链接的访问 使用限制： 使用限制上，不能对目录创建硬链接，不能对不同文件系统创建硬链接，不能对不存在的文件创建硬链接；可以对目录创建软连接，可以跨文件系统创建软连接，可以对不存在的文件创建软连接。 6.npm发包首先在github上新建项目，clone下来后 npm init -y，push完后我们就可以发包啦 在官网注册账号 需要切换npm源 如果是淘宝源、或者公司的源，需要在本地项目命令行输入（后面我们记得切回去，以免影响我们的日常使用） npm set registry https://registry.npmjs.org/ npm login 在本地和npm官网的账户连接 在package.json确保包名全球唯一，也就是name唯一，且main的值为我们打包的文件，因为读取的时候会根据main读取对应的文件 { \"name\": \"名称\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"./dist/bundle.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, //要发布到npm的文件 \"files\": [ \"lib\" ], \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^5.68.0\", \"webpack-cli\": \"^4.9.2\" } } 发布 npm publish 发包后无法获取最新版本时，请检查是否修改了src下文件，不然可能无法获取到最新latest包 并且确保package.json不能为 type:module (则以.js结尾或没有任何扩展名的文件将作为ES模块进行加载。默认是走type: commonjs) 7.npm linknpm install可以把发布在npmjs平台上的模块包下载到本地 但是对于未发布的包，我们无法测试使用（你可以在本地改源码，但是别人测试的时候下载你的仓库文件，然后 npm i，就不知道要不要改源码了 ），此时我们可以使用npm link npm link可以帮助我们模拟包安装后的状态，它会在系统中做一个快捷方式映射，让本地的包就好像install过一样，可以直接使用。在MAC中，我们在终端可以直接敲命令，其实是在执行/xxx目录下的脚本 当前：我们的test-project项目依赖 xx-module npm 包 首先，进入我们要开发的npm模块 xx-module，执行npm link cd xx-module npm link 执行命令后，xx-module项目会根据package.json上的配置，被链接到全局，路径是{prefix}/lib/node_modules/&lt;package&gt;，这是官方文档上的描述，我们可以使用npm config get prefix命令获取到prefix的值 然后，进入test-project项目，执行命令 cd test-project npm link xx-module 请注意，package-name取自package.json，而不是取自目录名称。 解除链接1）解除项目和模块的链接 cd xxx/xxx/test-project npm unlink xx-module 2）解除模块的全局链接 cd xxx/xxx/xx-module npm unlink xx-module 参考： npm link的使用 用一个实例简单介绍什么是pnpm NPM 7: This Is What I Call An Update","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JQuery","slug":"JQuery","date":"2020-12-23T16:36:12.611Z","updated":"2020-12-23T16:36:12.611Z","comments":true,"path":"2020/12/24/jquery/","link":"","permalink":"https://taylor12138.github.io/2020/12/24/jquery/","excerpt":"","text":"1.JQuery概述JavaScript库：即library，是一个封装好的特定集合（方法和函数），使得我们可以快速高效的使用这些封装好的功能，而jQuery 就是一个 JavaScript函数库 其他常见地js库还有Prototype、YUI、Dojo、ExtJS和移动端的zepto 优点： 1.轻量级，文件够小 2.跨浏览器兼容，基本兼容主流浏览器 3.链式编程、隐式迭代 4.对事件、样式、动画支持，极大地简化了dom的操作，支持插件扩展开发，有丰富的第三方插件 4.免费、开源 官网下载：https://jquery.com/ 最新版本早已不兼容ie6、7、8 等页面dom加载完毕再去执行代码（类似于DOMContentLoaded） //入口函数 $(function() { xxxx }) 要在页面引入官网下载的jQuery的js文件才能使用 2.jQuery的基本使用$是jquery的简称，一般在代码中用$替代jQuery $(function() { $(&#39;div&#39;).hide() }) 相当于 jQuery(function( jQuery(&#39;div&#39;).hide() ) {}) $是jQuery的顶级对象，相当于JavaScript的window，把元素$包装成jQuery对象，就可以调用jQuery方法 jQuery和dom用原生js获取的对象就是dom对象 用jQuery方式获取的对象就是jQuery对象 这两个对象是不一样的 jQuery对象的本质就是利用$对DOM对象包装后产生的对象（伪数组的形式储存） jQuery对象只能用jQuery方法，DOM对象则只能使用原生的JavaScript属性和方法 但是DOM对象和jQuery对象可以相互转换，因为原生js比jQuery更大，原生的一些属性和方法jQuery没有为我们进行封装，想要使用这些属性和方法需要把jQuery转换成DOM对象才能使用 //DOM转jQuery let myvideo = document.querySelector('video'); $(myvideo); //jQuery转DOM $('video')[index]或者$('video').get(index) $('video'); //获取元素 $('video')[0].play(); //将只有一个元素的视频过来并且使用DOM功能 3.jQuery的APIjQuery选择器$(&quot;选择器&quot;) 语法和CSS选择器一样即可 子代选择器 $(&quot;ul&gt;li&quot;) 后代选择器$(&quot;ul li&quot;) jQuery修改样式：$(&quot;div&quot;).css(&quot;属性&quot;, &quot;值&quot;) jQuery有隐式迭代，它会给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再循环，简化我们的操作 //一次性将所有选中的div元素背景颜色改为pink，不再需要for循环一个一个遍历更改 $(\"div\").css(\"background\", \"pink\"); jQuery筛选选择器 $(&quot;li:first&quot;) 选中第一个 $(&quot;li:last&quot;) 选中最后一个 $(&quot;li:eq(x)&quot;) 选中索引号为x的元素 $(&quot;li:odd&quot;) 选中索引号为奇数的元素 $(&quot;li:even&quot;) 选中索引号为偶数的元素 $(&quot;div&quot;).parent(); 返回的是最近一级的父元素 $(&quot;div&quot;).parents(); 返回的是所有祖先元素的数组，可以制定”()”里的类名单独指定是哪个祖先 $(&quot;div&quot;).children(&quot;ul&quot;); 返回指定的亲儿子，类似于子代选择器div&gt;ul $(&quot;div&quot;).find(&quot;li&quot;); 可以选定指定的所有孩子，类似于后代选择器 div li $(&quot;.item&quot;).sibling(&quot;li&quot;); 可以选定除本身外所有亲兄弟元素 $(&quot;li&quot;).eq(x); 选中索引号为x的元素, 类似$(&quot;li:eq(x)&quot;) ，但是此方法更推荐 $(&quot;li&quot;).hasCLass(&quot;类名&quot;); 查看是否有该类名，返回true或false jquery中的快速实现排他思想： $(function() { $(\"button\").click(function() { $(this).css(\"background\",\"pink\"); $(this).siblings(\"button\").css(\"background\", \"\") }) }) jQuery可以快速得到当前元素索引号，不再需要自己添加自定义属性index $(this).index() $(&quot;xxx:checked&quot;) 选择复选框中被选择的元素（$(&quot;xxx:checked&quot;).length为被选中复选框个数） jquery样式操作使用css方法： 1.参数只写属性名，返回属性值 $(this).css(&quot;color&quot;) 2.设置样式，属性名必须加引号，如果属性值值如果是数字可以不用跟单位和引号 $(this).css(&quot;color&quot;, &quot;red&quot;) 3.参数可以用对象的形式(里面的属性名不用加引号，如果如果属性值值如果是数字可以不用跟单位和引号) 如果是复合属性必须采取驼峰命名法（和DOM一样） $(this).css({ width: 400, height: 400, backgroundColor: \"green\" }) 直接设置类方式： 再写一个类，里面包含了所有你想要改变的样式，然后利用jQuery添加类功能，将其添加进去（注意直接添加类名，不需要 “.类名”） (原生js的className进行更改会覆盖原先的类名) // 1. 添加类 addClass() $(\"div\").click(function() { $(this).addClass(\"current\"); }); // 2. 删除类 removeClass() $(\"div\").click(function() { $(this).removeClass(\"current\"); }); // 3. 切换类 toggleClass() $(\"div\").click(function() { $(this).toggleClass(\"current\"); }); jQuery效果显示和隐藏效果 show([speed, [easing], [fn]]) 显示功能，参数可以省略， speed：三种预定字符串（”speed”,”normal”,”fast”）、或者使用毫秒数表示 easing：swing（在开头/结尾移动慢，在中间移动快）、linear（匀速） fn：回调函数 hide([speed, [easing], [fn]]) 隐藏功能，同上 toggle([speed, [easing], [fn]]) 切换（原本显示则隐藏，原本隐藏则显示） 滑动 slideDown([speed, [easing], [fn]]) 下拉显示，类似于手机官网那些下拉菜单，参数功能同上 slideUp([speed, [easing], [fn]]) 上拉隐藏，参数同上 slideToggle([speed, [easing], [fn]]) 拉动切换，参数同上 事件切换 hover([over],out) over: 鼠标移到元素上触发的函数（相当于mouseenter） out：鼠标移出元素触发的函数（类似于mouseleave） 简洁下拉菜单 $(\".nav>li\").hover(function() { $(this).children(\"ul\").slideDown(200); }, function() { $(this).children(\"ul\").slideUp(200); }); 或者 $(\".nav>li\").hover(function() { $(this).children(\"ul\").slideToggle(); }); 动画队列和其停止方法 上述下拉菜单代码有一个问题 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果的排队执行（即鼠标一次性经过多个选项，导致鼠标在一边停下来了之后，动画还在执行（因为还没执行完毕）） 停止排队： stop() stop()用于停止动画或者效果，将其写在动画或者效果的前面，相当于停止结束上一次的动画 //上述示例改进： $(\".nav>li\").hover(function() { $(this).children(\"ul\").stop().slideToggle(); }); 淡入淡出 fadeIn([speed, [easing], [fn]]) 淡入功能，参数可以省略， speed：三种预定字符串（”speed”,”normal”,”fast”）、或者使用毫秒数表示 easing：swing（在开头/结尾移动慢，在中间移动快）、linear（匀速） fn：回调函数 fadeOut([speed, [easing], [fn]]) 淡出 fadeToggle([speed, [easing], [fn]]) 淡入淡出切换 fadeTo([speed, opacity, [easing], [fn]]) 以渐进的方法修改透明度，opacity为透明度，必须写，取值范围0~1，speed也必须写 自定义动画animate animate(params, [speed], [easing], [fn]) params：想要更改的样式属性，以对象的形式传递，必须写，属性名可以不带引号，如果是复合属性需要采取驼峰命名法 其他的speed、easing、fn和之前相同 $(&quot;div&quot;).animate({ left: 500, top: 300, opacity: .4, width: 500 }, 500);4.jQuery属性操作element.prop(&quot;属性名&quot;) 获取属性值（固有的属性值） element.prop(&quot;属性名&quot;, &quot;属性值&quot;) 设置属性值 element.attr(&quot;属性名&quot;) 获取属性值（自定义属性），类似原生的getArribute element.attr(&quot;属性名&quot;, &quot;属性值&quot;) 设置属性值（自定义属性），类似原生的setArribute element.data(&quot;属性名&quot;, &quot;属性值&quot;) 设置数据缓存，data里的数据是存放在元素的内存中，而不是作为属性（这个方法可以获取data-index 即h5自带的自定义属性，不用写data-，写成$(“div”).data(“index”)） 5.jQuery内容文本值element.html() 获取元素内容（包含标签） 相当于原生的innerHTML element.html(&quot;内容&quot;) 设置元素内容 element.text() 获取元素内容（不包含标签） 相当于原生的innerText element.text(&quot;内容&quot;) 设置元素内容 element.val() 获取表单值 element.val(&quot;表单值&quot;) 设置表单值 6.jQuery的元素操作虽然jquery有隐式迭代，但是只是对同类元素做相同操作，如果想要给不同元素进行不同的操作，就需要使用到遍历 jQuery的遍历$(&quot;div&quot;).each(function (index, domEle) { xxxx; }) index（第一个参数）是每个元素的索引号，domELe（第二个参数）是遍历后的每个DOM元素对象，不是jQuery对象，如果想使用jQuery方法，需要给这个dom元素转换为jQuery对象（$(domEle)） $.each(object, function(index, element) { xxx; }) $.each() 方法可以用于遍历任何对象，主要用于数据处理，如数组、对象，index（第一个参数）为索引号（如果是对象，则为属性名），element（第二个参数）为遍历内容（如果是对象，则为属性值） 创建元素 $(&quot;&lt;li&gt;&lt;/li&gt;&quot;) 动态创建一个li标签 添加元素（创建完之后需要添加元素） 内部添加：（生成后它们是父子关系） element.append(&quot;内容&quot;) 放到匹配元素的最后面，类似于原生的appendChild element.prepend(&quot;内容&quot;) 放到匹配元素的最前，类似于原生的ul.insertBefore(xx, ul.children[0])(指定元素的前面) 外部添加：（生成后它们是兄弟关系） 外部添加：element.after(&quot;内容&quot;) 把内容放入目标元素的后面 element.before(&quot;内容&quot;) 把内容放入目标元素前面 删除元素element.remove() 删除匹配元素 element.empty() 删除匹配元素的所有子节点 element.html(&quot;&quot;) 清空匹配元素的内容（孩子） 7.jQuery事件事件注册element.事件(function() {}) 单个事件注册 如 $(&quot;div&quot;).click(function() {事件处理}) 其他事件和原生基本一致 事件处理on(可以绑定多个事件)on() 方法在匹配元素上绑定一个或多个事件的事件处理函数 element.on(events, [selector], fn) 1.events: 一个或多个用空格的事件类型，如”click” 2.selector: 元素的子元素选择器 3.fn：回调函数，即绑定在元素身上得到侦听函数 如 $(\"div\").on({ mouseenter: function() { //xxxxx }, click: function() { //xxxxx }, mouseleave: function() { //xxxx } }) 不同事件类型触发同一处理函数： $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() {}) on的优势2：可以进行事件委托如 //传统，但是给每个li都添加了一个事件，比较麻烦 $(\"ul li\").click(); //事件是绑定在ul身上，但是触发对象时li，li事件冒泡，冒泡到父级的点击事件然后执行程序 $(\"ul\").on(\"click\", \"li\", function() { }) 此前有blind()、live()等方法处理事件绑定或事件委托，但是我们最新版本用on就行了 on的优势3：动态创建元素，on可以给未来动态创建的元素绑定事件//传统，前面绑定事件，后面创建的标签没有绑定该事件 $(\"ol li\").click(function() {}) let li = $(\"&lt;li>xxx&lt;/li>\"); $(\"ol\").append(li); //使用on,之后创建的也能被给予绑定效果 $(\"ol\").on(\"click\", \"li\", function() {}) let li = $(\"&lt;li>xxx&lt;/li>\"); $(\"ol\").append(li); 事件off解绑off()方法可以移除通过on()方法添加的事件处理程序 element.off() 解绑该元素上所有事件 element.off(&quot;click&quot;) 解绑该元素上点击事件 $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() {}) $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;) 解除事件委托 只使用一次: 用one()来绑定有的事件只想触发一次，可以使用one来绑定 element.one(event, fn) 自动触发事件trigger比如click事件： 1.element.click() 2.element.trigger(&quot;click&quot;) 和上面的差不多 3.element.triggerHandler(&quot;click&quot;) triggerHandler不会触发元素默认行为（包括该元素绑定的其他行为），只触发”click” 事件对象element.on(events, [selector], function(event) {}) 中的event为事件对象 event.preventDefault() 或者return false 用于阻止默认行为 event.stopPropagation() 将其写于事件函数中，可以用于阻止冒泡 8.jQuery的其他方法jQuery拷贝对象$.extend([deep], target, object1, [objectN])（如果有冲突的，会覆盖掉targetObj 里面原来的数据） 1.deep: 如果为true为深拷贝，默认false为浅拷贝 （注意是复杂数据类型）浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝的对象，如果该复杂数据类型对象有冲突，直接覆盖掉 深拷贝，完全克隆，对于复杂数据类型拷贝的是对象，不是地址，修改目标对象不会影响被拷贝的对象（如果该复杂数据类型对象有冲突，但是里面的属性不冲突，则属性会合并在一起） //深拷贝时targetObject的msg会与obj的msg合并 //此时都有id，obj的id会覆盖掉targetObject的id var targetObject = { id: 0, msg: { sex: '男' //对象复杂数据类型 } }; var obj = { id: 1, name: 'andy', msg: { age: 18 } } $.extend(targetObject,obj); 2.target：要拷贝的目标对象 3.object1：待被拷贝到第一个对象的对象 （object拷贝给target） jQuery·多库共存随着jquery的流行，其他js库也会使用$作为标识符，这样一起使用会起冲突 需要一个解决方案，让jQuery和其他js库不存在冲突，可以同时存在，这就叫做多库共存 jquery解决方案： 1.把里面的$符号统一改为jQuery ，比如jQuery(“div”) 2.自定义，释放对$对控制权 var suibian = $.noConflict(); //var suibian = jQuery.noConflict(); suibian(\"span\") //原本是$(\"span\") jQuery插件jQuery功能比较有限，想要更加复杂的效果，可以借助jQuery插件（注：这些插件是依赖于jQuery，所以必须先引入jQuery文件，因此也成为jQuery插件） jquery常用网站： 1.jQuery插件库：http://www.jq22.com/ 2.jQuery之家：http://www.htmleaf.com/ (推荐) jQuery插件使用步骤：1.引入相关文件（jQuery、插件文件） 2.赋值相关html、css、js 图片懒加载: 在jQuery·插件可以找到，图片只加载到可视区域，减缓服务器压力 全屏滚动：jQuery的fullPage.js也十分好用 bootstrap也是依赖于jQuery开发的，因此里面的js插件使用，也必须引入jQuery文件 jQuery的位置位置主要有三个：offset()可设置、 position()只读、 scrollTop()/scollLeft()可设置 element.offset() 返回一个对象，里面包含left和top，用于设置或获取相对于文档document的偏移坐标 但是和原生不同的是，它可以设置偏移：element.offset({top: 10, left: 30})，且原生js的offset返回的是相对于父元素的偏移量 element.position() 获取带有相对于父级的偏移距离，如果没有定义父级，则以文档为准，但是此方法只能获取不能设置 element.scrollTop()/element.scrollLeft()设置或获取被卷去的头部和左侧，类似于原生js自带的元素滚动scroll","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"前端关于存储","slug":"前端关于存储","date":"2020-11-27T16:00:00.000Z","updated":"2022-05-28T02:27:42.473Z","comments":true,"path":"2020/11/28/qian-duan-guan-yu-cun-chu/","link":"","permalink":"https://taylor12138.github.io/2020/11/28/qian-duan-guan-yu-cun-chu/","excerpt":"","text":"本地存储使用HTML5可以在本地存储用户的浏览数据：local Storage、session Storage 1.数据存储于自己的浏览器当中 2.设置、读取十分方便，页面刷新数据不丢失 3.容量较大，sessionStorage约5M，localStorage约20M（可是我测试得到我chrome浏览器localStorage才5M） 4.只能存储字符串，可以将对象JSON.stringify() 编码后存储 cookie是网站为了标示用户身份而储存在用户本地终端上的数据；cookie数据始终在同源的http请求中携带（即使不需要），也会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存； 5.此外，User Data 是微软专门为IE在系统中开辟的一块存储空间，单个文件限制大小128kb，一个域名下可保存1M window.sessionStorage1.生命周期为关闭浏览器窗口 2.同一个窗口下数据可以共享 3.以键值对的形式存储使用 window.sessionStorage.setItem(key, value) 分别对应键和值，设置（添加或更改） window.sessionStorage.getItem(&#39;key&#39;) 获取 window.sessionStorage.removeItem(&#39;key&#39;) 删除 window.sessionStorage.clear() 删除所有数据(慎用)，不在Firefox中实现 4.所有现代浏览器在实现存储写入时都使用了同步阻塞方式，因此数据会被立即提交到存储。（除了老版IE） window.localStorage1.生命周期永久生效，除非手动删除，不然关闭页面仍然存在 2.多窗口共享（同一浏览器才能共享） 3.以键值对的形式存储使用 window.localStorage.setItem(key, value) 分别对应键和值，设置（添加或更改）（值是以字符串的形式进行存储的） window.localStorage.getItem(&#39;key&#39;) 获取 window.localStorage.removeItem(&#39;key&#39;) 删除 window.localStorage.clear() 删除所有数据(慎用)，不在Firefox中实现 CookieCookie是一种在客户端保持HTTP状态信息的技术：http协议是无状态的，但是在实际工作中，一些万维网网站希望能识别用户（给用户推销产品）=&gt;诞生了cookie小饼干（由服务器生成） cookie是存储在用户主机的文本文件，存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie，记录一段时间内某用户的访问记录 一旦浏览器保存了某个Cookie，那么以后每次访问服务器时，都会在HTTP请求头中将这个Cookie回传给服务器，所以我们前端这里几乎无需什么操作，几乎都是后端那边在操作 cookie数据大小不能超过4k 持久化cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 但是如果cookie不包含到期日期（Expires/Max-Age），则可视为会话cookie，它在浏览器关闭后就消失了 Web服务器怎么给客户端发Cookie的呢？服务器通过在HTTP响应头中增加Set-Cookie:字段，而浏览器则通过HTTP请求头增加Cookie字段回传 工作中识别用户给用户推销产品，用来保存一些不太敏感的数据（但我很纳闷，其实很多用户用cookie来记住密码，不过我看到一个答案就是：chrome是加密的，只是在密码管理里面明文显示而已。它是使用你Windows的登录密码加密的，还是比较安全的。） tips：一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token Cookie属性domain是域名 path是路径 两者加起来就构成了 URL，domain和path一起来限制 cookie 能被哪些 URL 访问。 某cookie的 domain为“baidu.com”, path为“/ ”，若请求的URL(URL 可以是js/html/img/css资源请求，但不包括 XHR 请求)的域名是“baidu.com”或其子域如“api.baidu.com”、“dev.api.baidu.com”，且 URL 的路径是“/ ”或子路径“/home”、“/home/login”，则浏览器会将此 cookie 添加到该请求的 cookie 头部中。 domain和path2个选项共同决定了cookie何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值 secure属性 secure 选项用来设置cookie只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 secure 选项的 cookie 才能被发送至服务器。 设置cookie服务端设置cookie cookie和session成对配合 + 生成 传 set-cookie字段，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段。 服务端可以设置cookie 的所有选项：expires、domain、path、secure、HttpOnly 客户端设置cookie document.cookie = \"name=Jonh\"; document.cookie = \"age=12\"; document.cookie = \"class=111\"; 但是红宝书推荐使用 encodeURIComponent 对名称和值进行编码 document.cookie = encodeURIComponent(\"name\") + \"=\" + encodeURIComponent(\"Jonh\"); encodeURIComponent()函数通过将一个，两个，三个或四个表示字符的UTF-8编码的转义序列替换某些字符的每个实例来编码 URI （对于由两个“代理”字符组成的字符而言，将仅是四个转义序列） 。 // encodes characters such as ?,=,/,&amp;,: console.log(`?x=${encodeURIComponent('test?')}`); // expected output: \"?x=test%3F\" console.log(`?x=${encodeURIComponent('шеллы')}`); // expected output: \"?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\" decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI） Sessioncookie和session都是用来跟踪浏览器用户身份的会话方式，通常使用cookie方式存储session ID到客户端 如果服务端直接是把用户信息放在cookie，并且每一次从客户端传过来使用的话，如果客户端偷偷更改数据，比如用户名，其实不是乱套了？所以服务端 不能 直接拿cookie来保存用户信息，然后直接来使用（也就是nodejs通过 res.cookie使用 ），所以存session id最稳妥 现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用 保持状态：cookie保存在浏览器端，session保存在服务器端 存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。 安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。 应用 cookie判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）；保存上次登录的时间等信息。 Session用于保存每个用户的专用信息，变量的值保存在服务器端，服务端会从请求传回来的 Cookie 中获取 SessionID，通过SessionID来区分不同的客户。 （1）网上商城中的购物车 （2）保存用户登录信息 （3）将某些数据放入session中，供同一用户的不同页面使用 （4）防止用户非法登录 cookie - session认证流程 1、用户向服务器发送用户名和密码。 2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 3、服务器向用户返回一个 session_id，写入 Cookie，（有时为了安全，分为多个cookie）传给客户端。 4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 session缺点： Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。 session持久化由于session是存储在服务器的内存中，如果服务器突然崩了，或者服务器关闭，那岂不是“七天免登录”存储功能失效了？ 此时服务端不能单单保存在服务器内存里，还要存到数据库中 session弊端当前登陆账号成功之后，别人只要拿到你的cookie（可以通过chrome插件一键导出cookie），然后别人就可以直接伪造你的身份直接拿cookie登录，所以在公共电脑，离开之后必须记得点击退出当前帐号，此时服务器就会销毁当前session Token上述展示了基于服务器验证的session（sessionID）暴露了一些弊端，当然使用session还有可能引起：跨域共享问题、CSRF攻击问题和可拓展性问题。 基于 Token 的身份验证是无状态的，我们不用将用户信息存在服务器或 Session 中。这种概念解决了在服务端存储信息时的许多问题。没有 session 信息意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录和已经登录到了哪里。 大多的token验证流程如下： 用户通过用户名和密码发送请求。 程序验证。 程序返回一个签名的 token 给客户端（令牌）。 客户端储存 token, 并且每次请求都会附带它。 服务端验证 token 并返回数据。（服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码） token优势 无状态（实际上是来自于JWT），无需存储session信息，负载均衡服务器，能够将用户请求传递到任何一台服务器上 可拓展，token保存在客户端本地，使用token可以和其他应用共享权限，比如将博客账号和qq账号进行关联，当通过第三方平台登录qq时，我们可以把博客发到qq平台中 安全性，防止CSRF攻击，请求中发送的是token而不是cookie，浏览器会将接收到的token值存储在Local Storage、sessionStorage或者cookie中 根据浏览器策略，通过domain和path传递cookie是浏览器行为（非人为控制），而token的获取需要通过js脚本控制，然后根据同源策略，b网站也只能拿到b网站的Local Storage、sessionStorage或者cookie中 在信任网站的HTML或js中，会向服务器传递参数token，不是通过Cookie传递的，若恶意网站要伪造用户的请求，也必须伪造这个token，否则用户身份验证不通过。 即使token存储再cookie中，同源策略限制了恶意网站不能拿到信任网站的Cookie内容（token的生成需要提取Cookie里面的内容进行生成），只能使用（只能携带，不能拿出来看！！），所以就算是token是存放在Cookie中的，恶意网站也无法提取出Cookie中的token数据进行伪造。也就无法传递正确的token给服务器，进而无法成功伪装成用户了。 移动端上不支持 cookie，而 token 只要客户端能够进行存储就能够使用，因此 token 在移动端上也具有优势。 不过，token有过期时间，超过事件后要重新获取token Token 的种类一般来说 token 主要三种： 自定义的 token：开发者根据业务逻辑自定义的 token JWT：JSON Web Token，定义在 RFC 7519 中的一种 token 规范 Oauth2.0：定义在 RFC 6750 中的一种授权规范，但这其实并不是一种 token，只是其中也有用到 token 附上登录认证的进化路程参考网址https://www.cnblogs.com/fengzheng/p/8416393.html （传统cookie-Session -&gt; 改造版cookie-session -&gt; 基于JWT的Token认证 -&gt; OAuth认证） 拦截器定义携带token本例使用axios带的请求拦截器，拦截请求，并且附带上token import MYRequest from './request' import { BASE_URL } from './request/config' const myRequest = new MYRequest({ baseURL: BASE_URL, interceptors: { requesInterceptor: (config) => { const token = '123' if (token &amp;&amp; config.headers) { config.headers.Authorization = `Bearer ${token}` } console.log('请求成功拦截', config) return config }, requstInterceptorCatch: (err) => { console.log('请求失败拦截', err) }, responseInterceptor: (config) => { // console.log('响应成功拦截', config) return config } } }) export default myRequest 内部上有： this.instance.interceptors.request.use( this.interceptors?.requesInterceptor, this.interceptors?.requstInterceptorCatch ) JWT 的组成和优势JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。 一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。中间用 . 分隔，例如：xxxxx.yyyyy.zzzzz 头部（Header）头部用于描述关于该JWT的最基本的信息 { &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot; }说明了这是一个JWT，并且我们所用的签名算法（后面会提到）是HS256算法 载荷（Payload）载荷中放置了 token 的一些基本信息，以帮助接受它的服务器来理解这个 token。同时还可以包含一些自定义的信息，用户信息交换。 Payload 部分也是一个 JSON 对象，JWT 规定了7个官方字段，供选用。 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 { \"iss\": \"John Wu JWT\", //签发者 \"iat\": 1441593502, //签发时间 \"exp\": 1441594722, //过期时间 \"aud\": \"www.example.com\", //受众 \"sub\": \"jrocket@example.com\", //主题 \"from_user\": \"B\", //自定义私有字段 \"target_user\": \"A\" //自定义私有字段 } 通过Node.js的包base64url来得到一个很长的字符串（ console.log(base64url(JSON.stringify(header))) ），如下图 签名（Signature）为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名 签名时需要用到前面编码过的两个字符串，使用 Header 里面指定的签名算法（默认是 HMAC SHA256） 加密算法对于不同的输入（头部和载荷）产生的输出总是不一样的，如果数据被修改，得到的签名总会是不一样的，而且，如果不知道服务器加密的时候使用密钥，得到的签名也会是不一样的。 如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token，返回一个HTTP 401 Unauthorized响应。 三者组合就形成了一个完整的JWT 建议 在JWT中，不应该在载荷里面加入任何敏感的数据（比如密码），怀有恶意的第三方通过Base64解码可以获取到JWT里的信息 虽说JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。（此时才可以写入秘密数据） 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 使用场景 完成加好友的操作，还有诸如下订单的操作 设计用户认证和授权系统，甚至实现Web应用的单点登录。 JWT和token的不同点Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。 JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。 JWT参考文章：http://blog.leapoahead.com/2015/09/06/understanding-jwt/ 阮一峰老师的介绍 http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html JWT详解攻略：https://learnku.com/articles/17883?order_by=vote_count&amp; JWT实战演练先进行安装 npm i jsonwebtoken npm i express-jwt jsonwebtoken: 用于生成 Token 。它也有解析 Token 的功能 express-jwt: 用于解析 Token（比 jsonwebtoken 解决方便） , 它把解析之后的数据，存放到 requset.user 中 jsonwebtoken 提供了sign(payload, secretOrPrivateKey, [options, callback])的方法。 sign ：对应的其实就是 JWT 签名(Signature)的动作 payload：对应的是传入的载荷，可以省略官方提供七个字段，额外添加自定义私有字段，比如用户信息userId等等 secretOrPrivateKey：自定义的密钥，属于敏感信息 options：可以配置 header 、荷载、指定算法类型（常用的只有 exp(expiresIn)有效时间 和 algorithm 算法类型这两个字段） 参考文章https://juejin.cn/post/6932374305758167054","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"PC&移动端网页特效(JS)","slug":"PC&移动端网页特效(JS)","date":"2020-11-17T16:00:00.000Z","updated":"2023-01-29T14:58:57.427Z","comments":true,"path":"2020/11/18/pc-yi-dong-duan-wang-ye-te-xiao-js/","link":"","permalink":"https://taylor12138.github.io/2020/11/18/pc-yi-dong-duan-wang-ye-te-xiao-js/","excerpt":"","text":"PC端1.offset元素偏移量我们使用offset系列相关属性可以动态获取元素的位置（大小）（父亲要定位此功能才有用 element.offsetTop 返回元素相对带有定位父元素上方的偏移，不带单位，如果没有定位或者没有父元素则以body为准 element.offsetLeft 返回元素相对带有定位父元素左方的偏移，情况同上 element.offsetWidth 返回自身宽度大小，自身宽度+padding+border element.offsetHeight 返回自身高度大小，同上 element.offsetParent 返回带有定位的父亲，否则返回body（element.parentNode 直接返回最近一级的父节点，不管父节点是否有定位） offset和style的区别：offset可以得到任意样式表的样式值 style只能得到行内样式表的样式值 offset系列获得的数值没有带单位 style.width获得的是带单位的字符串 offsetWidth等是包含padding+border style.width获得不包含padding和border的值 offsetWidth等属性是只读属性，只能获取不能赋值 style.width是可读写属性，可以赋值 所以offset适合读值，style适合赋值改值 一张图解offset 2.元素可视区client通过client系列的相关属性可以动态得到该元素的边框大小、元素大小等（与offset不同点是边框是否囊括其中） element.clientTop 返回元素上边框的大小 element.clientLeft 返回元素左边框的大小 element.clientWidth 返回自身包括padding、内容区的宽度，不包含border，返回数值不带单位 element.clientHeight 同上，返回高度 clientHeight 可以通过 CSS height + CSS padding - 水平滚动条高度 (如果存在)来计算. 备注: 此属性会将获取的值四舍五入取整数。 如果你需要小数结果, 请使用 element.getBoundingClientRect(). （番外）立即执行函数立即执行函数，不需要调用，直接执行 传统： function fn() {} fn(); 立执： (function(a, b) {}(1, 2)) //第一种 (function(a, b) {})(参数1, 参数2) //第二种 立即执行函数最大的优点就是独立创建了一个作用域 3.元素滚动scroll获取或设置一个元素的内容垂直滚动的像素数 有点像client，但是client是盒子的大小宽高，即使内容溢出后保持不变，但是scroll面对溢出状态的盒子，它提供的宽高与内容溢出的宽高相互关联。 以下的element，都是针对父盒子的，无论是事件监听or属性(记得父盒子小，子盒子要大于父盒子的大小，并且设置父盒子的css样式overflow: scroll 或者 overflow: auto) father.addEventListener('scroll', () => { console.log(father.scrollTop); }) element.scrollHeight 返回自身高度，不含边框，不带单位，像clientHeight + 超出文字部分高度 element.scrollWidth 返回自身宽度，不含边框，不带单位，像clientWidth + 超出文字部分宽度 element.scrollTop 返回被滚动条卷上去的上方距离，返回数值不带单位（要有滚动条，且内容大于盒子，往下拉的时候才会有） element.scrollLeft 返回被滚动条卷左的左侧距离，同上 (window的scroll没有scrollTop、scrollLeft，但是有个api可以获取当前网页的scrollTop： var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;) 滚动条在滚动时发生的事件：onscroll事件 检测整个页面的滚动属性： window.pageYOffset window.pageXOffset等 (ie9以上才支持) 让窗口滚动事件：window.scroll(x, y) 滚动事件方案antdesign对scroll的处理（滚动到屏幕顶部） https://github.com/ant-design/ant-design/blob/master/components/_util/scrollTo.ts#L34 网络上的一些滚动方案 https://www.cnblogs.com/nolaaaaa/p/9021967.html 三大系列总结offset常用于获取元素位置 element.offsetTop element.offsetLeft 只读的 client常用于获取元素大小 element.clientWidth element.clientHeight 只读的 scroll常用于获取滚动距离 element.scrollTop element.scrollLeft 可设置 4.滚动至浏览器的可视区域方法一：图片/元素的offsetTop &lt; 当前的元素父亲的scrollTop 图片/元素 offsetTop +图片/元素 offsetHeight &gt; 当前元素父亲的 scrollTop 方法二：window.scrollY &gt; 图片/元素的offsetTop 方法三：element.getBoundingClientRect(),返回的结果是包含完整元素的最小矩形，并且拥有left, top, right, bottom, x, y, width, 和 height这几个以像素为单位的只读属性用于描述整个边框。除了width 和 height 以外的属性是相对于视图窗口的左上角来计算的。 图片/元素的getBoundingClientRect().top &lt; window.innerHeight 且 图片/元素的getBoundingClientRect().bottom &gt; 0 方法四 IntersectionObserver API传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成性能问题。 目前有一个新的 IntersectionObserver API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。 var io = new IntersectionObserver(callback, option); callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。 // 开始观察 io.observe(document.getElementById('example')); // 停止观察 io.unobserve(element); // 关闭观察器 io.disconnect(); callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象 IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。 time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target：被观察的目标元素，是一个 DOM 节点对象 rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null boundingClientRect：目标元素的矩形区域的信息 intersectionRect：目标元素与视口（或根元素）的交叉区域的信息 intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0 实现懒加载实例 const observer = new IntersectionObserver(function(changes) { changes.forEach(function(element, index) { // 当这个值大于0，说明满足我们的加载条件了，这个值可通过rootMargin手动设置 if (element.intersectionRatio > 0) { // 放弃监听，防止性能浪费，并加载图片。 observer.unobserve(element.target); element.target.src = element.target.dataset.src; } }); }); function initObserver() { const listItems = document.querySelectorAll('list-item-img'); listItems.forEach(function(item) { // 对每个list元素进行监听 observer.observe(item); }); } initObserver(); 兼容性 Chrome 51+（发布于 2016-05-25） Android 5+ （Chrome 56 发布于 2017-02-06） Edge 15 （2017-04-11） iOS 支持 IE不支持。。。 more：阮一峰老师http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html Chrome 的黑科技——loading 属性从新版本 Chrome(76)开始，已经默认支持一种新的 html 属性——loading，它包含三种取值:auto、lazy 和 eager(ps: 之前有文章说是 lazyload 属性，后来 chrome 的工程师已经将其确定为 loading 属性，原因是 lazyload 语义不够明确)，我们看看这三种属性有什么不同： auto：让浏览器自动决定是否进行懒加载，这其中的机制尚不明确。 lazy：明确地让浏览器对此图片进行懒加载，即当用户滚动到图片附近时才进行加载，但目前没有具体说明这个“附近”具体是多近。 eager：让浏览器立刻加载此图片。 我们可以通过 chrome 的开发工具看看这个demo中的图片加载方式，我们把上一个 demo 中的 js 脚本都删掉了，只用了 loading=lazy 这个属性。接着，勾选工具栏中的 Disabled Cache 后仔细观察 Network 一栏，细心的人应该会发现，一张图片被分为了两次去请求！第一次的状态码是 206，第二次的状态码才是 200，如图所示： 要注意，使用这项特性进行图片懒加载时，记得先进行兼容性处理，对不支持这项属性的浏览器，转而使用 JavaScript 来实现，比如上面说到的 IntersectionObserver 使用： &lt;li class=\"list-item\"> &lt;img class=\"list-item-img\" alt=\"loading\" loading=\"lazy\" src='https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3648955221,727328923&amp;fm=26&amp;gp=0.jpg'> &lt;/li> 原理 浏览器会发送一个预请求，但是这个请求只拉取这张图片的头部数据，从这段数据中，浏览器就可以解析出图片的宽高等基本维度，接着浏览器立马为它生成一个空白的占位，此时返回206（范围请求） 在用户滚动到图片附近时，再发起一个请求，完整地拉取图片的数据下来，这个才是我们熟悉的状态码200请求。 面对连接数，不用怕，有http2.0的多路复用撑腰 兼容处理 if (\"loading\" in HTMLImageElement.prototype) { // 没毛病 } else { // ..... } 来源https://zhuanlan.zhihu.com/p/76820878 5.动画函数封装原理：获取盒子当前位置（position），通过定时器setinterval()不断移动盒子位置，利用定时器不断让盒子当前位置加上一个移动距离，最后加一个结束定时器条件（其实也可以用CSS animation 定义动画） &lt;div>&lt;/div> &lt;script> //简单动画函数封装obj目标函数，target目标位置 //给不同的元素制定了不同的定时器 //不过再js中尽量避免这一种“先创建再补充”的动态属性赋值 function animate(obj, target) { obj.timer = setInterval(function () { if (obj.offsetLeft >= target) { clearInterval(obj.timer); } else { obj.style.left = obj.offsetLeft + 5 + 'px'; } }, 30); } // 调用函数 let div = document.querySelector('div'); animate(div, 300); &lt;/script> 缓动动画：让元素运动速度有所变化 ，即让它每次移动的距离有所变化（如慢慢变小）就可以达到效果 比如可以：（目标值-现在位置）/10 作为每次移动的步长 停止条件：让盒子位置等于目标位置 动画函数添加回调函数：回调函数原理为函数作为一个参数，即将这个函数作为参数传到另一个函数里，当那个函数执行完毕之后，再执行传进去的这个函数，这个过程叫做回调 添加了一点细节和回调函数后的改进代码 //简单动画函数封装obj目标函数，target目标位置 //给不同的元素制定了不同的定时器 //不过再js中尽量避免这一种“先创建再补充”的动态属性赋值 function animate(obj, target, callback) { // 当我们不断点击按钮，元素速度会越来越快，因为开启了太多定时器 // 解决方案就是让我恩的元素只有一个定时器执行,清楚之前的定时器 clearInterval(obj.timer); obj.timer = setInterval(function () { // 把步长值改为整数，不要出现小数的问题 let step = (target - obj.offsetLeft) / 10; // 正值往小的取整，负值往大的取证, 保证数值刚好等于target（） step = step > 0 ? Math.ceil(step) : Math.floor(step); // 可以让800回到500，所以用== 而不是>= if (obj.offsetLeft == target) { clearInterval(obj.timer); // 如果有回调函数，在定时器结束时调用 /*if (callback) { callback(); }*/ //更棒写法 callback &amp;&amp; callback(); } else { obj.style.left = obj.offsetLeft + step + 'px'; } }, 30); } // 调用函数 let div = document.querySelector('div'); let btn500 = document.querySelector('.btn500'); let btn800 = document.querySelector('.btn800'); btn500.addEventListener('click', function () { animate(div, 500, function () { alert('hello') }); }) btn800.addEventListener('click', function () { animate(div, 800); }) 6.双击进入全屏这可以在很多浏览器中适用，但是 it won’t work in Safari。。 window.addEventListener(\"dblclick\", () => { if (!document.fullscreenElement) { canvas.requestFullscreen(); } else { document.exitFullscreen(); } }); 需要适配一下： window.addEventLisnter('dblclick', () => { if(!document.fullscreenElement) { canvas.requestFullscreem()'' } else { document.exitFullscreen(); } }) 移动端移动端兼容性较好，我们不需要考虑以前js的兼容问题，可以放心使用原生的JS书写，但是移动端也有自己独特的地方，如touch事件等 1.touch事件响应用户手指对屏幕的操作 touchstart 手指触摸到一个dom元素 （像mousedown） touchmove 手指在一个dom元素上滑动 （像mousemove） touchend 手指从一个dom元素上移开 （像mouseup） div.addEventListener('touchstart', function() {}) 移动端拖动原理：盒子原来的位置+手指移动的距离 拖动三部曲：（手指移动会触发滚动屏幕，所以要在这里阻止的屏幕滚动e.preventDefault()） 触摸 touchstart 获取初始坐标 移动手指 touchmove 计算手指滑动距离，并且移动盒子 离开手指 touchend //div加了绝对定位 &lt;div>&lt;/div> &lt;script> let startX = 0; let startY = 0; let x = 0; let y = 0; let div = document.querySelector('div'); div.addEventListener('touchstart', function (e) { // 获取第一个触碰的坐标 startX = e.targetTouches[0].pageX; startY = e.targetTouches[0].pageY; // 获取盒子的位置 x = this.offsetLeft; y = this.offsetTop; }) div.addEventListener('touchmove', function (e) { // 计算手指移动的距离，手指移动后坐标-手指初始坐标 let moveX = e.targetTouches[0].pageX - startX; let moveY = e.targetTouches[0].pageY - startY; // 移动盒子 this.style.left = x + moveX + 'px'; this.style.top = y + moveY + 'px'; // 阻止屏幕滚动 e.preventDefault(); }) &lt;/script> 无论是e中的 targetTouches 还是 touches 里面的item都属于一个 Touch 对象 touches：一个Touch对象代表一个触点，当有多个手指触摸屏幕时，TouchList就会存储多个Touch对象，前面说到的identifier就用来区分每个手指对应的Touch对象。 pageX、clientX、screenX的不同：https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y 2.移动端常见特效transitionend 事件移动端兼容性较强，在js制作时可以穿插 transform:translate(x, y) 、transition 等， 对于transition ，此时需要用到 transitionend 事件 ，等待过渡完成之后，再去判断是否到达最后一张，监听过渡完成事件 classList 属性它是h5新增的属性，返回元素的类名（返回形式为数组，因为一个元素可能包含多个类），但是ie10以上才支持（移动端也支持） let div = document.querySelector('div'); //返回第一个类的类名 console.log(div.classList[0]); 添加类名, 是追加，不会覆盖以前的类名，注意xx前面不用加 ‘.’ element.classList.add(&#39;xx&#39;) 移除类名 element.classList.remove(&#39;xx&#39;) 切换类名（原来有，就给你删除掉，原来没有，就给你加上） element.classList.toggle(&#39;xx&#39;) 移动端click问题移动端click事件会有300ms的延迟，原因是移动端双击会缩放页面 解决方案1：禁用缩放功能 &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt; 在最顶端的视口标签处写下user-scalable=no 解决方案2：利用touch事件自己封装： 手指触屏记录触摸时间 手指离开屏幕，用离开时间减去触摸的时间，若时间小于指定时间则没有缩放屏幕，定义为点击事件 禁止双指放大 document.documentElement.addEventListener('touchstart', function (event) { if (event.touches.length > 1) { //touches是一个 TouchList，其会列出所有当前在与触摸表面接触的 Touch 对象 event.preventDefault(); } }, false); 禁止双击放大 var lastTouchEnd = 0; document.documentElement.addEventListener('touchend', function (event) { var now = Date.now(); if (now - lastTouchEnd &lt;= 300) { event.preventDefault(); } lastTouchEnd = now; }, false); 解决方案3：使用fastclick插件 在 vue 中 npm i fastclick -S 在 main.js 中 import fastClick from 'fastclick' fastClick.attach(document.body) 展望现在谷歌的开发者文档《300ms tap delay, gone away》里面还提到在2014年的Chrome 32版本已经把这个延迟去掉了，如果有一个meta标签： &lt;meta name=\"viewport\" content=\"width=device-width\"> 即把viewport设置成设备的实际像素，那么就不会有这300ms的延迟，并且这个举动受到了IE/Firefox/Safari(IOS 9.3)的支持，也就是说现在的移动端开发可以不用顾虑click会比较迟钝的问题。 如果设置initial-scale=1.0，在chrome上是可以生效，但是Safari不会： &lt;meta name=\"viewport\" content=\"initial-scale=1.0\"> 还有第三种办法就是设置CSS： html{ touch-action: manipulation; } 这样也可以取消掉300ms的延迟，Chrome和Safari都可以生效。 3.摇一摇事件html5新增了一个devicemotion的事件，可以使用手机的重力感应。如下代码所示： window.ondevicemotion = function(event){ var gravity = event.accelerationIncludingGravity; console.log(gravity.x, gravity.y, gravity.z); } x，y，z表示三个方向的重力加速度 devicemotion事件会被不断地触发，根据以上，我们可以拿到摇摆的角度 + 时间间隔来判断用户是否是摇一摇！ 注意：ios 13 beat2 更新之后, devicemotion实践需要用户授权了 参考链接https://zhuanlan.zhihu.com/p/28052894 4.框架比如bootstrap，同样 来自于twitter，目前最受欢迎的前端框架(拿来主义) 中文官网：https://www.bootcss.com/ 官网：https://getbootstrap.com/ 2.x.x 已经停止维护，功能不够完善 3.x.x 目前使用最多，但已经放弃了ie6，ie7，对ie8支持但是界面效果不好，偏向于开发响应式布局，移动设备优先的web项目 4.x.x 最新版，但是目前不流行 根据官网的介绍引入js和结构即可使用 5.移动端滚动默认的滚动原理，在移动端十分卡顿 可以在github上安装 better-scroll 框架 让你的滚动更加丝滑 原生 JS 实现局部滚动：给定盒子高度，使用 overflow:scroll 使用better-scroll :（老师用的版本1.13.2） 安装 npm i better-scroll 基本使用在滚动内容外面套上一个 div 标签， class=&quot;wrapper&quot; 在js里引入并且使用 import BScroll from 'better-scroll' let wrapper = document.querySelector(\".wrapper\"); //滚动内容部分的元素 let scroll = new BScroll(wrapper, {}); //创建BScroll实例 如果在vue内使用，可以把创建BScroll对象放在 mounted生命周期钩子里 html部分： 注意：wrapper子元素只能有一个，所以不能直接绑定在ul上 注意：wrapper 在CSS里必须要有一个固定的高度 &lt;div class=\"wrapper\"> &lt;ul> &lt;!--许多的li --> &lt;/ul> &lt;/div> 事件监听BScroll创建出来的实例可以使用 on 监听事件 sroll是滚动事件 pullingUp是上拉事件 但是 *默认 *情况下 BScroll是不能实时监听滚动位置的，需要配置probeType better-scroll 管理的标签内部默认会阻止浏览器原生的click事件，需要配置click 必须在实例对象里开启pullUpLoad才能使用pullingUp事件，pullingUp事件只会触发一次，想要在发送网络请求，将新数据展示完毕继续使用该功能的话，需要 scroll.finishPullUp() new BScroll(wrapper, {配置option}) 1.重要配置属性probeType, probe：侦测, 默认值0（用scroll事件监听） 0、1都表示不侦测 1：非实时（屏幕滑动超过一定时间后）派发scroll 事件； 2：手指滑动时侦测，惯性滑动不侦测 3：只要滚动都进行侦测 2.click，默认值false better-scroll管理的标签内部默认会阻止浏览器原生的click事件 当设置为true的时候，better-scroll会派发一个click事件 3.pullUpLoad常用于上拉加载更多 默认值false 用pullingUp进行事件监听，传入boolean / Object ，设置为true或object开启功能 还有很多option配置，详情看官网 let wrapper = document.querySelector(\".wrapper\"); this.scroll = new BScroll(wrapper, { probeType: 2, click: true, pullUpLoad: true, }); //监听滚动事件 this.scroll.on(\"scroll\", (position) => { console.log(position); }); //回拉至x,y位置 //this.scroll.scrollTo(x, y[, time]); //监听上拉事件 this.scroll.on(\"pullingUp\", () => { console.log(\"上拉加载更多\"); }); //监听加载一次上拉事件，需要使用此函数才可以重新开启监听上拉事件 pullingUp this.scroll.finishPullUp(); // 修复better-scroll 因异步的网络请求图片到达，却未计算可滚动高度而无法滑动产生的bug，使用refresh进行刷新 this.scroll.refresh(); //输出滚条当前的x和y console.log(this.scroll.x); console.log(this.scroll.y); 解决better-scroll可滚动区域产生的bugbetter-scroll滚动区域是由 scrollHeight属性决定的，也就是content中子组件的高度 但有时因为异步操作（比如网络请求），导致 scrollHeight未能够计算出正确的组件高度 解决： 监听每一张图片加载完成（每一次的网络请求），只要有一张图片加载完成，就调用 refresh()一次 img.onload() = funciton(){}（vue中，监听加载则 @load=&quot;函数名&quot;） 使用事件总线 eventBus，管理、传递该加载事件到对应的组件，然后进行 refresh() 6.防抖函数有点像节流阀，节流阀：将多次执行变为在规定时间内只执行一次 也就是说，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。 防抖： 在规定的时间内执行多次事件只执行最后一次 （在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms） 上述 “解决better-scroll可滚动区域产生的bug” 操作我们可以看到，每有一张图片加载完成，则发送一次请求，这样会大大降低参加程序效率、性能 为此我们可以封装一个防抖函数 function debounce(func, delay) { let timer = null; return function (...args) { if (timer) clearTimeout(timer); timer = setTimeout(() => { // 这里的apply只用一个传入多个参数作用，箭头函数已经指向环境this，不需要用apply绑定 func.apply(this, args); }, delay); }; } 在vue中，我们可以在mounted里调用该函数 mounted() { // 监听goodListItem中图片加载完成 // 修复better-scroll 因异步的网络请求图片到达，却未计算可滚动高度而无法滑动产生的bug，使用refresh进行刷新 // 然后用防抖函数优化,减少函数调用频率 const refresh = this.debounce(this.$refs.scroll.refresh, 50); //得到一个带计时器的函数，里面保存着闭包的timer this.$bus.$on(\"itemImageLoad\", () => { refresh(); //调用refesh进行更新 }); }, 7.节流阀控制速度，用于类似于防止轮播图按钮连续点击，导致播放过快的后果 即当上一个函数动画内容执行完毕再去执行下一个函数动画，让事件无法连续触发 核心思路是：利用回调函数，添加变量进行控制。锁住函数和解锁函数 // 设置节流阀 let flag = true; arrow_r.addEventListener('click', function () { if (flag) { flag = false; fun(x, y, function () { flag = true; }); } }) 平时开发中常遇到的场景： 搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。 页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况） 这里借用老哥的节流代码 （附上原文https://segmentfault.com/a/1190000018428170/） function throttle(fn,delay){ let valid = true return function() { if(!valid){ //休息时间 暂不接客 return false } // 工作时间，执行函数并且在间隔期内把状态位设为无效 valid = false setTimeout(() => { fn() valid = true; }, delay) } } /* 请注意，节流函数并不止上面这种实现方案, 例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。 也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样 */ // 以下照旧 function showTop () { var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log('滚动条位置：' + scrollTop); } window.onscroll = throttle(showTop,1000) 其实也可以称之为前置防抖，因为可以这样写 // 前置执行的防抖 export const leadDebounce = (fn, delay = 400) => { let timer = null; return function () { if (timer) return; // eslint-disable-next-line prefer-rest-params if (fn) fn.apply(this, arguments); timer = setTimeout(() => { clearTimeout(timer); timer = null; }, delay); }; }; 8.异步竞态解决方案： 节流阀：可能导致用户点击无法响应 防抖：可能导致用户点击延迟相应 设置加载中的弹窗 闭包的方式：(React代码)，每一次重新渲染会重新加载useEffect，并且调用return里的函数，由此将闭包中的独立的didRequest改为true，使得数据无法更改（setState） 官方解释：如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除 useEffect(() => { let didRequest = false; 异步请求.then((data) => { if (!didRequest) { setState(xx); //.. } }); return () => didRequest = true; }) 9.懒加载我们可以在create-react-app、 next.js、webpack中使用懒加载，先设置初始值，等到用到的时候再异步加载 在react使用懒加载的一个小例子 const changeTime = async () => { const moment = await import(\"moment\"); setNowTime(moment.default(Date.now()).format()); }; 10.一些其他的优化 对于动画效果的实现，避免使用 setTimeout 或 setInterval，请使用 requestAnimationFrame。 将长时间运行的 JavaScript 从主线程移到 Web Worker。 使用微任务来执行对多个帧的 DOM 更改。 使用 Chrome DevTools 的 Timeline 和 JavaScript 分析器来评估 JavaScript 的影响。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"less样式","slug":"less样式","date":"2020-10-01T16:00:00.000Z","updated":"2022-07-02T07:52:16.187Z","comments":true,"path":"2020/10/02/less-yang-shi/","link":"","permalink":"https://taylor12138.github.io/2020/10/02/less-yang-shi/","excerpt":"","text":"less基础CSS的冗余度比较高，需要书写大量看似没有逻辑的代码，不方便维护，且无计算能力 而Less是CSS的拓展语言，也成为CSS预处理器（常见的CSS预处理器：Less、Sass、Stylus），可以计算（运算符的左右两侧必须加一个空格， 两个数参与运算，如果只有一个数有单位，最后结果以这个单位为准 两个数参与运算，如果两个数都有单位，以前面那个数字单位为准） Less的文件后缀名：.less （1）less变量@color: pink; /*@变量名:值;*/ @font: 14px; 使用： background-color: @color ; （2）less的编译需要把less编译成CSS才能放入H5使用 在VScode中安装easy-less插件，less文件保存后一键生成CSS文件 （3）less镶套在less不需要再 .header a {} 去选择后代选择器(再见) 可以直接： .header { width: 100px; a { color: red; } } 伪类选择器： .nav { &amp;:hover { color: blue; } &amp;::before { content: \"\"; } } 在一个less中可以引入另外一个less（套娃） @import \"common\"; /*导入conmon.less*/ Less函数each 类似于循环函数 先定义一个数组变量 @selectors: blue, green, red; 通过each(数组名, { .sel-@{value} {} });的方式获取数组中每一个值（ @{value} ） each(@selectors, { .sel-@{value} { a: b; } }); Outputs: .sel-blue { a: b; } .sel-green { a: b; } .sel-red { a: b; } 当然也可以通过定义对象变量，通过each函数分别得到每个对象的key、index、value @set: { one: blue; two: green; three: red; } .set { each(@set, { @{key}-@{index}: @value; }); } This will output: .set { one-1: blue; two-2: green; three-3: red; } range 传入一个数字，创建一个顺序数组列表 Examples: value: range(4); Outputs: value: 1 2 3 4; 搭配each来使用： each(range(4), { .col-@{value} { height: (@value * 50px); } }); Outputs: .col-1 { height: 50px; } .col-2 { height: 100px; } .col-3 { height: 150px; } .col-4 { height: 200px; } less和sassSass与Scss是什么关系? Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的s缩进。 （SASS版本3.0之前的后缀名为.sass，而版本3.0之后的后缀名.scss。） less和sass的区别 Less和Sass的主要不同就是他们的实现方式。 Less是基于JavaScript，是在客户端处理的。 Sass是基于Ruby的，是在服务器端处理的。 关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"移动&Web开发的常见布局(CSS)","slug":"移动&Web开发的常见布局(CSS)","date":"2020-10-01T16:00:00.000Z","updated":"2022-11-08T10:28:25.067Z","comments":true,"path":"2020/10/02/yi-dong-web-kai-fa-de-chang-jian-bu-ju-css/","link":"","permalink":"https://taylor12138.github.io/2020/10/02/yi-dong-web-kai-fa-de-chang-jian-bu-ju-css/","excerpt":"","text":"1.视口视口分类视口可以分为布局视口，视觉视口和理想视口 布局视口：一般移动设备浏览器都默认设置一个布局视口（980px），用于早期PC端页面在手机上显示的问题 缺点：使得元素看上去很小，字体小 视觉视口：用户正在看的网站区域，我们可以通过缩放操作视觉视口，但是不影响布局视口 理想视口：设定最理想的浏览和阅读宽度，与要手动添加meta视口标签通知浏览器（乔布斯发明） &lt;meta name=\"viewport\" content=\"width-device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"> content=”width-device-width” 适应窗口大小 user-scalable=no 不允许用户缩放 maximum-scale=1.0 初始的最小缩放比 minimum-scale=1.0 初始的最大缩放比 2.多倍图比如说2倍图，我们可以用2x图来描述，多倍图是为了在移动端上显示更加高清 在pc端，1px=一个物理像素，但是移动端不尽相同 移动端有物理像素比，可从px转化移动端时，（开发尺寸）px × 物理像素比 = 移动端显示的像素，我们可以通过 Window.devicePixelRatio //返回当前显示设备的*物理像素*分辨率与*CSS像素*分辨率之比 来查看当前的像素比 icon_alipay.png→iPhone 1-3代的手机(已经不考虑了) icon_alipay@2x.png→iPhone4/4S/5/5S/6/6S/7对应尺寸，这就是我们通常所说的2倍图 icon_alipay@3x.png→iPhone6P/6SP/7P使用的尺寸，这就是3倍图 https://www.zhihu.com/question/26195746 背景缩放background-size注意：background-size一定要放在background属性后设置 background-size用于规定背景尺寸 /*现有background: 才能设置*/ background-size: 图片宽度,图片高度; /*可以px，可以百分比（相对于父盒子）*/ background-size: cover; /*完全盖住盒子，可能图片显示不全*/ background-size: contain; /*宽高完全适应父盒子，父盒子可能有空白区域*/ 切图时可以用ps里的cutterman多倍切图 精灵图缩放1.使用工具（如firework）把精灵图缩放为原来的一半 2.根据大小测量坐标 3.注意代码里面的background-size也要写：精灵图原来的一半 （原图进行修改查看， 但是不要保存） （或者直接上，用chrome调试就行了） background-size: 宽度（原来的大小/倍数） 高度auto 3.移动端开发的选择1.单独移动端页面（主流）：京东、淘宝 pc和手机打开后显示的网页布局不同 2.响应式页面兼容移动端：三星官网 响应屏幕宽度，制作麻烦，需要大量调整兼容性 CSS的初始化推荐使用 normalize.css CSS3盒子模型传统盒子计算方式：CSS设置的width+border+padding CSS3盒子模型：盒子宽度=CSS设置的宽度width包含了border+padding 设置方式：(CSS高级部分讲过，但是使用此方法后文字使用line-heigh居中会有所影响,原因是我们要对其的是盒子内部中间的位置，即去除掉边框的高度的中间位置，但是line-heigh会把所有方框所有高度算进去) box-sizing:border-box; 移动端链接清除高亮移动端点击完链接 &lt;a&gt; 会出现高亮 ，清除高亮可用 -webkit-tap-highlight-color:transparent; 移动端链接清除外观效果在移动端浏览器默认的外观上在ios上加上这个属性才能给按钮和输入框自定义样式（清除原来的样式） -webkit-appearance: none; 禁用长安页面弹出菜单img, a {-webkit-touch-callout: none; } 4.移动端常见布局不需要像pc端一样排列版心 单独移动端页面（主流）：流式布局（百分比布局）（京东）、flex弹性布局（新闻网，强烈推荐）、less+rem+媒体查询布局（苏宁）、混合布局 流式布局也就是百分比布局，非固定像素布局，可自由伸缩 为了保护屏幕不被拉过宽（缩过窄），导致里面的元素显示出现问题，设置最大最小宽度 max-width: xxpx; min-width: xxpx; flex布局传统布局：兼容性好，布局繁琐，有一定局限 flex布局：操作方便，pc端浏览器支持差，IE11或者更低版本不支持或仅部分支持 flex可以让原本span（无法设置宽高）成功使用宽高属性，即不需要浮动，更不用清除浮动 （1）flex原理flex是flexible box的缩写，意为弹性布局，任何一个容器都可以指定为flex布局（谁都可以用，除了IE） 父盒子设置为flex后，子元素的float、clear、vertical属性都失效 采用flex布局的元素称为flex容器，他的所有子元素自动成为容器成员，称为flex项目，即它是通过给父盒子添加flex属性，来控制子盒子的位置和排列 （2）flex常见父项属性默认主轴方向是x轴，水平向右 侧轴方向是y轴 水平向下，我们的元素是跟着主轴排列地 flex-direction 设置主轴方向，剩下那个就自动变成侧轴 1.默认值row从左到右 2.row-reverse从右到左 3.column从上到下 4.column-reverse从下到上 justify-content 设置主轴上子元素的排列方式 1.flex-start默认 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.space-around平分剩余空间 5.space-between先两边贴边，再平分剩余空间 flex-wrap 设置子元素是否换行 默认不换行，装不开会缩小子元素的宽度，自动适应 nowrap：不换行，默认 wrap：换行 wrap-reverse：反着来换行 align-content 设置侧轴上的子元素的排列方式（多行）（即有换行情况）（单行情况下没用） 1.flex-start 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.stretch拉伸，默认 5.space-around平分剩余空间 6.space-between先两边贴边，再平分剩余空间 align-items 设置侧轴上的子元素的排列方式（单行） 1.flex-start 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.stretch拉伸，默认，但是子盒子不要带高度 flex-flow 复合属性，相当于同时设置flex-direction和flex-wrap flex-flow: column wrap; （3）flex常见子项属性flex属性，定义子项目分配剩余空间，用flex表示占有份数 flex: number;/*默认为0*/ 如果是flex：1的话，则将改行剩余空间全部划分给该子元素，不用设置宽高，且类似于百分比流式布局，可以根据窗口大小调节剩余空间大小 如果该行没有设置任何子元素在该行（假设当前主轴为x轴），然后将三个子元素设置flex：1，则每个盒子占33.33%的宽度（即设置该盒子的主轴长度） A设置flex:2 ， B设置flex:1 则A占比2/3，B占比1/3 (其实可以写百分比 即flex: 20%, 相对父级来说) align-self，控制子项自己在侧轴上的排列方式。 它允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items属性，默认值为auto，表示继承align-items的属性 span:nth-child(3) { align-self: flex-end; /*只让第三个盒子在侧轴上从尾部开始排列*/ } oder定义项目的排列顺序，数值越小，排名越靠前，注意，和z-index不一样（定位属性） span:nth-child(2) { order:-1; /*让2号盒子跑到1号盒子前面，因为默认是0，0&lt;1*/ } （4）flex的参数flex: 1 相当于 flex-grow：1 flex-shrink：1 flex-basis：0%。 第一个参数表示: flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 第二个参数表示: flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 第三个参数表示: flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小** 单值语法 等同于 备注 flex: initial flex: 0 1 auto 初始值，常用 flex: 0 flex: 0 1 0% 适用场景少 flex: none flex: 0 0 auto 推荐 flex: 1 flex: 1 1 0% 推荐 flex: auto flex: 1 1 auto 适用场景少 Rem适配布局（1）rem基础rem是一个单位（root em），是一个相对单位，类似于em，em是父元素的字体大小，如父元素的font-size为12px，子元素设置宽高为10em，则大小实际为10*12=120px；而不同的地方在于rem是相对于html元素的字体大小，rem的优点是可以通过修改html的文字大小来改变页面中的元素大小 （2）媒体查询媒体查询是CSS3的新语法，使用@media可以针对不同屏幕尺寸设置不同的屏幕样式 /*用@media开头，mediatype是媒体类型，关键字and、not、only，media feature是媒体特性，要用小括号包含*/ @media mediatype and|not|only (media feature) { CSS-Code; } mediatype查询类型： all 用于所有设备 print 用于打印机和打印预览 screen用于电脑屏幕，智能手机 媒体特性：暂且先了解三个 1.width 定义输出设备页面可见区域的宽度 2.min-width 定义输出设备页面最小可见区域宽度 3.max-width 定义输出设备页面最大可见区域宽度 @media screen and (max-width: 800px) and (min-width: 540px) { /*在屏幕上且最大宽度为800px且最小宽度为540px则设置该样式*/ body { background-color: pink; } } 当样式改变比较多的时候（如三星官网首页根据页面不同大小的变化样式的改变），可以针对不同的媒体使用不同的stylesheets（样式表）原理，直接在link中判断设备的尺寸，引用不同的CSS文件 &lt;link rel=\"stylesheet\" href=\"style320.css\" media=\"screen and (min-width: 320px)\"> 媒体查询最好的方法是从小到大 然后补充的一个点就是在@media：媒体查询第 4 级（第四版）（第五级仍然在起草）之后，支持这样的媒体查询写法： /* New Way */ @media (width &lt;= 768px) { … } @media (width >= 375px) { … } @media (375px &lt;= width &lt;= 768px) { ... } rem的实际适配1.按照设计稿与设备宽度比例，动态计算并设置html根标签font-size大小（屏幕宽度/划分的份数=font-size的大小）（划分份数有15、20、10都有可能，苏宁移动端网页是15） 2.CSS中，设计稿元素宽、高、相对位置等取值，按照同等比例换算为rem rem适配方案一：less 媒体查询 rem 适配方案二：flexible.js rem (推荐) flexible.js -&gt; rem再也不用太过繁琐的写下多个媒体查询，使用js做了处理 它的原理是把当前设备自动划分为10等份 会根据屏幕自动修改文字大小 github下载地址：https://github.com/amfe/lib-flexible 但是需要加一个限定弥补不足： /* 如果屏幕超过了750px, 那么我们按照750的设计稿走，不让我们的页面超过750px*/ @media screen and (min-width: 750px) { html { font-size: 75px!important; /*提权重*/ } } VScode -&gt; rem适配方案（add）：Vscode px转换rem插件cssrem （堪称外挂），及其好用 可以使得px直接转换rem 该插件默认的html字体大小为16px（根据当前页面大小（正常大小状态）/划分份数=得到我们应该设置的字体大小）,需要在设置里更改setting.json里的&quot;cssrem.rootFontSize&quot;: 16才可以 Grid布局也被称为网格布局。擅长于将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系（前提是HTML生成了这些区域）。类似于以下的效果 指定父元素横竖网格的大小（从而规定子元素的大小） #container{ display: grid; grid-template-columns: 50px 50px 50px; /*33.33% 33.33% 33.33%; 也可以*/ grid-template-rows: 50px 50px 50px; } 为了方便表示比例关系，网格布局提供了fr关键字（一下表示宽度比 1 ： 2） .container { display: grid; grid-template-columns: 1fr 2fr; } justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。 justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。 justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 可以看成和flex类似的部分 .container { justify-items: start | end | center | stretch; align-items: start | end | center | stretch; justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; } 详情可以参考阮一峰老师的教程https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html 响应式布局其原理就是根据媒体查询对不同宽度设备进行布局和样式设置，从而适配不同设备的目的 小屏幕（手机）&lt;768px 小屏设备（平板） &gt;=768px~&lt;992px 中等屏幕（桌面显示器）&gt;=992px~&lt;1200px 宽屏设备（大桌面显示器）&gt;=1200px @media screen and (max-width: 767px) { .container { width: 100%; } } @media screen and (min-width: 768px) { .container { width: 750px; } } @media screen and (min-width: 992x) { .container { width: 970px; } } @media screen and (min-width: 1200px) { .container { width: 1170px; } } (1)Bootstrap前端开发框架来自于twitter，目前最受欢迎的前端框架(拿来主义) 中文官网：https://www.bootcss.com/ 官网：https://getbootstrap.com/ 2.x.x 已经停止维护，功能不够完善 3.x.x 目前使用最多，但已经放弃了ie6，ie7，对ie8支持但是界面效果不好，偏向于开发响应式布局，移动设备优先的web项目 4.x.x 最新版，但是目前不流行 样式库的使用：1.创建文件夹结构（复制bootstrap的文件夹）-&gt; 2.创建html骨架结构（在bootstrap中文文档官网中找到bootstrap入门-基础模板）-&gt; 3. 引入相关样式文件 -&gt; 使用 (2)Bootstrap的布局容器bootstrap需要为页面内容和栅格系统包裹一个.container容器，Bootstrap预先定义好了这个类 .container已经定义好了响应式布局，如@media screen and (max-width: 767px)之类的 而.container-fluid类定义了流式布局（百分比布局） (3）Bootstrap的栅格系统亦称为网络系统，它指页面布局划分为等宽的列，通过样式定义来模块化页面布局（rem是把整个屏幕划分多个等份，这个是页面内容），bootstrap自动拓展到最多12等份 bootstrap里面的CSS已经包含了normalize.css即关于网页初始化的内容，所以不用再引入normalize.css进行初始化 栅格系统用于通过一系列的行row和列coloum的组合来创建页面布局 （行缩小到一定程度，模块进入下一个列）,实现列的平均划分，需要给列添加类前缀（添加类名），分别对应着响应式布局上面定义的四种媒体查询代码 超小屏幕列前缀.col-xs-小屏设备列前缀.col-sm-中等屏幕列前缀.col-md-宽屏幕列前缀.col-lg-有12份，让其占4分之一，即3份,所有盒子总和没达到12，则占不满，超过12，则另起一行（像浮动）.col-lg-3 大屏幕占4分之一，即3份，中等屏幕占3分之一，即4份，小屏幕占2分之一，即6份 .col-lg-3 col-md-4 col-sm-6 每一列的盒子里有默认左右15px的padding Bootstrap的列嵌套：父盒子会产生一个padding值，使得子盒子划分的时候没有按照父盒子的宽高划分，而是按照父盒子的宽高-padding值划分，所以在嵌套的时候最好加多一个盒子进行包装，并且此时子盒子和父级一样高： &lt;div class=\"col-md-4\"> &lt;div> &lt;div class=\"col-md-6\">&lt;/div> &lt;div class=\"col-md-6\">&lt;/div> &lt;/div> &lt;/div> &lt;div class=\"col-md-4\">&lt;/div> &lt;div class=\"col-md-4\">&lt;/div> &lt;div class=&quot;col-mid-4 col-md-offset-4&quot;&gt;&lt;/div&gt;的offset功能，在中间增加了4份的空格（1/3），实现每个盒子不必紧密相连的模型格式，其实可以把offset当成空盒子来看待 &lt;div class=&quot;col-md-4 colmd-push-8&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;col-md-4 colmd-pull-4&quot;&gt;右侧&lt;/div&gt;可以实现左右盒子颠倒的状态（做盒子推，右盒子拉） (4）响应式工具利用媒体查询功能，使用工具类可以方便针对不同设备展示或者隐藏页面内容（类似淘宝首页某类商品的隐藏） hidden-xs 超小屏：隐藏 小屏：可见 中屏：可见 大屏：可见 hidden-sm 超小屏：可见 小屏：隐藏 中屏：可见 大屏：可见 hidden-md 超小屏：可见 小屏：可见 中屏：隐藏 大屏：可见 hidden-lg 超小屏：可见 小屏：可见 中屏：可见 大屏：隐藏 &lt;div class=\"col-md-3 hidden-xs\">&lt;/div> 与之相反的是visible-xs，visible-sm等，可以实现广东财经大学首页的搜索栏隐藏模块功能 bootstrap官网里还有字体图标供给使用 bootstrap已经帮你写好清除浮动，只需添加类名clearfix 5.线性渐变颜色（针对于移动端）pc端需要很多私有前缀，特别麻烦，但是移动端只需要添加webkit就可以了 background: linear-gradient(起始方向,颜色1,颜色2); /*起始方向默认top*/ background: -webkit-linear-gradient(left,red,blue); /*一般都要添加-webkit-私有前缀*/ background: -webkit-linear-gradient(left top,red,blue); 6.CSS变量除了less可以声明变量，其实css自身也可以声明变量 CSS全局变量的声明是在变量名称前加两个中横线--，通常用于设置全局的主题颜色，主题背景颜色，字体大小等 :root { /* css定义变量的方式 */ /* 使用：var(变量名) */ --color-text: #666; --color-high-text: #ff5777; --color-tint: #fd5d7b; --color-background: #fff; --font-size: 20px; --line-height: 1.5; } /*使用*/ div { background-color: var(--color-tint); } 7.REM实战布局对于屏幕宽度小于600px，根字体大小设置为10vw 大于等于600px的按照 600px的屏幕宽度去计算，根字体大小同样给到10vw（适配pc端） 然后对改模板下所有px采取rem适配","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"matlab期末知识点汇总","slug":"matlab期末知识点汇总","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-06T09:30:41.436Z","comments":true,"path":"2020/08/06/matlab-qi-mo-zhi-shi-dian-hui-zong/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/matlab-qi-mo-zhi-shi-dian-hui-zong/","excerpt":"","text":"regress命令 用于一元及多元线性回归 B = regress(Y,X)[B,BINT] = regress(Y,X)[B,BINT,R] = regress(Y,X)[B,BINT,R,RINT] = regress(Y,X)B,BINT,R,RINT,STATS] = regress(Y,X)[…] = regress(Y,X,ALPHA) B：回归系数，类似于斜率，是个向量（“the vector B of regression coefficients in the linear model Y = X*B”）。BINT：回归系数的区间估计（“a matrix BINT of 95% confidence intervals for B”）。R：残差（ “a vector R of residuals”）。RINT：置信区间（“a matrix RINT of intervals that can be used to diagnose outliers”）。STATS：用于检验回归模型的统计量。有4个数值：判定系数R^2，接近1，回归方程越显著，F统计量观测值，F越大，回归方程越显著，检验的p的值，误差方差的估计。ALPHA：显著性水平（缺少时为默认值0.05）。 %导入数据 y=[7613.51 7850.91 8381.86 9142.81 10813.6 8631.43 8124.94 9429.79 10230.81 ... 10163.61 9737.56 8561.06 7781.82 7110.97]&#39;; x1=[7666 7704 8148 8571 8679 7704 6471 5870 5289 3815 3335 2927 2758 2591]&#39;; x2=[16.22 16.85 17.93 17.28 17.23 17 19 18.22 16.3 13.37 11.62 10.36 9.83 9.25]&#39;; X=[ones(size(y)) x1.^2 x2.^2 x1 x2 x1.*x2]; % size（）：获取矩阵的行数和列数 % s=size(A), 当只有一个输出参数时，返回一个行向量，该行向量的第一个元素时矩阵的行数，第二个元素是矩阵的列数。 % ones(M,N)产生一个M*N的矩阵 %开始分析 [b,bint,r,rint,stats] = regress(y,X);创建残差的置信区间图用regress返回的值r，rint：rcoplot（r，rint） 线性回归模型类线性回归模型类 wlb=LinearModel; %创建线性回归类对象，对象名wlb wlb=LinearModel.fit(x,y); %创建线性回归类对象，并对观测 数据做多元线性回归 wlb.plot %绘制wlb的效果图 wlb.anova %给出方差分析表 [y,ly]=wlb.predict(x) %给出x预测和置信区间 wlb.plotResiduals %绘制残差图 wlb. plotDiagnoisetics(method) %绘制不同统计量的残差图分 析 properties(wlb) %显示所有统计量属性t值和显著性水平有什么样的对应关系t-检验：可以用于比较两组数据是否来自同一分布。（可以用于比较两组数据的区分度） 在统计检验中，统计量t值和显著性水平具有什么样的对应关系？一般来说，大样本和正态分布情况下的数据，当1.65&lt;|t|&lt;1.96时,p&lt;0.10;当1.96&lt;|t|&lt;2.58时，p&lt;0.05；|t|大于2.58时，p&lt;0.01。 但是要注意的是，当样本量很小（小于30），数据分布形态不明或明显不服从正态分布（一座山一样的分布）时，t值和显著性水平不一定完全对应，例如t值绝对值大于2时，p值有可能大于0.05，也就是不显著。这种情况一般要采用非参数检验的方法，而不是t检验。 1、t值，指的是T检验，主要用于样本含量较小（例如n&lt;30），总体标准差σ未知的正态分布资料。T检验是用t分布理论来推论差异发生的概率，从而比较两个平均数的差异是否显著。 2、P值，就是当原假设为真时，所得到的样本观察结果或更极端结果出现的概率。如果P值很小，说明原假设情况的发生的概率很小，而如果出现了，根据小概率原理，我们就有理由拒绝原假设，P值越小，我们拒绝原假设的理由越充分。 p值代表的是不接受原假设的最小的显著性水平，可以与选定的显著性水平直接比较。例如取5%的显著性水平，如果P值大于5%，就接受原假设，否则不接受原假设。这样不用计算t值，不用查表。 3、P值能直接跟显著性水平比较；而t值想要跟显著性水平比较，就得换算成P值，或者将显著性水平换算成t值。在相同自由度下，查t表所得t统计量值越大，其尾端概率P越小，两者是此消彼长的关系，但不是直线型负相关 怎么得到检验回归系数显著性的T值对于X、Y两个正态总体的样本，其t检验应使用ttest2()函数来检验假设。[H,P,CI]=ttest2(X,Y) ttest2（）函数是用来检验具有相同方差的两个正态总体均值差的假设检验（即两正态总体的检验法）。 基本调用格式： h=ttest2（x，y）判断来自不同正态总体的样本数据x与y是否有相同的均值。当h=0表示接受原假设，当h=1表示拒绝原假设。 h=ttest2（x，y，alpha）调用格式表示执行显著性水平为（100*alpha）%的假设检验。没有给出alpha值，默认alpha=0.05。 h=ttest2（x，y，alpha，tail）调用格式表示执行以tail指定的备择假设作假设检验，原假设为均值等于m，当tail=‘both’时表明备择假设为“x与y均值不相等”，当tail=‘right’时表明备择假设为“x的均值大于y的均值”，当tail=‘left’时表明备择假设为“x的均值小于y的均值”。regstats函数（回归系数显著性检测？）MATLAB统计工具箱中提供了regstats函数，也可用来作多重线性或广义线性回归分析，它的调用方式如下：regstats(y,X,model)stats = regstats(…)stats = regstats(y,X,model,whichstats) 非线性用nlinfit函数或者开启cftool工具箱 eye函数该函数返回单位矩阵。 Y = eye(n)：返回n*n单位矩阵； Y = eye(m,n)：返回m*n单位矩阵；","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"数学建模国赛matlab知识点","slug":"数学建模国赛matlab知识点","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-22T07:55:04.587Z","comments":true,"path":"2020/08/06/shu-xue-jian-mo-guo-sai-matlab-zhi-shi-dian/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/shu-xue-jian-mo-guo-sai-matlab-zhi-shi-dian/","excerpt":"","text":"1.基础命令行太长，可加上三个小数点：“…” 进行分割（续行符），如 s=1-1/2+1/3-1/4... +1/5-1/6+1/7数值数据默认双精度double clear命令，清除工作区的所有变量 class(变量)得到变量类型 复型数据，虚数部分用i或j表示，如6+5i ，real函数求复数实部，imag函数求复数的虚部 以角度为单位的函数，在函数名后加“d”，如sin(pi/2)=sind(90) abs(xx)可求实数绝对值，复数的模，字符串的ascii码 rem(m,10)求m/10的余数 isprime(n)求n是否为素数，是返回1，否返回0 exp(pi/2)为e的2/Π次方 整形转换x=int8(129) //转有符号的int，最大127，即这里x=127 x=uint(129) //转无符号uint，即x=129 取整函数round()函数按照四舍五入 ceil()向上取整 floor()向下取整 fix()取靠近0的整数矩阵的建立//no.1 A=[1,2,3;4,5,6;7,8,9] //第一行1，2，3，第二行4，5，6冒号表达式e1:e2:e3 //分别为初始值，步长（两两之间间隔的大小，如果省略步长，则步长为1），终止值 inspace(a,b,n)//分别对应第一个元素，最后一个元素，元素总数（省略时为100）结构矩阵&amp;单位矩阵//结构矩阵 结构矩阵元素.成员名=表达式 a(1).x1=10; a(1).x2=&#39;liu&#39;; a(1).x3=[11,21;34,78]; //单元矩阵，用大括号 b={10,&#39;liu&#39;,[11,21;34,78]}2.矩阵引用矩阵元素A(3,2)表示A矩阵第三行，第二列元素 可用序号引用，如在A=[1,2,3;4,5,6;7,8,9]中，A(3)=7 (矩阵元素按列储存) D=sub2ind(S,I,J),分别为行数和列数组成的向量，转换矩阵元素的行下标，转换矩阵元素的列下标，D为序号（下标转序号） size(A)求矩阵A的行列数 [I,J]=ind2sub(S,D),分别为行数和列数组成的向量，序号（序号转下标） k=find(ch&gt;=&#39;a&#39;&amp;ch&lt;&#39;z&#39;) 找到符合条件的元素的序号 利用冒号获得子矩阵A(i,:) 第i行的所有元素 A(:,j) 第j列的所有元素 A(i:i+m,k:k+m) 第i~i+m行且在第k~k+m行的所有元素end运算符：表示某一维末尾下标 如：A(end,:)，是指A矩阵最后一行所有元素 利用空矩阵删除矩阵的元素将想要的元素范围赋值空矩阵[]即可，如A(:,[2,4])=[]，删除第二列，第四列元素 改变矩阵形状reshape(A,m,n)：在矩阵综援素不变的情况下，将A重新排列成m×n的二维矩阵 注意：并不改变元素个数及其储存顺序 A(:)：将矩阵A每一列元素堆叠起来成为一个列向量 3.算术运算&amp;字符串须知：加减运算两矩阵必须同型，乘法运算要求A行数和B的列数相同 点运算：两矩阵进行点运算是指它们对应元素进行运算，要求两矩阵同型 逻辑运算符：&amp;，|，~ 字符串和数值之间的转换：数值（ASCII码）=abs(字符串) 字符串=char(ASCII码) strncmp(s1,s2)：用于比较字符串s1，s2是否相等 strncmp(s1,s2,n)：用于比较字符串s1，s2前n个字符是否相等 strcmpi(s1,s2)：忽略大小写 4.特殊矩阵zeros函数：产生全零矩阵 ones函数：产生全1矩阵 eye函数：产生对角线为1的函数 rand函数：产生（0,1）区间均匀分布的随机矩阵 randn函数：产生均值为0，方差为1的标准正态分布随机矩阵 inv(矩阵)：求其逆矩阵 zeros(m):产生m×m零矩阵 zeros(m,n):产生m×n零矩阵特殊矩阵介绍： 魔方矩阵M=magic(8) (8行8列) 范德蒙矩阵vander(1:5) 希尔伯特矩阵：H=hilb(4) 伴随矩阵：A=compan(P) 帕斯卡矩阵：P=pascal(5) 对角阵对角矩阵：对角线上元素非零 数量矩阵：对角线上元素相等 对角矩阵：对角线上元素为1 diag(A)：提取矩阵A对角线元素，产生一个列向量 diag(A,k)：提取矩阵A第k条对角线元素，产生一个列向量 构造对角矩阵：diag(V)：以向量V为主对角线元素，产生对角矩阵 三角阵triu(A)：提取矩阵A的主对角线及以上的元素 tril(A)：提取矩阵A的主对角线及以下的元素 triu(A,k)：提取矩阵A的第k条主对角线及以上的元素 矩阵的转置A=[1,3;3+4i,1-2i] 转置：A.’ 共轭转置：A’ 若矩阵为实数，转置和共轭转置是一样的 矩阵旋转：rot90(A,k)，将矩阵A逆时针旋转90°的k倍，k为1可省略 矩阵左右翻转：fliplr(A) 矩阵上下翻转：flipud(A) 矩阵其他功能把一个方阵看作一行列式，并对其按行列式的规则求值：det(A) 求矩阵的秩：rank(A) 求矩阵的迹，即对角线元素之和：trace(A) 求矩阵A全部特征值，构成向量E：E=eig(A) 或者 [X,D]=eig(A) A的全部特征值构成对角阵D，X的各列是对应的特征向量 5.subplot画图subplot（m,n,p）或者subplot（mnp）此函数最常用：subplot是将多个图画到一个平面上的工具。其中，m表示是图排成m行，n表示图排成n列，也就是整个figure中有n个图是排成一行的，一共m行，如果第一个数字是2就是表示2行图。p是指你现在要把曲线画到figure中哪个图上，最后一个如果是1表示是从左到右第一个位置。 ） 6.MatLab中关于程序的操作建立函数，新建脚本，开头为： function C = 函数名( 参数A,参数B)，并且通过C返回（当有多个形参时，可用逗号分隔，而C为输出形参表，多个输出形参需要用方括号[] 括起来） 数据的输入：A=input(‘请输入A的值：’); 数据的输出：disp(输出项) 程序暂停：pause(延迟数秒),如果省略参数，则一直暂停，除非用户按任意键就可以继续执行 x^(1/3)=power(x,1/3) matlab中的switch case相对于C，java不需要break，且最后一个的default改成otherwise 匿名函数：简化了函数的过程：如f=@(x,y)x^2+y^2，f(3,4)进行调用，但是不适用于复杂函数 7.Plot函数plot(x,y)，x，y分别存储x，y坐标的数据 最简单的plot调用格式：plot(x)，下标为横坐标，值为纵坐标 x,y为同型矩阵，则分别对应x，y坐标绘画出曲线图 多条曲线可以plot(x1,y1,x2,y2,x3,y3……) x=linspace(0,2*pi,100) ,位置0到2pi的100个元素存于x plot（x,y,选项）选项有线性，颜色，数据点标记 线型：“ - ” 实线, “ : ”虚线, “ -. ”点画线, “ – ” 双画线 颜色：“ r ”红，“ g ”绿，“ b ”蓝。。。。。。 数据点标记：“ * ”星号，“ o ”圆圈，” s “方块。。。。 8.fplot函数fplot（f,lim,选项），f是函数，lim是x的取值范围，用二元向量[xmin,xmax]表示，默认[-5,5]，选项和plot相同 自变量无法间隔采样时使用fplot（函数变化趋势未知，或者在不同区间函数变化频率过大，如sin（x/1）） 9.曲线拟合polyfit（）进行拟合，找一个函数去逼近数据，再根据找到的函数预测下一个点的值（如 人口预测问题）（它实际上是求得最小二乘法拟合的多项式系数） p=ployfit（x,y,3）生成三次多项式函数，调用ployval（p,2020）进行计算（求2020年的人口）","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"模拟退火算法","slug":"模拟退火算法","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-07T03:16:44.061Z","comments":true,"path":"2020/08/06/mo-ni-tui-huo-suan-fa/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/mo-ni-tui-huo-suan-fa/","excerpt":"","text":"1.模拟退火算法可能的情况很多，数据量太大，用模拟退火搜索出需要的解（求最值）（最大值问题可以添加负号转换成求最小值问题） 启发式搜索：利用搜索过程中获取的信息改进搜索策略。启发式搜索有利于找到问题最优解，且有助于加速求解过程。 模拟退火可以说是最简单（应用）的启发式搜索之一 相比起爬山法（找到局部最优解），模拟退火算法有一定概率能接受比当前还要差的解，概率p位于[0,1]，旧解和新解的函数值越接近，p值就越大（概率为0对应爬山法，概率为1对应蒙特卡洛算法）；时间越长，p值越小；搜索前期p大，后期p小 2.搜索过程1.随机生成一个解A，计算F(A) 2.在A附近随机生成一个解B，计算F(B) 3.对比F(A)和F(B)，进行对比，若F(B)&gt;F(A)（求最大值）,B赋值A，F(B)&lt;F(A)，计算接受B的概率，接受则B赋值A，且重复以上操作，否则返回第2步，在原来A附近再生成一个B继续下去 如果优化问题有约束条件： 1.生成B是查看是否符合要求 2.使用罚函数 与时间相关的系数Ct如何设置：Ct是温度t的倒数（模拟退火） 如何再A附近随机生成一个解B：没有统一规定，需要具体问题具体分析 停止搜索1.达到迭代次数 2.达到指定温度 3.找到连续最优解，M（如30次）次迭代还未改变 3.实现产生新解： 1.matlab内置工具 根据温度不同，新解距离旧解的步长改变，温度高步长高，温度低步长短，由全局缩短为 x_new=x_i+T×z_i 然后检查x_new是否位于上下界 2.旅行商问题 交换法，位移法，倒置法","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"CSS渲染深究","slug":"CSS渲染深究","date":"2020-07-30T16:00:00.000Z","updated":"2022-06-19T15:30:15.071Z","comments":true,"path":"2020/07/31/css-xuan-ran-shen-jiu/","link":"","permalink":"https://taylor12138.github.io/2020/07/31/css-xuan-ran-shen-jiu/","excerpt":"","text":"CSS动画和JS动画的对比CSS动画优点： 动画流畅（以每一帧的间隔保证恰当的时间刷新UI） 性能较优 动画效果对帧速不好的低版本浏览器 代码简单，调优方向固定 缺点： 运行过程控制较弱,无法附加事件绑定回调函数 代码冗长 JS动画优点： JavaScript动画控制能力很强，动画能力强 兼容性好 CSS的repaint和reflow 以上为浏览器解析流程图(WebKit 主流程) 1、解析HTML以构建DOM树：渲染引擎开始解析HTML文档，转换树中的html标签或js生成的标签到DOM节点，它被称为 – 内容树；此外，CSS下载完之后对CSS进行解析，解析成CSS对象，然后把CSS对象组装起来，构建CSSOM树。 2、构建渲染树：解析CSS（包括外部CSS文件和样式元素以及js生成的样式），根据CSS选择器计算出节点的样式，在解析步骤中创建的CSSOM树和DOM树组合成一个Render树。（display: none;不会出现在render树上，visibility: hidden会出现在render树上，因为它们会占用空间）3、布局渲染树: 也就是layout，从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。4、绘制渲染树: 也就是paint，遍历渲染树，每个节点将使用UI后端层来绘制。 在 Chrome、Opera、Safari 和 Internet Explorer 中称为布局 (Layout)。 在 Firefox 中称为自动重排 (Reflow)，但实际上其过程是一样的。 reflow对节点大小和位置的重新计算称为回流reflow/ layout，每个页面至少需要一次回流（reflow/ layout），就是页面第一次加载的时候。 对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算并根据计算结果将元素放到它该出现的位置，过程称为reflow 它一般在DOM元素位置发生改变后触发，比如JS添加 DOM元素，CSS width的改变、CSS3的animation（animation里面藏着width的改变）、Scroll页面 repaint当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，过程称为repaint 它一般在改变 DOM 元素的视觉效果时触发，即不涉及任何排版布局的问题时触发，比如color、text-align、 注意：回流reflow一定会触发重绘repaint，而重绘不一定会回流 我们应该减少reflow和repaint的操作，提高渲染速度 reflow的成本比repaint高很多 下面操作可能导致高成本的消耗： 当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint。 当你移动 DOM 的位置，或是搞个动画的时候。 当你修改 CSS 样式的时候。 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。 当你修改网页的默认字体时。 display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint 优化方式 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className（或者使用的是vue、react等框架，虚拟dom会帮助你完成一次性的dom操作） 可以先把父元素隐藏起来，添加完子元素后，在把父元素显示出来；亦或者使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档 减少使用table布局 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量 使用transform、opacity、filters这些动画不会引起回流重绘，因为他们是在paint之后的 比如我在使用了transform:translate()后，无法获取正确的offsetTop、offsetLeft，由于他们未进行回流重绘，虽然视觉上确实是移动了，但是div在文档流中的位置是不变的 实质上Layout -&gt; Paint -&gt; 还有一个Composite(渲染层合并) 具体有关于会影响Layout的CSS属性可以在CSS Triggers网站中查阅。（可以方便我们优化） 浏览器对于回流重绘的优化现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程 但是：当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect 所以我们要有可能造成回流重绘时，要避免使用以上方法，导致队列进行刷新 关于特殊CSS属性的优化如果你修改一个非样式且非绘制的CSS属性，那么浏览器会在完成样式计算之后，跳过布局和绘制的过程，直接做渲染层合并。这种方式在性能上是最理想的。 不是所有属性动画消耗的性能都一样，其中消耗最低的是transform和opacity两个属性（当然还有会触发Composite的其他CSS属性），其次是Paint相关属性。所以在制作动画时，建议使用transform的translate替代margin或position中的top、right、bottom和left，同时使用transform中的scaleX或者scaleY来替代width和height。 transform在没有重绘的情况下，变换究竟是如何渲染动画的呢？基本答案是 CSS 转换直接发生在利用硬件加速的GPU内存中，从而避免了软件渲染。 渲染层（PaintLayer）PaintLayer 最初是用来实现 stacking contest（层叠上下文），以此来保证页面元素以正确的顺序合成（composite），这样才能正确的展示元素的重叠以及半透明元素等等。 将其分为常见的 3 类： NormalPaintLayer 根元素（HTML） 有明确的定位属性（relative、fixed、sticky、absolute） 透明的（opacity 小于 1） 有 CSS 滤镜（fliter） 有 CSS mask 属性 有 CSS mix-blend-mode 属性（不为 normal） 有 CSS transform 属性（不为 none） backface-visibility 属性为 hidden 有 CSS reflection 属性 有 CSS column-count 属性（不为 auto）或者 有 CSS column-width 属性（不为 auto） 当前有对于 opacity、transform、fliter、backdrop-filter 应用动画 OverflowClipPaintLayer overflow 不为 visible NoPaintLayer 不需要 paint 的 PaintLayer，比如一个没有视觉属性（背景、颜色、阴影等）的空 div。 合成层（Compositing Layers）合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。 渲染优化与此同时，我们通过CSS的属性来触发 GPU加速 浏览器会为此元素单独合成层，一个新的复合层。有了这一层，就有点React的PureComponent、usecallback内味了，进行局部更新，不影响他人。 为什么开启硬件加速动画就会变得流畅，那是因为每个页面元素都有一个独立的Render进程。 首先理解三个概念： CPU即中央处理器，它的功能主要是解释计算机指令以及处理计算机软件中的数据,也被称为主板。 GPU即图形处理器，是与处理和绘制图形相关的硬件。GPU是专为执行复杂的数学和几何计算而设计的，有了它，CPU就从图形处理的任务中解放出来，可以执行其他更多的系统任务。 硬件加速是指在计算机中透过把计算量非常大的工作分配给专门的硬件来处理来减轻CPU的工作量的技术。在CSS transition, transform和animation的世界里，他暗示我们应该卸载进程到GPU，因此加快速度。这种情况通过向它自己的层叠加元素，当加载动画的时候可以加速渲染。 有了新的“层”，就有了新的“Render进程”。Render进程中包含了主线程和合成线程，主线程负责： JavaScript的执行 CSS样式计算 计算Layout 将页面元素绘制成位图(Paint) 发送位图给合成线程 合成线程则主要负责： 将位图发送给GPU 计算页面的可见部分和即将可见部分(滚动) 通知GPU绘制位图到屏幕上(Draw) 我们可以得到一个大概的浏览器线程模型： 而在什么情况下我们可以单独创建出这样一个复合层(合成层)？ 它在以下情况下这样做： 对于 3D 或透视（opacity） CSS 转换（在我们的示例中），比如transform: translateZ(0)，注意它必须是 translateZ 对于&lt;video&gt;或&lt;canvas&gt;元素 使用 CSS 过滤器（filter）时 对于与提取到复合层的另一个元素重叠的元素（例如，使用z-index） 所以这时我们会想到：transfrom: translate(x, y)这种可以实现复合层吗？？？为什么2D没有会出现在上面的条件中？ 雀食可以，但是我们可以看到两个额外的重绘操作在动画时间轴的开始和结束 3D 和 2D 变换之间的区别在于 3D 变换使浏览器预先创建一个单独的复合层，而 2D 变换则是即时完成的。在动画开始时，会创建一个新的复合层并将纹理加载到 GPU，从而启动重绘。然后动画由 GPU 中的合成器执行。当动画完成时，附加的复合层将被移除，这将导致另一个重绘操作。 如何开启GPU加速？并非元素上的所有 CSS 属性更改都可以直接在 GPU 中处理。仅支持以下属性： transform opacity filter 因此，为了确保获得流畅、高质量动画的最佳机会，我们应该始终尝试使用这些 GPU 友好的属性。 或者尝试一下强制在GPU中渲染元素的方法：！ .example1 { transform: translateZ(0); } .example2 { transform: rotateZ(360deg); } 缺点： 没有什么是免费的！（英文直译hhh） 内存问题：最重要的问题与内存有关。向 GPU 加载过多纹理可能会导致内存问题 字体渲染：GPU 中的渲染会影响字体抗锯齿。这是因为 GPU 和 CPU 具有不同的渲染机制 will-change我们可能听听说过，3D transform会启用GPU加速①，例如translate3D, scaleZ之类，但是呢，这些属性业界往往称之为hack加速法。我们实际上不需要z轴的变化，但是还是假模假样地声明了，欺骗浏览器，这其实是一种不人道的做法。 使用“transform hack”来创建单独的复合层的必要性很麻烦。浏览器绝对应该提供一种直接的方法来做到这一点。这就是为什么引入了will-change 属性。这个功能可以让你通知浏览器哪个属性会发生变化，以便浏览器提前做相应的优化。 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。 这是一个通知浏览器transform属性将被更改的示例： .element { transition: opacity .3s linear; } /* declare changes on the element when the mouse enters / hovers its ancestor */ .ancestor:hover .element { will-change: opacity; } /* apply change when element is hovered */ .element:hover { opacity: .5; } 是不是有点缓存内味儿了？ 可惜并非所有浏览器都支持will-change，但是它出现已经有些时日了，兼容性这块Chrome/FireFox/Opera都是支持的。 使用 如果使用JS添加will-change, 事件或动画完毕，一定要及时remove. 比方说点击某个按钮，其他某个元素进行动画。点击按钮(click)，要先按下(mousedown)再抬起才出发。因此，可以mousedown时候打声招呼, 动画结束自带回调，于是（示意，不要在意细节）： dom.onmousedown = function() { target.style.willChange = 'transform'; }; dom.onclick = function() { // target动画哔哩哔哩... }; target.onanimationend = function() { // 动画结束回调，移除will-change this.style.willChange = 'auto'; }; 注意： 不能过度使用 + 要节制使用 + 不能过早使用will-change（因为会消耗内存） 而且任何带有 position: fixed 或者 position: absolute 的子元素将会相对于设置了 will-change: transform 的元素进行相对定位。所以在你使用的时候需要确保这种意料之外 containing block不会对你造成影响（类似于你要对子元素使用绝对定位，父元素不设置相对定位，但是父元素如果使用transform和will-change都会导致子元素按照父元素的位置来定位） 性能监控+合成层数量查看对于性能监控来说，我们可以直接使用浏览器自带的 Performance API 来实现这个功能。 我们只需要调用 performance.getEntriesByType(&#39;navigation&#39;) 亦或者再开发者模式下（F12）查看performance栏 使用 Chrome 的 DevTools 可以方便地查看页面的合成层数量选择 “More tools -&gt; Layers” 但是实际上针对不同移动端（ios和安卓）使用不同的浏览器，可能与本地电脑上调试时产生的合成层数量不同，这是手机浏览器的自带的层压缩策略不同而导致的 层爆炸由于某些原因可能导致产生大量不在预期内的合成层（也就是上方所谈及的复合层），虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。 首先回顾一下层的创建标准 从目前来说，满足以下任意情况便会创建层：1、3D 或透视变换(perspective transform) CSS 属性2、使用加速视频解码的 元素3、拥有 3D (WebGL) 上下文或加速的 2D 上下文的 元素4、混合插件(如 Flash)5、对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素6、拥有加速 CSS 过滤器的元素7、元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)8、有一个 Z 坐标比自己小的兄弟节点，且该节点是一个合成层(换句话说就是该元素在复合层的上层渲染) 而最容易不经意间产生层爆炸的是最后一条： 如果有一个元素，它的兄弟元素在复合层中渲染，而这个兄弟元素的z-index比较小，那么这个元素（不管是不是应用了硬件加速样式）也会被放到复合层中。 最可怕的是，浏览器有可能给复合层之后的所有相对或绝对定位的元素都创建一个复合层来渲染 例子演示http://fouber.github.io/test/layer/ 另外一个例子演示：(B被隐式提升为合成层) 但是如果调整一下b的位置 解决：人为提升动画元素（复合层标签）的z-index，让浏览器知道这个元素的层排序，就不会很傻地把其他z-index比它高的元素也弄到复合层中了 解决层爆炸最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰合成的排序，可以有效减少chrome创建不必要的合成层，也就是让他们回归普通的渲染层，提升渲染性能，移动端优化效果尤为明显。 或者把合成层的产生原因消除掉（在遍历元素中注意会引起层爆的样式） 层压缩因为合成层有很多种情况下都可以产生，甚至不经意间产生 （overlap），这严重影响到cpu性能和内存资源，浏览器也考虑到这一点，所以浏览器有它自己的层压缩策略（所以可能产生层爆炸的时候，可能并没有产生，因为浏览器对其进行了层压缩） 比如上面的层爆炸例子http://fouber.github.io/test/layer/，它在Chrome 94 Releases 版本被优化了。（我目前时Chrome 96）所以层压缩给得看浏览器版本 当然，浏览器也不是万能的，也有无法进行层压缩的情况，无法进行层压缩的情况：https://fed.taobao.org/blog/taofed/do71ct/performance-composite/ 在上面链接中淘宝前端团队也提及到 渲染优化的文章参考链接 参考链接https://github.com/amfe/article/issues/47 参考链接:https://www.w3cplus.com/css3/introduction-css-will-change-property.html 参考链接https://www.sitepoint.com/introduction-to-hardware-acceleration-css-animations/ 参考链接https://www.cnblogs.com/qiqi715/p/10207568.html 参考链接（淘宝技术团队）https://fed.taobao.org/blog/taofed/do71ct/performance-composite/ 参考链接（云音乐技术团队）https://segmentfault.com/a/1190000041197292","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Canvas","slug":"Canvas","date":"2020-07-30T16:00:00.000Z","updated":"2023-06-11T09:59:24.461Z","comments":true,"path":"2020/07/31/canvas/","link":"","permalink":"https://taylor12138.github.io/2020/07/31/canvas/","excerpt":"","text":"红宝书关于Canvas绘制图形需要先取得绘图上下文 let drawing = document.getElementByTagName('canvas'); if(drawing.getContext) { //... } 2D绘图2D上下文的坐标原点（0，0）在canvas标签的左上角，x向右增长，y向下增长 矩形fillRect、strokeRect、clearRect接收4个参数，分别为x坐标、y坐标、矩形宽度、高度 fillRect: 绘制矩形 + 填充 strokeRect: 绘制非实星填充 clearRect : 清除指定的矩形区域 if(drawing.getContext) { let context = drawing.getContext(\"2d\"); context.fillStyle = \"#ff000\"; context.fillRect(10, 10, 50, 50) } clearRect方法可以擦除画布中某个区域，让其变得透明 路径在绘制路径之前，需要“创建路径”，结束之后再“描画路径” beginPath：创建路径（线条） stroke：画路径 if(drawing.getContext) { let context = drawing.getContext(\"2d\"); context.beginPath(); //创建路径 //.. context.stroke();//描画路径 } 方法一：画初始点和末尾点 ctx.beginPath(); //我要开始画画了 ctx.strokeStyle = 'blue'; ctx.moveTo(80,40); //路径先初始点的坐标 ctx.lineTo(200,40); //路径先末尾点的坐标 ctx.stroke(); //我画完了 方法二：当然也可以通过画圆的方式来画 arc(x, y, radius, startAngle, endAngle, counterclockwise) x，y坐标为圆心 radius为半径，startAngle开始角度，endAngle结束角度 counterclockwise是否逆时针计算 ctx.arc(x, y, 30, 0, 2 * Math.PI); //画一个圆 ctx.arc(x, y, 30, 0, Math.PI); //画一个半圆 方法三：画一个弧 arcTo(x1,y1,x2,y2,r); 参数 描述 x1 两切线交点的横坐标。 y1 两切线交点的纵坐标。 x2 第二条切线上一点的横坐标。 y2 第二条切线上一点的纵坐标。 r 弧的半径。 变换当然我们也可以在其中使用我们熟悉的老朋友 rorate（angle） scale(scaleX, scaleY) translate(x, y)，执行这个操作之后，原本我们要仪仗的(0, 0)的原点坐标，变成了(x, y) 所有的变换，包括fillStyle、strokeStyle属性，都会一直保留在上下文中，直到再次修改他们。虽然没有办法明确地将所有之都重置为默认值，但是有两个方法可以帮我们跟踪变化：save()被调用之后，，当前时刻的所有设置会放到一个暂存栈中，之后调用 restore()方法可以取出并恢复之前保存的设置。 记住保存的是上下文的设置和变换，并没有保存上下文的内容。 绘制图像 或者可以使用 canvas.toBlob let img = document.imges[0]; context.drawImage(img, 10, 10) drawImage(图像, 绘制目标的x坐标, 绘制目标的y坐标) drawImage(图像, 绘制目标的x坐标, 绘制目标的y坐标, 目标宽度, 目标高度) toDataURL 转换图片为dataURL，一般使用为： canvas.getContent('2d').drawImage(img, 0, 0, widht, height) const dataUrl = canvas.toDataURL('image/png'); （1）usage在画布上定位图像： JavaScript 语法： context.drawImage(img,x,y); 在画布上定位图像 context.drawImage(img,x,y,width,height); 在画布上定位图像，并规定图像的宽度和高度： context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 剪切图像，并在画布上定位被剪切的部分 参数值 参数 描述 img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度（伸展或缩小图像）。 height 可选。要使用的图像的高度（伸展或缩小图像）。 （2）转化成图像或者将当前canvas转化成一个图像 &lt;canvas id=\"canvas\" width=\"5\" height=\"5\">&lt;/canvas> Copy to Clipboard 可以用这样的方式获取一个 data-URL var canvas = document.getElementById(\"canvas\"); var dataURL = canvas.toDataURL(); console.log(dataURL); // \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby // blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC\" 或许你想要获取的是图像的帧数据 const imageData = ctx.getImageData(0, 0, width, height); const pixelData = new Uint8Array(imageData.data.buffer); 此时还能用upng进行压缩 import UPNG from 'upng-js'; //.... const pngData = UPNG.encode([pixelData], width * scale, height * scale, 256); （3）压缩图片质量var base64 = canvas.toDataURL('image/jpeg', quality); type 可选 图片格式，默认为 image/png encoderOptions 可选 在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。 Chrome支持“image/webp”类型。 （4）获取图像信息CanvasRenderingContext2D.getImageData() 返回一个ImageData对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点为(sx, sy)、宽为sw、高为sh。 语法 ctx.getImageData(sx, sy, sw, sh);Copy to Clipboard 参数 sx 将要被提取的图像数据矩形区域的左上角 x 坐标。 sy 将要被提取的图像数据矩形区域的左上角 y 坐标。 sw 将要被提取的图像数据矩形区域的宽度。 sh 将要被提取的图像数据矩形区域的高度。 （5）画一个圆并且塞入图像ctx.save(); ctx.beginPath(); ctx.arc(x + radius, y + radius, radius, 0, 2 * Math.PI); // 画一个圆 ctx.closePath(); ctx.clip(); ctx.drawImage(userAvator, x, y, radius * 2, radius * 2); （6）canvas在高清屏幕的绘制由于 canvas 不是矢量图，而是像图片一样是位图模式的。高 dpi 显示设备意味着每平方英寸有更多的像素。也就是说二倍屏，浏览器就会以2个像素点的宽度来渲染一个像素，该 canvas 在 Retina 屏幕下相当于占据了2倍的空间，相当于图片被放大了一倍，因此绘制出来的图片文字等会变模糊。 我们可以先把所有的宽高比都设置成 * dpr 比如设置canvas宽高（style）为 320px × 400px，则 const dpr = window.devicePixelRatio || 2; export const MODAL_WIDTH = 320; export const MODAL_HEIGHT = 400; myCanvas.style.width = MODAL_WIDTH + 'px'; myCanvas.style.height = MODAL_HEIGHT + 'px'; myCanvas.width = MODAL_WIDTH * ratio; myCanvas.height = MODAL_HEIGHT * ratio; 绘制内部： 方法1: const context = myCanvas.getContext('2d'); context.font = \"36px Georgia\"; //一倍屏下18px字体 context.fillStyle = \"#999\"; context.fillText(\"我是清晰的文字\", 50*ratio, 50*ratio);// 坐标位置乘以像素比 方法2: const context = myCanvas.getContext('2d'); context.scale(ratio, ratio); context.font = \"18px Georgia\"; context.fillStyle = \"#999\"; context.fillText(\"我是清晰的文字\", 50, 50); 小实战画一个刮刮乐 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\" /> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> &lt;title>Document&lt;/title> &lt;style> #ggk { width: 400px; height: 100px; position: relative; left: 50%; transform: translate(-50%, 0); } .jp, canvas { position: absolute; width: 400px; height: 100px; left: 0; top: 0; text-align: center; font-size: 25px; line-height: 100px; color: deeppink; } &lt;/style> &lt;/head> &lt;body> &lt;h1 style=\"text-align: center\">刮刮乐&lt;/h1> &lt;div id=\"ggk\"> &lt;div class=\"jp\">不抽大嘴巴子&lt;/div> &lt;canvas id=\"canvas\" width=\"400\" height=\"100\">&lt;/canvas> &lt;script> document.addEventListener(\"selectstart\", function (e) { e.preventDefault(); }); let canvas = document.querySelector(\"#canvas\"); let ctx = canvas.getContext(\"2d\"); ctx.fillStyle = \"darkgray\"; ctx.fillRect(0, 0, 400, 100); let ggkDom = document.querySelector(\"#ggk\"); let jp = document.querySelector(\".jp\"); let isDraw = false; canvas.onmousedown = function () { isDraw = true; }; canvas.onmousemove = function (e) { if (isDraw) { let x = e.pageX - ggkDom.offsetLeft + ggkDom.offsetWidth / 2; console.log(e.pageX, 'pageX', ggkDom.offsetLeft, 'ggkDom.offsetLeft', ggkDom.offsetWidth / 2, 'ggkDom.offsetWidth / 2'); let y = e.pageY - ggkDom.offsetTop; ctx.beginPath(); ctx.arc(x, y, 30, 0, 2 * Math.PI); ctx.globalCompositeOperation = \"destination-out\"; ctx.fill(); ctx.closePath(); } }; document.onmouseup = function () { isDraw = false; }; &lt;/script> &lt;/div> &lt;/body> &lt;/html> globalCompositeOperation：合成属性 Canvas 2D API 的 Canvas.globalCompositeOperation 属性设置要在绘制新形状时应用的合成操作的类型，其中 type 是用于标识要使用的合成或混合模式操作的字符串。 它的每个属性值在官网里都有图文介绍：https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation 当然，在w3c网上面也有介绍：https://www.runoob.com/w3cnote/html5-canvas-intro.html source-over: 旧画布图形直接覆盖新的图形 source-in: 仅会出现旧画布图形和新的图形重叠的部分（展示新图像），有点像&amp;&amp;的感觉 source-out: 仅显示新图形部分，且仅仅新图形与老图形没有重叠的部分，其余部分全部透明 destination-over: 新图像会在老图像的下面。 destination-in: 仅会出现旧画布图形和新的图形重叠的部分（展示老图像），有点像&amp;&amp;的感觉 destination-out: 仅显示老图形部分，且仅仅老图形与新图形没有重叠的部分，其余部分全部透明 Canvas.fill() 是 Canvas 2D API 根据当前的填充样式，填充当前或已存在的路径的方法。采取非零环绕或者奇偶环绕规则。 Canvas.closePath() 是 Canvas 2D API 将笔点返回到当前子路径起始点的方法。它尝试从当前点到起始点绘制一条直线。如果图形已经是封闭的或者只有一个点，那么此方法不会做任何操作。 其他小案例取自菜鸟教程 一个小太阳、一个是小时钟案例 https://www.runoob.com/w3cnote/html5-canvas-intro.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>菜鸟教程(runoob.com)&lt;/title> &lt;style> body { padding: 0; margin: 0; background-color: rgba(0, 0, 0, 0.1) } canvas { display: block; margin: 200px auto; } &lt;/style> &lt;/head> &lt;body> &lt;canvas id=\"solar\" width=\"300\" height=\"300\">&lt;/canvas> &lt;script> init(); function init(){ let canvas = document.querySelector(\"#solar\"); let ctx = canvas.getContext(\"2d\"); draw(ctx); } function draw(ctx){ requestAnimationFrame(function step(){ drawDial(ctx); //绘制表盘 drawAllHands(ctx); //绘制时分秒针 requestAnimationFrame(step); }); } /*绘制时分秒针*/ function drawAllHands(ctx){ let time = new Date(); let s = time.getSeconds(); let m = time.getMinutes(); let h = time.getHours(); let pi = Math.PI; let secondAngle = pi / 180 * 6 * s; //计算出来s针的弧度 let minuteAngle = pi / 180 * 6 * m + secondAngle / 60; //计算出来分针的弧度 let hourAngle = pi / 180 * 30 * h + minuteAngle / 12; //计算出来时针的弧度 drawHand(hourAngle, 60, 6, \"red\", ctx); //绘制时针 drawHand(minuteAngle, 106, 4, \"green\", ctx); //绘制分针 drawHand(secondAngle, 129, 2, \"blue\", ctx); //绘制秒针 } /*绘制时针、或分针、或秒针 * 参数1：要绘制的针的角度 * 参数2：要绘制的针的长度 * 参数3：要绘制的针的宽度 * 参数4：要绘制的针的颜色 * 参数4：ctx * */ function drawHand(angle, len, width, color, ctx){ ctx.save(); ctx.translate(150, 150); //把坐标轴的远点平移到原来的中心 ctx.rotate(-Math.PI / 2 + angle); //旋转坐标轴。 x轴就是针的角度 ctx.beginPath(); ctx.moveTo(-4, 0); ctx.lineTo(len, 0); // 沿着x轴绘制针 ctx.lineWidth = width; ctx.strokeStyle = color; ctx.lineCap = \"round\"; ctx.stroke(); ctx.closePath(); ctx.restore(); } /*绘制表盘*/ function drawDial(ctx){ let pi = Math.PI; ctx.clearRect(0, 0, 300, 300); //清除所有内容 ctx.save(); ctx.translate(150, 150); //一定坐标原点到原来的中心 ctx.beginPath(); ctx.arc(0, 0, 148, 0, 2 * pi); //绘制圆周 ctx.stroke(); ctx.closePath(); for (let i = 0; i &lt; 60; i++){//绘制刻度。 ctx.save(); ctx.rotate(-pi / 2 + i * pi / 30); //旋转坐标轴。坐标轴x的正方形从 向上开始算起 ctx.beginPath(); ctx.moveTo(110, 0); ctx.lineTo(140, 0); ctx.lineWidth = i % 5 ? 2 : 4; ctx.strokeStyle = i % 5 ? \"blue\" : \"red\"; ctx.stroke(); ctx.closePath(); ctx.restore(); } ctx.restore(); } &lt;/script> &lt;/body> &lt;/html> 其中用到了save方法 let canvas = document.querySelector(\"#solar\"); let ctx = canvas.getContext(\"2d\"); ctx.save(); // Canvas 2D API 通过将当前状态放入栈中，保存 canvas 全部状态的方法；你可以理解为每一次绘制完一个针后记录下来，存到栈中，然后restore的时候返回初始状态，不影响上一个针的绘制效果 ctx.restore(); //回到save之前的状态 可以看一下这里的mdn例子加深下理解：https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/save 还有一个 ctx.clearRect(0, 0, 300, 300) CanvasRenderingContext2D.clearRect()是 Canvas 2D API 的方法，这个方法通过把像素设置为透明以达到擦除一个矩形区域的目的。 备注： 如果没有依照 绘制路径 的步骤，使用 clearRect() 会导致意想之外的结果。请确保在调用 clearRect()之后绘制新内容前调用beginPath() 。 可以理解为一个命令行中 clear的操作 参考： 使用Canvas制作刮刮乐，看看你能刮出什么奖品来？ pixijs1.pixi基础使用 PixiJS ，我们首先应该创建一个 Pixi 应用，并且添加到当前的节点处 // 创建一个Pixi 应用 let app = new PIXI.Application({width: 256, height: 256}); // 把 Pixi 应用中创建出来的 canvas 添加到页面上 document.body.appendChild(app.view); 容器（container）容器是用来装载多个显示对象的， 它可以用 PIXI.Container() 方法来创建，可以把它看成一个小组件，里面可以包裹多个精灵，或者其他容器等 精灵（spirite）精灵是可以放在容器里的特殊图像对象， 它可以用 PIXI.Sprite() 方法来创建。精灵是你能用代码控制图像的基础。你能够控制他们的位置，大小，和许多其他有用的属性来产生交互和动画，我自己感觉spirite对于pixi就像dom对于document一样 纹理（Texture） 因为 Pixi 用 WebGL 和 GPU 去渲染图像，所以图像需要转化成 GPU 可以处理的格式。可以被 GPU 处理的图像被称作 纹理 。在你让精灵显示图片之前，需要将普通的图片转化成 WebGL 纹理。 为了让所有工作执行的快速有效率，Pixi会自动使用 纹理缓存 来存储和引用所有你的精灵需要的纹理。纹理的名称字符串就是图像的地址。这意味着如果你有从&quot;images/cat.png&quot; 加载的图像(注意是图像，不会把json也给你存进来)，我们可以在纹理缓存中这样找到他： PIXI.utils.TextureCache[\"images/logo.png\"]; 那该如何将它转化成纹理？那就是是用Pixi已经构建好的loader对象（下方有loader的使用）,通过loader加载过的图片，都可以在PIXI.utils.TextureCache中找到 PIXI.Application 会自动选择使用 Canvas 或者是 WebGL 来渲染图形，这取决于您的浏览器支持情况 我们通常使用Pixi提供的Application方法来创建一个实例应用（app），它能自动创建我们等下讲到的renderer，ticker 和container、loader 注意：pixi从v3到v5，再到v7，关于loader的语法变动很多，大家需要注意网上学习的语法是哪个版本的，比如v5是没有的loader是没有on来监听事件的，v7甚至没有loader Application option: autoStart 布尔值 default 选修的构建完成后自动开始渲染。 注意：将此参数设置为 false 不会停止共享代码，即使您将 options.sharedTicker 设置为 true 以防它已经启动。自己阻止吧。 width 数字 选修的渲染器视图的宽度。 height 数字 选修的渲染器视图的高度。 view HTML画布元素 选修的用作视图的画布，可选。 transparent 布尔值 False 选修的如果渲染视图是透明的。 autoDensity 布尔值 False 选修的以 CSS 像素为单位调整渲染器视图的大小，以允许 1 以外的分辨率。 antialias 布尔值 False 选修的设置抗锯齿 preserveDrawingBuffer 布尔值 False 选修的启用绘图缓冲区保存，如果您需要在 WebGL 上下文中调用 toDataUrl，请启用此功能。 resolution 数字 1 选修的渲染器的分辨率/设备像素比，视网膜将为 2，移动端一般要根据window.devicePixelRatio 来。 forceCanvas 布尔值 False 选修的阻止选择 WebGL 渲染器，即使存在，此选项仅在使用pixi.js-legacy或@pixi/canvas-renderer模块时可用，否则将被忽略。 backgroundColor 数字 0x000000 选修的渲染区域的背景颜色（如果不透明则显示）。 clearBeforeRender 布尔值 True 选修的这会设置渲染器是否会在新的渲染通道之前清除画布。 powerPreference 细绳 选修的传递给 webgl 上下文的参数，对于具有双显卡的设备设置为“高性能”。（仅限 WebGL）。 sharedTicker 布尔值 False 选修的true使用 PIXI.Ticker.shared，false创建新的代码。如果设置为 false，则您无法将处理程序注册为在共享代码上运行的任何内容之前发生。系统代码将始终在共享代码和应用程序代码之前运行。 sharedLoader 布尔值 False 选修的true使用 PIXI.Loader.shared，false创建新的 Loader。 resizeTo 窗口 | HTML元素 application还有个销毁的方法： （removeView，stageOptions） removeView 布尔值 &lt;可选&gt; 错误的 自动从 DOM 中移除画布。 stageOptions 对象 | 布尔值 &lt;可选&gt; 选项参数。布尔值将表现得好像所有选项都已设置为该值 stageOptions.children 布尔值 &lt;可选&gt; 错误的 如果设置为 true，所有的孩子也将调用他们的 destroy 方法。’stageOptions’ 将传递给那些调用。 stageOptions.texture 布尔值 &lt;可选&gt; 错误的 如果 stageOptions.children 设置为 true，则仅用于子 Sprites。它是否应该破坏子精灵的纹理 stageOptions.baseTexture 布尔值 &lt;可选&gt; 错误的 如果 stageOptions.children 设置为 true，则仅用于子 Sprites。它是否应该破坏子精灵的基础纹理 app.destroy(true, {}); application滑动问题： // 可滑动 app.renderer.view.style.touchAction = 'auto'; app.renderer.plugins.interaction.autoPreventDefault = false; 2.loader类似于threejs的loader，threejs的loader种类繁多，但是pixijs的loader只有一种，是一个用于加载资源的东西，由 Chad Engler 从 Resource Loader 派生而来，用于加载资源，传入2个参数则可以设置别名 import * as PIXI from 'pixi.js'; const loader = new PIXI.Loader(); loader.add('bunny', 'data/bunny.png') .add('images/logo.png') .add('spaceship', 'assets.json') .add(\"logo\", \"images/logo.png\") .load(init); function init((loader, resources)) { // 以指定名稱的方式去取用 Texture Cache var sprite = new PIXI.Sprite(loader.resources.logo.texture); var sprite = new PIXI.Sprite(resources.logo.texture); //或者这样 var sprite2 = new PIXI.Sprite(loader.resources['spaceship'].texture); } add也可以传入数组 let app = new PIXI.Application({ width: 256, height: 256 }); app.loader .add([ \"images/imageOne.png\", \"images/imageTwo.png\", \"images/imageThree.png\" ]) .load((loader, res) => { console.log(loader === app.loader) //true }); 关于loader还有一些监听事件 //可取得下載進度 loader.onProgress.add((e) => { }); //載入檔案錯誤時 loader.onError.add((target, e, error) => { }); //每一次加载的回调 loader.onLoad.add((e, target) => { }); //全部加载完成后回调 loader.onComplete.add(() => { }); V7 and loaderpixi团队一直想要删除loader，因为它的遗留方法（例如，XMLHttpRequest），是从 resource-loader 衍生出来的，Loader 最初的设计灵感主要是由 Flash/AS3 驱动的，现在看来已经过时了。我们希望从新的迭代中获得一些东西：静态加载、使用 Workers 加载、后台加载、基于 Promise、更少的缓存层。这是一个简单的例子，说明这将如何改变： import { Loader, Sprite } from 'pixi.js'; const loader = new Loader(); loader.add('background', 'path/to/assets/background.jpg'); loader.load((loader, resources) => { const image = Sprite.from(resources.background.texture); }); 现在变成： import { Assets, Sprite } from 'pixi.js'; const texture = await Assets.load('path/to/assets/background.jpg'); const image = Sprite.from(texture); 删除loader缓存资源正常我们将资源从stage移除之后，utils.TextureCache依然会存在loader加载过的资源缓存 通过 sprite.destroy() 资源依然存在。 真正删除需要： sprite.destroy({texture: true, baseTexture: true}); 移除TextureCache、BaseTextureCache 纹理，并且会从stage消失 还有个children选项，若 children 设定为 true 時，會將 destroy() 的其他屬性如 texture: true 與 baseTexture: true 再傳入子物件、子孙物件 PIXI.BaseTexture：纹理存储表示图像的信息。所有纹理都有一个基础纹理。 PIXI.Texture：纹理存储表示图像或图像的一部分的信息。它不能直接添加到显示列表中。而是将其用作 Sprite 的纹理。如果没有提供框架，则使用整个图像。 PIXI.Texture 是对 PIXI.BaseTexture 的引用 sprite.destroy - 将销毁精灵，使 PIXI.Texture 和 PIXI.BaseTexture 保持不变sprite.destroy(true); - 将破坏精灵和 PIXI.Texture；PIXI.BaseTexture 保持不变sprite.destroy(true, true); - 将销毁精灵、PIXI.Texture 和 PIXI.BaseTexture 通常，您不希望每次调用 addSprite() 时都创建 PIXI.Texture 并在 removeSprite() 中销毁它。即使这是在 Pixi 内部处理的并且没有创建重复的纹理。提前创建你的纹理，将它们存储到数组中并在需要时选择一个。在没有其他精灵使用它时销毁 PIXI.Texture，并在完全完成后销毁 PIXI.BaseTexture。 并且通常不太建议销毁 Texture，因为：销毁 PIXI.Texture 不会释放内存，它只会使纹理无效并将其从图像缓存中删除，因此其他精灵将无法使用它。我真的不知道什么时候必须调用它 销毁 PIXI.BaseTexture 会释放绑定到它的 WebGL 对象。为您使用的动态纹理或不再需要的一些静态调用它。 3.设置精灵属性比如我上面加载了一个sprite，可以设置大小、缩放、位置 sprite.position.set(20, 20) sprite.x = sprite.x + 10 // 可以对 x、y 的某一项单独设置 // 缩放 sprite.scale.set(num, num) // 大小 sprite.width = sprite.width + 10 // 旋转 sprite.rotation += 0.1 mask 为 displayObject 设置掩码。蒙版是一种对象，它将对象的可见性限制为应用于它的蒙版的形状。在 PixiJS 中，常规掩码必须是 PIXI.Graphics或PIXI.Sprite对象。这允许在画布中更快地进行遮罩，因为它使用形状剪裁。 你可以直接理解为就是蒙版。裁剪的时候用到它 import { Graphics, Sprite } from 'pixi.js'; const graphics = new Graphics(); graphics.beginFill(0xFF3300); graphics.drawRect(50, 250, 100, 100); graphics.endFill(); const sprite = new Sprite(texture); sprite.mask = graphics; 设置文本 + 文本局中 + 气泡外框 // 创建文本对象 const text = new Text('您好，这是一条弹幕消息！', { fontSize: 16, fill: 0xffffff }); text.anchor.set(0.5); // 计算文本的长度 const textWidth = text.width; // 创建弹幕气泡对象 const bubble = new Graphics(); bubble.beginFill(0x000000, 0.8); bubble.drawRoundedRect(0, 0, textWidth + 20, 30, 15); bubble.endFill(); text.position.set(bubble.width / 2, bubble.height / 2); 4.pixijs的事件pixijs的两种渲染模式，都不是以dom结构为基础（可以联想到canvas），所以需要使用它内置的事件： pointerdown：类似于 mousedown。 pointerup：类似于 mouseup。 pointerover：类似于 mouseover。 pointerout：类似于 mouseout。 pointermove：类似于 mousemove。 现在我们给sprite添加事件 // 第一步：设置元素为可交互的 cat.interactive = true; // 第二部：监听对应的事件 cat.addListener('pointerdown', (e) => { cat.alpha = 0.5 //类似CSS3滤镜filter }); 我们也可以通过代码来触发事件 cat.emit('pointerdown') 5.pixijs绘制图形熟悉canvas的同学都知道，canvas可以利用 fillRect、moveTo、lineTo等随喜所欲画一些简单的矢量图形，pixijs也不例外 其中beginFill、endFill可以理解为canvas的 beginPath、stroke是一个道理 //画一个矩形 let rectangle = new PIXI.Graphics(); // 外边框的颜色 rectangle.lineStyle(4, 0xFF3300, 1); // 给矩形的内部填充颜色 rectangle.beginFill(0x66CCcc); // 绘制矩形。它的四个参数是 x, y, width, height rectangle.drawRect(0, 0, 64, 64); // 结束绘制 rectangle.endFill(); // 创建一个半径为32px的圆 const circle = new Graphics(); circle.beginFill(0xfb6a8f); circle.drawCircle(0, 0, 32); //x\\y\\半径 circle.endFill(); 6.给容器添加元素和threejs一样（threejs是往scene里添加东西），我们做好的元素，要往PIXI的容器（container）里面加，然后再通过，才能显示到屏幕上 app.stage是一个pixijsContainer的实例，作为最底层的舞台(stage)，所有要渲染的图形都应放在它的内部 我们可以选择直接添加在pixi的app.stage上，也可以创建一个自定义的container，然后再添加到app.stage上（自定义container好处在于，比如说修改container的透明度，位于其中的子节点，都会受到影响） // 自定义Container const myContainer = new Container(); // 相对于根节点偏移 myContainer.position.set(40, 40); myContainer.addChild(rectangle); app.stage.addChild(myContainer); document.body.appendChild(app.view); 实际上这里的app.view就是app.renderer.view，打印出来是一个canvas 7.渲染器Rendererapp.renderer是一个Renderer的实例，熟悉threejs的同学应该不陌生，如果WebGL 可以用，那么application自带的就是一个Renderer，否则为一个CanvasRenderer，它将场景及其所有内容绘制到支持 WebGL 的画布上。每当我们的元素变动，就需要重新渲染，然后我们就可以看到动画效果 renderer PIXI.Renderer | PIXI.CanvasRenderer // 把画布重新渲染为500*500大小 app.renderer.resize(500, 500); // 渲染一个容器 const container = new Container(); app.renderer.render(container); 通过打印renderer的type属性可以查看他的类型 console.log(app.renderer.type); 渲染模式 取值 UNKNOWN 0 WEBGL 1 CANVAS 2 改变容器(渲染器)的底色 app.renderer.backgroundColor = 0x061639; 要更改画布的大小，请使用renderer的resize方法，并提供任何新的width和height值。但是，为了确保画布的大小调整到与分辨率匹配，请将autoResize设置为true。 app.renderer.autoResize = true; app.renderer.resize(512, 512); 8.TickerTicker有点类似前端的requestAnimationFrame，当然大部分情况，我们也可以用 requestAnimationFrame来替代Ticker 在pixi源码可以看到，我们在注册application的时候，application会在初始化时注入ticker插件（Application.registerPlugin(TickerPlugin);） 他还会默认帮我们把autoStart干成true // 自定义ticker const ticker = new Ticker(); // 每次屏幕刷新重新渲染，否则只会渲染第一帧 ticker.add(() => { chanziAnimate.x += 1; }); function gameLoop() { chanziAnimate.x += 1; renderer.render(stage); // 重新渲染,如果是使用application初始化，可以忽略这一行，因为application.ticker在不断执行 requestAnimationFrame(gameLoop); } requestAnimationFrame(gameLoop); 尝试一下吧～https://codesandbox.io/s/elated-wind-5j60fu?file=/src/MoveDemo.js Ticker可以实现简单的动画，但如果我们希望实现一些复杂效果，则需要自己编写很多代码，这时就可以选择一个兼容pixi的动画库。市面上比较常见的动画库有：Tween.js，TweenMax（它包括了GreenSock动画平台的大部分核心功能） chatGPT: 总的来说，TweenMax 更加强大，而 TweenJS 更加轻量级。TweenMax 的学习曲线可能会比 TweenJS 更陡峭，但是它可以提供更多的控制和功能。如果您需要一个全面的动画库，或者需要创建复杂的动画效果，那么 TweenMax 可能是更好的选择。如果您只需要简单的 Tween 功能，并且希望使用更轻量级的库，那么 TweenJS 可能更适合您。 如果你不存在需要持续动画渲染的功能，可以选择关闭app.ticker的启动： app.ticker.stop(); //等到需要时再渲染： app.render(); 其他图片合成前端有时会把多张图片合并成一张图片（雪碧图），而不是一张一张去加载。。通过设置background-position来显示不同的图片。pixi.js也有类似的技术，我们可以利用Texture Packer软件，把多张图片合并成一张图片，合并的同时，软件会生成一份json配置文件，记录了每张图片的相对位置。 具体教程见这里 首先下载 -&gt; 拖动所需图片文件至texure packer，他将会自动生成 制作动画： 复选右边的图片，然后点击预览动画就可以看到图片连续起来的动画效果 然后点击发布精灵表 就会对应生成一个json文件（记录每个图像名字、大小、位置）和一个png文件（雪碧图） spritesheetSritesheets：https://pixijs.io/guides/basics/sprite-sheets.html 一般spritesheet用于是一张大的雪碧图（png），并且配合上一个json文件，json文件记录了雪碧图每个图片的位置以及其他信息 import { Application, Container, Sprite, Graphics, Loader, Spritesheet } from 'pixi.js'; // myjson记录了每张图片的相对位置 import myjson from './assets/treasureHunter.json'; // mypng里面有多张图片 import mypng from './assets/treasureHunter.png'; const loader = Loader.shared; const app = new Application({ width: 300, height: 300, antialias: true, transparent: false, resolution: 1, backgroundColor: 0x1d9ce0 }); document.body.appendChild(app.view); loader .add('mypng', mypng) .load(setup) function setup() { const texture = loader.resources[\"mypng\"].texture.baseTexture; const sheet = new Spritesheet(texture, myjson); } 需要注意的是，通过spritesheet加载完成后，有一些属性是为空的，所以所以我们需要等待加载完成去执行一些操作的话，需要等待spritesheet加载完成后（异步），在进行操作，这时需要用的哦它的prase方法 sheet.parse((textures) => { // mypng里面的一张叫treasure.png的图片 const treasure = new Sprite(textures[\"treasure.png\"]); treasure.position.set(0, 0); // mypng里面的一张叫blob.png的图片 const blob = new Sprite(textures[\"blob.png\"]); blob.position.set(100, 100); app.stage.addChild(treasure); app.stage.addChild(blob); }); Texture Packer要收费的，免费版可能有水印（刚开始会送你7天pro），这里有个免费版的Texture Packer可以看一下： http://free-tex-packer.com/download/ AnimatedSprite可以看成一个会动的Sprite，png -&gt; apng；Sprite -&gt; AnimatedSprite，AnimatedSprite接受一个图像数组，按照数组顺序播放图像，然后我们就可以看到“动起来的效果” 传入2个参数 textures autoUpdate，默认为true，采用PIXI.Ticker来更新动画时间 import { AnimatedSprite, Texture } from 'pixi.js'; const alienImages = [ 'image_sequence_01.png', 'image_sequence_02.png', 'image_sequence_03.png', 'image_sequence_04.png', ]; const textureArray = []; for (let i = 0; i &lt; 4; i++) { const texture = Texture.from(alienImages[i]); textureArray.push(texture); } const animatedSprite = new AnimatedSprite(textureArray); 当然，你也可以选择在图片合成工具的texurePacker里，设置图片名称，让他自动帮你生成动画： 此时通过spritesheet实例化生成的精灵表中，可以看到有animations属性（一个图片集数组），我们直接把它放到AnimatedSprite，就是一个动画精灵了 app.loader.add(\"chanziPng\", chanziPng).load(async (loader, resources) => { const chanziSheet = new PIXI.Spritesheet( resources[\"chanziPng\"].texture, chanzi ); await chanziSheet.parse(() => {}); // 创建动画雪碧 const chanziAnimate = new PIXI.AnimatedSprite( chanziSheet.animations[\"ani\"] ); // 设置动画时间 chanziAnimate.animationSpeed = 0.05; chanziAnimate.play(); app.stage.addChild(chanziAnimate); }); 尝试一下：https://codesandbox.io/s/elated-wind-5j60fu?file=/src/Component.js z-index有时候我们需要对一些元素层级来定位，决定元素的层次优先级，我们可以先开启 PIXI.settings.SORTABLE_CHILDREN：设置容器属性“sortableChildren”的默认值。如果设置为 true，容器将在调用 updateTransform() 时按 zIndex 值对其子项进行排序，或者在调用 sortChildren() 时手动排序。 PIXI.settings.SORTABLE_CHILDREN = true; 此时我们的 sprite.zIndex = xx;就可以生效了 一些pixi例子Run Pixie Run WASTE INVADERS 宝可梦实战（通过TexturePacker实现动画） 碰撞检测案例(飞机大战小游戏) 另一个飞机大战github 一些资源网站： 爱给网 (精灵图，场景图) 参考文章PixiJs PixiJS - 最快、最灵活的 2D WebGL 渲染引擎 PixiJS基础教程 Pixi v7迁移 一个老版本的pixi教程 fabricjsFabric.js 是一个强大的H5 canvas框架，在原生canvas之上提供了交互式对象模型，通过简洁的api就可以在画布上进行丰富的操作。它也是一个SVG-to-canvas 解析器。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"finished gitee","slug":"finished gitee","date":"2020-07-06T16:11:42.941Z","updated":"2020-07-06T16:11:42.941Z","comments":true,"path":"2020/07/07/finished-gitee/","link":"","permalink":"https://taylor12138.github.io/2020/07/07/finished-gitee/","excerpt":"","text":"原来是个人邮箱的设置必须得是公开的，我一直是设置为private，搞得一直错，终于搞出来了。 但是发现了gitee的一个缺点，每次部署完后都要去码云更新一次。。。","categories":[],"tags":[],"author":"Hello"},{"title":"CSS高级","slug":"CSS高级","date":"2020-05-30T16:00:00.000Z","updated":"2022-07-17T08:12:58.281Z","comments":true,"path":"2020/05/31/css-gao-ji/","link":"","permalink":"https://taylor12138.github.io/2020/05/31/css-gao-ji/","excerpt":"","text":"1.图形精灵图为了有效减少服务器接收和发射请求次数，提高速度出现的CSS技术。即将网页小背景图合成一张大图。 主要针对于背景图片（非产品类等更新换代图片） 主要使用background-position+x和y轴配合使用，x轴向右，y轴向下 background: url()no-repeat -182px 0; //分别对应x轴，y轴,基本都是负值缺点：文件大，放大缩小会失真，更换复杂 图片压缩优化网站： 自动生成雪碧图样式的网站：http://www.spritecow.com/ 熊猫压缩较少图片体积 在线压缩网站：https://tinypng.com/ image 转 DataUrI的网址：http://tool.c7sky.com/datauri/ 传统的url在浏览器地址栏中输入，可以直接导航到目标地址；而data URL则是一个data的url表现，可以理解为用url代表数据 浏览器不会缓存内联图片资源； 兼容性较差，只支持ie8以上浏览器； 超过1000kb的图片，base64编码会使图片大小增大，导致网页整体下载速度减慢 mobify最新的测试数据：DataURI要比简单的外链资源要慢6倍。 压缩图片可以使用统一的压缩工具 — imagemin，里面提供图片压缩、渐进式图片转换 渐进式图片一开始就决定了大小，而不像Baseline图片一样，不断地从上往下加载，从而造成多次回流，但渐进式图片需要消耗CPU去多次计算渲染，这是其主要缺点 更多图片优化方式可以看https://akarin.dev/2021/11/04/progressive-image-loading/ 还有nextjs对图片优化的方案：https://github.com/findxc/blog/issues/68 svg + canvasSVG 指可伸缩矢量图形 (Scalable Vector Graphics)，基于可扩展标记语言XML（老），SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失。SVG是通过DOM操作来显示的。 canvas：canvas 是H5新出来的标签(技术比较新)。画布是一个矩形区域，您可以控制其每一像素，Canvas是逐像素进行渲染的，一旦图形绘制完成，就不会继续被浏览器关注。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法 SVG &amp; canvas的区别： SVG不依赖分辨率 SVG支持事件处理器 SVG适合带有大型渲染区域的应用程序（地图） SVG复杂度高会减慢渲染速度（可能会reflow） SVG不适合游戏应用 但是在大部分场景中被，SVG 具有重要的优势，它的内存占用更低（这对移动端尤其重要）、渲染性能更高，并且用户使用浏览器内置的缩放功能时不会模糊。（面向低端安卓机，特定图表，水球图等） canvas依赖分辨率 canvas不支持事件处理器 canvas文本渲染能力较弱 canvas能够以png、jpg格式保存结果图像 canvas适合图像密集型游戏（他不会relfow） Canvas 更适合绘制图形元素数量较多（这一般是由数据量大导致）的图表（如热力图、地理坐标系或平行坐标系上的大规模线图或散点图等），也利于实现某些视觉 特效 2.字体图标iconfont常用于一些小图标（样式简单），展示状态时图标，实际上是字体 优点1.轻量级，够小 2.灵活性，可改多种效果 3.几乎支持所有浏览器 下载：相应网站（如https://icomoon.io/）下载后得到压缩包，解压后，把下载包里的fonts放入页面根目录下 使用：在CSS中根据说明引用全局声明，然后再在个体css中再次引用你想要的声明，同时可以自己调色和字体大小（font-size） 这里以阿里的图标为例子，把项目添加好之后，根据操作https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.16&amp;helptype=code一步一步来（这里是unicode引用），注意：**复制代码的时候，一定要在url的值中补充 “http:”** （使用bootstrap框架，可以直接使用其官网给的图标） @font-faceCSS at-rule 指定一个用于显示文本的自定义字体；字体能从远程服务器或者用户本地安装的字体加载. 如果提供了local()函数，从用户本地查找指定的字体名称，并且找到了一个匹配项, 本地字体就会被使用. 否则, 字体就会使用url()函数下载的资源。 通过允许作者提供他们自己的字体，@font-face 让设计内容成为了一种可能，同时并不会被所谓的”网络-安全”字体所限制(字体如此普遍以至于它们能被广泛的使用). 指定查找和使用本地安装的字体名称可以让字体的自定义化程度超过基本字体，同时在不依赖网络情况下实现此功能。 在同时使用url()和local()功能时，为了用户已经安装的字体副本在需要使用时被使用，如果在用户本地没有找到字体副本就会去使用户下载的副本查找字体。 @font-face 规则不仅仅使用在CSS的顶层，还可以用在任何CSS条件组规则中. @font-face { font-family: \"Open Sans\"; src: url(\"/fonts/OpenSans-Regular-webfont.woff2\") format(\"woff2\"), url(\"/fonts/OpenSans-Regular-webfont.woff\") format(\"woff\"); } 3.三角形若盒子设置宽高为0；此时又设置边框，则会形成组成一个正方形的4个三角形，实际上我们写三角形可以利用这个原理，把其他三个三角形隐藏起来则就只有一个三角形了 width: 0; height: 0; /*line-height: 0; font-size: 0; 有时需要添加，看浏览器*/ /*先设置一个边框，尽量大，以边框概括盒子大小*/ border: 50px solid #ccc; border-color: transparent red transparent transparent //上右下左的颜色 4.用户界面鼠标样式 cursorcursor: defalut 默认无样式 cursor: pointer 小手 cursor: move 移动 cursor: text 文本 cursor: not-allowed 禁止 轮廓线给表单（input）添加 outline: 0;，点击表单时，会去掉默认的l蓝色光标 防止拖拽文本域textarea{ resize: none }可以使文本框没有拖拽选项 5.Vertical-align(图片)css常用vertical-align让图片和文字对齐（但是只能针对行内元素或者行内块元素） vertical-align: middle; 中线对齐（一般使用这个来对齐） 图片底侧放置于盒子内时，时常有一个空白缝隙，可以使用vertical-align: middle||top||bottom;将其解决 （其实还可以直接转成块元素，但是此方法不提倡） 其实也可以将该盒子转化成 display: table-cell，然后同样可以使用vertical-align属性 常用的压缩图片地址（png）https://tinypng.com/ 6.文字溢出变省略号（推荐让后端写）单行文本：white-space: nowrap //强制一行内显示 ​ overflow: hidden; //溢出隐藏 ​ text-overflow: ellipsis ///变成省略号 多行文本：（有较大兼容性问题，适用于移动端或者webkit浏览器） ​ overflow: hidden; + text-overflow: ellipsis display: -webkit-box; /*单行伸缩盒子*/ -webkit-line-clamp: 2; /*限制其文本行数*/ -webkit-box-orient: vertical; /*设置盒子的子元素排列方式，（垂直居中）*/ 7.常见布局技巧可以使用margin的负值来消除浮动边框的重合（消除产生的巨大影子）如： margin-left: -Xpx; 想要移动到某个边框内自动变色可以使用hover，但是当排列方式为每个盒子的右边框被另外一个盒子的左边框压住时，变色效果会出bug，正确做法是：xx:hover{ position: relative; }添加相对定位使其马上覆盖当前所有单位 如果失败，有可能是因为当前已经添加了绝对定位了，此时只需要提高层级：z-index: 1; 8.CSS初始化为了照顾浏览器兼容，必须首先进行CSS初始化，即重新设定CSS个标签的初始默认值 9.CSS3新特性ie9+才支持 属性选择器可以不借助类选择器 input[att] {} 带有att属性值的被选中input[att=&quot;value&quot;] {} 带有att属性并且属性值等于value被选中 input[class^=icon]{} 选择类属性以icon开头的所有标签 input[class$=icon]{} 选择类属性以icon结尾的所有标签 input[class*=icon]{} 选择类属性含有icon的所有标签 如 .local-nav li [class^=\"local-nav-icon\"] { } 类选择器，伪类选择器，属性选择器（伪类选择器、属性选择器一般是11，因为包含标签名+/伪类名属性名=1+10=11）它们权重都为10 结构伪类选择器first和last等可以来了解一下，实际开发不太建议使用，也比较少使用。 值得注意的是 nth-child(n)比较重要 n可以是数字，可以是关键字（even偶数，odd奇数），甚至公式 ul li:nth-child(even){ } //选择所有的偶数孩子 ul li:nth-child(n){ } //选择所有孩子,因为n是公式类似n++，依次施加CSS效果 ul li:nth-child(2n){ } //选择所有的偶数孩子 ul li:nth-child(-n+5){ } //选择前5个孩子 nth-of-type和nth-child的不同： section div:nth-child(1){ } //先排序，再看是否符合div，如果是div就渲染 section div:nth-type(1){ } //先看是否符合div，如果是就在div里排序，选择第一个就渲染 伪元素选择器通过CSS创建新的子标签（比较简单的），从而简化html结构，（还与之前清除浮动使用的伪元素方法有关） element::before{ content：'XX'; /*必须要有content属性，为内容*/ } /*在元素内部前面（左）插入内容*/ element::after{ content: 'XX'; } /*在元素内部后面（右）插入内容*/ 它和标签选择器一样，权重=1，且为行内元素，想要设置大小必须转行内块 （还可以有element:hover::before{}的操作） 伪类和伪元素单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素 双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法; 所以我们最好养成习惯，伪元素写 :: 伪类写 : CSS3盒子模型只需增加如下代码 box-sizing: content-box; /*默认*/ box-sizing: border-box; /*只看盒子大小，不考虑border和padding因素*/ 即可不用考虑border和padding因素是否会将盒子本身撑大。 标准盒模型：box-sizing：content-box 怪异盒模型：box-sizing：border-box 这里提及到盒子模型就讲一讲标准盒模型和怪异盒模型 盒子模型W3C盒子模型(标准盒模型)和IE盒子模型(怪异盒模型) 标准盒模型： 盒子实际内容（content）的width/height=我们设置的width/height; 盒子总宽度/高度=width/height+padding+border+margin。 怪异盒模型： 盒子的（content）宽度+内边距padding+边框border宽度=我们设置的width/heigh 盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin。 总结： 总大小其实是一样的，只是我们设置标准盒子宽高是设置内容宽高，设置怪异盒子宽高是内容 + padding + border 宽高 CSS3滤镜filter用于模糊图形效果，filter: 函数(); 如：filter:blur(5px); //模糊处理，数值越大越模糊 …… 如果是只是单纯模糊背景图片，可以使用 backdrop-filter backdrop-filter: blur(8px); CSS3calc函数(计算函数)width: calc(100% - 80px); //宽度永远比父盒子宽度小30px CSS过渡（重点）一些变化的动画效果（时间缓滞），经常和 :hover、transform等 一起搭配 在官网中查看到兼容性比较差，反而@keyframe的兼容性很不错？！！ transition: 要过渡的属性 花费的时间（单位为s） 运动曲线（默认ease，可以省略） 何时开始（默认0s，可省略）; transition: width 0.5s,heigh 0.5s; /*多个属性\",\"分割，想要更多属性，直接属性值写all*/ xx:hover{width:100px;heigh:100px;} 过渡的属性： none 没有属性会获得过渡效果。 all 所有属性都将获得过渡效果。 property 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。 10.CSS的morecss的2D转换transform可以理解为变形 移动：translate 旋转：rotate 缩放：scale 2d为二维坐标，x轴向右，y轴向下 translate类似于定位transform:translate(x,y); transform:translateX(n); transform:translateY(n); /*单位是px，如果是百分号，则它的距离是盒子自身高宽对比出来的*/ translate最大的优点：不会影响其他元素的位置，绝对定位会脱标，margin会影响，（有点像相对定位，但是更方便，可以加过渡效果） 可用于定位父盒子的中间位置 使用： position: absolute; top: 50%; left: 50%; transform:translate(-50%,-50%);但是它对行内标签没有效果 rotate旋转transform:rotate(度数deg); transform-origin:x y; /*设置元素旋转依靠的中心点*/ x，y默认为50%，50%，设置x，y可以可是bottom，left等，如transform-origin:left bottom;为设置左下角为中心点 scale之缩放transform:scale(x,y);/*里面的数字不跟单位，是倍数，x，y分别是宽，高*/ transform-origin:x y; /*设置元素旋转依靠的中心点*/ 若只有一个参数，则同比放大 使用scale的优点：变大时不会影响其他盒子的位置，且放大是以中心向外扩张的放大，直接修改width和heigh放大是直接往下放大 11.动画用keyframes定义动画 @keyframes 动画名称 { 0%{ width:100px.... } 100%{ width:200px.... } }//可以设置25%，75%等多个状态，习惯上把0%也写了 //以下也可以 @keyframes 动画名称 { from{ width:100px.... } to{ width:200px.... } } 0%动画的开始 100%动画的结束 1.可以做多个状态变化 keyframe关键帧 2.里面的数字为整数 3.百分比为时间的划分 使用动画： div { animation-name:动画名称; animation-duration:持续时间; animation-iteration-count:播放次数，可以为infinite; animation-direction:xx; /*设置动画在每次运行完后是反向运行还是重新回到开始位置重复运行。*/ /*默认normal，alternate为设置动画交替反向运行，reverse为反向运行*/ animation-fill-mode:xx; //默认backwards，动画结束后返回原来位置，forwards可取消该功能 animation-play-state:xx; //running/paused 是动画运行或者暂停 animation-timing-fuction: ease; //默认ease加速度，linear匀速，step分步。。。 } 当然 animation-timing-fuction 可以使用 cubic-bezier 控制动画速度 https://cubic-bezier.com/#.51,0,.47,.99 使用多个动画用“，”分隔 如animation: bear 0.7s steps(8) infinite, move 0.7s …… animation: name duration timing-function delay iteration-count direction fill-mode play-state; animation一个推荐网址：https://xsgames.co/animatiss/ 3D转换x轴向右，y轴向下，z轴向外，最常用的是3d位移和3d旋转,以下许多功能与2d十分相似 设置为3d模式(变形效果) 如果选择平面，元素的子元素将不会有 3D 的遮挡关系。 由于这个属性不会被继承，因此必须为元素的所有非叶子子元素设置它。 transform-style: preserve-3d 3d移动transform: translate3d(x,y,z); transform:translateZ(n); /*translateZ一般采用px，3d的z轴显现出来需要透视功能*/ translateZ踩的坑1.在android上，如果对元素同时设置zindex和transform translateZ的值时，在显示上zindex的优先级要高于translateZ 2.在ios上，则相反，translateZ的优先级要高于zindex 3.所以最好在设置一系列元素时，zindex的值和translateZ的值应该一起逐级增长或逐级减少 https://blog.csdn.net/qappleh/article/details/95636682 我的解决方案： overflow:hidden //用于消除3d环境下ios层级问题 如果放在父级别不行，那就放在爷爷级别 网上的解决方案： 方法1：父级，任意父级，非body级别，设置overflow:hidden可恢复和其他浏览器一样的渲染。 方法2：以毒攻毒。有时候，页面复杂，我们不能给父级设置overflow:hidden，怎么办呢？ 杨过的情花剧毒怎么解的？断肠草啊，另一种剧毒。这里也是类似。既然“穿越”的渲染问题是由3D transform变换产生的，那么，要解决此问题，我们也可以使用3D transform变换。 透视透视我们也成为视距，即眼睛到屏幕的距离，透视的单位是像素，透视越小，盒子越大 透视写在被观察元素的父盒子上 perspective: xxpx;3d旋转一般加上透视效果会比较明显，3d旋转方向遵循左手定则： 左手大拇指指向旋转轴的方向，手指弯曲的方向则为旋转的方向 transform: rotateX(度数); /*沿着X轴旋转*/ transform: rotateY(度数); transform: rotateZ(度数); /*z轴旋转和2d普通rotate有点像*/ transform: rotate3d(x,y,z,度数); /*自定义轴旋转*/ 自定义旋转只对x轴选取为transform: rotate3d(1,0,0,度数); 对角线旋转为transform: rotate3d(1,1,0,度数) transform要看情况选择：先写旋转rotate再写移动translate或者相反情况 3d呈现transform-style控制子元素是否开启三维立体环境，代码要写给父级（一定是父级，不能爷爷级别，亲测过），此属性很重要 transform-style: preserve-3d /*此为开启立体空间，但是默认值为flat，不开启立体空间*/ 12.styled-components秉承着万物皆是组件的思想，让css样式变成组件，来加入 npm i styled-components 如果是配合上ts，还需要下载它的声明文件 npm i --save-dev @types/styled-components styled-components配合react使用 它内部还支持sass、less语法，先声明一个对象 styled.标签名+css模板字符串 import React from \"react\"; import styled from 'styled-components' export default function index() { const StyleFooter = styled.footer` background: yellow ul{ display: flex; li{ flex:1 } } ` return &lt;div> &lt;StyleFooter> &lt;ul> &lt;li>商店&lt;/li> &lt;li>商店&lt;/li> &lt;/ul> &lt;/StyleFooter> &lt;/div>; } 对子组件使用styled-components的方式： styled(子组件)+css模板字符串 同时子组件还需要通过props.className接收该样式 import React from \"react\"; import styled from 'styled-components' export default function Index() { const StyleChild = styled(Child)` background: yellow ` return &lt;div> father &lt;StyleChild>&lt;/StyleChild> &lt;/div>; } function Child(props: any) { return ( &lt;div className={props.className}>child&lt;/div> ) } 优缺点常规css性能 vs cssinjs css in js 更小（包的大小） 常规css渲染时间更短 并且：为了更好地比较用户交互，而不仅仅是页面加载。测量了进行项目分组的拖放活动性能。结果总结如下：即使在这种情况下，Linaria在几个类别中也击败了CSS-in-JS。 参考：https://zhuanlan.zhihu.com/p/513843865 13.clip-path一个用来设置蒙版的css属性，用它来绘制区域，只有在区域内的部分才能被看到，它支持 circle（圆形） ellipse（椭圆） polygon（多边形区域） 使用该蒙版后不能搭配box-shadow，因为此时蒙版被蒙住的部分，会展示不出box-shadow 但是可以使用伪元素 before 代替阴影，设置为阴影的颜色 各种形状的示例：https://blog.csdn.net/weixin_44116302/article/details/98882841 一个小的教学视频在b站：https://www.bilibili.com/video/BV18y4y1i7oP?zw 该教学的文档https://zxuqian.cn/videos/effects/effects-glitch/ 14 CSS3中-moz-或-webkit-是什么意思CSS3中新增了一些属性，例如box-reduis、box-orient、text-overflow等等，而这些属性在以往的版本中是不存在的，或者不被支持的，因此，针对不同的浏览器，规定其内核名称让它们可以对这些新增属性进行解析。这看上去是一个合理的解释，即-moz-是针对firefox的，-webkit-是针对safari和chrome的。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"CSS浮动+定位","slug":"CSS浮动+定位","date":"2020-05-16T16:00:00.000Z","updated":"2022-04-02T12:24:31.374Z","comments":true,"path":"2020/05/17/css-fu-dong-ding-wei/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/css-fu-dong-ding-wei/","excerpt":"","text":"1.浮动CSS三种传统布局：普通流 浮动 定位 标准流：标签按照默认排序 多个块级元素纵向排列用标准流，横向排列用浮动 选择器{ float: 属性值; //none不浮动 left向左浮动 right向右浮动 }//创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘 1.浮动元素会脱离标准流原来（排在浮动后面的）标准流的标签会顶上你原来的位置（但标准流之后的浮动挤不上去） （但是！！不会覆盖掉你的文字！，因为本身浮动是为环绕图片而设计的） 2.浮动元素会一行内显示并且元素顶部对齐紧贴在一起，不会有缝隙，装不开会另起一行 3.浮动元素具有行内块元素的特性添加浮动后自动附带行内块元素的特性 4.浮动自带文字环绕效果浮动的使用：一般采取先用标准流父元素排列上下位置，之后在子元素采取浮动，使得浮动在网页中间而不是左右侧 一般一个元素浮动了，他的兄弟标签最好也使用浮动 2.清除浮动布局1.父盒子不给高度，子盒子会自动撑开 2.父盒子不给高度的话，子盒子如果是浮动，父盒子会发生高度塌陷，导致高度变成0 所以总结：需要清除浮动！！！ clear: 属性值 一般属性值取both（常用）清楚两侧浮动，也有left，right 1.额外标签法，隔墙法，W3C推荐做法在浮动标签最后加多个一子标签（必须是块级元素），如： .clear{ clear: both; } &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;优点：通俗易懂，书写方便 缺点：结构化差 2.父级添加overflow（生成BFC元素） //父级盒子 .box{ overflow: hidden; //或者auto } 优点：代码简洁 缺点：无法显示出溢出部分 3.：after伪元素法额外标签的升级版，给父元素添加 .clearfix::after { content: \"\"; display: block; //伪元素默认是行内元素，所以得转 height: 0; clear: both; visibility: hidden; } .clearfix { *zoom: 1; //兼容ie6，ie7 } /*一般类名定义为clearfix*/ 优点：结构简单 缺点：需要照顾低版本浏览器 代表网站：百度，淘宝，网易 4.双伪元素清除浮动.clearfix::before, .clearfix::after { content: &quot;&quot;; display: table; //转化为块级，并且一行显示 } .clear::after { clear: both; } .clearfix { *zoom: 1; //兼容ie6，ie7 }优缺点同上，代表网站：小米，腾讯 3.CSS定位1.某个元素可以在盒子内移动位置，并且压住其他盒子。 2.滚动窗口时，盒子固定于屏幕某个位置。 定位=定位模式+边偏移量 定位选择器{ position: static; position: relative; position: absolute; position: fixed; position: sticky; top: 100px; //必备的指定位置，可以为left，right，bottom } position: static; //默认，无定位,标准流特性 position: relative; //相对定位，参照点是自己，移动位置后，原来的位置继续占有（没有脱标） position: absolute; //绝对定位，是相对于他的祖先元素。 1.没有祖先元素或者，祖先元素没有使用定位，则以浏览器为准直接偏移 2.如果祖先元素有定位（相对，绝对，固定），则以最近一级定位的祖先元素为参考点 3.绝对定位不再占有原来的位置（脱标） 4.加了绝对定位的盒子不能通过 margin: 0 auto; 来居中，让它居中的原理和fixed设置版心的原理差不多，都是left：50%+margin组合 position: fixed; //固定于浏览器可视区位置，不占有原先位置 1.还可以设置于版心附近，方法：让那个固定定位的盒子 left: 50%,然后让固定定位的盒子margin-left：版心的一半距离 position: sticky; //粘性定位，被认为相对定位和固定定位的混合体 relative -&gt; fixed 1.以浏览器可视窗口为参照移动的元素（固定特点） 2.粘性定位占有原先的位置 3.必须添加top，left等，不然相当于相对定位 4.常用于导航栏的滚动 缺点：很多比较老的浏览器都不支持（移动端不考虑） (子绝父相—–出自pink老师) -&gt;&gt;&gt;&gt;&gt;&gt;&gt; —–&gt; 子级使用绝对定位，父亲则需要使用相对定位 位置如果一个定位既设置了left，也设置了right，它默认会执行left。若及设置了top，也设置了bottom，会默认执行top（无关权重的事情） 定位叠放次序通过控制z-index来控制盒子的前后次序（叠放次序）z-index： 1; 1.数值越大盒子越靠上 2.如果值相同，按照书写顺序，后来居上 3.数字不能加单位 4.只有定位盒子才有z-index属性（还有flex） 5.如果该盒子父盒子层级使用了定位+z-index，但是父盒子的z-index值比较低，在“拼爹”的规则底下，即使子盒子本身z-index再大，也会被压着 定位的特殊性质1.行内元素添加绝对或固定定位，可以直接设置高度和宽度 2.块级元素添加绝对或固定定位，未设置宽高，会脱标，默认内容大小（类似浮动）（不会发生外边距合并） 3.和浮动不同，绝对或固定定位会压住你标准流文字等内容 4.元素的显示和隐藏1.displaydisplay: none; 隐藏对象（不再占有原来的位置，可以用于js的下拉菜单等功能） display: block; 显示对象（也可以是转换块元素） 2.visiblevisibility: visible; 元素可视 visibility: hidden; 元素隐藏（仍然占有原来位置） 3.overflowoverflow: visible; 超出你的标签部分（固定大小）可见 overflow: hidden; 超出你的标签部分（固定大小）隐藏，如果有定位的盒子慎用，他会切掉你溢出布局标签的部分 overflow: scroll; 可添加滚动条 overflow: auto; 需要的时候添加滚动条 5.文档流浮动和定位一些属性会脱离文档流 其实还有一个文本流，它其实就是一系列字符，是文档的读取和输出顺序，也就是我们通常看到的由左到右、由上而下的读取和输出形式。 只有postion一些属性可以从文本流脱离出来 文档流是相对于盒子模型讲的文本流是相对于文字段落讲的 所以我们可以看到浮动的时候文字环绕的形式，说明浮动并没有脱离文本流；但是position中的absolute和fixed全部脱离。 mdn: 下列元素会脱离常规流: floated items。浮动的元素 items with position: absolute (including position: fixed which acts in the same way)。通过设置position属性为absolute或者fixed的元素 the root element (html)根元素","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"CSS样式","slug":"CSS样式","date":"2020-05-09T16:00:00.000Z","updated":"2022-11-23T08:22:47.295Z","comments":true,"path":"2020/05/10/css-yang-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/css-yang-shi/","excerpt":"","text":"声明：可以使用chrome的F12浏览学习别人的样式并且调试你的代码 引入CSS/*1）link的写法：*/ &lt;link rel=\"stylesheet\" href=\"index.css\"> /*2）import的写法：*/ &lt;style type=”text/css”> @import url（“index.css”）； &lt;/style> link和@import的区别： （1）link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 （2）link可以加载CSS，Javascript；@import只能加载CSS。 （3）link加载的内容是与页面同时加载；@import需要页面网页完全载入以后加载。（所以有时候浏览@import加载CSS的页面时会没有样式（就是闪烁），网速慢的时候还挺明显。） 1.主要定义/*是类型选择,标签选择器*/ 元素（标签） { } /*选择所有元素*/ * { } /*的选择 选择多个类可以 &lt;div class=\"类1 类2\">&lt;/div>*/ .class(类名) { } /*id的选择,有点类似class，只能调用一次，别人切勿使用*/ #(id名) { } /*复合，后代选择器*/ 元素1（可以是类名） 元素2（可以是类名） { } /*只选择亲儿子，孙子不选*/ 元素1（可以是类名）>元素2（可以是类名） { } /*并集选择器，多个统一*/ 元素1, 元素2 { } /*选择类名1的下一个兄弟节点元素2*/ 类名1+元素2 { } /*m-small-cont 写成 &amp;-cont的形式， &amp; 表示嵌套的上一级*/ .m-small { &amp;-cont { } } 注意：如果一个元素拥有ID属性,那么ID属性的属性值就会成为window对象的属性名 文字注意：chrome默认最小展现字体为12px，想要查看需要在浏览器设置中设置 PC端解决小于12px字体问题的页面，需要自行设置使用transform属性（scale）对页面进行缩放解决 font-size: 12px 12像素大小文字 谷歌默认16px font-size: 12px 12像素大小文字 行高为12*1.5=18 font-weight: xxx 字体加粗 text-align: center 文字水平居中对齐 text-indent: 10px 文本首行缩进,最好使用em，如text-indent: 2em,em是相对单位，当前1个文字元素的大小 text-decoration: none取消下划线 line-height: 26px 行间距，用QQ截图可以偷偷测量，等于盒子高度时垂直居中 white-space: val; CSS 属性是用来设置如何处理元素中的 空白 (en-US)。 normal 连续的空白符会被合并，换行符会被当作空白符来处理。换行在填充「行框盒子(line boxes)」时是必要。 nowrap 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。 pre 连续的空白符会被保留。在遇到换行符或者``元素时才会换行。 pre-wrap 连续的空白符会被保留。在遇到换行符或者``元素，或者需要为了填充「行框盒子(line boxes)」时才会换行。 pre-line 连续的空白符会被合并。在遇到换行符或者``元素，或者需要为了填充「行框盒子(line boxes)」时会换行。 背景background-color //背景颜色 使用背景渐变色： linear-gradient background: linear-gradient(90deg,#9370DB,#AFEEEE,#FFA500,#9370DB); background: rgba(red（数值）,green(数值),blue（数值），透明度（0-1）) //背景颜色 透明化 background-image: url(地址)//背景图片，常见于标志，logo或者超大背景图片，有点是便于控制位置 baackground-repeat: no-repeat//背景平铺，默认为平铺，可以改成取消平铺 background-position: x y//背景图片的位置 ，可以使用方位名词，前后顺序可可以不一样top，center ，botton，left等（只写一个另外一个默认居中）。也可以使用精确单位x轴长度，y轴长度，（只写一个另外一个默认居中） background-attachment: scroll||fixed//背景图像随对象内容滚动||背景图像固定` background的复合方式（分别对应图片位置、图片大小，是否重复，url地址） background: left 5% / 60% 60% no-repeat-x url(); 列表list-style: none//去掉无序列表里 li 列表前面的小圆点 阴影box-shadow: 10px 10px 5px #888888; 分别对应阴影的水平，垂直和阴影，颜色 text-shadow: 1px 1px rgba(0,0,0,.2); 文字阴影效果 inputoutline: none; 消除输入边框 border: 0; 消除输入框的自带边框 透明opacity: 0.5 半透明 opacity: 1 不透明 opacity / display none / visibility 的不同：https://segmentfault.com/a/1190000015116392 box-sizingbox-sizing 属性可以被用来调整这些表现: content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。 border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。 border-box不包含margin 尺寸单位 px单位，像素单位 em单位，em是相对于父元素的字体大小，如父元素的font-size为12px，子元素设置宽高为10em，则大小实际为10*12=120px rem单位，相对于html字体大小 %单位，继承父元素单位 dp单位，屏幕密度 vh单位，viewpoint height，视窗高度，1vh等于视窗高度的1%。 vw单位，viewpoint width，视窗宽度，1vw等于视窗宽度的1%。 视区”所指为浏览器内部的可视区域大小，即window.innerWidth/window.innerHeight大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。 dpr 物理像素比 pc端一般都是1，移动端比如iPhone6/7/8都是2，移动端不尽相同 var dpr = window.devicePixelRatio || 1 vh视窗单位给移动端开发的适配是带来了极大的优势，但我想你在使用视窗单位的时候，应该也碰到了iOS上 Safari 的兼容性问题。因为，在iOS上的 Safari 有一个长期存在的，极其恼人的Bug，它不能与 vh 单位很好的配合。如果你将一个容器的高度设置为 100vh 时，会导致这个元素有点太高（会出现滚动条）。造成这种现象的主要原因是移动端上的 Safari 在计算 100vh 时忽略了它的部分用户界面。 这是由于 Safari 和 Chrome 使用的计算方法造成的 作者Luke Channings于2021 年 6 月 11 日 Safari 的新浮动地址栏显示在我们的测试按钮上方，这或多或少与 iOS 14 的行为完全相同。 仍然说Safari 15 不会改变100vh😢 的行为。 解决方案： 方案1 Let’s get started first with the JS file: 您始终可以通过使用全局变量来获取当前视口的值window.innerHeight。该值将浏览器的界面考虑在内，并在其可见性更改时更新 const appHeight = () =&gt; { const doc = document.documentElement doc.style.setProperty(‘ — app-height’, `${window.innerHeight}px`) } window.addEventListener(‘resize’, appHeight) appHeight()appHeight function has sets new style property var(— app-height) including current window height, — app-height it is necessary for next steps. :root { — app-height: 100%; }html, body { padding: 0; margin: 0; overflow: hidden; width: 100vw; height: 100vh; height: var( — app-height); }In the previous step I’ve created the reference — app-height, wrapping in the var() I’ve received CSS variable var( — app-height). This variable is allowed to read values created by JS. 方案2 CSS solution (not recommend)The last, but not the least solution is — webkit-fill-available, this solution works only on Apple devices, it won’t solve the problem on Android devices. I don’t recommend this solution, but it’s worth showing. 诀窍在于min-height: -webkit-fill-available;body 作为对 的渐进增强100vh，它应该适用于 iOS 设备。 height: 100%; height: -webkit-fill-available;但是方法二在时可能出现的其他问题（例如，对旋转设备的影响、Chrome 没有完全忽略该属性等）。 参考： 100vh problem with iOS Safari 移动 WebKit 中 100vh 的 CSS 修复 2.伪类选择器/*a超链接类 或者写成 a的类名:XXX{}*/ a:link 选择所有未访问的链接 a:visited 选择所有已被访问的链接 a:hover 常用，选择鼠标指向的链接 a:ative 鼠标按下未弹起的链接 /*如果全部都写，请按照LVHA的顺序写*/ /*input类，把获得光标的inut选取出来改写CSS*/ input:focus 3.行块转换display:block /*转块元素*/ display:inline /*转行内元素*/ display: inline-block /*转行内块*/ displat: table /*成为一个块级表格元素*/ display: table-cell /*使子元素成为表格单元格*/ /*使文字垂直居中 让文字行高=盒子的行高 行高>盒子高度偏下，&lt;偏上*/ line-height: 盒子高度 多行文字居中 父元素 display的table + 子元素：table-cell vertical-align: middle 配合可以实现多行文字居中 父元素设置对应的height和line-height 子元素设置display:inline-block + vertical-align:middle() + line-height (缺点：文本的高度不能超过外部盒子的高度。) .parent { height: 300px; line-height: 300px; } .son { display: inline-block; width: 300px; line-height: 20px; vertical-align: middle; } CSS水平垂直居中方式1.绝对定位 position: absolute; top: 50%; left: 50%; transform:translate(-50%,-50%); 2.flex布局 .parent{ display:flex; justify-content:center; align-content:center; } 3.grid布局，比flex的兼容性还低 .parent { display: grid; } .child { align-self: center; justify-self: center; } .parent{ display: grid; place-items: center; } 4.table-cell + vertical + text-align .parent { display: table-cell; vertical-align: middle; text-align: center; } .child { display: inline-block; } 5.table-cell + vertical + margin .parent { display: table-cell; vertical-align: middle; } .child { /*加上 display: table 兼容ie7*/ margin: 0 auto; } 6.行内元素水平垂直居中 text-align: center; line-height: 300px; /*和盒子高度保持一致*/ 关于九宫格样式布局可以参考以下链接博主的讲解，很详细 https://juejin.cn/post/6886770985060532231#heading-2 display和visibilitydisplay: none：该元素以及它的所有后代元素都会隐藏，无法使用屏幕阅读器等辅助设备访问，占据的空间消失 visibility: hidden：也可以隐藏这个元素，但是隐藏元素仍需占用与未隐藏时一样的空间，也就是说虽然元素不可见了，但是仍然会影响页面布局。（也就是仍然占据空间，只是隐藏起来） 除了占据空间这个重大的区别之外，还有2个区别： visibility具有继承性，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别 visibility: hidden不会影响计数器的计数，如图所示，visibility: hidden虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样 解决行内元素造成的间距 给其父元素添加了font-size:0 但是注意：IE6，IE7浏览器当设置font-size：0时，换行符、tab（制表符）、空格始终存在1px的空隙而最新版本的Safari浏览器，Chrome浏览器不支持字体大小为0的浏览器 设置浮动（不过可能会有布局问题） 设置margin为负值（感觉不太好） 将行内标签都放在同一行上 4.CSS的三大特性1.层叠性样式冲突选择就近原则，把前面的覆盖掉，不冲突的不覆盖 2.继承性子标签会继承父标签的属性 3.优先级1.选择器相同，执行层叠性 2.选择器不同，继承/*(0,0,0,0)&lt;元素(0,0,0,1)&lt;类(0,0,1,0)&lt;id(0,1,0,0)&lt;行内样式style(1,0,0,0)&lt;！important无限大 （属性选择器input[class^=icon]{} 是（0,0,0,1）（0,0,1,0） ） （！important加在某属性后面，如color: green!important） 继承的你加了！important，权值还是（0，0，0，0），毕竟是继承过来的 3.复合选择器有权重叠加的问题 ul li{}权重为(0,0,0,1)+(0,0,0,1) li为(0,0,0,1) .nav li为（0，0，1，1） 权重会叠加，但是永不进位，不是二进制 （a:hover为(0,0,1,1)） 5.CSS盒子border（会影响盒子大小） border-style: solid(实线边框，最常用) dashed(虚线) dotted（点线边框） border-width: XXpx border-color: XX 复写： border: 1px solid red 边框分开写法： border-top: 1px solid red border-collapse:collapse /*相邻边框合并*/ border-top-right-radius: 15px; /*右上方改圆角，无top，right则全部都改*/ padding内边距（会影响盒子大小，要设置了盒子宽高才会撑开） 适用于文字大小不一的盒子，不设置宽高，直接设置padding，字少空间小。字多空间大 子容器盒子没设置宽高，父容器盒子padding不会被撑开 padding: 5px; padding: 0 10px; /*分别对应上下和左右*/ padding-top: 5px; /*仅写上方内边距*/ margin外边距，盒子和盒子之间的距离（不会撑开） 使用方法和padding是一致的 margin可以让块级盒子水平居中：1盒子必须有宽度，盒子左右外边距设置为auto margin: 0 auto;(不适用于定位) 行内元素或者行内块元素水平居中只需在其父元素CSS样式中添加：text-align: center; 外边距合并问题1.外边距合并指的是，当两个垂直外边距（2个margin）相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。而左右外边距不合并。2.在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。3.注释：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 4.我们可以在a元素或者b元素再包裹一个容器并触发该容器生成一个BFC，就不会发生margin重叠了 比如 &lt;div class=\"container\"> &lt;p>&lt;/p> &lt;/div> &lt;div class=\"container\"> &lt;p>&lt;/p> &lt;/div> overflow visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 使用了overflow: scroll 或者 overflow: auto 才可以使用scroll事件的那些 scrollTop属性等 6.PSjpg： JPEG对色彩保留好，高清颜色多 gif：常用于小图片动画，可保留透明背景 png：结合jpg和gif，储存形式丰富，支持透明背景 PSD：保存PS设计稿 图层切图： 选定图层，右键，快速导出为png 切片切图： 切片工具—》选中—》左上角文件—》导出—》存储为Web所用格式—》JPEG（png可用于保存透明图）（保存的时候选”选中的切片“） ps插件切图：需要下载Cutterman插件 7.部署网站免费的远程服务器：http://free.3v.do/ 8.vhvh：viewport hetght 指当前可视窗口高度 100vh为100%的可视区域 height: 100vh; 9.BFC我们常说的文档流其实分为定位流、浮动流、普通流三种。而普通流其实就是指BFC中的FC Box 是 CSS 布局的对象和基本单位 Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 BFC：块级格式化上下文，我个人理解的是一种规则 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（margin外边距合并问题） 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算（清除浮动的原理，overflow: hidden） 触发BFC 根元素（CSS 中的根元素是指 :root 选择器匹配到的元素，在 HTML 中是 html 元素） float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible https://segmentfault.com/a/1190000013023485 这个网址里面又生成BFC的小案例，很有趣，可以加深理解","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"前端冗杂知识","slug":"前端冗杂知识","date":"2020-05-09T16:00:00.000Z","updated":"2023-03-26T05:42:01.931Z","comments":true,"path":"2020/05/10/qian-duan-rong-za-zhi-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/qian-duan-rong-za-zhi-shi/","excerpt":"","text":"1.BFFBack-end for Front-end，服务于前端的后端 BFF就是老生长谈的中间层概念，初衷是在后台服务与前端之前添加一层，比如在中间加上一个node.js，做到请求的转发 和 数据的转换，Nodejs既配合了前端技术栈，也更适应向微服务的并发请求 BFF作为中间层，优点是： 前后端彻底分离，即便是后期有微服务迁移，也不需改动前端代码 业务更向前靠拢，琐碎的api由前端开发自己决定，更适配前端框架 BFF可以自开mock，插件也能生成API文档，相比后端单开这类服务要方便些吧 留给后端更清晰的服务边界，只需要提供粗粒度的接口即可 缺点： 中间层转发会增加请求延迟。 需要保证端到端测试 必须随时准备好后端异常请求 BFF分成会增加开发成本 资料来源：https://www.jianshu.com/p/9cca72f9e93c 2.VSCode编译Emmet语法插件于市面上大多前端编译软件，如VScode所带有的，便于快速写html和CSS 网页移动端适配，开启理想视口，用于做移动端网页的适配 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> h5想要生成多个标签：div*10，再回车（或者tab），即可生成10个div标签。 生成父子关系标签：div&gt;span,再回车（或者tab），即可生成包含span标签的div标签。 生成兄弟关系标签：div+span,再回车（或者tab）。 输入：.nav 直接生成一个class=“nav”的div标签。(默认div) 输入：#nav 直接生成一个id=“nav”的div标签。 输入：p.nav 直接生成一个class=“nav”的p标签。 输入：.nav$*5 直接生成5个class=“nav1”,class=“nav2”…..的div标签。($是自增符号) 输入：div{前端真好玩}*5 直接生成5个&lt;div&gt; 前端真好玩 &lt;/div&gt; CSS样式内输入：tac 直接生成text-align: center; 其他语法缩写同样类似，诸如w100—&gt;width: 100 格式化直接鼠标右键，格式化文档，即可直接让文档变整齐。 （或者想要每次保存后自动格式化，需要在首页—首选项—设置—搜索emmet.include,在setting.json下的用户，添加 “editor.formatOnType”: true, “editor.formatOnSave”: true 即可） 又或者 On Windows Shift + Alt + F On Mac Shift + Option + F On Ubuntu Ctrl + Shift + I 生成代码片段snippet模板网站 https://snippet-generator.app/ 然后再vscode中 shift+control+P输入snippet进行代码片段配置，这样我们就可以直接输入我们的前缀（prefix）拿我们的代码片段模板了！ 使用Prettier自动格式化Prettier是一个强大的代码格式化工具 方法一： 在vscode中安装Prettier插件 项目中新生成 .prettierrc文件 （Prettier runtime compiler） { \"semi\": false, \"singleQuote\": true, \"trailingComma\": \"none\" } useTab：使用tab/空格缩进 tabWidth：tab是空格的情况下，空格数 printWidth：当行字符长度。推荐80 singleQuote：使用单引号还是双引号 trailingComma：多行输入时，尾部逗号是否添加 semi尾部是否添加分号 endOfLine：结束行形式 prettier格式化参考表格https://juejin.cn/post/6938687606687432740 一般我们还会给Prettier添加忽略文件 此时在根目录下新建 .prettierignore 文件 /dist/* .local .output.js /node_modules/** **/*.svg **/*.sh /public/*在设置中 save 中设置保存时自动化 在编辑器中右键有自动格式化选项 方法二： 直接在项目中安装 npm i prettier -D 依旧在根目录下新建文件.prettierrc文件 （Prettier runtime compiler），并且编辑保存 此时在根目录下，对文件保存即可 当然方法一、二一步一步保存嫌麻烦，也可以在 package.json文件下实行一步保存命令的配置 \"script\": { \"prettier\": \"prettier --write .\" } jsx and tsx 对于tsx、jsx文件，在vscode中Prettier默认不启用 需要在vscode中的setting.json中配置（通过Ctrl+Shift+P 打开 setting.json） { \"[typescriptreact]\": { \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" }, \"[javascriptreact]\": { \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" }, } 3.RPCRPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。 首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接 第二，要解决寻址的问题，连接到对应的服务器（如主机或IP地址）以及特定的端口 两台服务器之间以 序列化传输数据 + 反序列化得到数据结果 以上是它们连接的建立和数据的传输过程 远程调用的问题 Call ID映射。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。 序列化和反序列化问题 网络传输问题 RPC的大项目适用性： 做一个访问量不大的项目的时候,一台服务器部署上一个应用+数据库也就够了. 访问量稍微大一点之后呢,需要：集群.架设nginx,部署多个服务 再大一点，数据库已经扛不住了,有时候宕机. 那这个时候呢我们需要数据库读写分离,再架设几台数据库服务器,做主从,做分库分表。 再大一点，我们需要拆分模块，拆分项目，比如订单系统分一个项目，但是还是需要切换顶层的nginx.把要重启的服务的流量切到可用服务上. 这个时候就可以使用RPC 所有的服务在启动的时候注册到一个注册机里面,然后顶层处理在接收到nginx的请求时,去注册机找一个可用的服务,并调用接口. 这样子呢,在不加新功能的时候,顶层处理服务我们就不需要动了，那修改了用户信息项目的时候,我们只需要一个个更新用户信息项目的服务群就好了。 部分观点源自https://www.zhihu.com/question/25536695 Native Modules官方解释 有时，React Native 应用程序需要访问 JavaScript 中默认不可用的原生平台 API，例如用于访问 Apple 或 Google Pay 的原生 API。也许你想重用一些现有的 Objective-C、Swift、Java 或 C++ 库，而不必在 JavaScript 中重新实现它，或者为图像处理之类的事情编写一些高性能、多线程的代码。 NativeModule 系统将 Java/Objective-C/C++（本机）类的实例作为 JS 对象公开给 JavaScript（JS），从而允许您从 JS 内执行任意本机代码。虽然我们不希望此功能成为通常开发过程的一部分，但它的存在至关重要。如果 React Native 没有导出你的 JS 应用程序需要的原生 API，你应该能够自己导出它！ 所以我们可以在RN的项目里中看到导入RPC数据使用的是 import {NativeModules} from 'react-native'; const NERCTAppContextModule = NativeModules.NERCTAppContextModule || {}; // iOS审核屏蔽功能 const { source = '' } = NERCTAppContextModule; 4.Worker4.1 Web Works有时候我们需要在客户端进行大量的运算，但又不希望来阻塞我们js主线程 我们可能第一时间考虑的是异步，但是实际上运算量大、运算时间长的任务同样会阻塞我们异步的事件循环，甚至会导致浏览器的假死状态 此时html5的新特性：Web Works就派上用场，它允许我们把如此复杂的逻辑放在浏览器的后台线程中进行处理，让js不阻塞ui线程的渲染 //index.js const worker = new Worker(new URL('./worker.js', import.meta.url)) worker.postMessage({ question: 'hi worker线程，请告诉我今天的幸运数字是啥' }) worker.onmessage = (message) => { console.log('今天幸运数字是：', message.data.answer) } //worker.js self.onmessage((message) => { self.postMessage({ answer: 111 }) }) 4.2 HTML5中跨文档消息传递跨文档消息传送（cross-document messaging），有时候也简称为XDM，指的是来自不同域的页面间传递消息。 着是一个bom的api， MDN：window.postMessage。 XDM的核心是postMessage()方法，实际上我们可以使用postMessage()方法进行跨域 postMessage两个参数： data:作为postMessage()第一个参数传入的字符串数据。 origin:发送消息的文档所在的域，例如“https://www.w3cmm.com”。 // 跨域发送数据到目标源 window.onload = function () { document.getElementsByTagName(\"iframe\")[0].contentWindow.postMessage({name: 'wujiang'}, \"http://localhost:8090\") } // 监听目标源发送过来的数据 window.addEventListener('message', function (e) { if(event.origin==\"http://localhost:8080\"){//注意origin是发送消息的文档所在的域。 console.log('http://localhost:8090/a.ftl ===> http://localhost:8080/index.jsp') console.log(e) } }) 4.3 Service Worker概述Service workers 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用采取来适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。（在webpack中使用service worker需要安装WorkboxPlugin） 相当于一个服务器与浏览器之间的中间人角色，一个超级拦截器 细节 基于web worker 在web worker的基础上增加了离线缓存的能力 可以拦截全站的请求，并作出相应的动作-&gt;由开发者指定的动作 由事件驱动的,具有生命周期 可以访问cache和indexDB 支持推送 并且可以让开发者自己控制管理缓存的内容以及版本 可以通过 postMessage 接口把数据传递给其他 JS 文件 特点这个 API 之所以令人兴奋，是因为它可以支持离线体验，让开发者能够全面控制这一体验。（实际上的缓存的效果） 在 Service Worker 出现前，存在能够在网络上为用户提供离线体验的另一个 API，称为 AppCache。 AppCache API 存在的许多相关问题，在设计 Service Worker 时已予以避免。 比如：我们可以以网易新闻的wap页为例,其针对不怎么变化的静态资源开启了sw缓存（例子在里面的第六节部分） https://mp.weixin.qq.com/s/3Ep5pJULvP7WHJvVJNDV-g 使用Service Worker使用条件： 传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。 在Firefox浏览器的用户隐私模式，Service Worker不可用。 注册Service Worker（通过 .register方法进行注册，通过 .then方法进行回调） 监听install事件，缓存需要的文件 拦截请求查看是否已经有需要的数据 // index.js /* 判断当前浏览器是否支持serviceWorker */ if (navigator.serviceWorker) { navigator.serviceWorker .register('sw.js') .then(function(registration) { console.log('service worker 注册成功') //服务器被停了之后仍然会打印出来 }) .catch(function(err) { console.log('servcie worker 注册失败') }) } sw内可以使用self也可以使用this,每个sw仅会安装一次,除非发生更新 //sw.js //监听 `install` 事件，回调中缓存所需文件 //event.waitUntil 你可以理解为 new Promise， //它接受的实际参数只能是一个 promise，因为,caches 和 cache.addAll 返回的都是 Promise， this.addEventListener('install', e => { e.waitUntil( caches.open('my-cache').then(function(cache) { return cache.addAll(['./index.html', './index.js']) //资源列表 }) ) }) // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 this.addEventListener('fetch', e => { e.respondWith( caches.open('my-cache').then((cache) => { return cache.match(e.request.url) }) ) 此时，我们可以在chrome的F12开发者模式中查看 Application 看到 Service Worker 已经启动了 在 Cache 中也可以发现我们所需的文件已被缓存 该示例部署到服务器上之后，用户第一次打开index页面，仍然会从服务器上拉取，之后便去安装Service Worker，执行Service Worker中的install事件，浏览器会再次拉取需要缓存的资源，这一次的缓存是否从网络拉取取决于资源设置的过期时间。当install事件中的资源均拉取成功，Service Worker算是安装成功。如果有一个资源拉取失败，此次Service Worker安装失败，若用户下次再打开该页面，浏览器仍然会重复之前的安装流程尝试安装。 如果index页面的Service Worker安装成功，用户再次打开index页面发起的资源请求便会先经过Service Woker脚本的fetch事件，在该事件中前端开发可以通过编写逻辑控制请求从网络拉取还是从cache中读取或者自己构造一个response丢给前端。 推送消息 if ('serviceWorker' in window.navigator) { navigator.serviceWorker.register('sw.js', { scope: './' }) .then(function (reg) { console.log('success', reg); navigator.serviceWorker.controller &amp;&amp; navigator.serviceWorker.controller.postMessage(\"hello im page\"); }); } //sw.js this.addEventListener('message', function (event) { console.log(event.data); }) 接收信息 //sw.js this.addEventListener('message', function (event) { event.source.postMessage('我是 sw 将发送信息到 page'); }); if ('serviceWorker' in window.navigator) { navigator.serviceWorker.addEventListener('message', function (e) { console.log(e.data); }); } 更多通讯方式可以查看https://www.lmcc.top/articles/73.html（包含跨端通讯、两个sw服务通讯） 激活service worker 但是由于Service Worker 的激活是异步的,因此首次注册 Service Worker 的时候可能Service Worker 不会被立刻激活, reg.active 为 Null，系统就会报错。这个时候我们可以采用Promise内部轮询逻辑进行处理如果 Service Worker 已经被激活那就resolve if ('serviceWorker' in window.navigator) { navigator.serviceWorker.register('sw.js') .then(function (reg) { return new Promise((resolve, reject) => { const interval = setInterval(function () { if (reg.active) { clearInterval(interval); resolve(reg.active); } }, 50) }) }).then(sw => { sw.postMessage(\"im sw\"); }) navigator.serviceWorker.register('sw2.js') .then(function (reg) { return new Promise((resolve, reject) => { const interval = setInterval(function () { if (reg.active) { clearInterval(interval); resolve(reg.active); } }, 50) }) }).then(sw => { sw.postMessage(\"im sw2\"); }) } 生命周期首次加载 注册(register) 安装(installing) 活动(activated)或者异常(error) 可以更新存储在Cache中的key和value 空闲(idle) 拦截(fetch)或终止(terminated) fetch是最重要的一个阶段，拦截代理所有指定的请求，并进行对应的操作 更新加载 更新(update) 安装(installing) 等待活动(waiting)或者异常(error) 生命周期流程图（生命周期章节）（十分推荐！条理清晰）https://xie.infoq.cn/article/d6db2099c0064563a403c51ec 注意的点1、Service Worker线程运行的是js，有着独立的js环境，不能直接操作DOM树，但可以通过postMessage与其服务的前端页面通信。 2、Service Worker服务的不是单个页面，它服务的是当前网络path下所有的页面，只要当前path 的Service Worker被安装，用户访问当前path下的任意页面均会启动该Service Worker。当一段时间没有事件过来，浏览器会自动停止Service Worker来节约资源，所以Service Worker线程中不能保存需要持久化的信息。 3、Service Worker安装是在后台悄悄执行，更新也是如此。每次新唤起Service Worker线程，它都会去检查Service Worker脚本是否有更新，如有一个字节的变化，它都会新起一个Service Worker线程类似于安装一样去安装新的Service Worker脚本，当旧的Service Worker所服务的页面都关闭后，新的Service Worker便会生效。 更多service worker 框架库由于google推出直接编写原生sw比较繁琐和复杂所以一些工具框架就出现了,而Workbox相对来说较为优秀 在 Workbox 之前，GoogleChrome 团队较早时间推出过 sw-precache 和 sw-toolbox 库，但是在 GoogleChrome 工程师们看来，workbox 才是真正能方便统一的处理离线能力的更完美的方案，所以停止了对 sw-precache 和 sw-toolbox 的维护。 参考： https://zhuanlan.zhihu.com/p/115243059 https://x5.tencent.com/product/service-worker.html https://mp.weixin.qq.com/s/3Ep5pJULvP7WHJvVJNDV-g https://www.lmcc.top/articles/73.html https://xie.infoq.cn/article/d6db2099c0064563a403c51ec 5.GIF上报埋点使用GIF上报的原因： 图像类可以解决跨域的问题 防止阻塞页面的加载 相比png/jpg，gif体积最小，最小的bmp文件需要74B，png需要67B，而合法的gif只需要43B 用gif报埋点大多数采用1*1透明GIF上报 6.jsonserver可以用于临时模拟后端接口数据，只需要一个json文件即可（jsonserver内置帮你解决了跨域问题，设置了） 使用流程Install JSON Server npm install -g json-serverCreate a db.json file with some data { &quot;posts&quot;: [ { &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; } ], &quot;comments&quot;: [ { &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 } ], &quot;profile&quot;: { &quot;name&quot;: &quot;typicode&quot; } }Start JSON Server json-server --watch db.json 或者指定好端口号 json-server --watch db.json --port 8000 Now if you go to http://localhost:3000/posts/1, you’ll get { &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; }增删改查此时你还可以通过设置请求的method，来增删改查 查 get： http://localhost:8000/posts/1http://localhost:8000/posts?id=1直接查询到id为1的接口数据（自动检索 ） 增加数据 post axios.post(\"http://localhost:8000/posts\", { { \"id\": 2, \"title\": \"json-server\", \"author\": \"typicode\" } }) 修改数据 put、patch axios.patch(\"http://localhost:8000/posts/1\", { { \"title\": \"json-server\" } }) 删除数据 delete 在删除数据的时候，若对于不同的数据表，有关联的数据也会一并删除 比如 { \"posts\": [ { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }, { \"id\": 2, \"title\": \"other\", \"author\": \"othercode\" } ], \"comments\": [ { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 } ], } 此时 comments 第一个数据有一个字段是 postId，会和 posts中id为1的数据进行关联，此时删除掉posts的第一条数据，则连带comments的数据也会被删除掉 关联数据上面再2删除数据中我们可以看到有部分的数据是关联的 如果我们想要在get的时候，带上关联的数据，我们要用 _embed 或者 _expand 字段 _embed ：获取向下关联的数据 _expand ：获取向上关联的数据 //关联的表是comments axios.post(\"http://localhost:8000/posts?_embed=comments\").then(res => { console.log(res) }) //字段是postId，所以要用post，而不是posts axios.post(\"http://localhost:8000/comments?_expand=post\").then(res => { console.log(res) }) 7.网络基础知识区块链区块链我个人认为就是一个去中心化的一个数据存储中心，里面记录了每个人是什么、拥有什么，并不被某一公司所垄断，而是由世界上每个人通过互联网来维护的存储中心（记账本） web3Web 1.0 阶段，用户是单纯的内容消费者，内容由网站提供，网站让你看什么，你就看什么，典型例子就是新闻门户网站。 Web 2.0 阶段，用户是内容的生产者，网站只是一个向用户提供服务的平台，典型的 Web 2.0 平台有维基百科、抖音、微信等等。 Web3 的很多特征还不明确，但是国外很多文章认为，它跟区块链有关。（通过区块链，我们在虚拟世界中得以生存，无法被某个强大的集团 / 公司 垄断） Web 1.0 是用户读取互联网，Web 2.0 是用户写入互联网，Web3 是用户生活在互联网。 参考： https://www.ruanyifeng.com/blog/2021/12/web3.html https://pizzaparty.substack.com/p/the-metaverse-abstracted-reality 8.前端发展史https://developer.51cto.com/article/712519.html","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"主题与2d人物","slug":"主题与2d人物","date":"2020-05-05T17:03:19.452Z","updated":"2020-05-05T17:03:19.452Z","comments":true,"path":"2020/05/06/zhu-ti-yu-2d-ren-wu/","link":"","permalink":"https://taylor12138.github.io/2020/05/06/zhu-ti-yu-2d-ren-wu/","excerpt":"","text":"Start人物使用命令安装npm：npm uninstall hexo-helper-live2d npm install –save hexo-helper-live2d此时在blog/node_modeles下多出了一个“live2d-widget”下载动画model：这里是套用别人（大佬）的仓库https://github.com/xiazeyu/live2d-widget-models.git下载好后将packages里的所有文件拷贝到blog/node_modeles最后在win使用padnote _config.yml，把以下：live2d: enable: true pluginModelPath: assets/ model: use: live2d-widget-model-epsilon2_1 #模板目录，在node_modules里 display: position: right width: 150 height: 300 mobile: show: false #是否在手机进行显示 复制进去 再使用hexo clean g d进行部署 主题下载好了之后放入blog/themes里面（整个文件）再在win使用padnote _config.yml把theme: xx改成theme: (你要的主题名)最后部署","categories":[],"tags":[],"author":"Hello"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"personal","slug":"personal","permalink":"https://taylor12138.github.io/categories/personal/"},{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[]}