{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://taylor12138.github.io","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-05-04T06:35:25.450Z","comments":true,"path":"about/index.html","permalink":"https://taylor12138.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-05-03T17:22:42.000Z","updated":"2020-05-04T06:34:25.403Z","comments":true,"path":"friends/index.html","permalink":"https://taylor12138.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-03T17:20:07.000Z","updated":"2020-05-04T06:33:11.259Z","comments":true,"path":"categories/index.html","permalink":"https://taylor12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-03T17:17:32.000Z","updated":"2020-05-04T06:33:28.454Z","comments":true,"path":"tags/index.html","permalink":"https://taylor12138.github.io/tags/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-05-03T17:21:52.000Z","updated":"2020-05-04T06:33:52.664Z","comments":true,"path":"contact/index.html","permalink":"https://taylor12138.github.io/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"Echart","slug":"Echart","date":"2021-03-26T12:37:21.458Z","updated":"2021-03-26T17:20:06.101Z","comments":true,"path":"2021/03/26/echart/","link":"","permalink":"https://taylor12138.github.io/2021/03/26/echart/","excerpt":"","text":"Echart.jsEchart.js，它是由百度公司开发的一个使用JavaScript实现的开源可视化库（同时也有D3.js，它是国外的可视化库），兼容性强，底层以来矢量图形ZRender。，可高度个性化定制数据可视化图表 安装： npm install echarts --save 官网：https://echarts.apache.org/zh/index.html 使用步骤 引入Echart文件 准备呈现图表的盒子（一定要有宽高，比如width: 600px; height: 400px） 初始化echarts对象 准备配置项 将配置设置给echarts实例对象 import * as echarts from 'echarts'; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 绘制图表 myChart.setOption({ //标题 title: { text: 'ECharts 入门示例' }, //通用配置，可设置对图表接触事件 tooltip: { //默认mousemove，移动到每一项触发光标和详情信息 trigger:'item', //设置后要click，点击才会有信息提示 triggerOn:'click' }, //工具栏，里面有很多好用的工具 toolbox:{ feature:{ //可以直接到导出图片的功能 saveAsImage:{} } } //x轴 xAxis: { type: \"category\", data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子'] }, //y轴 yAxis: { type: \"value\", scale:true //让数据不会从0开始 }, //系列列表，通过type决定图表类型，可以有多个对象 series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); 轴的type： category 类目轴 value数值轴（一般为数值轴则不用设置data属性，它会去另一个轴每个类别取series找到对应的数据） 系列表的type：line（折线图）、bar（柱状图）、pie（饼图）、scatter（散点图）、graph（关系图）、tree（树图） 折线图数据曲线平滑：smooth:true 散点图、涟漪散点图（effectScatter） 需要二维数组配合使用 饼图的数据：{name:&#39;allen&#39;, value:100}，不需要x轴、y轴 更多配置项详情查看官方文档","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Vue(下)","slug":"Vue(下)","date":"2021-03-22T07:13:54.569Z","updated":"2021-03-25T17:28:03.992Z","comments":true,"path":"2021/03/22/vue-xia/","link":"","permalink":"https://taylor12138.github.io/2021/03/22/vue-xia/","excerpt":"","text":"由于Vue部分太多了，我大概写了1.8w字，所以分上下两篇来看。。。 6.Vuex概念Vuex是一个转为Vue.js应用程序开发的状态管理模式 其实可以简单看成把需要多个组件共享的变量全部存储在一个对象里面（状态：变量），然后把这个对象放在顶层的Vue实例中，让其他组件一起使用（而且交给Vuex大管家来管理，其数据还是响应式的） 我们其实可以自己通过prototype封装共享的变量对象，但是做不到响应式 多界面共享的例子：用户登陆状态、用户名称头像、地理位置、购物车信息 单页面状态管理： View(视图template部分) -&gt; Actions(事件行为) -&gt; State(变量) -&gt; View 多页面状态管理：Vuex 使用安装 npm install vuex --save 初始化 然后新建一个store文件夹，在里面创建 index.js 文件，以下步骤和创建router路由插件几乎相同 1.通过Vue.use(插件)，来安装插件 （在vue内部执行了插件.install方法） 2.创建store对象 3.将store对象传入Vue实例当中(在mian.js里面)，类似于添加了Vue.prototype.$store = store，但是却具有响应式能力 import Vuex from 'vuex' import Vue from 'vue' // 1.安装插件 Vue.use(Vuex) // 2.创建对象 const store = new Vuex.Store({ }) // 3.导出store对象 export default store //main.js import Vue from 'vue' import App from './App' import store from './store' Vue.config.productionTip = false new Vue({ el: '#app', store, render: h => h(App) }) ​ Vuex状态管理图 Devtools 是Vue开发的一个浏览器插件，用来记录每一次改变State 需要在浏览器上安装：可以去谷歌应用商店安装Vue.js devtools 插件 Vue官方不建议Components直接修改State ，但是官方允许Components直接修改Mutations Actions用于处理异步操作（Backend，也就是后端），Mutations一般都是存储同步操作 store对象内置属性： state：保存状态（变量），其他组件可以通过 $store.state.变量名进行获取（类似data） getters：类似于组件里的计算属性computed, 里面的函数默认可以传入state作为参数 mutations：定义修改状态的方法，里面的函数默认可以传入state作为参数（类似methods） actions：在里面处理异步操作 modules：用于划分模块 具体操作 const store = new Vuex.Store({ state: { counter: 10, }, mutations: { increment(state) { state.counter++; }, decrement(state) { state.counter--; }, actions:{}, getters: {}, modules:{} } }) 使用共享变量的组件，这时调用共享的方法Mutations需要用commit来提交 &lt;template> &lt;div id=\"app\"> &lt;h2>{{ $store.state.counter }}&lt;/h2> &lt;button @click=\"add\">+&lt;/button> &lt;button @click=\"sub\">-&lt;/button> &lt;/div> &lt;/template> &lt;script> export default { name: \"App\", methods: { add() { this.$store.commit(\"increment\"); }, sub() { this.$store.commit(\"decrement\"); }, }, }; &lt;/script> Vuex每个属性详解State单一状态树 vuex推荐只创建一个Vuex.Store实例，若创建多个，日后不方便进行维护 单一状态树可以最直接地找到某个状态 Getters基本使用 里面的函数默认可以传入state作为参数，但也可以默认传入 gatters 已有的数据（若传进来，第一个参数为state，第二个参数为getters）。如果要在组件中传入参数，则需要把返回的值改成返回一个函数 const store = new Vuex.Store({ state: { counter: 10, }, getters: { doubleCounter(state) { return state.counter * state.counter; }, doubleCountermore(state, getters) { return getters.doubleCounter + 1; }, add(state, getters) { return num => { return getters.doubleCountermore + num } } }, }) &lt;h2>{{ $store.getters.doubleCounter }}&lt;/h2> &lt;h2>{{ $store.getters.add(10) }}&lt;/h2> 在子组件使用getters时，还可以使用：mapGetters 辅助函数，它仅仅是将 store 中的 getter 映射到局部计算属性： 此时，我们便可以在子组件直接使用该数据：&lt;div&gt;&lt;/div&gt; import { mapGetters } from 'vuex' export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doubleCounter', 'doubleCountermore', 'add', // ... ]) } } Action基本使用 Action类似于Mutation，但是是用来替代Mutation进行异步操作的（其实也可以来替代一些功能复杂的操作） 和Getter、Mutation不同，默认传入的参数不是state，而是 context：上下文，在下面的例子里，可以把context理解成store对象 但是也不支持在action里直接修改state，即不支持 context.state.info.name = ‘Mikasa’ 详情关系图可以看Vuex状态管理图，在action使用commit进行提交 -&gt; mutation 第二个参数可选，为传入的对象payload，类似mutation 在组件中调用action的异步方法，使用 this.$store.dispatch(&quot;方法名&quot;[, 传入参数]); const store = new Vuex.Store({ state: { counter: 10, info: { name: 'Allen', age: 18, feature: '始祖巨人' } }, mutations: { update(state) { Vue.set(state.info, 'address', '帕拉迪亚岛') } }, actions: { aupdate(context, payload) { setTimeout(() => { context.commit('update'); console.log(payload); }, 1000); } }, }) //Vue对象的methods属性里 update() { this.$store.dispatch(\"aupdate\", \"我是payload\"); }, 使用Actions时可以返回一个Promise 当然，碰到了异步操作，且想要确认异步操作是否完成，少不了Promise的优雅加成： actions: { aupdate(context, payload) { return new Promise((resolve, reject) => { setTimeout(() => { context.commit('update'); console.log(payload); resolve(); }, 1000); }) } }, update() { this.$store .dispatch(\"aupdate\", \"我是payload\") .then(() => { console.log(\"执行成功！\"); }) .catch(() => { console.log(\"执行失败\"); }); }, 同样的，在子组件使用Actions时，也可以使用：mapActions 辅助函数，将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：（此时用 this.方法名即可调用） import { mapActions } from 'vuex' export default { // ... methods: { ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) } } Module基本使用 store推荐state单一状态树、但是state里包含太多数据会显得十分臃肿 为此，Vuex允许我们讲store分割成模块（Module），每个模块拥有自己的state、mutation等 const store = new Vuex.Store({ modules: { a: { state: {}, mutations: {}, actions: {}, getters:{} }, b: { state: {}, mutations: {}, actions: {}, getters:{} } } }) 或者在store的外部定义 module对象，然后直接在store的modules里面引用就可以了 const moduleA = { state:{}, mutations:{} } const store = new Vuex.Store({ modules: { a:moduleA } }) 在组件中使用模块的state数据： $store.state.模块名称.状态 &lt;h2>{{$store.state.a.name}}&lt;/h2> 组件中使用模块的mutation则使用方法和原来放在store里一样，在组件中直接this.$store.commit(事件类型)就可以了 getters也是也原来放在store里一样去使用，但是如果模块的getter想要使用到原来的store中的state，则此时模块的getter可以传入三个参数，分别是： 自身的state getters store的state const moduleA = { state: { name: 'Armin' }, getters: { fullname(state, getters, rootState) { return state.name + rootState.counter } } } 4.它的actions中 context.commit(&#39;函数&#39;); ，函数只能是模块中mutations里面的函数 Mutations基本使用mutations作为Vuex的一个属性，但是包含的东西比较多，就单独拉出一个篇章来讲 官方认可：Vuex的store状态的更新唯一方式：提交Mutation mutations里每个方法完成的事件尽量单一（也就是一个方法，不要有对于state的多种修改功能），方便跟踪Devtools的跟踪，可以选择放在Actions里，然后Action里的函数commit到不同的mutation函数对state修改 Mutation主要包括两部分： 字符串的事件类型 一个回调函数，该回调函数的第一个参数就是state 比如上述 使用 部分的例子中（代码放在了下方），increment为事件类型，(state) {state.counter++;}为回调函数 increment(state) { state.counter++; } 然后在组件中通过mutation更新进行使用 this.$store.commit(事件类型) mutations传参问题： 里面的函数默认可以传入state作为参数，第一个参数为state 第二个参数为外部传进来的参数（如果要传递多个参数，则我们可以以对象的形式进行传递），它有个专业名词叫 payload：载荷 const store = new Vuex.Store({ mutations: { increment(state) { state.counter++; }, incrementCount(state, num) { state.counter += num; } }, //组件的methods methods: { add() { this.$store.commit(\"increment\"); }, addCount(num) { this.$store.commit(\"incrementCount\", num); }, }, mutations提交风格 除了上述的commit提交方式，Vue还提供了另外一种风格，它是包含type属性的对象，而传入的参数即使并不需要传递多个，但也需要（自动）变成一个对象 this.$store.commit({ type: \"incrementCount\", // 这时传过来的num变成一个对象 num: num, }); 此时mutation传入的是对象，所以也要发生相应改变 mutations: { incrementCount(state, payload) { state.counter += payload.num; } }, Mutations常量类型 定义常量是减少错误的基本方法 在store文件夹里定义一个js文件，比如 mutation-type.js 用于存储常量名，然后在其他文件里用 import导入，用常量名以 [常量名]的形式 替代mutations里的函数名，然后引用mutation函数的时候，继续先import导入存储常量名的js文件，直接引用 this.$store.commit(常量名); 就可以了 虽然过程十分繁琐，但有利于项目开发后的维护找错 Mutation同步函数 通常情况下，Vuex要求我们Mutation中方法必须是同步方法 主要原因是我们使用devtools时，devtools可以帮助我们捕捉mutation的快照 但如果是异步操作，那devtools将不能很好的追踪到这个操作什么时候会被完成 Vuex响应式原理Vuex的store中的state是响应式的 state其中每个状态都有对应的 Dep -&gt; [Watcher]，监听变化 包括状态里对象的每个属性的变化 但这要求我们必须遵守Vuex对应的一些规则： 提前在store初始化所需的属性 当给state对象添加新属性时，使用下列方式： 方式一：使用Vue.set(obj, &#39;newProp&#39;, 123) 方式二：用新对象给旧对象重新赋值 这里和数组的响应原理一样，有一些数组方法也不是响应的，需要借助其他方法来进行响应处理（如 this.arr[0] = &#39;nothing&#39;; ） 删除属性的方式也相应改成使用 Vue.delete(obj, &#39;newProp&#39;) 7.网络封装选择一：传统的Ajax基于XMLHttpRequest（XHR），但是配置和调用比较混乱、编码也甚是麻烦，所以真是开发很少直接使用，而是使用jQuery-Ajax 选择二：jQuery-Ajax，但是Vue开发里面已经不再需要jQuery，没必要为了使用其中jQuery部分功能去引用整个jQuery框架 选择三：Vue1.x的时候，官方推出Vue-resource，但是在Vue2.0推出后，Vue作者已经就将其去掉了，不再进行更新 选择四：Vue作者推荐：axios axios请求方式： axios(config) axios.get(config) axios.post(config) axios.request(config) 等等 安装axiosnpm i axios --save 导入 import axios from 'axios' 使用 在Ajax篇章中已经有描述 8.其他事件总线事件总线和vuex的作用很像，只不过vuex用于管理状态（变量），而事件总线用于管理事件 1.在main.js 文件中 创建一个新的Vue实例，以得到一个bus Vue.prototype.$bus = new Vue(); 2.发射 this.$bus.$emit(&#39;事件名&#39;[, 参数]) 3.接受 this.$bus.$on(&quot;事件名&quot;, 回调函数(参数)) 4.可以在deactivated里设置离开时不接受该事件的传递（取消全局事件监听）：this.$bus.$off(&quot;事件名&quot;, 接收时的回调函数(参数));，回调函数要和接收时发生的回调函数保持一致 mixin（混入）为了减少两个对象之间重复的代码，Vue官方提供了 minxin（较少类重复的代码可以用es6的继承） 官方示例： var mixin = { created: function () { console.log(1) } } var vm = new Vue({ created: function () { console.log(2) }, mixins: [mixin] }) // => 1 // => 2 自定义插件正常情况下，我们都可以使用组件完成对应的模块功能，使用组件需要 1.在模板中引用 2.引入模块 3.组件的components中声明 但是如果想要在该组件完成固定功能，可能还需要 4.声明对应的data 5.写入对应的方法 6.组件之间传递变量 4、5、6步骤如果放在不同的组件使用一样的功能，可能要声明很多次，这时我们可以使用插件来简化（降低耦合）操作 下面以制作 Toast 自定义插件为例子（冒泡提示插件） 先建立toast组件 &lt;template> &lt;div class=\"toast\" v-show=\"isShow\"> {{ message }} &lt;/div> &lt;/template> &lt;script> export default { name: \"Toast\", data() { return { message: \"\", isShow: false, }; }, methods: { //duration时间间隔默认2s showMessage(message, duration = 2000) { this.message = message; this.isShow = true; setTimeout(() => { this.isShow = false; this.message = \"\"; }, duration); }, }, }; &lt;/script> &lt;style scoped> &lt;/style> 在toast组件的文件夹下，新建index.js文件 //引入toast组件 import Toast from \"./Toast\"; const obj = {}; // 可以选择传进来一个Vue，对Vue对象进行操作 obj.install = function (Vue) { // 1.创建组件构造器（在vue外面使用组件就要用到组件构造器） const toastConstructor = Vue.extend(Toast); // 2.使用new的方式创建组件对象 const toast = new toastConstructor(); // 3.将组件对象挂载到某元素上 toast.$mount(document.createElement('div')); // 4.toast.$el 对应的就是 div document.body.appendChild(toast.$el); // 5.设置prototype之后，以后调用插件方法只需要$toast即可 Vue.prototype.$toast = toast; } export default obj 在全局的main.js中使用该插件 import toast from \"@/components/common/toast\" Vue.use(toast); 这时我们就可以再各个组件中直接使用该插件了（此时只需要执行以下代码，即可出现冒泡提示） this.$toast.showMessage(\"你想要输入的信息\", 2000); //2000为自定义的时间间隔 vue图片懒加载可以使用vue-lazyload插件 $ npm i vue-lazyload -S （在main.js里）引用时可以传递一些想要的参数，比如加载前的图片显示等 import VueLazyload from 'vue-lazyload' Vue.use(VueLazyload) Vue.use(VueLazyload, { preLoad: 1.3, error: errorimage, loading: loadimage, attempt: 1 }) 安装和引用之后，将原来的 &lt;img :src=&quot;img.src&quot; &gt; –&gt; &lt;img v-lazy=&quot;img.src&quot; &gt;即可 Vue和React相同之处： React与Vue存在很多相似之处，例如他们都是JavaScript的UI框架，专注于创造前端的富应用。不同于早期的JavaScript框架“功能齐全”，Reat与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。 Vue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了’Virtual DOM’（虚拟DOM），如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM，这样可以减少开销；当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。 不同之处： React与Vue最大的不同是模板的编写。Vue鼓励你去写近似常规HTML的模板（template），写起来很接近标准HTML元素，只是多了一些属性，然后用类似于Angular风格的方法去动态输出内容；而React推荐你使用 JSX 来写模板，JSX只是JavaScript混合着XML语法，有部分人使用起来会觉得很畅快。值得一提的是，与React一样，Vue在技术上也支持render函数和JSX，但只是不是默认的而已 在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理，而Vue提供响应式的数据，当数据改动时，界面就会自动更新；React的数据使用state对象（状态）保存，在React中你需要使用setState()方法去更新状态 （我在观看视频老师对比React and Vue的时候看到的结果（虚拟DOM与DOM Diff 的原理，作者饥人谷，第二集））在测试插入10w个div标签的时候，DOM的原生渲染速度是大概2s；React的速度大概接近30s；Vue竟然是接近原生DOM，1s-3s 9.原理相关双向绑定Object.defineProperty( )的 get （读取属性值触发的函数）和 set（set就是在设置属性值触发的函数），所以Vue会根据数据变化，重新渲染到虚拟DOM，然后根据虚拟DOM，把真实DOM进行修改 Object.defineProperty(对象名, 属性名, desciptor) Object.defineProperty(obj, key, { set(newValue) { console.log(\"监听\" + key + \"改变\"); value = newValue; }, get() { console.log(\"获取\" + key + \"的值\"); return value; } }) Object.freeze()会阻止修改现有的 property，也意味着响应系统无法再追踪双向绑定变化。 当数据发生改变，Vue是如何通知哪一部分发生刷新？(set() {} 里面该如何进行操作？) 发布订阅者模式： // 发布者类 class Dep { constructor() { // 用于存储订阅者的数组 this.subs = []; } // 增加订阅者方法 addSub(watcher) { this.subs.push(watcher); } // 调用之后，每个订阅者都会进行更新 notify(){ this.subs.forEach(item => { item.update() }) } } // 订阅者类 class Watcher { constructor(name) { this.name = name; } update(){ console.log(this.name, \"发生更新\"); } } const dep = new Dep(); const watcher1 = new Watcher(\"item1\"); const watcher2 = new Watcher(\"item2\"); const watcher3 = new Watcher(\"item3\"); dep.addSub(watcher1); dep.addSub(watcher2); dep.addSub(watcher3); dep.notify(); data中每一个属性，都添加一个发布者类（new 一个 发布者实例） 谁通过 get(){}对数据进行获取，则对其添加订阅者类（new 一个 订阅者实例），然后将订阅者push进发布者的subs数组中 当数据发生修改，即触发 set(){}函数，在里面使用notify： set(){ dep.notify(); } 让所有订阅者随之发生更新（调用了所有订阅者的update方法） （实际上watcher有很多种，正常的data属性的渲染页面watcher（下面这个）、computed的watcher、watch（用户自定义）的watcher） Observer：每个属性创建一个Dep对象（发布者），若data数据发生改动，则调用Dep对象的notify方法 Compile：解析el中的指令，每次使用到data的数据，就创建一个Watcher（订阅者），然后加入到该属性对应的发布者 响应式的注意事项 Vue的缺点： 1.必须在 data 对象上存在才能让 Vue 将它转换为响应式的 var vm = new Vue({ data:{ a:1 } }) // `vm.a` 是响应式的 vm.b = 2 // `vm.b` 是非响应式的 2.若原来属性不存在，对象新增属性，Vue也检测不到 3.Vue 不能检测以下数组的变动： 1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 2.当你修改数组的长度时，例如：vm.items.length = newLength 上述数组的改变无法检测得到，使用Vue.set()才能新增一个属性 4.还有个小缺陷，就是默认会递归，递归你data里的属性，可能导致性能不高 注意 2020年后 Vue3.0已经换成用proxy代理了 Vue原理小知识Vue检测数组中的变化 我们都知道数组有push、shift、pop这些方法 而Vue对data里数组的原型方法（prototype）进行了重写，__proto__指向新的原型对象， 通过原型链定义函数，这样的话我们就可以在其中设置响应式（原来的函数.apply + 调用更新视图方法 notify()） 然后，利用observer对数组里的每一项进行监控 Vue采用异步渲染 为何Vvue采用异步渲染（数据）？ 防止一更改数据就更新视图 ，多个数据发生更改后，可以先过滤掉同一个订阅者（内置di，根据id过滤同一watcher，即不用导致watcher进行多次update），提高性能 虚拟DOMDOM实际操作是挺快的，任何基于DOM的库（Vue/React）都不可能操作DOM时比DOM快 虚拟DOM：一个能代表DOM树的对象，通常含有标签名、标签上属性、事件监听和子元素们，以及其它属性 为什么虚拟DOM比真实DOM快？ 减少DOM操作：可以将多次DOM操作合并为一次操作，比如添加100个节点原来是一个一个添加，现在是一次性添加 虚拟DOM借助DOM diff 可以把多余的操作省略掉，比如如果它发现有一些节点已经在页面里，就不选择更新，只更新不一样的部分（比如上面“虚拟DOM渲染特殊案例”提及到的） 跨平台，虚拟DOM不仅可以变成DOM，还可以变成小程序、ios应用、安卓应用，因为虚拟DOM本质上只是一个JS对象 （图片源自饥人谷） 创建虚拟DOM（原始方法）（分别对应React和Vue） （将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的） 虚拟DOM的缺点：需要额外创建函数，如createElement或h，但是有解决方法，如下：（通过babel、vue-loader转换） 现在创建DOM的方法： 虽然克服了虚拟DOM的缺点，但是新增了另外一个缺点，也就是严重依赖打包工具！！ 但其实当规模比较合理的时候，比如几千的时候，使用虚拟DOM是很好的，他可以通过算法优化很多多余的操作，但是当规模大到一定的程度，10w以上等等，在这个情况下原生DOM能保持稳定性，而React就崩了（我在Vue和React的对比里面提及到） DOM diffdiff就是一个函数，我们称之为patch； pathces= patch(oldVNode, newVNode)，分别对应旧节点和新节点，patches就是运行的DOM操作 把虚拟DOM想象成树型 只更新不一样的部分（比如上面“虚拟DOM渲染特殊案例”提及到的） Tree diff逐层对比，查看哪里需要更新；看节点（Element diff）/组件（Component diff），查看标签名/组件类型 若标签类型没变，只更新div对应的DOM属性，变了的话直接替换 没替换的话，进入标签后代/深入组件 后继续做 Tree diff 递归 但DOM diff也有 bug 更新的时候，直接看第一个children， 把 hello -&gt; world，然后再删除掉原来的 span -&gt; world；而不是直接删除掉hello的children 所以我个人理解 优点就是：复用性提高； 缺点就是由于diff算法，导致了实际上比较简便的操作变得复杂了（可以使用key避免） 时间复杂度：两棵树的diff时间复杂度为O(n^3)，但是Vue优化了（双指针），O(n^3) -&gt; O(n)，即4个指针分别指向新节点头，新节点尾、旧节点头、旧节点尾，两两进行比较 10.Vue3.0他在介绍中表明的是： 更小、更快、更易维护，一些命令的变化。 3.0 新加入了 TypeScript 以及 PWA 的支持 而我主要关注的是（在响应式原理上变化比较大）：放弃 Object.defineProperty ，使用更快的原生 Proxy 细节方面： 单独功能可以抽离 取代了mixin（尤雨溪作者本人指出minxin模块来源不清晰、命名问题、性能开销问题） 引入 setup函数，在props初始化之后调用，可以用来取代 beforeCreate 、 created钩子函数，因为它在 beforeCreate之前调用 。 在 setup 内部可以使用 this，但你大部分时候不会需要它。 ，因为未执行 Created 无法使用 data 和 methods 的变量和方法 setup() 可以返回一个对象 —— 这个对象上的属性将会被暴露给模版的渲染上（即 setup里的属性可以类似于data在模板中直接使用） 所有现有的生命周期钩子都会有对应的 onXXX 函数（只能在 setup() 中使用） import { onMounted, onUpdated, onUnmounted } from 'vue' const MyComponent = { setup() { onMounted(() => { console.log('mounted!') }) onUpdated(() => { console.log('updated!') }) // destroyed 调整为 unmounted onUnmounted(() => { console.log('unmounted!') }) } } Vue2.x版本中的双向绑定不能检测到下标的变化，不存在的属性不能被拦截（其实也是因为 Object.defineProperty方法必须传入对象、属性参数），属性中还有属性嵌套还得递归 proxy可以劫持整个对象，并返回一个新对象，管你属性存不存在都可以拦截 响应式方面 性能得到很大提升 不用初始化的时候就递归遍历属性；响应式不区分数组和对象 Proxyvue3.0 使用proxy代替了vue2.0版本中的defineProperty的数据拦截 Proxy代理Object 控制和修改Object的基本行为，比如属性调用、属性赋值、删除属性、方法调用等 target是被代理的对象，handler是一个对象，属性是各种控制或修改target基本行为的方法 const p = new Proxy(target, handler); 它里面的get()、set()和Object.defineProperty()的get方法、set方法有点像，重新定义了属性的读取、设置行为 get()拦截某个属性的读取操作。可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。 set()拦截某个属性的赋值操作。可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。 里面的方法一般都需要返回值 var obj = new Proxy({}, { get: function (target, propKey, receiver) { console.log(`getting ${propKey}!`); return Reflect.get(target, propKey, receiver); }, set: function (target, propKey, value, receiver) { console.log(`setting ${propKey}!`); return Reflect.set(target, propKey, value, receiver); } }); 元编程：指某种计算机程序的编写，操纵其他（或自身）程序作为他们的资料，或在运行时完成部分本应在编译时完成的工作，让程序员获得更高的工作效率，或给予程序更大灵活度而无需重新编译 编写元程序的语言为元语言，一门编程语言同时也为自身的元语言称为反射 more: 这里Proxy相对与原来Vue2.0的响应式的 “不管三七二十一，上来就给你判断对象 + 递归 ” 不一样，做了小优化，他在修改数据时并不是一上来就递归，而是先通过get方法获取，如果获取到的结果是一个对象，则再做一层代理，进行递归，然后再通过set修改 既然Proxy可以改属性 + 新增属性，那他怎么识别？通过 if 语句 + 对象.hasOwnProperty(属性) 判断，原来是否有这个属性 为什么以前不用Proxy？兼容性差。。。ie11就不兼容 Reflect Reflect 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上，也就是说，从Reflect对象上可以拿到语言内部的方法。 Reflect修改某些Object方法的返回结果，让其变得更合理。 比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 上面两点表明 Reflect可能将成为日后替代 Object对象方法的新的王！ 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 // 老写法 'assign' in Object // true // 新写法 Reflect.has(Object, 'assign') // true Reflect对象的方法与Proxy对象的方法一一对应**，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 Proxy(target, { set: function(target, name, value, receiver) { var success = Reflect.set(target, name, value, receiver); if (success) { console.log('property ' + name + ' on ' + target + ' set to ' + value); } return success; } }); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。 个人认为：这样就形成了Proxy和Reflect的最佳搭配，既保证了原来（默认）的行为，又可以自己添加额外的行为","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"深入JavaScript内存","slug":"深入JavaScript内存","date":"2021-03-20T16:00:00.000Z","updated":"2021-03-21T12:18:55.345Z","comments":true,"path":"2021/03/21/shen-ru-javascript-nei-cun/","link":"","permalink":"https://taylor12138.github.io/2021/03/21/shen-ru-javascript-nei-cun/","excerpt":"","text":"内存概述内存也是有生命周期的，不管什么程序语言，一般可以按顺序分为三个周期： 分配期 分配所需要的内存 使用期 使用分配到的内存（读、写） 释放期 不需要时将其释放和归还 定义变量自动分配内存 绝大部分情况下也不需要手动释放内存 而我们程序员大多只需关注使用内存 内存泄漏当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用（或者由于设计错误）而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。 而内存泄漏也是造成应用程序OOM（内存严重不足）的罪魁祸首之一 内存泄露的问题其困难在于 1.编译器不能发现这些问题。 2.运行时才能捕获到这些错误，这些错误没有明显的症状，时隐时现。 3.对于手机等终端开发用户来说，尤为困难。 解决方法： 避免创建全局变量，开启严格模式 不能滥用闭包 清除没有用的DOM元素引用 (document.body.removeChild(DOM元素)) 定时器用完离开页面记得手动删除（clearInterval()） 使用Vue的时候，在页面销毁时记得对事件解绑，对EventBus进行解绑 beforeDestory () { window.removeEventListener('事件名', 接收时的回调函数(参数)) } destroyed () { this.$bus.$off(\"事件名\", 接收时的回调函数(参数)); } 在ES6 里可以使用 WeakMap、WeakSet JavaScript的垃圾回收机制（GC）标记清除算法设置一个根对象（root）（在Javascript里，根是全局对象）），然后垃圾回收器会定期从根（root）扫描内存中的对象，凡是能从根到达的对象，就是还需要用的，到达不了的进行标记，稍后回收 所有标记清除算法有两个阶段： 标记阶段 清除阶段 算法缺陷：无法从根对象查询到的对象都会被清除，垃圾收集完毕后会造成大量内存碎片 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进 引用计数算法古老的垃圾回收算法，可怜的它现在几乎没人用了 原理是跟踪记录每个值被引用的次数，被引用一次，则count + 1（除了弱引用类型WeakMap、WeakSet） chrome V8 回收算法Chrome 浏览器所使用的 V8 引擎就是采用的分代回收策略。这个和 Java 回收策略思想是一致的。目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（新生代younggeneration），少回收「持久对象区」（老生代 tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。 减少垃圾回收对性能的影响：1.让垃圾回收尽量少地进行 2.避免内存泄露","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"http具体而微","slug":"http具体而微","date":"2021-03-14T16:00:00.000Z","updated":"2021-03-26T09:02:42.877Z","comments":true,"path":"2021/03/15/http-ju-ti-er-wei/","link":"","permalink":"https://taylor12138.github.io/2021/03/15/http-ju-ti-er-wei/","excerpt":"","text":"1.http概述从计算机网络的学习我们了解到：HTTP协议[超文本传输协议]，协议详细规定了浏览器和万维网服务器之间相互通信的规则 新的http/2 使用二进制传输（二进制分帧），减少服务端压力，连接吞吐量更大，改善TCP拥塞状况，同时慢启动时间减少 多路复用 压缩headers（最小数据量化） 支持server push（服务端推送），他可以对客户端的一个请求发送多个响应，，而且它还有一个很大的优势：可以缓存，使用场景如下，「如果客户端早已在缓存中有了一份 copy 怎么办？] 这种情况下，HTTP/2 允许客户端通过 RESET_STREAM 主动取消 Push ，然而这样的话，原本可以用于更好方向的 Push 就白白的浪费掉数据往返的价值。 对此，一个推荐的解决方案是，客户端使用一个简洁的 Cache Digest 来告诉服务器，哪些东西已经在缓存，因此服务器也就会知道哪些是客户端所需要的，因为 Cache Digest 使用的是 Golumb Compressed Sets，浏览器客户端可以通过一个连接发送少于 1K 字节的 Packets 给服务端，通知哪些是已经在缓存中存在的； http/1处理减少请求的方式是线头阻塞（合并多个请求为一个请求），但实质上有一定的开销 下面我们阐述http 1.x版本的内容 http协议的特点 永远都是客户端发起请求，服务器回送响应 http协议是无状态的，但是在实际工作中，一些万维网网站希望能识别用户（给用户推销产品）=&gt;诞生了cookie小饼干，cookie是存储在用户主机的文本文件，记录一段时间内某用户的访问记录（不太敏感的数据） http采用TCP作为运输层协议，但是http协议本身是无连接的 （交换http报文之前不需要建立连接） http连接方式：持久连接（非流水线式（有点像停等协议）、流水线式（有点像GBN或SR协议，即后退N帧协议和选择重传协议））、非持久连接（每次传输都要三次握手） 资源通过 URL进行定位 URL：统一资源定位器 URL和域名的区别域名，Domain Name，通常指一个网址的顶级域名。URL，website address，网页或网站的地址。 URL中包含了网站的域名.比如一个网址：www.cnblogs.com/gopark/p/8430916.html其中cnblogs.com是域名，cnblogs是网站名字，com是域名后缀；www.cnblogs.com代表一个二级域名，通常www被用来用为首页标识；https://www.cnblogs.com/gopark/p/8430916.html，这个则是一个完整的网站首页URL地址。https://，这是一个协议，是网站在网上传输的协议 URL和URI的区别： URI，统一资源标志符，表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行标识的。 URL是URI的一个子集，通俗地说，URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上 http请求 get 获取资源。get注重url获得的参数，且只产生一个TCP数据包 获得get请求的内容，它的内容是在url的? 之后的部分 post 创建资源（带请求体）。post的信息放在Request body中，且产生TCP两个数据包（firefox浏览器除外） post回退时会再次提交请求；一般情况下，私密数据传输用POST + body就好 put 更新资源（带请求体） delete 删除资源 请求报文： 1.行 第一部分是请求类型（GET、POST之类的） 第二部分是url的路径 第三部分是http协议的版本（目前使用最多的是1.1） 2.头（首部） 格式是值键对的形式 Host: atguigu.com Cookie: name=guigu Content-type = application/x-www-form-urlencoded User-Agent: chrome 83 3.空行 4.体 GET的话，请求体为空，POST的话，请求体可以不为空 响应报文 1.行 第一部分是http协议的版本（目前使用最多的是1.1） 第二部分是响应状态码 第三是响应状态字符串 2.头 （首部） 格式和请求头一样 3.空行 4.体 html的内容 报文和实体 http报文和http实体是不同的概念，http报文类似于运输的箱子，http实体类似于箱子中的货物（个人感觉 实体 = 报文 - 行 - 除了实体首部字段的所有首部字段） 报文：网络中交换和传输的数据单元，即一次性要发送的数据块，包含了发送的完整数据信息 实体：作为请求和响应的有效载荷数据 http工作 地址解析，通过DNS解析域名,得主机的IP地址 封装http的请求数据包 封装成TCP包，建立TCP连接（三次握手） 客户端向服务器发送请求 服务器向客户端返回响应 关闭TCP连接（四次挥手） 2.持久连接在http初始协议版本中，每进行一次http通信都要断开一次TCP连接，如果需要同时请求多个资源时就造成了无缘无故的TCP连接建立和断开，造成资源浪费，增加通信开销。 为了解决上述问题，http/1.1和http/1.0想出了持久连接的方法，其特点是只要一方没有明确提出断开，就保持TCP连接。在 http/1.1 中，所有的连接默认都是持久连接 延伸出来的管线化持久连接使得管线化的方式成为可能，管线化技术出现后，不用等待即可发送下个请求 3.首部字段概述HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段。 在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。 结构 格式是值键对的形式 类型分为： 通用首部字段（请求和响应通用）Cache-Control、Connection等 请求首部字段（请求专用）Accept、Accept-Charset、Host（请求资源所在服务器）等 响应首部字段（响应专用）Accept-Ranges、Location（令客户端重定向至指定 URI）、Server（HTTP 服务器应用程序的信息）等 实体首部字段（通用，针对报文的实体部分）Allow、Content-Encoding等 4.http和httpshttp：超文本传输协议，它是以一种明文的方式（传输是明文的），没有任何加密，如果我们在该网站输入登录密码等信息，发送请求到服务器时，如果有人在中途截取我们的信息，那我们的信息可能就暴露了，默认80 https：超文本传输安全协议，利用SSL/TLS来加密数据包。默认443，需要到 CA 申请证书，一般免费证书很少，需要交费，握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； 对称密钥的弊端就是，可能被中间人拦截，这样中间人就可以获取到了密钥，就可以对传输的信息就行窥视和篡改。 非对称密钥（RSA）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密 但它的弊端就是，算法很慢 我们使用结合的方式！ 使用 非对称密钥（RSA） 发送 对称密钥，然后双方使用 对称密钥 进行通信 SSL协议：这个协议简单来说就是提供数据安全和完整性的协议，也就是负责网络安全的加密。比如我们访问了一个https网站，客户端和服务端会（握手阶段） 先建立安全的连接通道，客户端先给出协议版本号 + 支持的加密方法 + 随机数等 确认信息后，服务器会生成一个加锁的箱子，但是这把锁有两把不一样的钥匙，一把留给服务器自己（私钥），一把提供给客户端（公钥） 服务器发送 — &gt; 未上锁的箱子 + （里面放着一份网站的证书（证书包括公钥和数字签）到 – &gt; 客户端（你访问的服务器没问题）） 客户端生成两把对称密钥，一把留给自己，然后把信息 + 另一把对称密钥放到箱子中，用钥匙锁上（只能用私钥开）发送 —&gt;服务器 然后服务器用另外一把钥匙（私钥）打开箱子，然后双方可以通过对称密钥通信了 在这个过程中，即使箱子被拦截了，也很难打开箱子 中间人攻击因为传输非对称密钥的时候，服务端发送的是公钥，，有可能被中间人拦截后进行篡改 这时我们就需要数字证书，确定服务端的身份，一定是服务端发送的，而数字证书类似于我们的公证处 这篇文章可以生动形象地了解到 https 的原理 https://juejin.cn/post/6844903504046211079 TLS协议它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本 对比SSL的增强内容： 更安全的MAC算法 更严密的警报 “灰色区域”规范更加明确定义 session恢复握手阶段通过SSL/TLS进行连接，如果出于某种原因，对话中断，就需要重新握手 此时有两种方法可以恢复原来的session session ID session ticket Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过Session ID来区分不同的客户，通过这个Session ID，双方还可以重新使用已有的”对话密钥“，无需重新生成 session ID的优点是高兼容性，但缺点是只能保留在一个服务器上 session ticket优点可在其他服务器上使用，缺点：目前只有火狐和谷歌支持 session ticket是加密的，只有服务器才能解密，其中包括对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。 5.响应状态码200：ok 204：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。 206：客户端进行了范围请求，服务器成功执行部分get请求 301：永久重定向 第一次进入a.com，请求-&gt;b.com，以后每次进入a.com就不用请求直接去b.com（请求的资源已被永久分配了新的 URI） 302：临时重定向（暂时性转移） 每一次都会进入a.com，然后请求-&gt;b.com（请求的资源已被临时分配了新的 URI） 303：有点像302，只不过303提醒你应该使用get请求 304：自从上次请求后，请求的网页未修改过，所以没有响应主体部分 307：同302 400：报文存在语法错误 401：未授权 403：服务器理解了请求但拒绝对其进行授权，被禁止，资源访问被服务器拒绝了 404：找不到， 413：表示http请求实体太大。 500：内部错误 502：错误网关，从上游服务器收到无效响应，可能也是停机维护，或者服务器暂未开启， 503：服务器目前无法使用（由于超载或停机维护）通常，这只是暂时状态。（服务不可用） 504：网关超时 6.http缓存常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力。对于开发者来说，长久缓存复用重复不变的资源是性能优化的重要组成部分！！！ 浏览器第一次向一个web服务器发起http请求后，服务器会返回请求的资源，并且在响应头中添加一些有关缓存的字段（添加后浏览器才知道是否应该缓存资源）如： Cache-Control（控制浏览器是否可以缓存资源、强制缓存校验、缓存时间）（通用头部） no-cache：含义是不使用本地缓存，需要使用协商缓存，也就是先与服务器确认缓存是否可用。 no-store：禁用缓存。 public：表明其他用户也可使用缓存，适用于公共缓存服务器的情况。 private：表明只有特定用户才能使用缓存，适用于公共缓存服务器的情况 Expires（与响应头中的 Date 对比）（实体头部） Last-Modified（弱校验， 根据文件修改时间，可能内容未变，不精确）（实体头部） ETag（强校验，根据文件内容生成精确）（响应头部） Date等等。 http缓存都是从第二次请求开始的。第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源 强缓存 + 协商缓存之后浏览器再向该服务器请求该资源就可以视情况使用强缓存和协商缓存。 强缓存：（当前缓存未过期）浏览器直接从本地缓存中获取数据，不与服务器进行交互。 协商缓存：（当前缓存过期）浏览器发送请求到服务器，服务器判定是否可使用本地缓存。 联系与区别：两种缓存方式最终使用的都是本地缓存；前者无需与服务器交互，后者需要。 缓存过期策略1、设置 Cache-Control: max-age=1000 。响应头中的 Date 经过 1000s 过期（比起首部字段Expires，会优先处理s-maxage或max-age。）2、设置 Expires 。此时间与本地时间(响应头中的 Date )对比，小于本地时间表示过期，由于本地时钟与服务器时钟无法保持一致，导致比较不精确（http1.0时代，Pragma也是1.0时代的产物）3、如果以上均未设置，却设置了 Last-Modified ，浏览器隐式的设置资源过期时间为 (Date - Last-Modified) * 10% 缓存过期时间。 前端缓存图： 7.其他范围请求假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载，要实现该功能，这就要用到范围请求。（前提是上一次请求到这一次请求时间段内，下载对象没有发生改变） 什么是XSSCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击，通过注入恶意脚本，，使之在用户浏览器上运行，然后利用这些恶意脚本，攻击者可以获取用户的敏感信息Cookie、SessionID等 XSS 常见的注入方法： 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。 在标签的 href、src 等属性中，包含 javascript: (伪协议)等可执行代码。 等等。。。。 XSS攻击类型 存储型XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大 攻击者将恶意代码提交到目标网站数据库中 客户端最后从服务器得到的就是恶意代码，在浏览器执行的也是该恶意代码 恶意代码将用户数据发送至攻击者网站 反射型XSS（有点像那种色情小广告，点进去你就没了） 攻击者构建特殊URL，里面包含恶意代码 当用户打开此URL时，网站的服务端将恶意代码从中取出，并且拼接在HTML返回给浏览器 恶意代码被浏览器执行，然后将用户数据发送给攻击者网站 DOM型XSS（感觉和反射型XSS很像，只不过这个是属于JavaScript的安全漏洞（浏览器的DOM解析），反射型XSS时属于服务端的安全漏洞），所以防范DOM型XSS是前端的责任 同样的，攻击者构造特殊URL，其中包含恶意代码 用户打开后，浏览器解析，JavaScript取出URL然后执行 恶意代码被浏览器执行，然后将用户数据发送给攻击者网站 防范XSS常用的防范手段： httpOnly: 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。 输入过滤: 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。 转义 HTML: 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义 添加白名单：对于显示富文本来说，以上方法可能会将需要的格式也过滤掉，这时我们可以添加白名单的方式 预防存储型XSS和反射型XSS攻击： 纯前端渲染 同上面常用的防范手段一样的转义html 预防DOM型XSS攻击 DOM型XSS攻击实际上是JavaScript代码本身不够严谨， .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。（尽量避免这种直接插入式的写法） 什么是CSRFCSRF是一种跨站请求伪造，也被称为 one-click-attack 或者 session riding 下面的图源自这个大佬 ： https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html （随便点开，放心绝对不是XSS或者CSRF ，手动狗头） 触发条件： 用户登录并且信任网站A，并产生cookie 未登出A的情况下，访问网站B（此网站虽然是攻击网站，但是它可能是一个存在其他漏洞的可信任的经常被人访问的网站） （感觉通俗来讲就是，你在存放重要信息的网站A登录后，没有关闭 且 本地的cookie没有过期，登陆了另外一个（攻击）网站，它就会偷你的cookie来操作你网站A的账号） 常见类型 Get类型的CSRF POST类型的CSRF 链接类型的CSRF，上面两种打开网页就中招，这种要点击的，比较low 防御CSRF 验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差 Referer check：请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。 token：token 验证的 CSRF 防御机制是公认最合适的方案。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。 劫持DNS劫持 DNS ： 域名 -&gt; ip地址 ，进行域名解析的服务器 （DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在/etc/resolv.conf文件。） DNS劫持又称域名劫持,是指通过某些手段取得某域名的解析控制权，修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址。 DNS劫持其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了 防止DNS劫持 网络层面： 手动修改DNS 修改路由密码 应用层面： 有点复杂，可以网上查询（泪。。） HTTP劫持 你DNS解析的域名的IP地址不变。在和网站交互过程中的劫持了你的请求。在网站发给你信息前就给你返回了请求。 HTTP劫持很好判断，当年正常访问一个无广告的页面时，页面上出现广告弹窗，八成就是运营商劫持了HTTP。下图中，右下角的广告并不是所访问的网站放置的。","categories":[],"tags":[],"author":"Hello"},{"title":"项目部署","slug":"项目部署","date":"2021-03-07T16:00:00.000Z","updated":"2021-03-09T10:13:16.957Z","comments":true,"path":"2021/03/08/xiang-mu-bu-shu/","link":"","permalink":"https://taylor12138.github.io/2021/03/08/xiang-mu-bu-shu/","excerpt":"","text":"部署方式利用脚手架打包后得到dist文件 将自己电脑作为服务器，部署本地 ：window -&gt; 使用nginx或者tomcat 远程主机，进行部署：linux centos -&gt; nginx 如 注意 ：使用nginx时，关闭不用粗暴乱结束进程关闭，可能会产生一些关不掉等小bug，记得cmd进去nginx根目录下 nginx -s stop即可 在部署Vue、Node.js和MongoDB部署上给予一定帮助的网址：https://segmentfault.com/a/1190000022921908 部署时踩的坑： 面对404时，是找不到资源，在本地上可以运行，而部署到服务器上却出现了404，很有可能是api链接等没有写对，导致找不到真正的地址；部署后台项目的时候，我将异步请求的 axios baseURL 改成：自己的公网地址:端口号，实际上是只需改成：自己的公网地址就可以了，害我看了半天 面对502时，可能是服务器暂未开启 面对500时，是服务器发生内部错误，我看了半天的服务端代码，发现没错，实际上是请求的数据有一段时number类型，我测试的时候胡乱输入字符串，也会发生500错误 服务器软件 Web服务器：提供Web化服务，当下几乎所有服务器软件都可以成为Web服务器 Http服务器：侧重静态资源传输的支持 应用服务器：常被称作动态服务器 1.Nginx：http服务器，性能好、稳定好、一般放在最前面 2.Tengine：基于Nginx，加强和封装 3.Apache：静态服务器，性能不如Nginx，所以Nginx使用居多 4.IIS：微软阵营的Web服务器，只能运行在windows，http静态服务器 5.Tomcat：典型java应用服务器软件，动态服务器， 一般和Nginx这种静态服务器一起打配合","categories":[],"tags":[],"author":"Hello"},{"title":"git基本命令符","slug":"git基本命令符","date":"2021-02-28T16:00:00.000Z","updated":"2021-03-10T07:35:24.130Z","comments":true,"path":"2021/03/01/git-ji-ben-ming-ling-fu/","link":"","permalink":"https://taylor12138.github.io/2021/03/01/git-ji-ben-ming-ling-fu/","excerpt":"","text":"版本控制它是一种软件开发过程中，管理我们对文件、目录、或工程等内容的修改历史、方便我们查看更改历史记录，备份以便恢复以前的版本软件工程技术。简单来说就是用于管理多人协同开发项目的技术 SVN：集中式版本控制、所有版本存在服务器上，需要连网才能看到历史版本，服务器坏了可能导致数据丢失。工作时我们首先需要从中央服务器的到最新版本 Git：分布式版本控制，每个人都拥有全部的代码（可能有安全隐患），这样就可以在本地查看历史版本，可以离线在本地提交，只需练网时push到相应服务器即可。协同方式：A修改了代码、B也修改了代码，这时只需要你们两人之间把各自修改的代码推送给对方，即可看到对方修改 Git是目前（2021年）世界上最先进的分布式版本控制系统 Git启动Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多 Git CMD：Windows风格命令行 Git GUI：图形界面，不建议初学者使用 Git基本命令符config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system -&gt; global -&gt; local 底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件 查看系统config git config --system --list 查看当前用户（global）配置 git config --global --list 安装Git后必须执行的(不然提交不了项目)：设置用户名和邮箱 git config --global user.name \"taylor12138\" git config --global user.email \"277421392@qq.com\" 查看当前仓库配置信息 git config --local--list 基本理论Git本地有三个工作区域： 工作目录（Working Directory）：平时存放项目代码的地方（主要跟我们挂钩的两个区域之一） 暂存区（Stage/Index）：临时存放改动，事实上只是一个文件 资源库（Respository/Git Directory）：安全存放数据的位置，这里有提交到所有版本的数据 再加上远程仓库（Remote Directory）：托管代码的服务器（主要跟我们挂钩的两个区域之一） 忽略文件有时我们不想把某些文件也一并上传，比如前端项目中的 npm_modules 可以在 .gitignore文件下添加忽略的文件 *.txt #忽略所有.txt结尾的文件 !lib.txt #将lib.txt除外（不被忽略） /temp #仅忽略根目录下的TODO文件，不包括其他目录的temp文件 build/ #忽略build/目录下的所有文件 doc/*.txt #忽略doc/notes.txt但不包括doc/server/arch.txt github建立连接的方法方法1：在GitHub网站上新建仓库 然后拷贝仓库的地址，进行克隆下载到本地 把自己原来项目除了git文件的所有文件拷贝进下载的文件夹里（克隆下载的文件本身自带.git文件） 利用工具 进入新的文件夹 可以查看状态：（可以查看文件是否被跟踪） git status 一般git上传只需要 1 放入暂存区 git add . 2 提交到git本地仓库， -m是提交信息 git commit -m '描述' 3 推送到远程 git push 方法2：将本地项目直接push，不用拷贝 创建一个全空的仓库 然后该项目有提示：git remote add orgin https://github.com/xxxxxxxx.git的指令 和 git push -u origin master指令 在项目的终端执行 Git分支git branch #查看所有分支 git branch -r #查看远程分支 git branch dev #新建dev分支，但是现在仍停留在原分支 git branch -d dev #删除dev分支 git merge [branch] #合并指定分支到当前分支 如果多个分支并行执行，会导致代码并不冲突，也就是同时存在多个版本 一般来说master主分支非常稳定，用来发布新版本，工作一般在新建的dev分支上工作，等待dev分支稳定后才可合并到master主分支上","categories":[],"tags":[],"author":"Hello"},{"title":"webpack","slug":"webpack","date":"2021-02-06T16:00:00.000Z","updated":"2021-03-14T13:53:40.584Z","comments":true,"path":"2021/02/07/webpack/","link":"","permalink":"https://taylor12138.github.io/2021/02/07/webpack/","excerpt":"","text":"1.Webpack概述webpack是一个现代的JavaScript应用的静态模块打包工具（依赖于node环境） 它可以帮你把AMD、CMD、CommonJS、ES6的一些模块化编写方式，转化为— &gt; 浏览器可以识别的模块化方案 而且不仅仅JS文件，CSS文件、图片文件等在Webpack也会被当成模块来使用 打包后生成一个文件夹，在服务器进行部署即可 起步新建两个文件夹，src放置开发的源码，dist放置之后打包的文件 方法一：webpack在打包的时候，会查看你有没有依赖其他文件，所以给一个入口文件(main.js或者index.js)就好了 webpack 入口文件.js ..\\dist\\打包后文件名.js 这时在html文件内用script引用打包后的js文件即可 方法二：新建一个 webpack.config.js，配置入口 entry和出口 output，output推荐用对象的形式来写 const path = require('path'); module.exports = { entry: './src/main.js', output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js' } } 由于要依赖node的核心模块path以动态获得output的绝对路径，这里先进行npm初始化，得到package.json包， 这时在命令窗口直接输入 webpack 或者用映射来运行：（更推荐，因为它会优先在本地找依赖包，而不是全局找依赖包，全局依赖包可能因为版本原因导致代码报错） 在package.json文件中的 script 配置 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack\" }, 然后再命令窗口输入 npm run build 2.Loader(前言：你已经是一个成熟的webpack了，应该学会自己安装loader！！！) webpack主要用来处理我们js代码，进行模块化开发，并且自动处理js之间的依赖关系 但是在开发中，我们不仅仅有基本的js代码需要处理，也需要加载css、图片，包括一些高级的将ES6转化为ES5代码，或者TypeScript转化为ES5代码，将scss、less转化为css等等 对于webpack本身能力来说，对于这些转化是不支持的，这时我们需要用到loader。 1.通过npm安装需要使用的loader 2.在webpack.config.js的module关键字下进行配置（根据官网给的配置信息填充就可以了） 处理CSS文件这里举一个CSS文件打包的例子，需要配置 style-loader （负责将导出的样式添加到DOM）和 css-loader（负责加载并解析import的CSS文件） 在 入口的js文件 里添加 指定的css文件，这时候打包使用webpack进行打包就会连同css文件也打包进去了 //依赖CSS文件 require('./css/normal.css') 处理图片在使用到图片的场景时，又需要对应的图片url-loader 关于url的loader中配置的option选项有一个limit 可以进行设置： limit: 8192, 当加载的图片小于这个limit时，会将图片编译成base64字符串形式 若大于limit，则需要换一个loader，即使用file-loader模块进行加载，从入口js文件打包会得到一张随机命名（32位的哈希值）的图片于dist文件夹中。 （如果index.html（想要加载到的页面）在dist文件外面，这时就还需要在webpack的配置文件里的output中，添加publicPath:&#39;dist/&#39;，这样以后涉及到url的路径，都会自动添加上 &#39;dist/&#39;；但是如果安装了HtmlWebpackPlugin插件之后，html文件将在dist文件夹中自动生成，此操作则要废弃） 但是真实开发中对打包的图片命名有一定要求，我们可以在url-loader的配置option里面，增加其他属性 options: { limit: 8192, // 按照这个规范进行命名 name: 'img/[name].[hash:8].[ext]', }, 处理ES6语法如果希望将ES6语法转化成ES5语法，我们可以使用babel对应的loader，配置打包得到新的js文件 处理Vue引入Vue.js 首先在项目中使用Vue.js，需要先通过npm安装Vue npm install vue --save 但是，vue在最终构建发布版本时，会构建两类版本，分别是 runtime-only 代码中不能有任何的template runtime-compiler 代码中可以有template。（此版本需要在webpack.config.js中配置信息，此时在module配置项的下方添加：） resolve: { // 别名,让vue结尾的指向一个具体的文件夹的文件 // 默认指向'vue/dist/vue.runtime.js' alias: { 'vue$': 'vue/dist/vue.esm.js' } } 如果想要通过vue文件分离组件和主要的main.js文件时，会是使用到vue文件 这时需要安装 vue-loader（负责加载） 和 vue-template-compiler（负责编译） 老样子在module的 rules 添加配置信息 test: /\\.vue$/, use: ['vue-loader'] 但是Vue Loader v15 现在需要配合一个 webpack 插件才能正确使用： // webpack.config.js const VueLoaderPlugin = require('vue-loader/lib/plugin') module.exports = { // ... plugins: [ new VueLoaderPlugin() ] } 3.pluginplugin是插件的意思，通常用于对某个现有架构进行扩展 loader类似于一个转换器，plugin相对webpack本身的拓展，类似于一个拓展器 使用： 1.通过npm安装需要的插件（但是有些插件webpack已经内置了） 2.然后在webpack.config.js中的plugins进行配置 下面举一个加入版权的插件的例子 // webpack.config.js const webpack = require('webpack'); module.exports = { // ... plugins: [ new webpack.BannerPlugin('最终版权归Hello所有') ] } HtmlWebpackPlugin真是发布项目时，发布的是dist文件夹中的内容，但是打包的时候并没有将html文件也打包进dist文件夹中， 此时我们需要用到HtmlWebpackPlugin插件，它会自动生成一个index.html文件（可以按照指定模板来生成），并且将打包后的js文件，自动通过script标签插入到body中 1.安装插件 npm install html-webpack-plugin --save-dev 2.使用插件，在webpack.config.js中使配置信息 // webpack.config.js const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { // ... plugins: [ new HtmlWebpackPlugin() ] } 此时生成的html文件的body内还没有根元素绑定Vue，我们可以给个模板，让它根据模板生成该 div元素 new HtmlWebpackPlugin({ // 寻找当前目录下的index.html, 根据这个生成模板 template: 'index.html' }) js压缩的plugin压缩js代码空间（丑化）安装：这里我是用的 uglifyjs-webpack-plugin版本时1.1.1，和CLI2保持一致 npm install uglifyjs-webpack-plugin@1.1.1 --save-dev module.exports = { // ... plugins: [ new UglifyJsPlugin() ] } 4.其他webpack搭建服务为了让webpack提供开发时服务，可以装载webpack-dev-server搭建本地服务器（脚手架2里使用的版本为2.9.3，所以这里我安装2.9.3），它内部使用了express框架 npm install webpack-dev-server@2.9.3 --save-dev 在webpack.config.js里配置 var path = require('path'); module.exports = { //... devServer: { contentBase: path.join(__dirname, 'dist'), // inline是否实时监听 inline:true, compress: true, port: 9000 } }; 此时还可以和起步配置 npm run build 一样顺便在package.json文件的script中增加 &quot;dev&quot;:&quot;webpack-dev-server&quot; 这时候运行起来就直接 npm run dev即可 配置文件分离开发时依赖的配置文件和发布时依赖的配置文件进行分离 新建一个build文件夹 -&gt; 新建一个 base.config.js文件 (公共的配置放在base里) 、prod.config.js文件（放置生产时的配置）和dev.config.js（放置开发时的配置） 这里还需要安装 npm i webpack-merge@4.1.5 --save-dev 然后分别在prod.config.js文件 和dev.config.js 写好各自的配置 const webpackMerge = require('webpack-merge'); const baseConfig = require('./base.config'); // 合并导出 module.exports = webpackMerge(baseConfig, { //各自配置 }); 最后在package.json配置文件中，修改 原来运行webpack 和 运行webpack服务器的 键位 改为 ： \"build\": \"webpack --config ./build/prod.config.js\", \"dev\": \"webpack-dev-server --config ./build/dev.config.js\" 这里如果打包后文件出现不是在原来的目录，可以检查一下base.config.js文件的 output出口，进行修改 小笑话","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Vue(上)","slug":"Vue(上)","date":"2021-02-01T14:13:10.649Z","updated":"2021-03-27T02:27:27.456Z","comments":true,"path":"2021/02/01/vue-shang/","link":"","permalink":"https://taylor12138.github.io/2021/02/01/vue-shang/","excerpt":"","text":"1.邂逅VUEvue是一个渐进式框架，这意味着可以作为你应用的一部分嵌入其中，对项目一点点进行重构，响应式：界面随着数据随时发生改变 以前JS原始编写的方法：命令式编程； Vue编写方法：声明式编程 vue全家桶：Core + Vue-router + Vuex Vue特点： 解耦视图和数据 可复用组件 前端路由技术 状态管理 虚拟DOM 引入vue $ npm install vue 体验： &lt;div id=\"app\"> &lt;ul> &lt;li v-for='item in message'>{{item}}&lt;/li> &lt;/ul> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { message: ['i', 'wanna', 'be', 'with', 'you'] } }) &lt;/script> Vue的MVVMMVVM 模式，顾名思义即 Model-View-ViewModel 模式，最标志性的特性就是 数据绑定 ，操作数据 = 操作视图，操作DOM Model 层: 对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步 View 层:作为视图模板存在， 数据绑定的声明、 指令的声明、 事件绑定的声明。 ViewModel 层（vue）:把 View 需要的数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责 MVVM是MVC的改进版，MVC中的M就是单纯的从网络获取回来的数据模型，V指的我们的视图界面，而C就是我们的ViewController。 ViewModel充当了一个UI适配器的角色，也就是说View中每个UI元素都应该在ViewModel找到与之对应的属性。除此之外，从Controller抽离出来的与UI有关的逻辑都放在了ViewModel中，这样就减轻了Controller的负担。 2.基础语法Vue对象传入的option： el：决定Vue对象挂载在哪个元素上 data：存储数据，类型为对象或者函数 methods: 用于在Vue对象中定义方法 在官网中还有一些其他的option 在开发中在对象/类里面定义的叫方法（method），独立出来作用全局的称为函数（function） 双括号语法被称之为mustache语法，八字胡 &lt;!-- item和message分别为data中的字符串 --> &lt;li>{{item + '' + message}}，hello&lt;/li> &lt;!-- counter为data中的数字 --> &lt;li>{{counter * 2}}&lt;/li> &lt;!-- 得到getNumber函数返回值 --> &lt;li>{{getNumber()}}&lt;/li> Vue的生命周期在创建Vue对象的时候，内部会一步一步做出一系列复杂的事情/操作，而在做每一系列事情的过程当中，如果中间穿插 created、mounted、updated、destroyed等生命周期钩子函数它会指示你（它会内部自动执行，不需要手动调用），目前做到事情的哪一步。 这样我们才能更好地依照某种顺序（等待某一步的完成），去完成另外一件 “需要上一步已达成” 这个条件下执行的事件 生命周期就是一个对象（如vue)从声明到使用到销毁的各个阶段，为了开发方便框架会在每个阶段的节点上定义一个特定函数，这个特定函数就是生命周期函数，也叫钩子函数 官网附有生命周期示意图 V-指令v-once 只会在第一次渲染数据，随后数据发生改变，元素内的数据不会再发生改变，阻止了响应式，可以添加在标签属性上 &lt;h2 v-once>{{message}}&lt;/h2> v-html 类似于JS原生里的innerHTML，可以添加在标签属性上 &lt;h2 v-html=\"数据名称\">&lt;/h2> v-pre 进行原封不动的解析，可以添加在标签属性上 &lt;!-- 页面得到结果{{message}} --> &lt;h2 v-pre>{{message}}&lt;/h2>` v-cloak 为了防止用户加载页面是，加载JavaScript卡住，导致页面显示源码 ‘‘ ，添加 &lt;h2 v-cloak>{{message}}&lt;/h2> 等到Vue对该元素进行解析渲染，页面中才会显示该元素（原理应该是使用了display: none） v-bind 使用{{值}}可以将Vue的数据插入元素内容中，但是如果想让Vue的数据动态绑定元素标签属性中的值（比如img的src，a标签的href）,可以使用v-bind。v-bind还有一个对应的语法糖 :（简写方式），方式如下 &lt;a v-bind:href=\"bdurl\">baidu&lt;/a> &lt;a :href=\"bdurl\">baidu&lt;/a> 与此同时v-bind也可以动态绑定class属性值，但是它动态绑定class属性的重大意义在于可以写入对象，以键-值的形式，通过布尔值修改，来动态修改元素是否使用该类（在标签上还可以再自定义添加上自带的class，不参与动态绑定变化） 其实动态绑定class还可以采用数组语法，只不过目前用的比较少了 &lt;div id=\"app\"> &lt;ul> &lt;li v-for=\"(item, index) in movies\" @click=\"colorch(index)\" :class=\"{active: index === iscolor}\">{{item}}&lt;/li> &lt;/ul> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { movies: ['batman', 'superman', 'spiderman'], iscolor: -1 }, methods: { colorch: function (index) { this.iscolor = index; } } }) v-bind还能动态绑定元素style样式的某个的单个属性，但是添加的时候注意，vue的语法中最好采用驼峰命名法，而且属性值外加单引号&#39;&#39; &lt;h2 :style=\"{fontSize: '100px'}\">{{message}}&lt;/h2> 注意，绑定属性名的时候，不能用驼峰命名法，可能html不能正确识别，如果要用的话，则属性名要发生改动：:topImages -&gt;改成-&gt; :top-images=&quot;xxx&quot; computed计算属性Vue对象的option之一,当成属性去使用，不用加()进行函数调用，计算属性不像methods会被多次调用，它只会被调用一次（因此效率相对于methods更高），内部对计算属性做了缓存 &lt;div id=\"app\"> &lt;h2>{{fullname}}&lt;/h2> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { firstname: 'Lebron', lastname: 'James' }, computed: { fullname: function () { return this.firstname + ' ' + this.lastname; } } }) &lt;/script> 实际上计算属性一般只使用了它本身的get方法，而它的完整写法为： fullname: { set: function () { //一般情况下，我们不希望计算属性使用set方法,这样的话它就变成了一个只读属性 }, get:function() { return this.firstname + '' + this.lastname; } } Computed 默认调用的是get方法 不能传参，想要传递参数得用set设置好，再用get取 watch属性watch也是属于组件中的属性（和data，props，methods等并列），对应一个对象类型，里面存放函数方法，这些函数适用于监听某些data中属性的改变。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 函数命名方式：data中的属性名(改变后的值[, 改变前的值]){} watch:{ // 监听data中message的改变 message(){ console.log(\"hello\"); } //相当于message:function(){console.log(\"hello\")} } 除了传入函数外，其实watch里面传的是键值对，值除了函数还可以包含两个参数 immediate：组件加载立即触发回调函数执行， deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用（内部实际上是通过递归取值，然后进行逐个监听），而computed不需要deep，是因为它是从模板双括号取值，即使用JSON.stringfy()把对象的值一次性取出来 因为是递归，比较耗性能，尽量不要采用 watch: { message: { //使用deep、immediate参数时，对应的函数名必须为handler handler(newVal, oldVal) { console.log(oldVal) console.log(newVal) }, deep: true } }, computed和watch computed： 支持缓存，只有依赖数据发生改变时才会重新计算 不支持异步，当computed内有异步操作时无效，无法监听数据的变化 如果一个属性是由其他属性计算而来的，且一对一或者多对一，则一般用computed watch： 不支持缓存，数据变化则会直接触发相应操作 支持异步 监听的函数接收两个参数，第一个参数是最新的值（newValue）；第二个参数是输入之前的值（oldValue） 可以监听具体到数据的某个属性（对象） 缓存实现原理：new watcher -&gt; 这里有个dirty属性，默认为true - &gt; 求值计算，然后dirty = false -&gt; 当依赖数据再次发生改变时 dirty = true 事件监听v-on 绑定事件监听器，缩写（语法糖）为 @ ，类似于jQuery的 on 事件处理 &lt;button @click=\"increment\">+&lt;/button> &lt;button @click=\"decrement\">-&lt;/button> 正常情况下，函数如果需要传递参数，然而你没有传递，则函数形参为undefined v-on参数问题： 如果该方法不需要传递参数，则方法后面的()可以不用添加 但是如果方法本身是需要一个参数的，但是传进来的时候没有加 ()，（如@click=”decrement”），则Vue会将浏览器中生成的事件对象Event作为参数，传入方法中 方法定义时，我们需要event对象，同时又需要其他参数时，在html标签内的方法括号中只添加参数 + $event &lt;button @click=\"cclick(123, $event)\">call&lt;/button> methods: { cclick(number, event) { console.log(number, event); } } v-on修饰符 @事件名.stop阻止事件冒泡：相当于原生的e.stopPropagation() &lt;div @click=\"cclick\"> &lt;button @click.stop=\"cclick\">call&lt;/button> &lt;/div> @事件名.prevent阻止默认事件 =&gt; 相当于原生的 e.preventDefault(); @事件名.{keyCode | ketAlias} 从键盘特定键位触发回调（ @keyup.enter=&quot;xxx&quot; ） @事件名.native 监听根元素原生事件（在组件中使用） &lt;Compon_test @click=&quot;() =&gt; {}&quot;&gt;&lt;Compon_test&gt; =&gt; Compon_test.$on(&#39;click&#39;, () =&gt; {}) Compon_test.$emit(&#39;click&#39;) &lt;Compon_test @click.native=&quot;() =&gt; {}&quot;&gt;&lt;Compon_test&gt; =&gt; Compon_test.addEventListener @事件名.once 只触发一次回调 条件判断 + 循环遍历v-if=&quot;布尔值(或vue对象中存储的变量)&quot;来决定元素标签是否显示出来 v-if 可以搭配 v-else 来决定显示哪一些元素标签 &lt;h2 v-if=\"score>=90\">优秀&lt;/h2> &lt;h2 v-else-if=\"socre>=80\">良好&lt;/h2> &lt;h2 v-else-if=\"socre>=60\">及格&lt;/h2> &lt;h2 v-else>不及格&lt;/h2> v-show决定一个元素是否渲染出来（用法和 v-if相似），只是 v-show控制结点的display，而v-if是删除/创建节点 当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。 v-for遍历数组/对象 遍历过程额外获取数组索引值使用 v-for=&quot;(item, index) in 数组名&quot; 遍历过程额外获取对象属性名使用 v-for=&quot;(value, key) in info&quot; （如果只有value,，则遍历对象每个属性的属性值） 遍历过程额外获取对象属性名，数组索引值使用 &quot;(value, key, index) in info&quot; （如果只有value,，则遍历对象每个属性的属性值） &lt;ul> &lt;li v-for=\"item in strs\">{{item}}&lt;/li> &lt;li v-for=\"(item, index) in strs\">{{index}}.{{item}}&lt;/li> &lt;li v-for=\"value in info\">{{value}}&lt;/li> &lt;li v-for=\"(value, key) in info\">{{key}}:{{value}}&lt;/li> &lt;li v-for=\"(value, key, index) in info\">{{index}}.{{key}}:{{value}}&lt;/li> &lt;/ul> 官方推荐我们使用 v-for的时候，给元素或组件添加上 key属性（能更好的复用，提高增删时的性能，高效更新虚拟DOM），并且此时key属性绑定为item或者 item.id 比较好，能形成一一对应（也可以是item对象中的id）。这时候就可以唯一标识元素或组件，用diff算法正确识别节点，找到正确位置插入/删除节点。 如果key用index，是不可以的，因为index，即下标，会随着DOM元素的位置而改变，导致key = “index”，加了和没加一样！！ 如果item不是字符串、数字之类的，也不推荐使用 原因：没有key会像操作顺序表（或者数组）一样操作改变位置及之后所有数据，有key就会像链表一样断链后链接，只进行一次操作 &lt;li v-for=\"item in strs\" :key=\"item\">{{item}}&lt;/li> v-for and v-if 由于v-for的优先级是大于v-if的，当 v-for遍历出来后再每次都v-if进行判断比较消耗性能， 所以建议把v-if放在外层（比如直接放在template模板上） 哪些数组的方法是响应式的： 和对象不同的是，有些数组方法使用后Vue的页面不会及时响应 实际上这个响应式最好记的就是数组方法 看他是否真的改变原数组，而不是返回一个新数组（或者通过官方文档查看它是否为被包裹过的方法） // 1.push this.arr.push('David'); // 2.pop 删除数组中最后一个元素 this.arr.pop(); //3.shift 删除数组第一个元素 this.arr.shift(); //4.unshift 数组最前面添加元素 this.arr.unshift('David', 'Eason'); // 5.splice 用于删除多组元素且添加数据 // splice(开始位置, 删除个数, ...要添加的元素) this.arr.splice(1, 0, 'David'); // 6.sort this.arr.sort(); // 7.reverse this.arr.reverse(); 通过索引值修改数组元素并不会向页面及时响应结果： //修改对象用splice或者 Vue.set(修改对象, 索引值, 修改后的值) this.arr[0] = 'nothing'; 虚拟DOM渲染特殊案例这里在输入input数据之后，再点击切换按钮，会出现另外一个input框内仍保留之前输入的数据的情况 这是因为Vue在进行DOM渲染的时候，会先把所有元素标签通过一个虚拟DOM（virtual DOM）放到内存里，然后再渲染到浏览器上；所以出于性能考虑，会尽可能复用已经存在的元素，而不是创建新元素；复用的时候对比每个层级，把修改之后的套在原来的元素上（比如属性类型，属性id等） 在以下的案例中，Vue内部会发现原来的input元素不再使用，直接作为else中的input来使用（类似于让现任穿前任的衣服） 也就是说，在第一个input输入字符，然后“切换类型”，转为第二个input后，你依旧可以看到刚才输入的字符 解决方法：增加key属性，作为唯一的标识，key不同不进行复用 &lt;input type=&quot;text&quot; placeholder=&quot;用户名&quot; key=&quot;username&quot;&gt; &lt;div id=\"app\"> &lt;div v-if=\"loginType\"> &lt;label for=\"email\">用户邮箱&lt;/label> &lt;input type=\"text\" placeholder=\"用户邮箱\"> &lt;/div> &lt;div v-else> &lt;label for=\"nickname\">用户名&lt;/label> &lt;input type=\"text\" placeholder=\"用户名\"> &lt;/div> &lt;button @click=\"loginType=!loginType\">切换类型&lt;/button> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { loginType: true } }); 过滤器filtersVue对象的option之一,当成属性去使用，调用需要在元素标签中添加 {{传入的参数 | 过滤器函数名}}可以把过滤器简单理解为一种格式化，比如时间，数字等等；它的实际效果和methods调用函数方法也差不多，只是编写样式更易懂、简洁 &lt;td>{{book.price | Price_str}}&lt;/td> 过滤器里面一般存函数，参数为过滤的数据 //toFixed为保留两位小数 filters: { Price_str(price) { return '$' + price.toFixed(2); } } V-modelv-model也常常被用来实现表单（input、checkbox、select）和数据的双向绑定 v-model如果用在普通div上，只能用来作数据绑定功能（无事件功能、实际上div不支持 v-model，但是组件就可以 ） &lt;input type=\"text\" v-model=\"message\"> {{message}} //在Vue对象中的data data: { message: 'nothing' } 利用 v-model实现单选框互绑 &lt;!-- 添加v-model之后，radio的input不需要加name属性来互斥radio（单选框） --> &lt;label for=\"male\"> &lt;input type=\"radio\" id=\"male\" value=\"male\" v-model=\"sex\">男♂ &lt;/label> &lt;label for=\"female\"> &lt;input type=\"radio\" id=\"female\" value=\"female\" v-model=\"sex\">女♀ &lt;/label> &lt;h2>你选择的性别是：{{sex}}&lt;/h2> v-model其实是是一个语法糖，两个指令的结合 v-bind绑定data数据 + v-on绑定input事件改变data数据 &lt;input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\"> &lt;h2> {{message}}&lt;/h2> v-model还有修饰符 lazy、number、trim &lt;!-- 修饰符lazy 使用之后使得input事件变得类似于change事件，等到用户输入完字符，敲回车/失去焦点才会修改数据 --> &lt;!-- &lt;input type=\"text\" @change=\"message = $event.target.value\"> --> &lt;input type=\"text\" v-model.lazy=\"message\"> &lt;!-- 修饰符number v-model默认给data赋值时，都是赋值为string类型，增加number修饰符可改变v-model赋值类型--> &lt;input type=\"number\" v-model.number=\"age\"> &lt;!-- 修饰符trim，v-model默认给data赋值时剥除两边空格 --> &lt;input type=\"number\" v-model.trim=\"name\"> 由于默认 v-model是 data数据 + input事件，我们可以在源码上自定义 v-model 自定义组件上使用 自定义 v-model ： &lt;el-checkbox v-model=\"check\">&lt;/el-checkbox> //全局注册组件 Vue.component('el-checkbox', { template:`&lt;input type=\"checkbox\" :checked=\"check\" @change=\"$emit('change', $event.target.checked)>\"` //model属性,服务于v-model model:{ prop:'check', //更改默认value名字 event:'change' //更改默认方法名,input事件改为change事件 }, props:{ check:Boolean } }) 原生标签上使用自定义 v-model const VueTemplateCompiler = require('vue-template-compiler'); const ele = VueTemplateCompiler.compiler('&lt;input v-model=\"value\"/>'); /** with(this) { return _c('input', { directives:[{ //directives是对输入框的配置 name:\"model\", rawName:\"v-model\" vale:(value), expression:\"value\" }], domProps:{ \"value\":(value) //这里value是默认，可以自定义为check }, on:{ \"input\":function($event) { //这里的默认input可以自定义为change if($event.target.composing) return; value = $event.target.value } } }) } **/ el和template同时有el和template，则将template里的模板，直接把el绑定的元素替换掉 3.组件化开发组件化开发思想即把页面拆分成一个个小的功能块，每个功能完成属于自己那部分的独立功能，分而治之 组件使用三个步骤 创建组件构造器 Vue.extend()，通常我们在创建组件构造器时会传入template作为自定义模板 注册组件 Vue.component(自定义组件标签名, 组件构造器对象) 注意：定义的标签必须小写 使用组件 必须在Vue的实例范围内使用组件，即使用该组件时，必须把标签放在Vue绑定的标签内 最终内部调用 $mount()进行挂载 &lt;div id=\"app\"> &lt;!-- 3.使用组件 --> &lt;!-- 比如这里绑定了id为app的块元素，则该自定义标签可以在该块内使用 --> &lt;my-cpn> &lt;/my-cpn> &lt;/div> &lt;script> // 1.创建组件构造器对象 const cpnConstructor = Vue.extend({ // 模板 template: `&lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div>` }); // 2.注册组件 // 严重注意：定义的标签必须小写 Vue.component('my-cpn', cpnConstructor); const app = new Vue({el: '#app'}); &lt;/script> 注意：在父组件中使用子组件不能使用 v-on 监听原生事件，必须添加 native修饰符，才能进行监听 获取组件内的元素，需要用到 $el，所有组件都有一个元素 $el 用于获取组件中的元素，比如获取 组件 的 offsetTop console.log(this.$refs.tabControl.$el.offsetTop;) 组件分类全局注册&amp;局部注册：上面的例子为注册全局组件，意味着可以再多个Vue实例下使用 以下的例子为局部注册组件（局部注册组件自定义标签名不支持 -） Vue对象中的components属性来注册局部组件,在开发过程用的最多的还是局部组件 const app = new Vue({ el: '#app', components: { //自定义组件标签名:组件构造器对象 my_cpn: cpnConstructor } }); 父组件和子组件 在组件构造器(组件二)中对另外一个组件(组件一)进行注册（components{}）,这样的好处是可以在组件二模板里面,使用组件一,这样子就形成了父子组件的关系 父组件模板的所有东西都会在父级作用域进行编译，子组件模板的所有东西都会在子级作用域进行编译 注意: 在模板中，子组件的标签一定要写在父组件的DIV里面，因为定义模板时一般要有一个外层包裹的根元素（一般使用div） &lt;div id=\"app\"> &lt;cpn2>&lt;/cpn2> &lt;/div> &lt;script> //子组件,子组件要比父组件先创立 const cpnConstructor = Vue.extend({ template: ` &lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div> ` }); //父组件 const cpnConstructor2 = Vue.extend({ template: ` &lt;div> &lt;h2>模板2内容&lt;/h2> &lt;cpn1>&lt;/cpn1> &lt;/div> `, components: { cpn1: cpnConstructor } }); // root组件 const app = new Vue({ el: '#app', components: { cpn2: cpnConstructor2 } }); &lt;/script> 组件语法糖Vue为了简化组件使用的过程，提供了创建 + 注册合并的语法糖，直接适用对象替代extend步骤 //创建+注册全局组件语法糖 Vue.component('mycpn', { template: ` &lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div> ` }) //创建+注册局部组件语法糖 const app = new Vue({ el: '#app', components: { mycpn2: { template: ` &lt;div> &lt;h2>模板2内容&lt;/h2> &lt;/div> ` } } }); 组件模板的分离写法 为了使结构更加清晰，最好将html分离出来写，这里有两个组件模板分离的写法 1.script标签，注意类型必须是text/x-template（但是现在比较少使用了） 2.使用template标签 &lt;template id=\"cpn\"> &lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div> &lt;/template> &lt;script> Vue.component('mycpn', { template: '#cpn' }) &lt;/script> 组件的数据访问组件的data 组件内部不能直接访问Vue实例里的数据，包括data，methods等 组件是一个单独功能模块的封装，也有属于自己的data属性（其实可以把Vue实例也看成一个特殊的组件，组件在自己的标签里只能访问自己的data），当然也有自己的methods属性 但是！！：和Vue的data不同的是，组件自己的data必须用函数写（methods不用），然后再返回一个实例对象 组件中的data写成一个函数，数据以创立新一个对象的函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，（因为函数会创建自己的作用域）类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。（同一个组件标签名用的是同一个组件构造器对象） 而单纯的写成对象形式，就使得所有组件实例在使用的时候直接引用同一个对象，导致共用了一份data，就会造成一个改变，全都会发生改变的局面。 &lt;template id=\"cpn\"> &lt;div> &lt;h2>{{str}}&lt;/h2> &lt;/div> &lt;/template> &lt;script> Vue.component('mycpn', { template: '#cpn', data() { return { str: 'hello world' } } }) &lt;/script> 父子组件的通信 父组件传给子组件：子组件通过props方法接受数据; （外加 v-bind属性传值）Vue实例的data -&gt; 子组件的props数组中某个变量名进行接收，当作数据来使用，然后在渲染到template模板中（mustache语法） 子组件传给父组件：$emit方法（自定义事件）传递参数 在真实开发中，Vue实例和子组件的通信也可以当作父组件和子组件的通信来看 父组件传递给子组件实例： &lt;div id=\"app\"> &lt;mycpn :smovies=\"movies\" :smessage=\"message\">&lt;/mycpn> &lt;/div> &lt;template id=\"cpn\"> &lt;div> &lt;ul> &lt;li v-for=\"item in smovies\">{{item}}&lt;/li> &lt;/ul> &lt;h2>{{smessage}}&lt;/h2> &lt;/div> &lt;/template> &lt;script> // 父组件传子组件 props const app = new Vue({ el: '#app', data: { movies: ['ironman', 'batman', 'spiderman'], message: 'hello world' }, components: { mycpn: { template: '#cpn', props: ['smovies', 'smessage'] } } }); &lt;/script> 注意：props定义的属性名同样不要使用驼峰标识，因为HTML属性不支持大写（自定义组件名也是不要大写）（非要用大写则在html里时，将对应的大写前加 -，这样的话大写转小写） 对于通过props从父组件传递过来的值最好不要直接修改，而是在子组件的data创建数据，以传递过来的值对其进行赋值，然后想修改的手再在data的数据中修改 prop的赋值方式 // props: ['smovies', 'smessage'] // 这种对象写法还可以指定每个 prop 的值类型,甚至提供默认值,必传值,更常用 // 但是props里属性为对象或者数组时,默认值必须是一个函数 // props:{ // smovies:Array, // smessage:String // } props: { smovies: { type: Array, default() { return [] } }, smessage: { type: String, default: 'nothing', require: false // 使用该子组件的时候,是否必须要给这个smessage属性赋值 } } 子组件传父组件 流程： 1.子组件通过$emit()触发事件，子组件发送出去一个事件 this.$emit(事件名称, [传递参数]),是自定义事件 2.父组件通过 v-on监听子组件事件 &lt;!-- 父模板 --> &lt;div id=\"app\"> &lt;!-- 父组件需要使用事件监听 v-on 进行监听，然后自己在methods定义相对应的处理函数就可以了 --> &lt;!-- v-on不仅可以监听DOM事件，还可以监听组件之间的事件 --> &lt;mycpn v-on:Bigclick=\"FatherListener\">&lt;/mycpn> &lt;/div> &lt;!-- 子模版 --> &lt;template id=\"cpn\"> &lt;div> &lt;ul> &lt;li v-for=\"item in categories\" @click=\"itemclick(item)\">{{item.name}}&lt;/li> &lt;/ul> &lt;/div> &lt;/template> &lt;script> const app = new Vue({ el: '#app', components: { mycpn = { template: '#cpn', data() { return { categories: [ { id: 1, name: \"热门推荐\" }, { id: 1, name: \"手机数码\" }, { id: 1, name: \"家用家电\" }, { id: 1, name: \"电脑办公\" }, ] } }, methods: { itemclick(item) { this.$emit('Bigclick', item); } }, } }, methods: { //基本的事件默认传入event，但是子组件传来的事件，如果附带上参数，则如果父组件处理的函数自带传来的参数 FatherListener(item) { console.log(\"hello\", item); } } }); &lt;/script> 父子组件对象操作上面的组件数据访问我们已经提到了父子组件相互通信的方法（子组件传子组件信息给父组件，父组件传父组件的信息给子组件），但有时我们想直接访问组件（父组件获取子组件信息），而不是当子组件触发某个事件时，将子组件数据传给父组件再进行操作 父组件想要访问子组件：使用 $children 或者 $refs 子组件访问父组件：使用 $parent 父组件想要访问子组件： 但是真实开发中，我们不会通过$children去拿子组件对象进行操作，这是因为当使用$children[索引号]的方式拿取数据，当Vue绑定的标签内在中间新插入新子组件，会导致拿到的是新子组件的数据 所以用$refs比较多，无论Vue绑定的标签内是否有子组件，this.$ref 都默认为空 &lt;!-- 对应的html标签 --> &lt;div id=\"app\"> &lt;cpn> &lt;/cpn> &lt;cpn ref=\"cpn2\"> &lt;/cpn> &lt;button @click=\"btnClick\">打印子组件信息&lt;/button> &lt;/div> //子组件信息 cpn: { template: '#cpn', data() { return { name: 'Allen' } }, methods: { showMessage() { console.log('nothing'); } } } //Vue的mothods中的方法： btnClick() { // 1.$children // 调用Vue绑定的标签内第一个子组件的方法showMessage() this.$children[0].showMessage(); console.log(this.$children[0].name); // 2.$ref,在标签上加属性：ref=\"cpn2\",此时this.$ref不再为空 console.log(this.$refs.cpn2); } 使用前要注意：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。 ref如果绑定在组件中，那么通过 this.refs.ref绑定的名称获取到的是一个组件对象 ref如果绑定在元素中，那么通过 this.refs.ref绑定的名称获取到的是一个元素对象（此时ref的功能不是用于父组件获取子组件的数据，而是组件自己内部想要在某个地方获取到自己的某个标签（元素），这样有较高安全性，因为类名可能会重复，到时候项目开发时通过类名的获取，不一定能够准确获取目标） 子组件想要访问父组件：（开发中不建议用，因为引用了外部组件的数据，还是父组件的数据，这样会导致独立性、可复用性降低，有较大耦合性）$parent 如果想访问根组件数据用 $root //cpn的methods中： methods: { btn_click() { console.log(this.$parent); } } 插槽slot组件的插槽也是为了让封装的组件更具有扩展性（使用同一组件但能自定义特色风格） 在组件（模板）中增加 &lt;slot&gt;&lt;/slot&gt;，然后在html上使用组件时，往中间添加的标签/文字，都会放在template模板中slot标签内 推荐使用 div标签先将 slot包起来再使用 &lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;，可以避免很多bug &lt;!-- 组件cpn的模板中添加： --> &lt;div> &lt;h2>我是子组件&lt;/h2> &lt;p>这是子组件的段落&lt;/p> &lt;!-- 同时也可以定义一个默认值，这里没有传入则插槽内默认显示一个button --> &lt;slot>&lt;button>按钮&lt;/button>&lt;/slot> &lt;/div> &lt;!-- 使用插槽进行替换 --> &lt;cpn>&lt;button>其他&lt;/button> &lt;/cpn> 具名插槽 如果有多个插槽且想要替换掉指定的插槽，一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名字“default”。 注意 v-slot 只能添加在 &lt;template&gt; 上 &lt;!-- 组件cpn的模板中添加： --> &lt;div> &lt;slot name=\"left\">&lt;span>左边&lt;/span>&lt;/slot> &lt;slot name=\"mid\">&lt;span>中间&lt;/span>&lt;/slot> &lt;slot name=\"right\">&lt;span>右边&lt;/span>&lt;/slot> &lt;/div> &lt;!-- 如果是在&lt;template>上的话，可以使用新版的 v-slot了 --> &lt;!-- 替换掉name为mid的插槽--> &lt;cpn> &lt;template v-slot:mid> &lt;span>nothing&lt;/span> &lt;/template> &lt;/cpn> 旧版本的：&lt;div slot=&quot;插槽名&quot;&gt;首页&lt;/div&gt; 作用域插槽 大前提：父组件模板的所有东西都会在父级作用域进行编译，子组件模板的所有东西都会在子级作用域进行编译 当前需求：想办法在父组件的作用域拿到子组件的数据，然后再在父组件做一个插槽填充（这里不能使用$refs因为，还没渲染完毕，在初始渲染的时候你不能用$refs进行访问） 多个插槽写法：v-slot:插槽名=”数据调用方法名”， 首先在子组件模板中的 &lt;slot&gt;&lt;/slot&gt;查找中添加自定义属性，自定义属性=”想要绑定的数据名” &lt;!-- 子组件--> &lt;!-- 注意：:data属性名这里可以随便改自己喜欢的名字，但是必须要小写，v-slot的也是一样要注意小写 --> &lt;slot :data=\"pLanguages\"> &lt;ul> &lt;li v-for=\"item in pLanguages\">{{item}}&lt;/li> &lt;/ul> &lt;/slot> Vue里支持通过template，来拿到刚才的data属性，使用 v-slot:default=&quot;自定义插槽 prop 的对象&quot;（这里未定义插槽名，所以使用default）获取子组件通过属性传递过来的数据，然后通过 自定义插槽 prop 的对象.子组件自定义属性名调用子组件的数据 &lt;!-- 在html中使用组件 --> &lt;cpn> &lt;!-- &lt;span v-for=\"item in pLanguages\">{{item}}&lt;/span> 错误，不可以直接获取--> &lt;template v-slot:default=\"slot\"> &lt;span v-for=\"item in slot.data\">{{item}} - &lt;/span> &lt;/template> &lt;/cpn> JavaScript的模块化常见的模块化规范：CommonJS、AMD、CMD、ES6的Modules CommonJS可以在我的Node.js篇章里面了解 ES6模块化 ： export导出 import 导入 在 style 里导入使用 @import 首先将模块化的js文件引入时需要添加类型 module ：&lt;script src=&quot;js地址&quot; type=&quot;module&quot;&gt;&lt;/script&gt; 然后再所需模块内进行导出 / 导入 // 导出方式1 let name = 'allen'; export { name } // 导出方式2 export var num = 1000; export function sum() { } // 导出方式3,这种方法只能导出一个,只能使用一次default export default adress 四种导入方法 // 1.导入单个num import { num } from \"./aaa.js\"; console.log(num); // 2.导入默认的值（default），能够自己命名 import add from \"./aaa/js\"; console.log(add); // 3.统一全部导入 import * as aaa from \"./aaa\"; console.log(a.num); //1.下载后module的引用比较特殊 import Vue from 'vue' 4.Vue CLI在开发大型项目的时候，则必须使用到Vue CLI，CLI是Command-Line Interface ，翻译为命令行界面，俗称脚手架 使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置（终于不用自己配置webpack了！） Vue CLI 的使用前提：Node &amp; Webpack 安装脚手架（同时也自动装上vue）： npm install -g @vue/cli CLI 3+ 初始化 vue create my-project 但是我们这里也要使用cli 2 的功能所以还得 拉取 2.x模板 npm install -g @vue/cli-init CLI 2 初始化项目 vue init webpack my-project CLI 2 初始化vue init webpack 项目名称，这个项目名称为创建最终项目文件夹名 然后会出现选项： 然后得到一个文件，可以查看 package.json 文件里的 script，得知相应的运行命令；下面对存放在里面的每个文件进行介绍 build、config（配置基础变量）存放webpack的配置区域 src 放置源代码区域 static 放置静态资源的区域，原封不动复制到dist文件夹里 .babelrc 关于转化为ES5的相关配置 部分配置的介绍关闭ESLint代码规范（可能不符合部分代码风格，比如不加分号，定义函数时函数名后空一格等） config -&gt; index.js -&gt; useEslint: false Runtime-only 和 Runtime + Compiler的不同之处在main.js里面 //runtime compiler new Vue({ el: '#app', components: { App }, template: '&lt;App/>' }) //runtime-only //直接render，跳过template部分 new Vue({ el: '#app', render: h => h(App) }) Runtime-only在实际公司开发中使用的比较多，性能更好，代码更少（不用处理template和ast， 它的 .vue文件由 webpack用到的loader：vue-template-compiler 解析成render， 也就是render(App) -&gt; 组件App的 template 替换掉绑定的元素 ） 实际上，Vue实例的template -&gt; 会保存在option里 -&gt; 进行parse解析成抽象语法树（ast）（描述了我们标签的详情数据情况） -&gt; compile编译成 render函数 -&gt; 翻译成虚拟DOM（virtual DOM） -&gt; 渲染成UI 所以实际上compiler是处理 template部分和 ast部分 动态创建标签：createElement(&#39;标签&#39;, {标签属性}, [&#39;&#39;]), createElement(组件)也可以 //render函数的真身：(APP为组件对象) render: funciton(createElement) { return createElement(APP); } CLI 3与2版本有很大区别 基于webpack 4 打造 设计原则是“0配置”，移除根目录下的build、config 提供了vue ui 命令，提供了可视化配置，更加人性化 移除了static，新增了public，并且将index.html移动到public中，public类似于新的static 初始化后同样会出现初始化的配置选项 preset 预设：default是默认；manually select features是手动 feature特性：按空格选中/取消（Linter代码规范可以取消掉、Babel为支持es6以上语法 ） placing config配置的存放：config files 独立存放；package.json 放在package.json中 save prest：是否保存刚才配置好的预设 （如果想删除，则要找到.vuerc文件，进入后进行修改删除） CLI 3 的配置去哪里了？ -&gt; 启动配置服务器（可视化配置）： vue ui 导入当前项目脚手架的文件夹，然后可以在当前页面添加需要的插件，配置甚至运行等 如果真的要手动修改掉基础的配置，需要新建vue.config.js在当前项目目录下（原来build和Config文件的配置都放在node_modules里面了），在里面进行 module.exports = {}配置，到时会和原来的配置进行合并作为整体配置 module.exports = { devServer: { //运行后默认打开浏览器 open: true } } 5.Vue router前后端路由概述路由就是网络把信息从源地址传输到目的地址的活动 后端渲染是将数据在后端处理生成html发给浏览器，前端渲染是通过ajax拿到数据，操作dom节点 渲染ui （相当于Node.js里的服务器渲染和客户端渲染） 1.后端路由（后端渲染）：服务器处理一个url映射一个页面，通过正则匹配，交给controller进行处理，然后生成html等数据返回前端 2.前后端分离（前端渲染）： 输入url 去静态服务器里获取 html + css + js 浏览器执行JS代码 -&gt; JS代码中有API请求，去到API接口服务器中获取数据 随着Ajax的出现，有了前后端分离的开发模式，前后端分离最大的优点就是责任清晰，分工明确，并且在移动端（IOS/Android）出现后，后端使用之前一套API即可 前端路由 在前后端分离中，静态资源服务器放了好几套的 HTML + CSS +JS，每个对应不同的页面 SPA页面（单页面富应用）：整个网站只有一个html页面 而在前端路由中： 静态资源服务器只有一个html（甚至也只有一个CSS + 一个JS） 网页获取到静态资源后，由前端路由配置映射关系 点击url，通过JS代码判断，从那个获取的一个静态资源里再抽取资源，然后显示出来（这里抽取的资源，再vue里，相当于一个url映射一个组件，一个组件对应一个网页） 改变url，依然是页面不发生整体刷新 url的hash 为了改变url，而让也页面不发生刷新，可以使用 url的hash 或者html5 的 history模式 Push：通过window.hash = &#39;xxx&#39;更改href，网页不会刷新（默认）（带有hash的前端路由，有点事兼容性高，缺点是URL带#号不好看） Push：也可以通过history.pushState({}, &#39;&#39;, &#39;xxx&#39;)更改href，网页也不会刷新， 可以使用history.back()或者history.go(-1) 后退功能进行回退 Push，入栈顶，可回退 Replace：还可以通过 window.replace、 history.replaceState({}, &#39;&#39;, &#39;xxx&#39;)来更改，不可回退 Replace，替换掉当前的路由 在Vue实例中使用 this.$router.back() 也可以实现回退 （源码上除了hash、history、其实还有一个abstract模式） vue-router关于url改动的问题 由于默认是使用hash改动url，如果想要改成Html5的history模式，则在router对象里利用mode属性进行修改 const router = new Router({ routes, mode: 'history', LinkActiveClass: 'active' //可以把router-link当前被选中（点击）的标签的类名，改为active }) 基本使用目前三大框架都有自己的路由实现：Angular的ngRouter、React的ReactRouter、Vue的vue-router 安装：(或者脚手架选择的时候，可以自动帮你安装路由，并且以下步骤不用实施) npm install vue-router --save于src文件夹里创建 router文件夹 -&gt; index.js 1.通过Vue.use(插件)，来安装插件 （在vue内部执行了插件.install方法） 2.创建路由对象，routes属性用于配置路由和组件的映射关系 3.将router对象传入Vue实例当中 import Router from 'vue-router' import Vue from 'vue' Vue.use(Router); const routes = [ ]; const router = new Router({ routes }) export default router; router 为 Vue的 路由属性，直接赋值即可 //main.js import Vue from 'vue' import App from './App' import router from './router' //自动找到该目录下的index文件 Vue.config.productionTip = false new Vue({ el: '#app', router, render: h => h(App) }) 使用 1.在components文件夹里新建组件 如： home.vue 和 about.vue，里面自己适配好template 和 script 2.在routes里编写映射关系，一个对象对应一个映射关系 踩坑：配置路由映射时，component不能加s url 中出现 path,则显示该对象里的组件component import Home from '../components/home' import About from '../components/about' const routes = [ { path: '/home', component: Home }, { path: '/about', component: About } ]; 3.通过&lt;router-link&gt;和&lt;router-view&gt;使用路由: vue-router模块源码中，注册了全局组件 RouterView 和 RouterLink 所以可以使用这两个标签 由于这里我们把Vue实例的渲染属性绑定了 App.vue 的组件对象，我们把&lt;router-link&gt;和&lt;router-view&gt;添加至 App.vue组件的template中使用 &lt;template> &lt;div id=\"app\"> &lt;!-- &lt;router-link >是Vuerouter已经注册的的内置标签，最终会被渲染成a标签 --> &lt;router-link to=\"/home\">首页&lt;/router-link> &lt;router-link to=\"/about\">关于&lt;/router-link> &lt;!-- &lt;router-view>是Vuerouter已经注册的，决定路由的页面渲染 --> &lt;router-view>&lt;/router-view> &lt;/div> &lt;/template> 配置首页 const routes = [ { path: '/', // redirect 重定向 redirect: '/home' } ]; router-link的其他属性的补充 to属性：写上路径，点击后则会把网页的url进行路径的改动，然后router-view就会根据这个路径渲染网页 tag属性：默认最终渲染为为 a 标签，tag=&quot;button&quot; 则渲染为button标签 replace属性：如果当前的router对象中mode属性为 ‘history’，增加该属性，则url的改变方法改为： history.replaceState() router-link的原理： &lt;template> &lt;div id=\"app\"> &lt;button @click=\"homeClick\">首页&lt;/button> &lt;button @click=\"aboutClick\">关于&lt;/button> &lt;router-view>&lt;/router-view> &lt;/div> &lt;/template> &lt;script> export default { name: \"App\", methods: { // 通过代码修改路径 // vue-router源码往所有组件里都添加了$router属性 // history的pushStatus， push => pushStatus // 但是连续点击会报错，可以试一试this.$router.push('home').catch(err => err) homeClick() { this.$router.push(\"/home\"); }, aboutClick() { this.$router.push(\"/about\"); }, }, }; &lt;/script> //选择hash的mode $router.push() --> HashHistory.push() --> History.transitionTo() --> History.updateRoute() --> {app._route = route} --> vm.render() 1 $router.push() //调用方法 2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶） //（其实也就是window.location.hash= XXX） 3 History.transitionTo() //监测更新，更新则调用History.updateRoute() 4 History.updateRoute() //更新路由 5 {app._route= route} //替换当前app路由 6 vm.render() //更新视图 其他知识点动态路由 某些情况下，一个页面的path是不确定的，比如我希望我的路径是 /user/aaa 或 /user/bbb /user/:id 这种path和Component的匹配关系，我们称之为动态路由（也是路由传递数据的一种方式） 动态路由的绑定：新建一个user.vue文件，然后把vue文件映射到路由的js文件中（router的index.js） &lt;template> &lt;div> &lt;h2>用户界面&lt;/h2> &lt;h2>{{ userId }}&lt;/h2> &lt;/div> &lt;/template> &lt;script> export default { name: \"User\", computed: { // route指当前处于活跃状态的路由，属性使用类似上面 ‘router-link的其他属性的补充’中 的$router属性 // vue-router源码往所有组件里都添加了$route属性 // 不要搞错成router，router是路由对象，用来配置路由和组件的关系 // params是参数的意思 userId() { //这里的userId对应的是映射时的/:userId return this.$route.params.userId; }, }, }; &lt;/script> import User from '../components/user' const routes = [ { path: '/user/:userId', component: User } ]; 接着在大组件app.vue中使用该模板 &lt;router-link :to=\"'/user/' + userId\" tag=\"button\">用户&lt;/router-link> 或者利用事件进行跳转+传递params this.$router.push(\"/detail/\" + userId); 在app.vue导出的实例对象里添加相应的data属性： data() { return { userId: \"zhangsan\" }; }, 路由懒加载 由于打包时，除了其他一些文件，主要的部分丢存放于一个js当中，然后在请求静态资源服务器时，可能因为文件太大，导致第一次请求资源时（即那一个主要的js文件），花费过长的时间，可能在请求过程，浏览器出现短暂的空白。 vue搭建脚手架时，对js、css文件等进行了分包 npm run build /dist/static/js 文件中 app.xxx.js 是业务代码 、vendor.xxx.js是提供商/第三方包的源码、mainfest.xxx.js是为打包的代码做底层支撑（让浏览器识别ES6、commonJS语法等） 当打包构建应用时，JavaScript包会变得特别大，如果我们把不同路由由对应的组件分割成不同同代码块，然后当路由被访问时才加载对应组件，这样才会更加高效（采取一个路由打包一个js文件的方法，先向静态资源服务器请求当前最需要的js文件） 懒加载：用到时，再加载 于router文件夹的index.js中每个加载修改为函数的形式 // 懒加载 const Home = () => import('../components/home'); const About = () => import('../components/about'); const User = () => import('../components/user'); const routes = [ { path: '/', redirect: '/home' }, { path: '/home', component: Home }, { path: '/about', component: About }, { path: '/user/:userId', component: User } ]; 路由嵌套如果想要进行路由细分（比如进入 /home 之后，还想要在进入 /home/message ），则形成了路由嵌套 嵌套的实现： 创建相应的子组件，并且在路由映射中配置相应的子路由 在组件内部使用 &lt;router-view&gt;标签 以下操作作为例子进行路由嵌套 新建两个vue文件（用于嵌套在home路由上） 在路由的js文件中的routes数组里，每个对象都可以有一个children属性，里面可以保存嵌套的路由 const HomeNews = () => import('../components/HomeNews') const HomeMessage = () => import('../components/HomeMessage') { path: '/home', component: Home, children: [ { path: '', redirect: 'news' }, {// 子路由不需要加 '/' path: 'news', component: HomeNews }, { path: 'message', component: HomeMessage } ] }, 然后再home组件中添加 router-view 进行子路由页面渲染 &lt;template> &lt;div> &lt;h2>首页&lt;/h2> &lt;!-- 这里需要给完整的路径， 不能直接to=\"/news\" --> &lt;router-link to=\"/home/news\" tag=\"button\">新闻&lt;/router-link> &lt;router-link to=\"/honme/message\" tag=\"button\">信息&lt;/router-link> &lt;router-view>&lt;/router-view> &lt;/div> &lt;/template> 参数传递从一个路由页面跳转到另外一个路由页面时，我们可能希望传递一些消息 传递参数主要有两种类型：params和query params类型：如动态路由的配置 /router/:参数名 传递方式：在path后面跟上响应的值 传递后形成的路径 /router/123， /router/abc 子组件通过 this.$route.params.参数名获取参数 query类型： 正常路由配置方式 传递方式：对象中使用query的key作为传递方式 传递后形成的路径： /router?id=123, /router?id=abc 在总组件 app.vue 中进行配置 &lt;router-link :to=\"{ path: '/Profile', query: { name: 'Allen', age: 18, heigh: 1.88 } }\" tag=\"button\"> 档案&lt;/router-link> 或者利用事件进行跳转+传递query 事件名(){ this.$router.push({ path:'/detail', query:{ name: 'Allen', age: 18, heigh: 1.88 } }) } 若想在子组件的template模板中中获取该参数，则使用 route.query进行获取（得到一个对象，里面存储参数） &lt;p>{{ $route.query }}&lt;/p> 总结：大量数据使用query，因为query传过去是对象 router和route 大前提：所有的组件都继承vue类的原型 vue-router源码往所有组件里都添加了$router属性（往vue的原型上加的，用的是vue.prototype在原型对象上添加） 所以在任何一个组件里，都可以使用 this.$router进行获取 前端路由使用history刷新页面时，router-link的原理中使用到 $router.push(&quot;路径&quot;)，router对象为路由文件夹router中index.js导出的router对象 而 route 是当前活跃的路由，vue-router源码往所有组件里也添加了$route属性（往vue的原型上加的，用的是vue.prototype在原型对象上添加） 所以在任何一个组件里，都可以使用 this.$route进行获取 导航守卫在发生路由跳转时，我们有时需要去监听这个跳转事件，然后对网页进行相应的变化（比如网页标题的改变） 方法一：使用生命周期函数 vue的生命周期函数 created() {} 来定制，缺点：一个功能的实现需要在多个（甚至是每个）子组件上定义。 方法二：导航守卫 先给每个路由添加 元数据 meta （描述数据的数据） const routes = [ { path: '/about', component: About, meta: { title:'关于' } }, { path: '/home', component: Home, meta: { title: '首页' }, children: [ { path: '', redirect: 'news' }, {// 子路由不需要加 '/' path: 'news', component: HomeNews }, { path: 'message', component: HomeMessage } ] } ] 使用导航守卫，这时可以使用to.meta.title获取，但是如果路由中使用了路由嵌套，还得格外注意使用 to.matched[0].meta.title获取，使用下标为0的进行获取，则当你未进行嵌套时，还能正常获取，因为确实是当前选定路由的第一个 next() 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 // 导航守卫 router.beforeEach(function (to, from, next) { //从from跳转到to， from和to都是Route类型 document.title = to.matched[0].meta.title; //有next才能实现路由跳转，一定要加上 next(); }) 这里的beforeEach 是前置守卫，是路由跳转之前进行的回调 后置钩子 afterEach(to, from) 不需要主动调用next函数，等待路由跳转结束后也会调用函数 无论是前置守卫还是后置钩子，都被称为全局守卫，除此之外，还有路由独享守卫 beforeEnter、 组件内守卫 beforeRouteEnter 等 keep-aliverouter-view也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存（比如实现功能：进入 /home ， 默认进入 /home/news，如果跳转到 /home/messgae 之后，再跳转到其他页面，此时回到 /home 可以直接进入上一次查看的页面/home/messgae，而不是默认页面/home/news） keep-alive 是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染，它的原理是避免组件被销毁（所以使用keep-alive之后，组件不会触发destoryed 钩子函数） 生命周期函数 activated 和 deactivated 只有在组件被保持了 keep-alive 时，才能被正常使用 &lt;keep-alive> &lt;router-view>&lt;/router-view> &lt;/keep-alive> //home.vue的script部分 export default { name: \"home\", data() { return { path: \"/home/news\" }; }, // 使用组件内守卫记录离开时的路径信息，并且再用生命周期函数activated实现跳转 //activated为当前页面活跃状态的钩子函数 activated() { this.$router.push(this.path).catch((err) => {}); }, beforeRouteLeave(to, from, next) { this.path = this.$route.path; next(); }, }; keep-alive有两个非常重要的属性 include：字符串或正则表达，只有匹配的组件才会被缓存 exclude：字符串或正则表达，任何匹配的组件都不会被缓存 注意：这里的 “,”不能加空格 &lt;!-- 使用keep-alive include=\"组件的name\" --> &lt;keep-alive include=\"home,User\"> &lt;router-view>&lt;/router-view> &lt;/keep-alive>","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"MongoDB","slug":"MongoDB","date":"2021-01-29T06:03:24.964Z","updated":"2021-03-06T14:02:10.700Z","comments":true,"path":"2021/01/29/mongodb/","link":"","permalink":"https://taylor12138.github.io/2021/01/29/mongodb/","excerpt":"","text":"1.MongoDB概述MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 mongoDB不需要学习sql语句 关系型数据库和非关系型数据库表就是关系 or 表与表之间存在关系 所有关系型数据都需要通过sql语言来操作 所有关系数据库在操作之前都需要设计表结构 而且数据表还支持约束 唯一性 主键 默认值 非空 非关系型数据库非常灵活，有的非关系型数据库就是key- value键值对 而MongoDB是长得最像关系型数据库的非关系型数据库 数据库 =&gt; 数据库 数据表 =&gt; 集合（数组） 表记录 =&gt; （文档对象） { 数据库:{ 集合:[ {name: &#39;Allen&#39;}, {name: &#39;Allen&#39;}, {name: &#39;Allen&#39;}, ] } } MongoDB不需要设计表结构 2.使用打开方式一：根据菜鸟教程提供的window MongoDB操作教程，就可以注册成window的一个服务，然后可以通过鼠标右键开启和停止这个服务了 方式二： #mongodb 默认使用执行 mongod 命令所处盘根目录下的/data/db作为自己的数据存储目录 #所以在第一次执行该命令之前，先手动新建一个 E(MongoDB所属盘):/data/db #然后再自己所属盘下 运行该命令 mongod 停止服务：ctrl + C或者直接关闭cmd窗口 如果想要修改默认的数据存储目录路径，可以（但是比较麻烦，不推荐） mongod --dbpath=数据存储目录路径 连接用一个命令窗口来打开MongoDB数据库 此时再打开一个窗口，输入以下命令进行连接 #该命令默认连接本机的MongoDB服务 mongo 断开连接 exit基本命令show dbs 查看显示所有数据库 db 查看当前操作的数据库，默认为test，供测试 show collections 查看当前数据库的集合 use 数据库名称 切换到指定数据库，如果没有该数据库则会新建一个 #在当前数据库的students集合中插入一个数据（对象） db.students.insertOne({\"name\": \"Jack\"}) #查看当前数据库的students集合中的数据 db.students.find() #移除 title 为“MongoDB”的文档 db.test.remove({'title': 'MongoDB'}) WriteResult({ 'nRemoved' : 2 }) #删除了两条数据 3.在Node中操作MongoDB数据方法一：使用官方的mongodb包来操作（并且根据文档提供的使用方法步骤进行操作） https://github.com/mongodb/node-mongodb-native 方法二：使用第三方mongoose来操作 MongoDB数据库 https://mongoosejs.com/ 而这个第三方包mongoose 是基于MongoDB 官方的 mongodb 包进行的二次封装 （mongoose所有api都支持promise） npm init -y npm i mongoose 以下代码在mongoose官网也能查看到 1.引包 require(&#39;mongoose&#39;); =&gt; 2.连接数据库 mongoose.connect (指定连接的数据库不一定需要存在，当你插入第一条数据之后就会被自动创建出来)=&gt; 3.创建模型mongoose.model(表名, 数据结构)（这里模型创建十分灵活，只需要在代码中设计你的数据库就可以了） =&gt; 4.实例化模型(new)，并将每个实例化的数据保存 save() 在该模型集合里 //demo.js // 引包 const mongoose = require('mongoose'); //连接MongoDB数据库（这里顺便创建了一个叫test的数据库） mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true }); //创建一个模型，说白了就是在设计数据库 // 这里第一个参数是表名：Cat，第二个参数是数据结构 const Cat = mongoose.model('Cat', { name: String }); for (let i = 0; i &lt; 10; i++) { // 实例化一个Cat（往cats集合里面插入每一个kitty数据） const kitty = new Cat({ name: 'Zildjian' }); // 持久化保存kitty实例 kitty.save().then(() => console.log('meow')); } 设计文档结构在第3步创建模型之前，其实还可以独立开来，使用Schema设置文档结构 字段名称就是表结构的属性名称 约束的目的就是为了保证数据的完整性，不要有脏数据 var mongoose = require('mongoose'); var Schema = mongoose.Schema; mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true }); var userSchema = new Schema({ username: { type: String, required: true //设置该属性必须有配置，使用required }, password: { type: String, required: true }, email: { type: String } }); 然后再用mongoose.model(表名, 数据结构)发布模型，此时把这个例子中userSchema放入第二个参数即可 var User = mongoose.model('User', userSchema); 第一个参数：为传入一个大写名词单数字符串，用来表示你的文档名称 第二个传的是对文档的约束，架构Schema 之后文档再变成复数，变成集合的名称，因为这才是一个集合，例如这里的User会变成users，即集合的名称 返回值是模型构造函数，我们有了模型构造函数之后，就可以对users集合数据进行操作了 操作数据确保数据库MongoDB被打开，并且再另外一个窗口进行连接 注意：mongoose增加数据是给你自动生成id 增加数据 利用返回的模型构造函数，new一个实例对象，顺便使用save()进行保存 let allen = new User({ username: 'allen', password: '123456', email: 'allen@qq.com' }); //ret是刚刚插入的那条数据 allen.save((err, ret) => { if (err) { console.log('保存失败'); } else { console.log('保存成共'); console.log(ret); } }) 查询数据 模型构造函数.find() 查询所有数据，ret返回一个数组，记录里面的数据（文档） User.find(function (err, ret) { if (err) { console.log('查询失败'); } else { console.log(ret); } }); 条件查询，查询username为Bruce的数据(按条件查找，ret返回一个数组，记录里面的数据（文档）) User.find({ username: 'Bruce' }, function (err, ret) { if (err) { console.log('查询失败'); } else { console.log(ret); } }); 只找到第一个匹配到的对象（文档）数据，ret返回一个对象 User.findOne({ username: 'Bruce', password: '123456' }, function (err, ret) { if (err) { console.log('查询失败'); } else { console.log(ret); } }); //promise格式，因为mongoose所有api都支持promise // User.findOne({ username: 'Bruce', password: '123456' }) // .then(data => { // console.log(data); // }, err => { // console.log('查询失败'); // }) 利用或，满足其中一个条件查询成功 User.findOne({ $or: [ { email: body.email }, { nickname: body.nickname } ] }, function (err, data) { if (err) { res.status(500).send('Server err'); }else { console.log(data) } }) 删除数据 remove现在似乎已经废弃了，所以采用delete 删除单个数据，删除条件为username: &#39;Zildjian&#39;的数据 User.deleteOne({ name: 'Zildjian' }, function (err) { if (err) console.log('删除失败'); }); 删除多个，删除条件为username: &#39;Zildjian&#39;的数据 User.deleteMany({ name: 'Zildjian' }, function (err) { if (err) console.log('删除失败'); }); 根据id删除： findByIdAndDelete 更新数据 根据id更改数据 User.findByIdAndUpdate('60142a5acbcef341281a7d18', { password: '789456' }, function (err, ret) { if (err) console.log('更新失败'); else console.log('更新成功！'); }) 还有其他更新数据方法可以在mongoose文档查看","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"计网personal note","slug":"计网personal note","date":"2021-01-08T06:57:51.068Z","updated":"2021-03-20T08:07:33.172Z","comments":true,"path":"2021/01/08/ji-wang-personal-note/","link":"","permalink":"https://taylor12138.github.io/2021/01/08/ji-wang-personal-note/","excerpt":"","text":"1.计网概念是将一个分散的，具有独立功能的计算机系统，通过通信设备和线路连接起来，由功能完善的软件实现资源共享和信息传递 计算机网络是互连的、自治的计算机集合 功能数据通信（连通性）（通信子网：网络层、数据链路层、物理层）（是点到点的通信） 资源共享（资源子网：应用层、表示层、会话层） （是端到端的通信） ​ 两个子网之间隔着传输层 主机在osi模型中有七层，而中间系统只有物理层、数据链路层、网络层三层（交换机和网桥这种甚至只有物理层、数据层两层） 分布式处理（多台计算机各自承担同一工作任务的不同部分） 提高可靠性 负载均衡 组成硬件、软件、协议（核心） 边缘部分（用户可以直接使用）、核心部分（为边缘部分服务） 功能组成：从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 分类分布范围划分：广域网WAN、城域网MAN、局域网LAN、个人区域网PAN 使用者划分：公用网（电信）、专用网（军队） 交换技术划分：电路交换、报文交换、分组交换 拓扑结构划分：总线型、星型、环型、网状型 传输技术划分：广播式网络（共享公共通信通道）、点对点网络 标准的划分法定标准：OSI 事实标准：TCP/IP（并不是指这两种协议，而是对许多大大小小的协议的泛指） 速率 &amp; 带宽 &amp; 吞吐量1.速率速率即数据率或数据传输率、或比特（bit）率，其实也就是速度 kb/s…. 存储容量是以 字节（Byte）作为单位 2.带宽原本：指某个信号具有的频带宽度，即最高频率和最低频率之差，单位是赫兹Hz 现在：它用来表示网络通信线路传送数据的能力，通常指单位时间内从网络某一点到另外一点的“最高数据率”，单位是比特每秒（和速率一样）（其实就是表示所支持最高速率为多少） 3.吞吐量单位时间内通过某个网络（信道、接口）的数据量，单位是 b/s…… 吞吐量还受到带宽或者网络额定速率的限制 吞吐量更像瞬时速率，带宽像最大速率 时延指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需要的时间，也叫做延迟或迟延，单位是秒s 分别为 发送时延（把所有数据从发送端推到信道上，发生在主机内部）=数据长度/信道带宽，高速链路指的是发送速率的提高，即带宽的提高，导致发送时延的减少 传播时延（在信道上传播一段距离所花费的时间，发生在信道上）=信道长度/电磁波速率 排队时延（等待处理） 处理时延（检错，找出口） 时延带宽积bit = 传播时延s * 带宽b/s，它又称为以比特位单位的链路长度，链路的容量 往返时延RTT：从发送方发送数据开始，到发送方收到接收方的确认经历的时延，RTT = 往返传播时延 + 末端处理时间 = 传播时延*2 + 末端处理时间 利用率信道利用率 = 有数据通过的时间 / 总时间 链路利用率=发送延时/总用时 = 发送延时/（发送时延+2*传播时延+确认帧传输时延） 网络利用率 = 信道利用率加权平均值 分层关于实体、协议、服务和接口： 1.实体：第n层元素称为n层实体，同层另外一端主机的实体叫对等实体 2.协议：对等实体（或多个实体）通信规则，分为语法、语义、同步（操作顺序） 3.接口：上层使用下层服务的入口 4.服务：下层为相邻上层提供功能调用（相邻，下层为上层才能为称之为服务） 计算机网络体系结构是计算机网络各层及其协议的集合 各层功能简洁概述应用层：所有能和用户交互产生网络流量的程序 表示层：用于处理两个通信系统中，交换信息的表示方式（语法和语义）功能：数据格式变换（翻译）、数据加密和解密、数据的压缩和恢复 会话层：向表示层实体/用户进程提供建立连接并连接上有序地传输数据。这是会话，也是建立同步 传输层：负责主机两个进程的通信，即端到端的通信，传输单位是报文段或用户数据段。功能：可靠传输（有确认机制）、不可靠传输；差错控制；流量控制（发送速率）；复用分用（复用是多个应用层可同时使用下层运输层服务，分用是目的主机传输层把收到的信息分别交付给上面应用层中相应进程，应用：端口号）（osi面向连接，tcp/ip无连接+面向连接） 网络层：把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报（osi无连接+面向连接，tcp/ip无连接） 数据链路层：主要任务是把网络层传下来的数据组装成帧，数据链路层的传输单位是帧 物理层：主要任务是在物理媒体上实现比特流的透明传输 TCP/IP的应用层：合并应用层、表示层、会话层 5层参考模型数据封装与解封装应用层：单位：报文 传输层：单位：报文段 网络层：单位：数据报 数据链路层：单位：帧 物理层：单位：比特 香农定理 2.物理层物理层解决如何连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体（不同厂家生产的介质），它的任务是确定传输媒体接口有关的一些特性（定义标准，类似于水晶头规格，电压范围） 定义的特性：机械特性、电气特性、功能特性、过程特性 数据通信基础知识 数据：传送消息的实体，通常是有意义的符号序列 信号：数据在传输过程中的存在形式 数字信号/离散信号，计量单位是码元 模拟信号/连续信号 信源：产生和发送数据的源头 信宿：接收数据的终点 信道：信号传输的媒介，一般用来表示某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道 三种通信方式 单工信道：只有一个方向，仅需一条信道 半双工信道：双方都可以发送和接收，但是不能同时，类似于对讲机，需要两条信道 全双工信道：双方可同时收发，需要两条信道 两种数据传输方式串行传输 并行传输 编码与调制信道上的信号除了可以分为模拟信道和数字信道、无线信道和有线信道之外，还可以分为基带信号和宽带信号 基带信号：将数字信号1或0直接用两种不同的电压表示，再送到数字信道（在计算机中是使用数字信号，人类是模拟信号）上去传输（基带传输），基带信号最重要的一点就是来自于信源 宽带信号：将基带信号进行调制模拟后形成频分复（载波调制）用模拟信号，再传送到模拟信道上去传输（宽带传输）。载波调制（带通调制）把信号频率范围调到较高的频段以便在信道中传输 编码方式非归零编码：高1低0，容易，但是没有检错功能，无法判断码元的开始与结束，难以同步 归零编码：1：中间高，两边中等；0：中间低，两边中等 曼彻斯特编码：1：前高后低；0：前低后高，这种方法所占频带宽度是基带宽度的两倍，所以它的数据传输速率只有调制速率的1/2 差分曼彻斯特编码：同1异0，即码元为1，则前半段半个码元和上一个码元的后半段的电平相同，0则相反，抗干扰性强于曼彻斯特编码 数字数据调制为模拟信号调制解调器的调制：数字信号-&gt;模拟信号 调幅：0没幅度，1有幅度 调频：0低频，1高频 调相：调成正弦波和余弦波 QAM正交振幅调制，相当于调幅+调向 调制解调器的解调：模拟信号-&gt;数字信号 3.数据链路层结点：主机和路由器 链路：网络中两个结点之间的物理通道，主要介质为双绞线、光纤等 数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议和硬件和软件加到链路上就构成数据链路 帧：链路层的协议数据单元，封装网络层数报 数据链路层 负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报，它最基本的服务是将源自于网络层的数据可靠的传输到相邻结点的目标机网络层（简单来说就是加强物理层传输原始比特流的功能），将物理层提供可能出现差错的物理连接改造成为逻辑上无差错的数据链路 功能一：为网络层提供：无确认无连接服务、有确认无连接服务、有确认面向连接服务（有连接一定有确认） 功能二：链路管理，即连接的建立、维持和释放（用于面向连接） 功能三：组帧 功能四：流量控制 功能五：差错控制 封装成帧实际上就是将网络层的ip数据报形成帧数据部分，加上帧首部，帧尾部 这样接收端在收到物理层上交的比特流后，就可以根据首尾标记进行识别 帧首部和帧尾部包含许多信息，其中有个重要作用就是：帧定界（确定帧的界限）； 帧同步：接收方应当能从接收到的二进制比特流区分帧的开始和结束 四种封装成帧方法： 1.字符计数法 2.字符填充法（帧首部SOH，帧尾部EOT）：为了保障字符填充的透明传输，在控制信息的前面+转义字符 3.零比特填充法（帧的首尾部都是01111110）：为了保障字符填充的透明传输，中间数据部分，只要有5个1，就立刻填入一个0，简称5110方法 4.违规编码法：曼彻斯特编码都是“高-低”，所以首尾帧用“高-高”、“低-低”定界帧的起始和结束 透明传输指不管所传的数据是什么样的比特组合，都应当能够在链路上传送，因此链路层“看不见”有什么妨碍数据传输的东西（保证传输透明，传输数据的比特组合可能和某控制信息一样（比如对数据链路层进行什么操作），但是数据链路层不管它，完全把它当作一个信息直接传递） 差错控制差错有：位错（比特位出错）和帧错（丢失、重复、失序） 差错控制：检测编码（奇偶校验码、循环冗杂码CRC）和纠错编码 冗余编码：在数据发送前，先按照某种关系加上一定的冗余位（比如余数），构成一个符合某一规则的码字后在发送，根据规则，接收端查看收到的码字是否符合原规则，从而判断对错 CRC循环冗余码： 发送端：要传的数据 / 生成多项式（一个数值） = 商…..FCS冗余码（余数）；最终要发送的数据为 要穿的数据 + FCS冗余码 接收端：收到的数据 / 生成多项式 = 商…0 余数为0，无差错 计算冗余码：（1）加0，生成多项式G(x)的阶（即生成多项式的位数-1）为r，则加r个0；（2）模2除法，同0异1 余数为0，接受，不为0，丢弃 此方法只能做到对帧的无差错接收，但是不能算作“可靠传输”，因为“可靠传输”的定义是数据链路层发送什么，接收端就接收到什么，但是此方法丢弃了部分错误的，没有完全接收 数据链路层流量控制较高发送速度和较低接收能力不匹配会出现传输错误 数据链路层的流量控制是点对点的（接收方收不下就不回复确认），传输层的流量控制是端对端的（接收端给发送端一个窗口公告） 停止等待协议：每发送完一个帧，等待对方确认再发下一个（停止等待协议类似于特殊的滑动窗口协议，但只是发送窗口和接收窗口都只有一个） 滑动窗口协议： 发送窗口指在发送端维持一段连续的，允许发送的帧的序号（正在发送的数据），相对应的是接收窗口，滑动窗口协议解决流量控制问题和可靠传输问题 后退N帧协议，发送窗口大小&gt;1，接收窗口大小=1 选择重传协议，发送窗口大小&gt;1，接收窗口大小&gt;1 在链路层在发送过程，发送窗口和接收窗口大小固定 停止等待协议除了比特出差错，底层还会出现丢包问题（线路、病毒等原因导致数据包的丢失） 停止等待协议重申：每发送完一个帧，等待对方确认再发下一个（停止等待协议类似于特殊的滑动窗口协议，但只是发送窗口和接收窗口都只有一个） 有差错的情况： 1.数据帧丢失或检测到帧出错 每发送一个帧，启动一个超时计时器 重传时间&gt;往返传播时延RTT 超时重传 注意：（1）发完一个帧后，要保留他的副本，（2）数据帧和确认帧必须编号、（3） 2.ACK丢失（确认丢失） 同上，但是接收方丢弃重复帧，重传确认帧 3.ACK迟到 仍然是超时重传，接收方丢弃重复帧，重传确认帧（当后面发送方终于等到一开始的确认帧时，直接收下并且丢弃） 协议的优点：简单，缺点：信道利用率低（发送时间Td / （发送时间Td + RTT + 确认分组时间Ta）） 滑动窗口后退N帧 发送窗口重申：发送窗口指在发送端维持一段连续的，允许发送的帧的序号（正在发送的数据） 接收窗口：接收方维持一组连续的允许接收帧的序号 后退N帧协议，发送窗口大小&gt;1，接收窗口大小=1 累积确认：接收方不用对于每个数据帧返回确认帧，可以隔一会返回一个确认帧，它保证这个帧，以及之前的所有帧都得到了确认 超时事件：发送方会重传所有已发送但是未被确认的帧，比如再等待1号帧，但是一直等不到，等来2，3号帧，会将其丢弃，直到重传的1号帧的到来，并且继续重传刚才已经发过的2、3号帧 滑动窗口长度：窗口大小W小于帧总类的一半 选择重传协议中的滑动窗口 和后退N帧不同的是，如果帧没有按序到达，也会将之后序号的帧暂存在接收窗口 如果接收方收到的帧序号是窗口的下界（最左边窗口对应的序号），则窗向前移动到最小序号未确认帧处 超时事件：一个超时事件发生后只重传一个帧 如果收到了窗口序号外的帧（小于窗口下界，可能因为某些原因传的慢，但是已经超时重传了），就返回一个ack 滑动窗口长度：发送窗口最好等于接收窗口 ；窗口大小W小于帧总类的一半 传输数据的链路点对点链路应用：ppp协议、广域网 广播式链路：局域网 广播信道介质访问控制就是采取一定措施，使得两对节点之间通信（因为广播式链路，是多个点共享信道）不会发生互相干扰的情况 静态划分信道：频分复用、时分复用、波分复用、码分复用 动态分配信道（CSMA/CD包含其中）：分为轮询访问介质访问控制、随机访问介质访问控制 随机访问介质访问控制：所有用户可随机发信息，发送信息时占全部带宽 CSMA/CD协议先听再说、边听边说 载波监听多点接入/碰撞检测 CSMA/CD CS：载波监听，每个站在发送数据之前以及发送数据时，都要检测一下总线上是否有其他计算机在发送数据。其实就是检测信道上电压的摆动幅值（在站点的位置检测有没有信号进来），幅值较大，则说明信道上有人在说话，就不发送，直到检测信道上空闲才发送 MA：多点接入，表示许多计算机以多点接入的方式连在一根总线上 ，其实也说明了该协议应用于总线型网络 CD：碰撞检测，“边发送边监听”，适配器边发送数据，边检测信道上信号电压变化，以判断自己发送数据时其他站是否也在发，也说明了该协议应用于半双工网络 为什么先听后还是有可能发生冲突？因为电磁波在总线上总是以有限速率进行传播，即传播时延对载波监听的影响 检测到数据帧有错误，则确定发生了碰撞和冲突，停发 只要经过 2T 时间没有检验出碰撞，就能肯定这次不会发生碰撞（T为单程端到端的传播时延） 采用截断二进制指数规避算法确定重传时机： 1.确定基本规避时间，争用期为2T，2T &lt;= 最小帧长 / 数据传输速率 2.定义参数k，它等于重传次数，但k不超过10，k = min[重传次数, 10] 3.从离散的整数集合[0, 2^k-1]中随机取出一个数r，重传所需要退避的时间，就是r倍的基本规避时间，即2r*T 4.当重传达到16次仍不能成功，说明网络太拥挤，则抛出此帧向高层报错 为了避免帧太短导致该协议的作用无效（传短帧后才知道发生碰撞），以太网定义了最小帧长64byte = 512bit，小于此大小为无效帧 MAC层在局域网中，硬件地址又称为物理地址或MAC地址，它是每个适配器（网卡）都有的一个全球唯一地48位二进制地址 MAC层主要功能包括数据帧的封装和卸装 MAC帧：是以以太网V2的格式 以太网由Xerox等公司联合开发地基带总线局域网规范，是当今现有局域网最通用的通信协议标准，使用CSMA/CD技术 以太网提供无连接、不可靠服务 PPP协议局域网普遍采取多点接入技术（总线型） 广域网中通常采用点对点技术（将多个局域网互联，资源共享） PPP协议是目前使用最广泛的数据链路层协议（拨号上网）只支持全双工 ppp协议的三个组成部分： （1）一个将ip数据报封装到串行链路 （2）链路控制协议LCP（身份验证） （3）网络控制协议NCP，为网络层协议建立和配置逻辑连接 PPP帧格式：零比特填充法 4.网络层主要任务就是把分组从源端传送到目的端，为分组交换网上的不同主机提供通信服务，传输单位是数据报（数据报是比较长的数据，分组是把数据包进行切割，划分出来的片段） 功能一：路由的选择和分组转发（选最佳路径） 功能二：异构网络互联 功能三：拥塞控制 数据交换方式两台主机通过网络核心【路由器】进行数据转发 （1）电路交换：比如电话网络，独占资源 （2）报文交换：报文是源应用发送的信息整体，无需建立连接、可靠、利用率高，且多目标，但报文大小不定，需要网络节点有较大缓存空间 （3）分组交换：大数据块分割成小数据块（把报文切割成小数据块），它相对于报文交换，存储管理更容易；但是乱序到达目的主机时，需要分组排序重组 数据报和虚电路数据报方式为网络层提供无连接服务（因特网在使用）（无连接服务为不事先为分组的传输确定传输路径，不同分组传输路径可能不同） 路由器根据分组目的地址转发分组，基于算法构建的转发表，为每个分组独立选路 虚电路方式为网络层提供连接服务（虚电路是一条源主机到目的主机类似于电路的路径（逻辑连接），路上所有结点都要维持这条虚电路的建立，并有一张虚电路表） 每个分组携带虚电路号，可以使得一系列的分组沿着相同路径转发出去 路由算法和路由器概述算法的“最佳”只能是相对于某一种特定要求下得出的比较合理的选择而已 静态路由算法：非自适应路由选择，即管理员手动配置，不适用于大型网络，适合小的、安全要求高的网络 动态路由算法：自适应路由选择 采用分层次的路由选择协议：（1）因特网规模大（2）许多单位不想让外界知道自己的路由选择协议 因此把互联网划分为许多较小的自治系统AS，一个AS的所有路由器在本自治系统内都应该相互连通；一个AS对其他AS表现出是一个单一的一致的路由选择策略（分层次是分成内部和外部） 内部网关协议IGP，一个AS内使用 外部网关协议EGP，AS之间使用 内部网关协议 RIP基于距离向量的路由选择协议，最大优点是简单（适用于小规模网络） 它要求网络中每个路由器维护它从其他每个目的网络的唯一最佳距离纪录（维护的是路由表），也就是最短跳数 RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达，所以只适合小规模互联网 RIP协议的特点： 1.仅和相邻的路由器交换信息 2.交换的信息时自己的路由表 3.固定时间间隔交换路由信息 路由器刚开始工作时，只知道直接相连的几个网络的距离（距离定义为1） 距离向量算法： 1.修改相邻路由器发来的RIP报文中所有表项，对地址为X的相邻路由器发来的RIP报文，下一跳地址改为X，并把所有“距离”字段+1 2.对修改后RIP报文的每个项目，若原路由表没有目的网络N则添加；若已经含有，且下一跳地址和原来一样，则即使跳数可能增大，但也必须发生更改；若已经含有，且下一跳地址不同，则将跳数相对较小的项目更新入路由表 3.若180s没收到相邻路由表的更新，则记为不可达路由器，距离设置为16 RIP其实是应用层的协议，使用UDP传送数据，使用UDP’无可靠保证，但是开销小 好消息传得快，坏消息传得慢 OSPF协议使用的是迪杰斯特拉最短路径算法，适用于大规模互联网 它最主要的特征就是使用了分布式链路状态协议 30min更新一次 传递协议：IP 外部网关协议 BGP和其他AS邻站BGP发言人交换信息，交换网络可达性信息，发生变化时更新有变化部分 不用找到最佳路径，找到较好路由选择就够了 传递协议：TCP，保证可靠的交付 IP数据报格式在TCP/IP标准中，数据报格式中的数据常常以32位（4Byte）为单位来描述 数据报长度不能超过MTU（1500字节byte），如果超过了就分片 分片流程： 数据报中有标识数据段，同一数据报分片使用同一标识 数据报中有标志数据段，DF = 1禁止分片；DF = 0，允许分片，在DF = 0的条件下，MF = 1后面还有分片；MF = 0最后一块没分片 数据报中有片偏移数据段，指出较长分组分片后，某片在原分组相对位置，以8B为单位，所以能得出除了最后一个分片，每个分片的长度都一定是8B的整数倍 ip数据报固定首部长度为20字节 ip地址ip地址，在全世界范围内唯一的32位标识符，可以唯一标识一个主机或者路由器等设备的接口 ip编制历史阶段： 1.分类的ip地址 2.子网的划分 3.构成超网 分类的ip地址：ip地址{&lt;网络号&gt;, &lt;主机号&gt;}，如果主机连在一个网络上，则网络号是相同的，主机号不相同 分类分成5类，分类方法靠前面的四位来区分 ，分类因为各网络差异比较大，有的网络主机数多，有的少，且ip地址是32位，我们为了便于书写，常常每八位插入一个空格（但在机器中并没有这样的空格） A类：2^7-2是因为全零指本网，全1；127指回环，2^24-2是因为全零指本机，全1指广播地址 B类：128.0.0.0不能指派，2^14-1 C类：192.0.0.0不能只派，2^21-1 特殊ip地址： 网络号全0，主机号全0，本网范围内标识本主机，只能作为源地址 网络号全0，主机号特定值，本网范围某主机，只能作为源地址 网络号全1，主机号全1，本网广播地址，只能作为目的地址 网络号特定值，主机号全0，网络地址，表示一个网络，啥也不能作 网络号特定值，主机号全1，直接广播地址，只能作为目的地址，表示对特定网络上所有主机广播 网络号127，主机号任意，用于本地软件测试 分类ip地址缺点：ip地址空间利用率有时很低；2级地址不够灵活 子网的划分ip地址{&lt;网络号&gt;, &lt;&lt;子网号&gt;，&lt;主机号&gt;&gt;}，三级的ip地址，但是就算划分子网后，对外表现仍然是一个网络，即本单位外网络看不见本单位内子网划分 子网号能否全0、全1要看情况，主机号部分仍然不能全0、全1 子网掩码：极力推荐子网掩码中使用连续的1：比如B类 11111111 11111111 11111111 00000000，子网掩码和ip地址相与，就可以得到子网网络地址 路由表中包含：目的网络地址、目的网络子网掩码、下一跳地址 使用子网分组转发 1.提取目的ip地址 2.判断是否可直接交付，用ip地址与子网掩码相与，匹配则交付 3.若1-2步骤不行，判断特定主机路由 4.若1-3步骤不行，检测路由表有无路径，也是相”与“判断 5.若1-4步骤不行，默认路由处理 0.0.0.0 6.最后还不行丢弃分组，报错 无分类编址CIDR是否可以使用一个变长的子网掩码，而非定长的？CIDR消除了传统A、B、C类和子网划分的概念 ip地址{&lt;网络前缀&gt;，&lt;主机号&gt;} CIDR的记法：ip地址后加上/，然后写上网络前缀的位数即可 128.14.32.0/20，则表示前20位位网络前缀 CIDR把网络前缀相同的连续ip地址组成一个CIDR地址块此时最小地址为：网络前缀保持不变，主机号全0，最大地址为：网络前缀保持不变，主机号全1 CIDR地址掩码为网络前缀的每个位，填充为1，后面的主机号位填充为0 构成超网定义：将多个子网聚合成一个较大的子网，叫作构成超网或路由聚合，使得路由器转发表不用写那么多数据 构成超网方法：将网络前缀缩短 最长前缀匹配：使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由，前缀越长，地址块越小，路由越具体 在CIDR中子网号可全0、全1 ARP协议ARP高速缓存：保存的是ip地址和mac地址的映射（对应），解决下一跳走哪的问题 在实际链路上传送数据帧时，最终必须使用mac地址 注意：硬件地址又称物理地址，从层次的角度，物理地址是给物理层和数据链路层使用的地址，而ip地址时网络层和以上各层使用的地址，是一种逻辑地址；以太网帧在传输过程中有关其内部的mac地址和ip地址的变化情况：源ip地址和目的ip地址不会产生变化，而源mac地址和目的地址逐网络（或逐链路）都发生变化 ARP协议的使用： 检查ARP高速缓存是否已经有对应的ip地址到mac的映射表项,如果没有执行以下步骤 局域网络内：某主机要发射数据帧，但是不知道目的主机的mac地址，但是直到发送主机、目的主机的ip地址，以及知道自身的物理地址，这时发射主机发送广播请求分组（全1），最后收到目的主机的单播响应分组，得到该主机的mac地址，写入ARP缓存 局域网外：寄希望于默认网关（与外界沟通的路由器），跳到路由器的mac地址，然后该路由器响应发送主机的广播请求，把路由器的mac地址映射返回；然后一直传到目的主机局域网的路由器的mac地址，这时该局域网路由器发送广播请求分组（全1），最后收到目的主机的单播响应分组，得到该主机的mac地址 ICMP协议ICMP循序主机或路由器报告差错情况和提供有关异常情况的报告 ICMP报文 + ip数据报首部 = ip数据报的数据部份 +ip数据报首部 = ip数据报 ICMP分为：ICMP差错报文和ICMP询问报文 ICMP差错报文：1.终点不可达（无法交付问题）；2.时间超过（数据报生存时间为0或者数据报片没有收集完整，应用：Traceroute）；3.参数问题（首部字段出问题）；4.改变路由（重定向） ICMP询问报文：1.回送请求和回答（测试目的栈是否可达，应用：ping xxip地址，测试两个主机的连通性）；2.时间戳请求和回答 IPV632位的IPV4地址空间已经分配殆尽了，IPV6从根本解决地址耗尽问题 更大的地址空间：原来的32位 -&gt; 128位 拓展的地址层次结构、灵活的首部格式、改进的选项。。。。。 IPV6由两大数据部分组成，基本首部和有效载荷 IPV6的表示方法为：冒号十六进制记法，允许零压缩 IPV6向IPV4过渡策略：双栈协议（同时启用IPV4和IPV6）、隧道技术（重新封装） 5.传输层主机才会有的层次，功能有： 提供进程和进程之间的通信（网络层提供主机和主机之间的逻辑通信） 复用和分用 对报文进行差错检测 两个协议，TCP和UDP 端口号传输层有一个端口（逻辑端口/软件端口），它可以唯一标识一个具体的进程，端口号只有本地意义 端口号长度为16bit，能表示65536个不同端口号 分为服务端口号和客户端口号 服务端口号：熟知端口号（给TCP/IP最重要的一些应用程序，0-1023，让所有用户都知道）、登记端口号（1024-49151） 客户端口号：49152-65535，仅在客户进程运行时才动态选择 重要端口号： 传输层两个好兄弟，大哥TCP和二弟UDP，大哥靠谱，二弟不靠谱 传输单元为报文段 TCP传送数据前必须建立连接，不提供广播或多播，时延大，适用大文件 1.面向连接（虚连接）的传输控制协议 2.每一条TCP只能有两个端点，点对点 3.TCP提供可靠交付服务 4.全双工通信，发送方的发送缓存：准备发送的数据&amp;已发送但尚未收到确认的数据；接收方的接收缓存：按序到达但违背接受应用读取&amp;不按序到达的数据 5.面向字节流 TCP首部格式最小长度为20字节 序号为发送的数据（报文段）的第一个字节的序号 确认号：用于接收方发送的TCP确认报文段，确认号是期待发送方下一个报文段第一个数据字节序号 数据偏移：实际上就是TCP首部长度 紧急URG：URG = 1，在发送报文段时拥有插队权力 同步SYN：建立连接时同来同步的 TCP连接管理连接的建立 -&gt; 数据的传送 -&gt; 连接的释放 tcp连接建立采用客户服务器方式，主动发起连接的应用进程叫作客户，被动等待连接建立的应用进程叫服务器 连接建立过程：三次握手 客户端发送报文段，里面无应用层数据，SYN（同步位） = 1，seq（序号） = x（随机） 服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据 SYN = 1，ACK（确认位） = 1，seq = y，ack（确认号） = x + 1. 客户端为TCP连接分配缓存和变量，并向服务器返回确认的确认，可以携带数据，SYN = 0，ACK = 1，seq = x + 1，ack = y + 1 2次不行： 客户端向服务器发送建立连接的请求报文段，有可能因为网络滞留了，之后等到这个滞留报文段到达服务端时，客户端早已重新发送请求连接的报文，而服务端不这么认为，服务端他以为你发了新的连接请求，此时服务端向客户端发送确认报文，而客户端收到这个响应，但是发现这个请求在之前就发过了，就会忽略，而此时服务端苦苦等待客户端的响应，这样就会造成资源浪费 4次不行： 意义不大，因为此时我们都知道双方的发送和接收功能都是正常的 洪范攻击：发生在osi第四层，利用三次握手的特性，拼命向服务器发送大量的TCP SYN，也就是三次握手的第一次数据包，当服务器返回ACK后，该攻击者就不对其进行确认，让TCP处于挂起状态，服务器收不到再确认，还会重复发送ACK给攻击者，然后浪费服务器资源，消耗CPU和内存，可能导致服务器死机 连接释放过程：四次挥手（参与一条TCP连接的两个进程任何一个都可以终止该连接，连接结束后主机中的“资源”将被释放） 客户端发送连接释放报文段，停止发送数据，主动关闭TCP FIN（释放位） = 1，seq（序号） = u 服务器回送确认报文段，客户端到服务器这个方向的连接就释放了—-半关闭状态 ACK = 1，seq = v，ack = u+1 服务器端发完数据，发送释放报文段，主动关闭TCP连接 FIN = 1，ACK = 1，seq = w，ack = u+1 客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后（防止服务器未接收到确认，这时服务器可以及时再次发送释放报文段），连接彻底关闭 SYN：同步序列号，是用来建立连接的握手信号。ack：确认序号，当ACK为1时，ack有效，当ACK为0时，ack无效。seq：序号。ACK：确认序号有效。FIN: 结束标志，用来表示断开连接。 TCP可靠传输保证接收方从缓存区读出的字节流与发送方发出的字节流是完全一样的 1.检验，与UDP一样，增加伪首部 2.序号，对应TCP首部格式的序号 3.确认号，对应TCP首部格式的确认号 4.重传（超时重传），TPC采用自适应算法，动态改变重传时间RTTs（加权平均往返时间） 5.冗余ACK，当比期望序号大的失序报文段到达时，发送冗余ACK，指明下一个期待字节的序号（发送方收到3个冗余ACK，则认为报文段丢失，选择重发） TCP流量控制同数据链路层的滑动窗口进行流量控制 但是TCP的发送窗口是根据接收方的报文段（rwnd = 400，则窗口大小为400B），动态变化其大小（在链路层在发送过程，发送窗口和接收窗口大小固定），如果设置rwnd = 0，则发送端等待接收方再次发送rwnnd &gt; 0 的报文段，如果一直等不到（可能接收方返回的报文段丢失了），TCP连接的一方（此时仍是0窗口大小）启动计时器开始计时，一段时间结束后发送零窗口的试探报文段，然后接收方会再发一次原来要返回的报文段 TCP拥塞控制出现条件：对资源的需求&gt;可用资源 网络性能下降、网络吞吐量随输入负荷增大而下降 拥塞控制是全局性的过程，防止过多数据注入网络 拥塞控制的方法：慢开始、拥塞避免、快重传、快恢复 发送窗口 = Min{接收窗口，拥塞窗口} 接收窗口：接收方根据接收缓存设置的值，反应接收方容量 拥塞窗口：发送方根据自己估算的网络拥塞程度设置的值，反应当前网络容量 一个传输轮次 = 一个RTT UDP无连接的用户数据报协议 1.传送数据前不用建立连接，收到报文后也不需要任何确认，不保证可靠交付 2.UDP是面向报文的（面对应用层交下来的报文，不拆分也不合并，保留报文边界），适合一次性传输少量数据的网络应用（够小就可以完整交付，不用拆分），适用小文件 3.无拥塞控制，适合很多实时应用 4.UDP首部开销小，8B；TCP则是20B，和ip数据报固定首部长度 它只在ip数据报服务上增加了复用分用、差错检测功能 在分用时，找不到对应端口，则向发送方发送ICMP“端口号不可达”差错报文 提供全双工服务 UDP校验时： 1.会发现有“伪首部”，它只在计算校验和时才出现，不向下传送也不向上递交 2.全0填充数据部分和校验和字段 3.伪首部+首部+数据部分采用二进制反码求和，把和，求它的反码，填入校验和字段，去掉伪首部，发送 4.接收端填上伪首部，采用伪首部+首部+数据部分采用二进制反码求和，全1无差错，否则丢弃数据报/交给应用层附上出差错的警告 二进制反码求和: 规则是从低到高位逐列进行bai计算，0和0加得0,0和1加得1,1和1加得0但要产生一个进位1，加到下一列，若最高位产生了进位，则最后得到的结果要加1。 6.应用层应用层对应用程序的通信提供服务 应用层协议的定义： 应用进程交换的报文类型，请求还是响应 各种报文类型的语法，如报文中各个字段及其详细描述 字段语义及其包含的信息含义 进程何时，如何发送报文 应用层功能： 文件传输、访问和管理 电子邮件 虚拟终端 查询服务和远程作业登陆 有两种模型：客户服务器模型（C/S）、P2P模型 客户服务器模型（C/S）： 服务器：提供计算服务的设备。1. 24小时永久提供服务；2.永久性访问地址 客户机：请求计算服务的主机，1. 与服务器通信，使用服务器提供的服务；2.间歇性接入网络；3.使用动态的ip地址；4.不与其他客户机直接通信 P2P模型： 无服务器 每个主机既可以提供服务，也可以请求服务，任意节点可以直接通讯 DNS域名解析系统域名：www.baidu.com DNS: 域名 -&gt; ip地址 域名自左向右，级别由低到高，分别对应三级域名、二级域名、顶级域名 交给域名服务器解析域名，域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器、本地域名服务器（最近） 首先 在本机域名解析的缓存中查找该域名 ，若找不到 -&gt; 发给本地域名服务器，无法解决-&gt;求助根域名服务器-&gt; 查询顶级域名服务器 -&gt; 查询权限域名服务器 亚洲平均2000万人平分一个根域名服务器，北美平均300万人平分一个根域名服务器，所以北美上网速度&gt;亚洲 域名解析过程：递归查询（靠别人，请求根服务器-&gt;根服务器请求顶级域名服务器。。。较少使用）、迭代查询（靠自己，由自己来查询根域名服务器，顶级域名服务器） 万维网和http协议万维网是大规模、联机式信息储藏所，无数个网络站点、网页的集合 统一资源定位符URL可以唯一标识资源（文字、视频、音频） URL： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; http默认80端口号 协议：http、ftp 主机：域名、ip地址 端口和路径有时可以被省略掉 http协议定义了浏览器怎么向万维网服务器请求万维网文档，以及万维网怎么把文档传送给浏览器：建立tcp连接 -&gt; http请求报文-&gt; http响应报文 -&gt; 释放TCP连接 http协议的特点 http协议是无状态的，但是在实际工作中，一些万维网网站希望能识别用户（给用户推销产品）=&gt;诞生了cookie小饼干，cookie是存储在用户主机的文本文件，记录一段时间内某用户的访问记录（不太敏感的数据） http采用TCP作为运输层协议，但是http协议本身是无连接的 （交换http报文之前不需要建立连接） http连接方式：持久连接（非流水线式（有点像停等协议）、流水线式（有点像GBN或SR协议，即后退N帧协议和选择重传协议））、非持久连接（每次传输都要三次握手）","categories":[{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"}],"tags":[],"author":"Hello"},{"title":"Ajax","slug":"Ajax","date":"2020-12-29T12:31:35.297Z","updated":"2021-03-17T10:24:51.335Z","comments":true,"path":"2020/12/29/ajax/","link":"","permalink":"https://taylor12138.github.io/2020/12/29/ajax/","excerpt":"","text":"1.Ajax概述它最大的特点是可以在网页不刷新的情况下向服务端http请求，然后得到http响应 它全称为 Asynchronous JavaScript And XML，就是异步的JS和XML，通过Ajax可以在浏览器中向服务器发送异步请求，最大优势：无刷新获取数据。AJAX不是新的编程语言，而是一种将现有标准组合在一起使用的新方式 Ajax在应用当中需要一个服务端，可以选择nodejs来配合使用 XML简介XML可扩展标记语言，是被设计用来传输和存储数据的，它和html很像，它们不同的是html中都是预定义标签，而xml没有预定义标签，全是自定义标签，用来表示一些数据 最开始ajax在进行数据交换的时候，所使用的格式就是XML 但是现在ajax都是使用json了，json相对xml更为简洁，而且在数据转换这块比较容易，可以借助json的一些api方法，快速将字符串转成js对象，灵活度远胜XML Ajax特点优点： 1.可以无需刷新而与服务器端进行通信 2.允许根据用户事件来更新部分页面内容 缺点 1.没有浏览记录，不能回退 2.存在跨域问题（同源） 3.SEO不友好（搜索引擎优化）（源代码（响应体）没有部分商品信息，那些商品信息都是ajax向服务端发请求，通过服务端返结果，然后js动态创建到页面，所以爬虫也爬不到商品数据） 2.Express框架基于Node.js平台快速、开放、极简的Web开发框架，高度封装了http模块 安装：用VScode打开文件目录，然后在该目录下右键-&gt;在集成终端打开-&gt;输入命令 npm init --yes 进行初始化，创建一个package.json文件-&gt; npm i express --save 安装框架 -&gt; 在js中输入 1.http.createServer() =&gt; express() 创建服务器 2.if (url.parse(req.url, true).pathname === 路径){} =&gt; app.get(路径, fn) 判断路径进行处理 3.app.use(&#39;public&#39;, express.static(&#39;./public/&#39;)); 处理公开目录，当以/public/开头的时候，去./public/目录中查找对应的资源，如 http://127.0.0.1:5208/public/404.html，直接进行访问（常用） 第一个参数其实是别名，app.use(&#39;a&#39;, express.static(&#39;./public/&#39;)); 处理公开目录，当以/a/开头的时候，去./public/目录中查找对应的资源，如 http://127.0.0.1:5208/a/404.html，直接进行访问 如果省略第一个参数：app.use(express.static(&#39;./public/&#39;))，则可以在原始网页网址+资源名称，如 http://127.0.0.1:5208/404.html，直接进行访问 4.url.parse(req.url, true).query=&gt; req.query 原来的get获取url ? 后的参数的方法的改变（只能拿get请求的参数） 模板对象：在Express中，模板引擎的使用有更好的方式res.render(‘文件名’, {模板对象})，可以自己尝试看art-template官方文档，让它们结合使用 5.express不需要 res.end()结尾来结束响应，而且它还提供了res.send(JSON.stringify(对象)) =&gt; res.json() 自动帮你把json对象转换成字符串，然后发送给浏览器 // 引包 var express = require('express'); // 创建服务器，相当于原来的http.createServer() var app = express(); //当服务器收到get请求 '/' 的时候，执行回调函数 // 不用再设置http头部文件，并且不用设置charset=utf-8:防止中文乱码，它会根据你的语言更改language //内置处理有不认识的路径时，自动发404 app.get('/', function (req, res) { res.send('Hello, world!'); }) app.get('/about', function (req, res) { //拿出get请求参数：在Express中可以直接通过req.query来获取查询字符串参数 //http://127.0.0.1:5208/about?a=1&amp;b=2 console.log(req.query); res.send('你好！！!'); }) // 公开指定目录（处理静态资源public那块） // 之后你就可以通过public的方式访问public目录的所有资源了 // 替代了原来判断路径+读文件+end结束的过程 app.use('/notebook/', express.static('./notebook/')); // 相当于server.listen app.listen(5208, () => { console.log('app is running at port!'); }) 然后继续右键在集成终端打开-&gt;输入命令 node 该js的文件名 这里的 app.get(&#39;/&#39;,(request, response) 中的 / 是路径（当然可以写成/路径名 之类的），当客户端浏览器向服务器发送请求时，如果url的路径，也就是请求行的第二部分，它的路径对应该路径的话，就会执行这个回调函数里面的 代码，并且由response做出响应 以上步骤来简单构建一个服务端，提供ajax使用 基本路由服务器中get和post部分相当于路由表，帮你映射关系： app .get('/login', callback) .get('xxx', callback) .post('yyyy', callback) 配置art-template模板引擎在官方文档可以看得到Express配合使用的安装导航：https://aui.github.io/art-template/ npm install --save art-template npm install --save express-art-template 注意：Express有个约定，把所有视图文件都放在views目录之中，如果想要修改，则app.set(&#39;views&#39;, render函数的默认路径) 然后 app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;)) 第一个参数表示当渲染以.art结尾的文件时，使用art-template模板引擎；express-art-template专门用在Express中把art-template整合，且express-art-template依赖了art-template 而这时就可以使用模板引擎的render了 app.engine('html', require('express-art-template')); app.get('/', (req, res) => { //去找views目录下的404.html res.render('404.html'); }) 接而根据导航一步一步指引，进行操作就行了 重定向注意：服务端重定向对异步请求是无效的（表单的异步提交），异步请求的重定向只能在客户端里面实现，可以在ajax的success里使用 window.location.href = '/' 原来是 res.statusCode = 302; res.setHeader('Location', '/'); //响应头的Loacation路径设置为 '/' 即首页 res.end(); 现在： res.redirect('/'); Express获取表单POST请求体数据当以post请求/post的时候，执行指定函数，获取数据的表单form添加 action=路径, method=&quot;POST&quot; 这样的话我们就可以利用不同的方法，让一个请求路径使用多次 app.post('/post', (req, res) => { // 1.获取表单post数据 // 2.处理 // 3.发送响应 }); 因为express内置没有获取表单post的api，所以需要借助第三方插件，在官网-&gt;资源-&gt;body-parser 注意：express4不再支持body-parser 如果仍想使用，可以npm install express@3 安装 npm install --save body-parser 然后跟着官网指示一步一步进行配置 配置body-parser，则会在request请求对象上多出一个body属性，然后此时我们可以使用req.body获取表单post请求体数据了 //引包 var bodyParser = require('body-parser'); //配置post插件body-parser // parse application/x-www-form-urlencoded app.use(bodyParser.urlencoded({ extended: false })); // parse application/json app.use(bodyParser.json()); app.post('/post', (req, res) => { // 1.获取表单post数据 // 2.处理 // 3.发送响应 console.log(req.body); //get使用的是req.query }); 定制404页面在挂载路由app.use(router);之后增加 app.use(function(req, res) =&gt; {})处理404页面，所有未处理的请求路径都会跑到这里 crude案例先初始化 npm init -y 装express：npm i -S express 建2个文件夹，分别为views和public 装模板引擎：npm install --save art-template express-art-template 装bootstrap的css：npm i -S bootstrap 外部备上一个index.html、db.json(用于存储数据) 将app.js作为执行的js文件，而router.js作为辅佐的路由js文件，并将其引入app.js，student.js作为增删改查封装的api 请求方法 请求路径 get参数 post参数 备注 get /students 渲染页面 get /students/new 渲染添加学生 post /students/new name、age、color、hobbies 处理添加学生请求 get /students/edit id 渲染编辑页面 post /students/edit id、name、age、color、hobbies 处理编辑请求 get /students/delete id 处理删除请求 //app.js var express = require('express'); var router = require('./router.js'); var bodyParser = require('body-parser'); var app = express(); // 一定要在挂载路由之前配置好模板引擎和bodyParser app.engine('html', require('express-art-template')); app.use(bodyParser.urlencoded({ extended: false })); app.use(bodyParser.json()); app.use('/node_modules/', express.static('./node_modules/')); app.use('/public/', express.static('./public/')); //挂载路由 app.use(router); //这里可以设置一个定制404页面，所有未处理的请求路径都会跑到这里 //app.use(function(req, res) => {}) app.listen(5208, () => { console.log('5208 is running!!...'); }) //处理路由的router.js文件 var fs = require('fs'); var express = require('express'); var Student = require('./student.js'); //这样也不太方便 // module.exports = function (app) { // app.get('/students', (req, res) => { // }); // } //express提供了一种更好的方式，专门用来包装路由 // 1.创建一个路由容器 // 2.把路由都挂载到router容器中 var router = express.Router(); router.get('/students', (req, res) => { Student.find((err, data) => { if (err) { return res.status(500).send('Service err 500'); } // 进行数据渲染 res.render('index.html', { fruits: [ '苹果', '雪梨', '西瓜' ], students: data }); }) }); router.get('/students/new', (req, res) => { res.render('new.html'); }); router.post('/students/new', (req, res) => { // 1.获取表单数据 // 2.处理,将数据保存与db.json中，用于持久化,即将db.json读取处理啊，转对象，往对象中push数据，再转回字符串，再把字符串写入文件 // 3.发送响应 var student = req.body; Student.save(student, (err) => { if (err) { return res.status(500).send('Service err 500'); } res.redirect('/students'); }) }); router.get('/students/edit', (req, res) => { // 1.在客户端处理链接问题，使用&lt;a href=\"/students/edit?id={{ $value.id }}\"> // 2.获取编辑的学生id // 3.渲染编辑页面 Student.findById(parseInt(req.query.id), (err, student) => { if (err) { return res.status(500).send('Service err 500'); } res.render('eidt.html', { student: student }) }) }); router.post('/students/edit', (req, res) => { Student.updateById(req.body, function (err) { if (err) { return res.status(500).send('Service err 500'); } res.redirect('/students'); }) }); router.get('/students/delete', (req, res) => { // 获取删除的id // 根据id，进行删除，然后发送响应 Student.remove(req.query.id, function (err) { if (err) { return res.status(500).send('Service err 500'); } res.redirect('/students'); }) }); // 3.导出 module.exports = router; // student.js用于纯粹对文件封装增删改查功能 // 只处理数据，不关心业务 // node的奥义所在：封装异步api var fs = require('fs'); var dbPath = './db.json'; //1.获取学生列表 // callback的第一个参数是err，第二个参数是结果 exports.find = function (callback) { //readFile 的第二个参数是可选的，传入utf8则按照utf-8编码转成正常字符 fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 callback(null, JSON.parse(data).students); }) }; // 根据id获取学生对象 exports.findById = function (id, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 var students = JSON.parse(data).students; student = students.find((item, index) => { return item.id === parseInt(id); }); callback(null, student); }) } //2.保存学生 exports.save = function (student, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 var students = JSON.parse(data).students; // 处理id唯一性问题 student.id = students[students.length - 1].id + 1; students.push(student); // JavaScript 值(对象或数组)转换为 JSON 字符串 var ret = JSON.stringify({ students: students }); ReRead(dbPath, ret, err, callback); }) }; //3.更新学生 exports.updateById = function (student, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 先把number类型的三个值从string转number student.id = parseInt(student.id); student.age = parseInt(student.age); student.color = parseInt(student.color); // 字符串转对象 var students = JSON.parse(data).students; // 使用ES6的find方法找到id对应的对象 var stu = students.find((item) => item.id === student.id); // 遍历拷贝对象 for (let key in student) { stu[key] = student[key]; } // JavaScript 值(对象或数组)转换为 JSON 字符串 var ret = JSON.stringify({ students: students }); ReRead(dbPath, ret, err, callback); }) }; //4.删除学生 exports.remove = function (id, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 var students = JSON.parse(data).students; // 获取要删除的id对象的下标 var deleteId = students.findIndex((item) => item.id === parseInt(id)); // 删除该id的对象 students.splice(deleteId, 1); var ret = JSON.stringify({ students: students }); ReRead(dbPath, ret, err, callback); }) }; // 重新读入的api function ReRead(dbPath, ret, err, callback) { fs.writeFile(dbPath, ret, (err) => { if (err) { return callback(err); } // 成功为null callback(null); }); } cookie和Session在express中，默认不支持Session和Cookie session是基于cookie实现的 但是我们可以使用大三方中间件：express-session来解决 npm install express-session 配置： var session = require('express-session'); app.use(session({ //配置加密字符串 secret: 'keyboard cat', resave: false, //无论你是否适用session,我都给你分配一把钥匙 saveUninitialized: true })); 添加session数据：req.session.foo = &#39;xxx&#39; 访问session数据：req.session.foo 这时候，服务器只需要调用req.session.xx就可以使用session保存的数据了 中间件使用express框架、一些其他的API之后，传进来的req和res经过了一些中间件（函数方法），使得req和res内部拥有了一些属性，可以直接使用req.body、req.query、req.session 等，并且在挂载路由后，在路由的js文件中，不用再次引用（require）这些api方法，同样可以使用req.body、req.query、req.session 等属性（其实也可以理解为，req、res等参数传进来路由器js文件时，已经被赋予以上属性，页面不用关心参数从中间件得到的属性，而是要关心是否需要引包才能使用方法） 中间件本身就是一个方法，它有三个参数：request、response、next（使用下一个中间件） 如果一个请求进入中间件，不调用next则会停留在当前中间件，调用了next后继续向后找到第一个匹配的中间件（平常我们看到很多组件其实已经吧next封装好了） 在express中，对中间件有几种分类： （1）不关心请求路径和请求方法的中间件，也就是任何请求都会进入这个中间件 app.use(function(req, res, next)) （2）关心请求路径的中间件，以’/xxx’开头，需要匹配才会进入此中间件，如果不匹配自动跳过，去下一个中间件 app.use(&#39;/xx&#39;, function(req, res, next)) （3）严格匹配请求方法和请求路径的中间件 app.get() app.post() //127.0.0.1:5208/b app.use(function (req, res, next) { console.log(1); next(); }); app.use('/a', function (req, res, next) { console.log('a'); }); app.use('/b', function (req, res, next) { console.log('b'); }); app.use(function (req, res, next) { console.log(3); }); //输出: 1 b 利用next处理发生错误： //上方错误的代码： //当调用next的时候，如果传递了参数，则直接往后找到带有四个参数的应用程序级别中间件 //if (err) { // next(err) // } //中间件要放到最后，搭配404处理一起使用 app.use(function (req, res, next) { res.render('404.html') }); app.use(function (err, req, res, next) { res.status(500).send(err.message) }); 3.原生ajax的get/post请求先在script绑定事件对象 1.创建对象（控制平台中network也有XHR，它是对ajax请求做一个筛选） XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 ajax 编程中被大量使用。 2.初始化，设置请求方法（请求类型）和url xhr.open(请求类型, url)，请求类型为get或post 3.发送 xhr.send() 4.事件绑定，处理服务端返回的结果 onreadystatechange on 有 when的意思，即当。。。的时候readystate是xhr对象当中的属性，表示状态0/1/2/3/4，分别对应以上步骤完成与否的状态 0：未初始化 1：open方法已经调用完毕 2：send方法已经调用完毕 3：表示服务端返回了部分的结果 4：服务端返回了所有的结果change 改变的时候触发，这里一般会触发四次，改一次触发一次 5.此时xhr对象的属性有： status状态码（200等） statusText 状态字符串（OK等） getAllResponseHeaders() 所有响应头 response 响应体 ajax的get请求案例const btn = document.querySelector('button'); const result = document.querySelector('#result'); btn.addEventListener('click', function () { //1.创建对象，控制平台中network也有XHR，它是对ajax请求做一个筛选 const xhr = new XMLHttpRequest(); //2.初始化，设置请求方法（请求类型）和url xhr.open('GET', 'http://127.0.0.1:8000/server'); //3.发送 xhr.send(); //4.事件绑定，处理服务端返回的结果 xhr.onreadystatechange = function () { //判断,服务端返回了所有的结果 if (xhr.readyState === 4) { //判断响应状态码 if (xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) { //处理结果 行、头、空行和体 //1.响应行里的数据 console.log(xhr.status); //状态码 console.log(xhr.statusText); //状态字符串 console.log(xhr.getAllResponseHeaders()); //所有响应头 console.log(xhr.response); //响应体 //2.设置result文本 result.innerHTML = xhr.response; } } } }) &lt;/script> ajax的post请求注意post和get的不同点在于： 1.初始化xhr.open(&#39;POST&#39;, url) 2.get是在初始化时，xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/server?a=100&amp;b=200&#39;);进行参数传递的 而post是在发送时send(a=100&amp;b=200);进行参数传递的 4.ajax其他ajax请求头设置设置请求头，并且必须在open之后，send之前 xhr.setRequestHeader(头的名字, 头的值); xhr.open('POST', 'http://127.0.0.1:8000/server'); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send('a=100&amp;b=200&amp;c=300'); Content-Type是来设置请求体内容类型 与此同时还可以自定义属性，xhr.setRequestHeader(&#39;name&#39;, &#39;Allen&#39;); 但会报错，除非后端人员在服务器： 1.先把服务器对当前页面的post请求改成all，这样可以接受任意类型的请求 app.post(url, callback) =&gt; app.all(url, callback) 2.请求里设置 res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;); 响应json数据保存在json文件的是json字符串 JSON.stringify(对象) JavaScript 值(对象或数组)转换为 JSON 字符串 JSON.parse(data) 字符转对象 或者直接在xhr.open之前设置： xhr.responseType = &#39;json&#39;，这样通过xhr.response得到的响应体数据都是以对象形式，不需要再进行JSON.parse(xhr.response) IE缓存问题ie浏览器它会对ajax的请求结果做一个缓存，这样导致下次再次发送请求时，用的是本地之前的缓存进行响应，而不是最新数据，这样导致时效性比较强的使用场景，ajax这个缓存会影响最终的结果正确的呈现 ajax关于ie缓存问题解决方法：xhr.open(&#39;POST&#39;, &#39;http://127.0.0.1:8000/server/ie?t=&#39;+Date.now()); ajax请求超时问题与网络异常我们永远不能保证服务端快速、及时的响应 这时我们对超时、异常情况给用户进行提醒（超时后自动取消请求） //超时 2s 设置 xhr.timeout = 2000; //超时回调函数 xhr.ontimeout = function () { alert(\"网络异常，请稍后重试\"); } // 网络异常回调设置 xhr.onerror = function () { alert(\"您的网络似乎出了一点问题。。。\"); } ajax取消请求上方是超时自动取消请求 这里演示的是手动取消请求 let xhr = null; btn[0].addEventListener('click', function () { xhr = new XMLHttpRequest(); xhr.open('GET', 'http://127.0.0.1:8000/server/time'); xhr.send(); }); //取消按钮 btn[1].addEventListener('click', function () { xhr.abort(); }) 请求重复发送问题过于频繁地发送请求会导致服务器压力过大 这里可以设置，再次发送请求时，把上一个请求取消掉（这里地重复发送问题让我想起了节流阀） let isSending = false; btn[0].addEventListener('click', function () { // 判断标识变量,如果正是在发送，则取消该请求，创建新的请求 if (isSending) xhr.abort(); xhr = new XMLHttpRequest(); isSending = true; xhr.open('GET', 'http://127.0.0.1:8000/server/time'); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { // 在这里不加状态码判断，因为这可能是一个失败的请求，如果加判断的话，可能导致isSending永远不为false isSending = false; } } }); 表单的同/异步提交使用jQuery实现ajax的注册小案例 （异步提交，即使用submit事件来提交数据，同步提交是直接form表单上增加属性值： action=路径, method=&quot;POST&quot;） 表单具有默认的提交行为，默认是同步的，同步表单提交缺点： 1.浏览器会锁死（转圈儿）等待服务端的响应结果。 2.表单的同步提交之后，无论服务端响应的是什么，都会直接把响应的结果（res.send()）覆盖掉当前页面。（上面crude案例没有覆盖是因为，每次post请求后都直接重定向了） 3.用户提交表单之后，页面重新渲染显示仅仅有“密码/邮箱已存在，请稍后重试”的另外一个页面，重新更改需要后退网页进行再次表单修改、提交，所以体验很不好，所以后面采用了直接res.render(当前页面, {数据渲染})+提示的方法 优点：由服务端处理，更加安全一点 异步提交: 减少服务器压力，让客户端处理更多交互效果 //&lt;form id=\"login_form\"> &lt;button type=\"submit\">登录&lt;/button> &lt;/form> $('#register_form').on('submit', function (e) { e.preventDefault() var formData = $(this).serialize() $.ajax({ url: '/register', type: 'post', data: formData, dataType: 'json', success: function (data) { var err_code = data.err_code if (err_code === 0) { // window.alert('注册成功！') // 服务端重定向针对异步请求无效 window.location.href = '/' } else if (err_code === 1) { window.alert('邮箱已存在！') } else if (err_code === 2) { window.alert('昵称已存在！') } else if (err_code === 500) { window.alert('服务器忙，请稍后重试！') } } }) }) 5.AJAX的使用工具jQuery中的AJAX要去github下载包，或者用script加载工具的网址 又或者在BootCDN网站上找到工具包网址，用script加载使用（相对于github网址更快速） get和post $.get(url, 参数, callback, type) $.post(url, 参数, callback, type) 回调函数里接收的data为响应，即服务器里send的数据 type：如响应体类型’json’则将json字符串转化为对象 &lt;button>get&lt;/button> &lt;button>post&lt;/button> &lt;script> $('button').eq(0).click(function () { $.get('http://127.0.0.1:8000/server/jquery', { a: 100, b: 200 }, function (data) { console.log(data); }, 'json'); }); $('button').eq(1).click(function () { $.post('http://127.0.0.1:8000/server/jquery', { a: 100, b: 200 }, function (data) { console.log(data); }); }) 另外一种方式，可定义的属性操作比较灵活、结构清晰，但是相对以上两种方式代码以较复杂 $('button').eq(2).click(function () { $.ajax({ url: 'http://127.0.0.1:8000/server/jquery', data: { a: 100, b: 200 }, type: 'GET', //把接收到的数据转成对象 dataType: 'json', // 成功的回调 success: function (data) { console.log(data); }, timeout: 2000, // 失败的回调 err: function () { console.log('出错啦！'); }, //头信息 // headers: { // c: 300, // d: 400 // } }) }) Axios目前（2020）年最热门的ajax工具库，要去github下载包，或者用script加载工具的网址 又或者在BootCDN网站上找到工具包网址，用script加载使用（相对于github网址更快速） 项目中使用axios居多、支持Promise（当成Promise对象来看待） axios常见配置 url：请求地址 method：请求方法 baseURL：请求根路径 transformRequest:[function(data){}]：请求前数据处理 transformResponse:[function(data){}]：请求后数据处理 headers:{‘x-Requested-With’:’XMLRequest’}：自定义请求头 params：URL查询对象（一般用于get请求） axios的通用方式和jQuery的方式都很像 btn[2].addEventListener('click', function () { axios({ method: 'POST', url: 'http://127.0.0.1:8000/axios', params: { id: 100, level: 500 }, headers: { a: 100, b: 200 }, // 请求体参数 data: { username: 'allen', password: 123456 } }).then(res => { //处理返回结果 console.log(res); }) }) get&amp;postget方法：axios.get(url[, config]) 如果不想把对应参数直接拼接到 url 的后面，则可以把对应参数放到params btn[0].addEventListener('click', function () { axios.get('http://127.0.0.1:8000/axios', { // url参数 params: { ID: 12345 }, }).then(value => { //这里没有使用回调函数，因为axios支持Promise，所以使用痛恨处理回调 //value是一个对象，里面包含了响应的各类信息 console.log(value); }); }); post方法：axios.post(url[, data[, config]]) 一般可以把对应参数放到data（即request.body） btn[1].addEventListener('click', function () { axios.post('http://127.0.0.1:8000/axios', { // post第二个参数可以设置请求体 username: 'allen', password: 'allen' }, { //设置其他参数，如headers等 }) }); axios.all我们在Promise中学习过处理相互依赖的并发网络请求解决方法（多个并发网络请求的响应全部到达后才去做相应处理） 但是axios本身支持支持Promise语法，所以可以直接使用 axios.all([axios(), axios().....]).then(result =&gt; {}) axios.all([ axios({url: ''}), axios({url: ''}) ]).then(results => { // results是一个数组，它包含以上异步操作的结果 console.log(results[0], results[1]); }) 全局配置事实上，在开发中很多参数都是固定的 这时候我们可以进行一些抽取，也可以利用axios全局配置 axios.defaults.配置 axios.defaults.baseURL = 'http://123.207.32.32:8000'; axios.defaults.timeout = 5000; 之后不用再次在axios中设置了（除非你想更改），已经有了默认值 axios实例和模块封装有时我们需要从不同的服务器发送请求，则需要对应不同的ip地址，这时设置全局配置不太合适 所以一般都是创建对应axios实例进行配置 // 创建实例 const instance = axios.create({ // 在里面进行实例的基本配置 baseURL: 'http://123.207.32.32:8000', timeout: 5000 }); instance({ url:'/home/multidata' }).then(res => { console.log(res); }) 而且在开发过程中，不推荐组件内直接引用第三方的 axios 进行依赖，如果有一天axios不再进行维护，改动时会十分麻烦 所以我们可以对其进行模块封装： 在src文件夹下，新建一个network文件夹，然后再该文件夹下新建一个 request.js 文件 在里面撰写基于 axios 发送网络请求、不同实例的代码 //request.js import axios from 'axios' export function request(config) { // 1.创建axios实例 const instance = axios.create({ baseURL: 'http://123.207.32.32:8000', timeout: 5000, }) return instance(config); } //main.js // 使用封装request模块 import { request } from './network/request' request({ url: '/home/multidata' }).then(res => { console.log(res); }).catch(err => { console.log(err); }) axios拦截器axios提供了拦截器，用于我们在每次发送请求或者得到响应后，进行相应的处理 拦截请求：axios.interceptors.request.use(成功的回调, 失败的回调) 拦截响应：axios.interceptors.response.use(成功的回调, 失败的回调) 下面以instance为实例，进行演示 request拦截下来的config参数其实就是我们的网络请求的配置（但没有拦截下数据） response拦截下来的结果（包含数据） request拦截下来进行处理 比如：config一些信息不符合服务器要求，添加headers之类的 比如：每次发送网络请求，都希望在界面中显示一个请求的图标 比如：某些网络请求（登录（token）），必须携带一些特殊的信息 instance.interceptors.request.use(config => { console.log(config); // 拦截完后必须把配置给人还回去，不然网络请求会发送失败 return config; }, err => { console.log(err); }); instance.interceptors.response.use(res => { console.log(res); // 拦截完后必须把配置给人还回去，不然网络请求无返回结果（undefined） //一般返回data就可以了(这个才比较有用) return res.data; }, err => { console.log(err); }) 利用fetch发送ajax请求fetch属于全局对象，可以直接去调用，不同下载什么包，返回的结果是一个promise对象 const fetchResponsePromise = fetch(resource [, init]) resource：url，或者一个request对象 init：可选的配置项 btn[0].addEventListener('click', function () { fetch('http://127.0.0.1:8000/fetch', { //请求方法 method: 'POST', // 请求头 headers: { name: 'Allen' }, //请求体,经MDN文档上介绍，这里可以以多种形式来撰写 body: 'username=allen&amp;age=18' }).then(res => { //返回的结果是一个promise对象,所以使用then回调方式接收和处理结果 console.log(res); }) }) 6.跨域同源策略同源，即（当前网页的url和ajax请求的目标资源的url之间）协议、域名、端口号必须完全相同，而ajax是默认遵从同源策略， 而违背同源策略就是跨域，假如当前网页时a.com，而你向b.com发送了请求，则此时是跨域请求 单台服务器的性能是有上限的，需要外加更多的计算机、服务器提升服务水平 满足同源的情况： btn.onclick = function () { const xhr = new XMLHttpRequest(); // 这里满足url同源策略，所以在以 //http://127.0.0.1:9000/home打开网站时,可以简写为/data xhr.open('GET', '/data'); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status >= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); } } } }; const express = require('express'); const app = express(); app.get('/home', (req, res) => { res.sendFile(__dirname + '/kuayu.html'); }); app.get('/data', (req, res) => { res.send('用户数据'); }) app.listen(9000, () => { console.log(\"服务已启动，9000端口监听中...\"); }) JSONP是一个非官方解决跨域的问题，只支持get请求。 在网页有一些标签天生具备跨域能力，比如img，link，script 而JSONP是利用script标签的跨域能力来发送请求 JSONP实现跨域原理优点：兼容性非常好 缺点：是只支持get请求，不支持post请求。 &lt;script src=\"http://127.0.0.1:9000/jsonp\">&lt;/script> app.get('/jsonp', (req, res) => { res.send('console.log(\"hello world\")'); }) JSONP跨域实例动态创建script标签，添加src值为请求的域名地址，再动态添加至body内部 const input = document.querySelector('input'); const p = document.querySelector('p'); // 声明handle函数 function handle(data) { input.style.border = \"solid 1px #f00\"; p.innerHTML = data.msg; }; input.addEventListener('blur', function () { let username = this.value; //1. 创建script标签 const script = document.createElement('script'); //2. 设置script的src属性 script.src = 'http://127.0.0.1:9000/jsonp'; //3.将script插入文档中(添加节点) document.body.appendChild(script); }) //服务器部分 //jsonp app.get('/jsonp', (req, res) => { const data = { exist: 1, msg: '用户名已经存在' }; // 转字符串再调用handle函数 res.send(`handle(${JSON.stringify(data)})`); }) jQuery实现跨域功能$(*selector*).getJSON(*url,data,success(data,status,xhr))* getJSON() 方法使用 AJAX 的 HTTP GET 请求获取 JSON 数据。而跨域的实现是通过在url后增加&#39;?callback=?&#39;，并且在服务器上调用接收jQuerycallback参数的函数 $('button').eq(0).click(function () { // 在jQuery里发送JSONP请求,这里第一个参数后一定要加'?callback=?' $.getJSON('http:127.0.0.1:9000/jQuery-jsonp?callback=?', function (data) { console.log(data); $('#result').html(` 名称: ${data.name},&lt;/br> 城市: ${data.city[1]} `) }); }) //服务器部分 app.get('/jQuery-jsonp', (req, res) => { const data = { name: 'Allen', city: ['北京', '澳门', '广州'] }; // 接收jQuerycallback那个参数 let cb = req.query.callback; // 转字符串再调用handle函数 //cb实际上是jQuery+一串数字，但他保存的其实是调用jQuerygetJSON里的回调函数 res.send(`${cb}(${JSON.stringify(data)})`); }) CORS解决跨域问题CORS，跨域资源共享，它是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊操作，完全在服务器中进行处理，支持get、post请求，跨域资源共享标准新增了一组http首部字段，允许服务器声明哪些源站通过浏览器权限访问哪些资源 工作原理：设置一个响应头（使用自定义的HTTP头部）告诉浏览器，该请求允许跨域，然后浏览器收到该响应以后对响应放行 setHeader(&quot;允许跨域响应头&quot;, &quot;*&quot;); 设置允许跨域的响应头,有Access-Control-Allow-Origin、Access-Control-Expose-Headers、Access-Control-Max-Age、Access-Control-Allow-Credentials、Access-Control-Allow-Methods、Access-Control-Allow-Headers 第二个参数*是通用的意思，也可以设置专用的url //服务器部分 app.all('/CORS', (req, res) => { // 设置允许跨域的响应头 res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); res.setHeader(\"Access-Control-Allow-Headers\", \"*\"); //这里表示的是只有地址为http://127.0.0.1:5500这样的网页，才能向我们这个服务发送请求 // res.setHeader(\"Access-Control-Allow-Origin\", \"http://127.0.0.1:5500\"); res.send('hello world'); }) 如果设置请求头不行的话可以安装 CORS （1）安装cors： npm install cors express –save （2） 然后在文件中引用： var cors = require('cors'); var express = require('express'); var server = express(); server.use(cors()); postMessage这是由H5提出来的的API，IE8以上支持这个功能。window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，都遵循同源策略才能够实现通信。 window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全 nginx代理跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路： 通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript进阶ES6","slug":"JavaScript进阶ES6","date":"2020-12-27T02:02:23.693Z","updated":"2021-03-26T09:20:34.985Z","comments":true,"path":"2020/12/27/javascript-jin-jie-es6/","link":"","permalink":"https://taylor12138.github.io/2020/12/27/javascript-jin-jie-es6/","excerpt":"","text":"1.ESMAScript6ES6其实是一个泛指，泛指ES2015后续的版本 2.新增语法声明变量ES5之前因为if、for都没有块级作用域的概念，所以很多时候都需要借助 function的作用域 解决应用外部变量的问题 let 声明的变量 1.只在所处块级有效（大括号中有效，也就是说if和for都有它的块级作用域了），可以防止循环变量变成全局变量 2.不存在变量提升，只能先声明再使用 3.暂时性死区（即在块级作用域中使用某变量，则会先在该块级中查找次变量） var num = 10; if(true) { console.log(num); //报错，变量声明在后面 let num = 20; } 利用let解决异步问题：（因为let仅在当前块级有效） for (let i = 0; i &lt; lis.length; i++) { lis[i].onclick = function () { console.log(i); } } const声明常量，常量就是值（内存地址）不能变化的量（值可以改，内存地址不能变） 1.具有块级作用域 2.const声明常量时必须赋值 3.基本数据类型：常量赋值后，不可修改；复杂数据类型：对象赋值后（数组之类的）不可更改，但是可以更改数据结构内部的值 4.不存在变量提升，只能先声明再使用 const ary = [100, 200]; ary[0] = 'a'; //可以 //ary = ['a', 200]; //不可以 解构赋值ES6允许从数组或者对象（分别使用[]、{}）中一一提取值，按照对应的位置，对变量赋值 //数组 let ary = [1, 2, 3]; let [a, b, c, d, e] = ary; //1, 2, 3, undefined, undefined //也可以 let [a, b, c] = [1, 2, 3]; //对象 let person = {name: 'zhangsan', age: 20}; let{name, age} = person; //如果是对象的话 let{age, name} = person; 也能得到正确的赋值 对象的另一解构写法 let {name: myName, age: myAge} = person; 如果name和age分别和person中的属性值匹配成功，则将右侧该属性值赋值给左边myName，myAge变量 箭头函数(形参) =&gt; {函数体} 箭头函数用来简化定义函数语法 const fn = () => { console.log('xx'); } // 也可以，返回undefined //const fn = () => console.log('xx'); 如果函数体只有一句话，且代码执行结果就是返回值，则可以省略大括号 //传统 function sum(num1, num2) { return num1+num2; } //new const sum1 = (num1, num2) => num1+num2; 如果形参只有一个，小括号可以省略 //传统 function sum(a) { return a; } //new const sum1 = a => a; 箭头函数和传统函数不一样，箭头函数的this指向函数定义位置（使用了箭头函数的那个函数）的上下文this（定义函数地点最近作用域中的this），所以 1. 箭头函数不适合事件回调 function fn() { console.log(this); return () => { console.log(this); } } const obj = { name: 'zhangsan' }; const resFn = fn.call(obj); //这时this指向obj，所以箭头函数跟着指向obj resFn(); //返回{ name: 'zhangsan' } { name: 'zhangsan' } 对象不能产生作用域，所以箭头函数实际被定义在全局作用域下，所以此处的this指向window，所以箭头函数处的this.age未定义 2.不适合对象的方法 var obj = { age: 20, say: () => { alert(this.age); //undefined }, con: function () { console.log(this); //obj } } obj.say(); obj.con(); const obj = { aaa() { setTimeout(function () { setTimeout(function () { console.log(1, this); //window }) setTimeout(() => { console.log(2, this); //window }) console.log(3, this); //window }) setTimeout(() => { setTimeout(function () { console.log(4, this); //window }) setTimeout(() => { console.log(5, this); //obj }); console.log(6, this); //obj }); } } arguments的使用当我们不确定函数用多少个参数来传递的时候，arguments实际上是当前函数的一个内置对象（函数才拥有），arguments储存了传递的所有实参,它展示的方式是伪数组，因此可以进行遍历（使用for等） 注意：箭头函数是用不了arguments function fn(){ console.log(agruments); console.log(agruments.length); } fn(1,2,3); //则输出1，2，3 伪数组：1.具有length属性 2.按索引凡是储存数据 3.不具有push，pop功能 剩余参数剩余参数语法允许我们将一个不定数量的参数表示为一个数组 ...args 潜规则： ...args要放到参数的最后，不然会报错 //1.作为传参（rest参数） function sum(first, ...args) { console.log(first); //10 console.log(args); //20, 30 } sum(10, 20, 30); //2.剩余参数配合解构 let students = ['allen', 'berry', 'david']; let [s1, ...s2] = students; //s1为allen，s2为[berry. david]的数组 //3.作为参数传入，将数组arr2里的数据划分成若干个，然后一个一个传入数组arr1：（扩展运算符） arr1.push(...arr2); 和arguments不一样的是，arguments得到的是一个对象，而…args中 args得到的是一个数组，可以使用数组方法（filter、some、map、every等） function data1(){ console.log(arguments); } function data2(...args){ console.log(args); } 参数默认值可以给函数附上默认的参数值，在调用时没有给到的形参会用默认值代替 一般具有默认值的参数都靠后（潜规则） function add(a, b ,c=10){ return a + b + c; } console.log(add(1, 2)); //13 3.ES6内置对象的扩展array的扩展 ...ary 扩展运算符是和剩余参数相反的原理，它可以将数组或者对象转为用逗号分隔的参数序列 ...ary let ary = [1, 2, 3]; console.log(...ary); // 1, 2, 3 //相当于 console.log('1', '2', '3'); 扩展运算符应用：数组合并 //方法一： let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; //方法二 ary1.push(...ary2); ...ary扩展运算符还能把伪数组转换成真正的数组，然后可以使用数组的方法 Array.from() 同样的，构造函数方法Array.from() 也可以将类数组或可遍历对象转换成真正的数组（如果是对象必须要有length属性） （浅拷贝的数组实例） let arraylike = { 0: 'a', 1; 'b', length: 2 }; let arr2 = Array.from(arraylike); //[a, b] 但是Array.from还可以接收一个函数，用来对每个元素进行处理，将处理后的值放入返回的数组 Array.from(数组, 形参item =&gt; {函数体}) let arraylike = { 0: 1, 1; 2, length: 2 }; let arr2 = Array.from(arraylike, item => item * 2); //[2, 4] find() 用于找出第一个符合条件的数组成员，如果没有找到返回undefined let ary = [{ id: 1, name: 'A' },{ id: 2, name: 'B' }]; let arr2 = ary.find((item, index) => item.id == 2); findIndex() 用于找出第一个符合条件数组成为的位置，如果没有返回-1 如let index = ary.findIndex((value, index) =&gt; value &gt; 9); includes() 表示某个数组是否包含给定的值，返回布尔值（之前是使用indexof进行判断，但是表达比较晦涩，这个是新增的） string的拓展ES6新增的创建字符串的方式，使用反引号定义 let name = allen;(模板字符串) 模板字符串的特点： 1.可以解析变量，不用字符串拼接${变量名} 2.可以换行，撰写较为美观 3.可以调用函数，得到的结果为函数返回值${函数名()} const saySomething = () => '我是函数'; let a = `allen`; let = `hello, my name is ${name}`; let html = `&lt;div> &lt;span>${saySomething()}&lt;/span> &lt;/div>`; startsWith() 表示参数字符串是否以原字符串开头，返回布尔值 endsWith()表示参数字符串是否以原字符串结尾，返回布尔值 let str = 'hello world !'; str.startsWith('hello'); //true str.startsWith('!'); //true repeat() repeat方法表示将原字符串重复n次，返回一个新字符串 ，如&#39;x&#39;.repeat(3) 返回 xxx set数据结构ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值（不会存储重复的值）、自动去重 集合实现了 iterator接口，所以可以使用 for of Set本身是一个构造函数，用来生成Set数据结构 const s = new Set([\"a\", \"a\",\"b\"]); console.log(s.size); const ary = [...s]; //数组去重 s.add(value) 添加某个值，返回Set结构本身 s.delete(value) 删除某个值，返回布尔值表示删除成功与否 s.has(value) 返回布尔值，查看是否为Set成员 s.clear() 清空所有成员 s.values()查看所有元素 Set结构实例与数组一样，也有forEach方法，用于对每个成员执行某种操作，没有返回值 map数据结构 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key） （Object的键为字符串）。 使用对象作为键是 Map 最值得注意和重要的功能之一 let map = new Map(); let john = { name: \"John\" }; map.set('1', 'str1'); // 字符串键 map.set(1, 'num1'); // 数字键 map.set(true, 'bool1'); // 布尔值键 map.set(john, 123)); // 对象键 // 还记得普通的 Object 吗? 它会将键转化为字符串 // Map 则会保留键的类型，所以下面这两个结果不同： alert( map.get(1) ); // 'num1' alert( map.get('1') ); // 'str1' alert( map.size ); // 3 方法 + 属性 new Map() —— 创建 map。 map.set(key, value) —— 根据键存储值。 map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。 map.has(key) —— 如果 key 存在则返回 true，否则返回 false。 map.delete(key) —— 删除指定键的值。 map.clear() —— 清空 map。 map.size —— 返回当前元素个数。 map.keys() —— 遍历并返回所有的键（returns an iterable for keys）， map.values() —— 遍历并返回所有的值（returns an iterable for values） map.entries()—— 遍历并返回所有的键值对 弱引用类型（很多属性、迭代方法不能用 + 保存的元素有限制） let s = new WeakSet()保存的元素必须得是引用类型（对象 / 数组）（DOM元素也是对象，所以也能存储） let map = new WeakMap()的key 必须得是引用类型（对象 / 数组）（DOM元素也是对象，所以也能存储） 正常引用类型的垃圾回收： 谁引用这个数据，就引用次数 + 1， 原来引用这组数据，后面赋值为null，引用次数 -1 当这组数据引用次数为0，则根据垃圾回收机制会被回收掉 弱引用类型的垃圾回收： 当weak弱引用数据时，引用次数不会 + 1 这样的话优点就是，清除变量的时候，不用再去weak弱引用类型那里进行清除（不用赋值null） obj的拓展利用对象字面量创建对象即直接用{}创建对象而不是new出来，而ES6新增对象字面量的增强写法 const name = 'Allen'; const age = 18; const height = 1.88; // ES5对象字面量各类属性、函数写法 obj = { name: name, age: age, height: height, run: function () { } }; // ES6对象字面量各类属性、函数写法 obj2 = { name, age, height, run() { } //此写法仅支持在字面量中 }; 判断一个对象是否为空，可以使用 Object.key(对象名称).length === 0js 判断对象的属性是否存在 in运算符 （属性名 in 对象） 情况1:对象自身属性 var obj={a:1}; \"a\" in obj//true 情况2:对象继承的属性 var objA = {a:1}; var objB = Object.create(A) \"a\" in objB //true 查找符合条件的第一个对象 find(function(currentValue, index, arr),thisValue) 参数 描述 currentValue 必需。当前元素 index 可选。当前元素的索引值 arr 可选。当前元素所属的数组对象 thisValue 可选。 传递给函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值 //实现一步查找符合条件的product let product = state.cartList.find(item => item.id === payload.id); 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined。 4.Promisecallback hell回调地狱：callback hell，异步里面套着另一个异步 无法保证异步任务执行顺序： var fs = require('fs'); fs.readFile('./index.txt', function (err, data) { if (err) { // throw的作用：抛出异常 //即1.阻止程序的执行， 2.把错误信息打印到控制台 throw err; } console.log(data); }); fs.readFile('./index2.txt', function (err, data) { if (err) throw err; console.log(data); }); fs.readFile('./index3.txt', function (err, data) { if (err) throw err; console.log(data); }); 通过回调嵌套的方式来保证顺序，但由此催生了回调地狱，语法十分丑陋，代码丑陋 fs.readFile('./index.txt', function (err, data) { if (err) { // throw的作用：抛出异常 //即1.阻止程序的执行， 2.把错误信息打印到控制台 throw err; } console.log(data); fs.readFile('./index2.txt', function (err, data) { if (err) throw err; console.log(data); fs.readFile('./index3.txt', function (err, data) { if (err) throw err; console.log(data); }); }); }); Promise为了避免回调地狱嵌套，所以ES6中新增了API：Promise（生产微任务） 应用场景：数据来源于多个接口，出现回调嵌套 Promise本身不是异步的，只是里面的任务往往都是异步的 new Promise(resolve => { resolve(); console.log(\"promise\"); }).then(value => console.log(\"success!\")); console.log(\"end\"); //执行顺序: //promise //end //success! 创建一个promise容器 =&gt; 而这里容器一旦创建，就开始执行里面的代码 =&gt; 容器中存放一个异步任务默认pending状态，表示正准备去做，即将发生的 个人觉得：resolve和reject类似于两个callback，然后再外面进行回调罢了finally()方法用于指定不管Promise对象最后状态如何，都会执行的操作，该方法时ES2018引入的标准 var fs = require('fs'); //封装实例化Promise+读取数据API function ProReadFile(Path) { return new Promise(function (resolve, reject) { fs.readFile(Path, 'utf8', function (err, data) { if (err) { // 失败了，承诺容器中的任务失败 // 把容器的pending状态改为Rejected // 调用reject相当于调用了then方法第二个参数函数 reject(err); } else { // 承诺容器中的任务成功 // 把容器的pending状态改为成功Resolved // 调用resolve相当于调用了then方法第一个参数函数 resolve(data); } }) }); }; 当返回结果成功后，then做指定操作 then的说明： then(resolve(), reject()) 成功状态Fulfilled时（resolve，成功则进入下一个then），then方法接收两个参数:1.容器中的resolve函数, 2.容器中的reject函数，这里把then看成一个整体，then会默认返回一个fulfilled状态的Promise 失败状态Rejected（自己设置判断失败的条件，然后reject函数），会回调catch 在类里面定义 一个then方法，那么他会包装成一个Promise，但是注意这个Promise 默认没有状态，需要手动去 resolve 或者 reject ProReadFile('./index.txt') .then(function (data) { console.log(data); //当第一个读取成功时，这里返回后面想要继续执行的Promise异步任务，如果没有返回，则后面收到的是undefined //我们真正有用的是return 一个Promise对象 //如果return 123，则接下来的then的function参数接受的data是123，而且并不是前面的异步任务执行完毕才进入下一个then return ProReadFile('./index2.txt'); }, err => { console.log('读取文件失败', err); }) .then(function (data) { console.log(data); //第二个读取成功时，这里返回后面想要继续执行的Promise异步任务 return ProReadFile('./index3.txt'); }, err => { console.log('读取文件失败', err); }) .then(function (data) { console.log(data); }, err => { console.log('读取文件失败', err); }) catch效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中（推荐把catch放在链式结构的最后，前面无论第几个出错，都会跑到最后执行这个catch（除非你事先在前面用reject的回调函数处理过错误结果了））。请看下面的代码： ProReadFile('./index.txt') .then(function (data) { console.log(data); return ProReadFile('./index2.txt'); }).catch(err => {console.log('文件读取失败', err)}) 特殊情况状态传递 注意：如果resolve或reject中的参数是promise实例对象 var p1 = new Promise(function (resolve, reject) { setTimeout(function () { resolve('1'); }, 3000); }) var p2 = new Promise(function (resolve, reject) { setTimeout(function () { resolve(p1); // resolve的参数是一个promise对象 }, 1000); }); p2 .then(function (data) { console.log('resolve执行') console.log(data) }, function (err) { console.log(err) }) 3s后依次打印 ‘resolve执行’ ‘1’ （时间 = max （p1的定时时长, p2的定时时长）） 这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 let p1 = new Promise((resolve, reject) => { reject(\"拒绝\"); }) new Promise((resolve, reject) => { resolve(p1); }).then(res => { console.log(\"res\"); }, err => { console.log(\"err\", err); }) //err 拒绝 上面说到p1的状态会传递，所以这里p1的状态是Rejected，传递给了下面这个Promise，执行的是Rejected的回调 返回值问题 注意 如果返回值为一个普通参数 then方法会返回一个新的promise,这个新promise的value由return的值决定 执行return语句后不是Promise实例，是123，则导致当前then方法返回的promise变为成功状态 pending-&gt;fulfilled(Resolved) 在这里它其实是 return new Promise.resolve(123)的简写 var p2 = p1.then(function (data) { console.log(data); return 123456 }, err => { console.log('读取文件失败', err); }) .then(function (data) { console.log(data); // 这个回调一定会被调用 }, err => { console.log('读取文件失败', err); }) 注意 甚至没有返回值时，它还会自动给你 pedding -&gt; fulfilled，然后进入下一个then的第一个成功的回调函数里 而反而如果你 return 了一个promise实例，在这个实例里面没有调用 resolve 或者 reject，就进入不了下一个then里面 所以！！！ 因为异步操作我们才使用Promise，而返回值非Promise的情况会导致未执行完异步操作则直接进入下一步的then里面，这样和原来未使用Promise语句地执行方式相同，和我们想要有序地进行异步操作的初衷背道而驰 所以我们推荐返回值返回一个 new Promise，这样等到Promise实例调用resolve / reject后才会进入下一步then，才符合我们的代码规范和初衷！！ 直接抛出异常问题 注意 如果想要返回后直接跳转到下一个then的reject函数里，可以直接 throw ErrorMessage 执行throw语句后，导致当前then方法返回的promise变为失败状态 pending-&gt;Rejected 因为它其实是 return new Promise.reject(&#39;error message&#39;)的简写 var p2 = p1.then(function (data) { console.log(data); throw 'error message'; }, err => { console.log('读取文件失败', err); }) .then(function (data) { console.log(data); }, err => { console.log('读取文件失败', err); // 这个回调一定会被调用 }) 双重then问题 注意 then方法提供一个供自定义的回调函数，若传入非函数，则会忽略当前then方法。 以下的例子就是忽略了第一个then，因为它未传入函数，传入的是 ‘新的值’ let func = function() { return new Promise((resolve, reject) => { resolve('返回值'); }); }; let cb = function() { return '新的值'; } func().then(cb()).then(resp => { console.warn(resp); console.warn('========='); }); //输出：返回值 ============ 状态问题 注意 在执行promise后，return时都会包装成一个新的Promise实例，但如果then方法还未被调用，则这个实例它的状态还是pedding let p1 = new Promise((resolve, reject) => { resolve(\"fulfilled\"); }) let p2 = p1.then( val => {console.log(val);}, err => {console.log(err)} ) console.log(p1); console.log(p2); setTimeout(()=>{ console.log(p1); console.log(p2); }) //输出 //Promise&lt;resolved> //Promise&lt;pending> //fulfilled //Promise&lt;resolved> //Promise&lt;resolved> Promise的all方法使用应用场景：处理多个相互依赖的异步请求 Promise.all([ new Promise((resolve, reject) => { setTimeout(() => { resolve('hello'); }, 1000); }), new Promise((resolve, reject) => { setTimeout(() => { resolve('world'); }, 2000); }) ]) // 两个网络请求都完成后才会进入then .then(results => { // results是一个数组，它包含以上异步操作的结果 console.log(results[0], results[1]); }) 除了 all之外，还有allSettle、race方法，分别表示只有一个状态为fulfilled就执行 和 谁执行的快就取决于谁的状态 （感觉race方法可能是封装ajax中设置请求超时时长的原理） async和await语法糖async和await时Promise的语法糖，（个人感觉async没什么作用，因为正常情况下我们封装普通函数也可以在里面 return new Promise，只不过是await必须放到async的函数里才能被使用，汗。。。） 使用 await 异步函数() 相当于 .then(res =&gt; { return 异步函数() })，处理异步任务，有异步任务 -&gt; 同步任务的感觉，记得每次都把异步任务放在await后面，而且每次在await 异步操作之后的同步任务就像被放在另一个then里面，会等待异步任务的完成后再执行 async function pro(delay = 1000) { return new Promise((resolve, reject) => { setTimeout(() => { resolve(\"hello\"); }, delay); }) } async function show() { for (const item of [\"Allen\", \"Bruce\", \"Carry\"]) { let hello = await pro(); console.log(item); console.log(\"hello\"); console.log(\"world\"); } } show(); // //原始方法 // let p = Promise.resolve(); // for (const item of [\"Allen\", \"Bruce\", \"Carry\"]) { // p = p.then((res) => { // return pro(); // }).then(() => { // console.log(item); // console.log(\"hello\"); // console.log(\"world\"); // }) // } 语法糖可以配合 then、 catch一起使用 async function fn() { return await new Promise((resolve, reject) => { setTimeout(() => { console.log(\"nononon\"); resolve(); }, 1000); }) } fn().then(res => { console.log(\"success\"); }).catch((err) => { console.log(err); }) async + await实现并行执行 （配合Promise.all） async function fn(k) { return await new Promise((resolve, reject) => { setTimeout(() => { console.log(k); resolve(k); }, 1000); }) } async function hd() { let res = await Promise.all([fn(\"hello\"), fn(\"world\")]) console.log(res); } hd(); Promise缺点 无法取消Promise,一旦新建它就会立即执行，无法中途取消。（只能抛出错误中断（throw）） 如果不设置回调函数，promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 可能代码撰写比较繁琐 + 冗长 5.SymbolSymbol表示独一无二的值，是ES6引入的第七种数据类型，是一种类似于字符串的数据类型（永远不会重复的字符串） 特点： Symbol的值是唯一的。解决命名冲突的问题（内部实现唯一性，不可见，也就是打印不出来） Symbol不能与其他数据进行运算（隐式类型转换会报错，但是，Symbol 值可以显式转为字符串、转为布尔值） Symbol定义的对象属性不能使用for in 、for...of 进行循环，但是可以使用 Reflect.ownKeys来获取对象的所有键名 基本创建 let s1 = Symbol(); // let s2 = Symbol('描述字符串');，我们可以通过描述字符串更好的理解这个值的作用 let s2 = Symbol('allen'); let s3 = Symbol('allen'); // 返回false，因为描述字符串类似于身份证上的名字，我们可能同名同姓但是不可能同一身份证 console.log(s2 === s3); //false Symbol.for进行创建，是作为一个函数对象，通过这种方式创建，我们是可以通过描述字符串得到得出唯一的symbol值该方法会根据给定的键 key，来从运行时的全局 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。（用于需要共享和重用符号的实例） let s4 = Symbol.for('bruce'); let s5 = Symbol.for('bruce'); console.log(s5 === s4); //true Symbol.keyFor(s4); //\"bruce\" 应用能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 注意： Symbol值作为对象属性名时，不能用点运算符。 在对象中使用变量定义属性时，必须放在方括号内，与普通键值(String)进行区分。 let mySymbol = Symbol(); // 第一种写法 let a = {}; a[mySymbol] = 'Hello!'; // 第二种写法 let a = { [mySymbol]: 'Hello!' }; a[mySymbol] // \"Hello!\" let s = Symbol(); let obj = { [s]: function (arg) { ... } }; obj[s](123); 利用Symbol的特性可定义内部私有属性或方法 function getObj(obj) { let privateKey = Symbol('privateKey'); objCopy = { ...obj } || {}; objCopy[privateKey] = function privateFunc() { console.log('privateFunc ') } return objCopy; } let newObj = getObj(); console.log(newObj[privateKey]); // 报错，外部无法获取到privateKey的值 console.log(newObj[Symbol('privateKey')]); //undefined,此时的symbol已经变成新的symbol值 Symbol的内置属性 Symbol.hasInstance：对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。 class MyClass { [Symbol.hasInstance](foo) { return foo instanceof Array; //如果直接 return false，则调用instanceof的时候无论前面接什么实例，都会返回false } } [1, 2, 3] instanceof new MyClass() // true Symbol.isConcatSpreadable：对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 let arr1 = ['c', 'd']; ['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e'] arr1[Symbol.isConcatSpreadable] // undefined let arr2 = ['c', 'd']; arr2[Symbol.isConcatSpreadable] = false; ['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e'] 还有很多，可以去阮一峰的ES6入门查看 在学习过程踩的坑var name = Symbol(); //Uncaught TypeError: Cannot convert a Symbol value to a string 在网上找的的解释： var 定义的变量会把它提升到当前函数作用域顶部，如果是浏览器全局作用域就会成为window的一个属性。 By the way，let会把变量提升到当前块级作用域顶端，如果在浏览器全局作用域下，不会让变量成为window的属性。 name 是window对象的一个固有属性，对它的赋值，会被强制转为string。 可以打开控制台打印一下window，第二个属性就是name。 给name赋值一个对象，会自动转换为string类型 symbol Symbol的隐式类型转换会报错 使用 var 声明变量 =&gt; 给 window 的变量赋值 =&gt; window.name的赋值必须转换为字符串 =&gt; 对值Symbol()转换为字符串的过程中，触犯了的 “Symbol()隐式类型转换” 6.XX器迭代器迭代器是一种接口，为各种不同数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作 实际上 Iterator接口，就是对象里面的一个属性，而属性的名字就叫做 Symbol.Iterator ES6创造了一种 for of循环，Iterator主要供 for of消费，也就是可以使用for of，就有 Symbol.Iterator属性 定义 Symbol.Iterator则定义它的迭代方式 错误：迭代失败！！！ const banji = { name: \"4399\", status: [ 'Allen', 'Bruce', 'Cat' ] } for (item of banji) { console.log(item); } next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。 正确√，重新定义了迭代器，用来迭代status const banji = { name: \"4399\", status: [ 'Allen', 'Bruce', 'Cat' ], [Symbol.iterator]() { let index = 0; return { next: () => { // 这里的this指向我们的banji // value为迭代的值，done表示是否停止迭代的状态 if (index &lt; this.status.length) { const result = { value: this.status[index], done: false }; // 下标自增，继续迭代 index++; return result; } else { return { value: undefined, done: true } } } } } } //这里的item直接输出value for (item of banji) { console.log(item); } 生成器名词解释： Generator 函数是 ES6 提供的一种异步编程解决方案 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 使用方法： Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态（使用yield分割）。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 // yield用于函数代码的分割，3个分隔符产生4块代码 function* gen() { console.log(\"123\"); yield 'aaaaa'; console.log(\"456\"); yield 'bbbbb'; console.log(\"789\"); yield 'cccc'; } let gen1 = gen(); console.log(gen1); // 生成器执行必须调用next()，value的值 = yield后的值 //这里的item是执行相对代码块后，然后输出value for (item of gen1) { console.log(item, \"这是一个片段\"); } //123 //aaaaa 这是一个片段 //456 //bbbbb 这是一个片段 //789 //cccc 这是一个片段 // gen1.next(); ///123 // gen1.next(); ///456 在生成器的next传入实参，传入的参数作为上一个yield语句的整体返回结果 function* gen(arg) { console.log(arg); let one = yield 111; console.log(one); let two = yield 222; console.log(two); let three = yield 333; console.log(three); } let iterator = gen('AAA'); iterator.next(); //AAA iterator.next(); //undefined iterator.next('BBB'); //BBB iterator.next('CCC'); //CCC 生成器应用异步编程 下面使用 setTimeout 模拟异步任务的执行 function getUser() { setTimeout(() => { let data = \"用户信息\" iterator.next(data); }, 1000) } function getGood() { setTimeout(() => { let data = \"商品信息\" }, 1000) } function* gen() { let data = yield getUser(); console.log(data); yield getGood(); } let iterator = gen(); iterator.next(); 个人感觉比promise麻烦很多。。。，代码太长了 7.其他static类（class）通过 static 关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能。 关于块级作用域 + 函数声明的诡异代码先上代码，先上代码 console.log(a) // undefined { a=1 function a() {} } console.log(a) // 1 console.log(a) // undefined { function a() {} a=1 } console.log(a) // func a 我在网上搜到的解释，希望对你们有帮助（请自行脑部理解！！！）","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Nodejs","slug":"Nodejs","date":"2020-12-26T13:25:21.026Z","updated":"2021-03-15T07:36:24.809Z","comments":true,"path":"2020/12/26/nodejs/","link":"","permalink":"https://taylor12138.github.io/2020/12/26/nodejs/","excerpt":"","text":"1.Node概述Node.js是一个能够在服务器上运行JavaScript的环境 为什么选择node： 1.node使用JavaScript语法开发后端应用 2.一些公司要求前端人员掌握Node开发 3.生态系统活跃，有大量开源库 4.现有前端开发工具大多居于node开发 node是基于chrome V8引擎的JavaScript代码运行环境（浏览器也是JavaScript代码运行环境），源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码) 在命令行工具中输入 node -v 即可查看nodejs是否安装成功 node.js的组成：JavaScript由3部分组成，ECMAScript，DOM，BOM Node.js由ECMAScript及Node环境提供的一些附加API组成的，包括文件、网络、路径等一些更强大的API（没有DOM，BOM） 使用在cmd命令符窗口中使用 node xx.js 即可完成（在执行文件的目录下按住shift+鼠标右键可快速进入当前目录的命令符窗口，然后配合tab键位快速打开） 也可以直接使用 node进行回车，可以直接供测试使用（核心模块可以直接用，不用require），类似于浏览器的console控制台 2.Node.js模块化开发JavaScript弊端：文件依赖（a.js-&gt;b.js-&gt;c.js，相互依赖，但是很难直接看出来，分析完后才知道要一个一个引入）和命名冲突（在相互依赖的js中声明同样的变量名导致的错误） 模块化开发：一个功能一个模块，多模块组合完整应用，抽离一个模块不会影响其他功能的运行，降低程序的耦合性，方便代码复用（虽然开发效率低一点） commonJS的提出为了弥补JavaScript没有标准的缺陷，希望JS’能在任何和地方运行，CommonJS对模块的定义十分简单 模块化node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到（除了console.log的输出内容），因为在node的定义中，每个js文件的js代码都是独立运行在一个函数中，而不是全局作用域。 当node执行模块中代码，它首先在代码顶部添加： function(exports, require, module, __filename, __dirname){} 将代码包含进去 模块内部使用exports 对象进行成员导出，使用require方法导入其他模块（注意ES6不使用require而是使用import） exports //a.js let version = 1.0; const sayHi = name => `你好, ${name}`; //向模块外导出数据 exports.version = version; exports.sayHi = sayHi; require,如果直接使用模块名来引入，没有添加路径，它会首先在当前目录的node_modules中寻找是否含有该模块，没有则一直往上一级寻找var math = require(&quot;math&quot;) （require加载规则：优先从缓存加载，即之前加载过的模块，不再加载） 模块中的路径标识是相对于当前文件模块，不受到node命令所处路径影响，想查看路径影响可跳转阅读 10. Path //b.js //b.js导入a.js, ./b.js是b.js的路径，路径模块必须加'./', 如果只加了'/'，就当作此盘根目录下路径，也就是绝对路径处理 let a = require('./a.js'); console.log(a.version); console.log(a.sayHi('xx')); //使用a.js的方法 模块导出的另一种方式(和exports差不多)： //a.js module.exports.version = version; module.exports.sayHi = sayHi; //b.js let a = require('./a.js'); //b.js导入a.js, ./b.js是b.js的目录 console.log(a.version); console.log(a.sayHi('xx')); //使用a.js的方法 module代表当前模块本身 exports是module.exports的别名（地址引用关系），它们俩指向同一块内存空间，导出对象（当exports和module.exports对象指向的不是同一个对象时）最终以module.exports为准，即想要直接以对象的方式进行全部修改，只能以module.exports进行声明，比如 module.exports = { name: &#39;allen&#39;,} 用module.exports来改动的话，是改对象，更改对象里的值 用exports以对象方式来改动的话，是改变量，更改了地址 最后return的是 module.exports ，所以给exports重新赋值不管用 __filename 当前模块的完整路径 __dirname 当前模块所在文件夹完整路径（所属目录的绝对路径） 注意：如果a加载了b ，b又加载了a，（即a require b，b require a）说明思路有问题 模块分类核心模块 由node引擎提供 核心模块的标识就是模块的名字（如node提供的文件模块fs） 文件模块 由用户自己定义 第三方模块（可以通过npm下载，它的查找方式是先找到当前目录下node_modules/xx/package.json文件，查看其中main属性，记录了js文件的入口，当main没有指定，默认执行node_modules/xx/目录下的index.js）（模块查找机制：如果以上任何条件不成立，则会进入上一级目录中的node_modules） globalnodejs的全局变量保存在global里面 global.a get在地址栏输入网址永远是get、get在回退时是无害的 get注重url获得的参数，且只产生一个TCP数据包 获得get请求的内容，它的内容是在url的? 之后的部分 ​ -url 是nodeJs的url模块 ​ -url.parse 解析url请求 (url.parse(req.url, true) 对 url的信息进行解析，得到一个对象，使用true的话，能把里面的重要属性query（查询字符串），也转换成对象) 比如创建端口号为5208的服务器，在网址末尾写上?a=1&amp;b=2&amp;c=3之类 http://localhost:5208/?a=1&amp;b=2&amp;c=3 （查询Content-type网址：http://tool.oschina.net/） var http = require('http'); var url = require('url'); http.createServer(function (req, res) { res.writeHead(200, { 'Content-Type':'text/plain;charset=utf-8' }); // req.url是：/?a=1&amp;b=2&amp;c=3 //url.parse(req.url, true)是： 转对象 //有用的信息保存于query属性中 [a: 1,b: 2,c: 3] var _param = url.parse(req.url, true).query; console.log(_param.a); console.log(_param.b); console.log(_param.c); res.end(); }).listen(5208) console.log(\"5208服务器已经启动。。。。\"); postpost请求，要么是表单post请求，要么是api的post请求，只要记得一般情况下，私密数据传输用POST + body就好。 post的信息放在Request body中，且产生TCP两个数据包（firefox浏览器除外） post回退时会再次提交请求 querystring 模块从字面上意思就是查询字符串，一般是对http请求所带的数据进行解析 querystring.parse(str[, sep[, eq[, options]]]) 将一个字符串反序列化为对象 var http = require('http'); var querystring = require('querystring'); var _formHtml = '&lt;form method=post>' + '网站名：&lt;input name=\"name\">&lt;br>' + '年龄：&lt;input name=\"age\">&lt;br>' + '&lt;input type=\"submit\">' + '&lt;/form>'; http.createServer(function (req, res) { var body = ''; //当服务端接收到数据时触发data req.on('data', function (_d) { body += _d; }) req.on('end', function () { // 转换成一个对象 body = querystring.parse(body); console.log(body); res.writeHead(200, { 'Content-Type': 'text/html;charset=utf-8' }) if (body.name) { res.write(\"姓名：\" + body.name); res.write('&lt;br>'); res.write(\"年龄：\" + body.age); } else { res.write(_formHtml); } res.end(); }) }).listen(5208); console.log(\"5208服务器已启动！！\"); 3.Nodejs的包通俗来说，单个js文件算一个模块，放在一个文件夹里就是一个包了 CommonJS 的包规范由包结构和包描述两个部分组成 包结构：用于组织包中的各种文件 ​ -package.json 描述文件 （important） ​ -bin 可执行二进制文件 ​ -lib js代码 ​ -doc 文档 ​ -test 单元测试 包描述文件（上面的那个-package.json 描述文件）：描述包的相关信息，以供外部读取分析。它用于表达非代码相关信息，是一个json格式的文件，实际上加载包时使用的原则是：node_modules/express/package.json main, 而且它其中保存着十分重要的第三方包依赖项信息（dependencies） 并且建议每个项目里带一个（有且只有一个）package.json文件npm init npm init -y 里面的-y就是yes的意思，在init的时候省去了敲回车的步骤，生成的默认的package.json package.json和package-lock.jsonnpm 5以前是不会有package-lock.json这个文件的 npm 5 以后才加入 从安装上看，npm都会生成或更新package-lock.json这个文件 npm 5 版本以后的安装包，不用加–save添加依赖，它会自动保存依赖 它会自动创建或者更新package-lock.json package-lock.json里面保存的是node_modules所有包的依赖，包括依赖的包里package.json所依赖的包名（套娃） 因此重新npm install时速度会有所提升 从文件上看 lock是用来锁定版本的，如果当前项目依赖了1.1版本，但是重新npm install 其实会给你下载最新版本，而不是1.1 而package-lock.json的另一个作用就是锁定版本号，防止自动升级最新版 NPM（Node Package Manager） CommonJS包规范时理论，NPM是其中一种实践，是Node包管理器 对于Node而言，NPM帮助其完成第三方模块的发布，安装和依赖（A-&gt;B-&gt;C，下载C直接A, B也下），借助NPM，Node与第三方模块之间形成良好的一个生态系统（安装了node以后，自带安装npm） 在cmd命令行窗口： npm -v 查看版本 （或者包名 --version） npm 帮助说明 npm search 包名 搜索包 安装 npm install 下载当前项目所依赖的包（根据package.json配置里的依赖下载） npm install 包名 / npm i 包名 当前目录安装包（可以先创建一个文件夹）（尾部加--save，则添加到当前package.json的依赖里） 如果尾部加 --save-dev则为开发时依赖 npm install 包名 -g 全局模式安装包（一般都是计算机里的工具） 删除 npm remove 包名 / npm r 包名 删除包 （这个好像是旧版的） npm uninstall 模块：删除模块，但不删除模块留在package.json中的对应信息 npm uninstall 模块 --save 删除模块，同时删除模块留在package.json中dependencies下的对应信息 npm uninstall 模块 --save-dev 删除模块，同时删除模块留在package.json中devDependencies下的对应信息 连接国外的npm服务器是，遇到卡顿问题可以试一试国内淘宝的镜像npm进行配置（此时指令nmp-&gt;cnmp）(但是听说cnmp会有诡异的bug) 4.Buffer缓冲区数组不能存储二进制文件，而buffer就是专门来存储二进制数据 从结构上buffer非常像一个数组，他的元素为16进制的两位数 var str = \"hello, 艾伦\"; var buf = Buffer.from(str); console.log(buf.length); //占用内存大小 console.log(str.length); //字符串长度 var s = buf.toString(); //将缓冲区的数据转换回字符串 var j = buf.toJSON(); //将缓冲区的数据转换回json对象 buffer存储的数据都是二进制数据，但是显示的时候都是以16进制显示，范围是00 - ff（00000000 - 11111111），所以是8 bit （位），8 bit = 1 byte （字节）（一个英文占一个字节，一个汉字占3个字节） buffer 构造函数（new Buffer）不推荐使用 但是可以：使用Buffer.alloc(size)分配一个大小为size的新建Buffer 还有：Buffer.allocUnsafe(size) 创建一个指定大小的buffer，但是buffer可能含有敏感数据（分配时未清空上一次使用内存存放的数据，但是性能够好） Buffer的大小一旦确定，则不能修改，Buffer实际上是对底层内存的直接操作 可以通过索引操作buffer中的元素 buf[0] = 88 这里的88是16进制，然后再控制台console.log进行输出时，显示的是10进制（只要数字在控制台输出一定是10进制） 5.文件系统fs通过node操作系统中的文件，在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地文件发送给远程客户端，该模块提供了一些标准文件访问api来打开，读取，写入文件，以及与其交互 引入fs模块，fs是核心模块，直接引用不用下载 fs模块中所有的操作都有两种形式可供选择：同步和异步 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码（顺序执行） 异步文件系统不会阻塞程序的执行，而是在操作完成时（异步都有callback）（异步方法不可能有返回值）通过回调函数结果返回 fs中带Sync的的方法是同步方法，不带Sync的方法是异步方法 文件打开同步文件打开 fs.openSync(path, flags[, mode]) ​ -path 打开的文件路径 ​ flags 打开文件操作类型 比如 r 只读的、 w 可写的 ​ mode 操作权限 ，一般省略 该方法会返回一个文件描述符作为结果，我们可以通过该描述符来对文件进行各种操作 异步文件打开 fs.open(path, flags[, mode], callback) ​ callback不能省略 ​ 回调函数中有两个参数 ​ err 错误对象 没有错误则为null ​ fd 文件描述符 无返回值 文件写入同步文件写入 fs.writeSync(fd, string[, position[, encoding]]) ​ fd文件描述符，需要传递要写入的文件的描述符 ​ string写入内容 ​ position起始位置，一般省略 ​ encoding 默认utf-8 异步文件写入（写在fs.open的回调函数里） fs.write(fd, string[, position[, encoding]], callback) ​ 当前回调有三个参数 ​ err ​ written ​ string 关闭文件服务器是持续运行的，不想我们平时运行的文件，结束后自动释放空间 fs.closeSync(fd) ​ fd文件描述符，需要传递要写入的文件的描述符 fs.close(fd, callback) ​ 异步，完成回调只有一个可能的异常参数 简单文件写入（常用）一步搞定，省略打开，关闭 fs.writeFile(file, data[, options], callback) fs.writeFileSync(file, data[, options]) ​ file 要操作文件的路径 ​ data 要写入的数据 ​ option 选项，可选，对写入进行配置：有encoding（默认utf-8）、mode（权限）、flag（文件操作形式，默认w，如果内容不存在则创建，存在则截断） ​ callback 当写入完成以后执行的函数 var fs = require(\"fs\"); fs.writeFile(\"index.txt\", \"aaa\", function (err) { if (!err) { console.log(\"写入成功！\"); } else { console.log(\"error!\"); } }); 流式文件写入同步、异步、简单文件的写入，都不大适合大文件的写入（都是一次写入），性能较差，容易导致内存溢出 而流式文件的传输相当于两个水池之间插入一条管道，持续的多次的写入 它本质上也是一个异步 创建一个可写流，参数功能和之前的文件读写相同 var ws = fs.createWriteStream(path [, option]) var fs = require(\"fs\"); var ws = fs.createWriteStream(\"index.txt\"); // 监听文件的打开和关闭 ws.once(\"open\", function () { //once为对象绑定一个一次性的事件，jQuery也有出现过类似的one console.log(\"流打开了\"); }); ws.once(\"close\", function () { console.log(\"流关闭了\"); }); ws.write(\"通过可写流写入文件的内容\"); ws.write(\"啊大苏打\"); ws.write(\"大撒大撒\"); // 关闭流，关闭流入口 // ws.close(); 当前版本也可以了（关闭流出口） ws.end(); 文件读取（all kinds）这里只讲讲简单文件读取和流式文件读取 简单文件读取（参数功能同上） fs.readFileSync(path [, options]) fs.readFile(path [, options], callback) ​ callback回调函数参数 ​ err 错误对象 ​ data 读取到的数据，会返回一个Buffer 流式文件读取 它也适合一些比较大的文件，可以分多次将文件读取到内存中 创建一个可读流： fs.createReadStream(path) 如果要读取一个可读流的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，然后读取到的数据存放在参数中返回（它的参数没有err，因为事件触发后就意味着不会再出错了） var fs = require(\"fs\"); var rs = fs.createReadStream(\"cool.jpg\"); var ws = fs.createWriteStream(\"copy.jpg\") // 监听 rs.once(\"open\", function () { console.log(\"可读流打开了\"); }); rs.once(\"close\", function () { console.log(\"可读流关闭了\"); // 数据读取完毕，关闭可写流 ws.end(); }); ws.once(\"open\", function () { console.log(\"可写流打开了\"); }); ws.once(\"close\", function () { console.log(\"可写流关闭了\"); }); // 开始读取 rs.on(\"data\", function (data) { //将数据读到data中 // 将读取的数据写入可写流中 ws.write(data); }) 流式文件原本需要data方法进行读取，但是有个更方便的方法： 将可读流和可写流管道相通，形成管道流，用了 pipe() 的方法 改： // 开始读取 /* rs.on(\"data\", function (data) { //将数据读到data中 // 将读取的数据写入可写流中 ws.write(data); })*/ // 开始读取 rs.pipe(ws); 文件读取配合文件写入，可完成文件的传输 服务器就是接收用户的请求，并返回响应，而请求和响应就是数据流 fs其他方法fs.existsSync(path) 是否存在 fs.stat(path, callback) 文件状态（里面包含文件大小等信息） fs.readdir(path, [, option], callback) 读取文件目录列表 fs.readdir(path, [, option])读取一个目录的目录结构 fs.truncateSync(path, size) 截断文件，将文件修改为指定大小 6.创建服务1.先引入模块 var _http = require(&#39;http&#39;); 创建服务器http.createServer([options][, requestListener]) request监听事件需要接收两个参数，Request请求对象（获取客户端请求信息），Response响应对象（用来给客户端发送响应消息） 再创建服务器的回调函数里添加http头部信息，然后向客户端发送数据 响应对象1.响应对象response添加信息：response.writeHead(statusCode[, statusMessage][, headers]) ​ statusCode 为状态码 ​ headers为响应头 text/plain:纯文本 text/html: 可识别为html标签的文本 ​ charset=utf-8:防止中文乱码（服务器默认发送数据时utf8，但是浏览器不知道你是utf8，它会默认按照当前操作系统的编码去解析） response.setHeader(name, value)也可以写响应头 （writeHeader可以设置http返回状态码，多个http响应头。但是setHeader只针对单一属性的设置。） 2.响应对象response发送数据，并且结束响应（end）： response.end(&quot;第一个http服务&quot;); （当然也可以response.write(&quot;xxx&quot;); response.end()） 注意：响应内容只能是二进制数据或字符串（Buffer或String） var _http = require('http'); // 创建服务器 _http.createServer(function (request, response) { // http头部信息 response.writeHead(200, { 'Content-type': 'text/plain;charset=utf-8' }); // 向客户端发送数据，并且结束响应（end） response.end(\"第一个http服务\"); }).listen(5205); //自己设置监听的端口号最好不要用8888，8080，可能会被电脑其他应用占用，容易报错 console.log(\"5205已经创建!\"); 绑定端口号也可以直接给实例绑定： ​ var server = http.createServer(){} ​ server.listen(端口号, callback) 此时打开本地浏览器，local:host5205即可查看访问 response的重定向通过服务器让客户端重定向 状态码设置302临时重定向 statusCode 在响应头通过location告诉客户往哪重定向 setHeader 客户端发现收到服务器的响应状态码为302，就会自动去响应头找location，然后对该地址发起新的请求 所以你就能看到客户端自动跳转（这里是跳转至首页） //接收表单数据后（get），进行跳转，跳转至首页 var comment = url.parse(req.url, true).query; comments.unshift(comment); //从头部增加数组元素，comments为数组变量 res.statusCode = 302; res.setHeader('Location', '/'); //响应头的Loacation路径设置为 '/' 即首页 res.end(); 请求对象1.请求路径为： request.url, url：统一资源定位符 路径优化问题： var http = require('http'); var fs = require('fs'); var wwwDir = 'C:/Users/ok-pc/blog/source/_posts'; //文件路径 http.createServer(function (req, res) { var url = req.url; var filePath = '/index.html'; if (url !== '/') { filePath = url; } fs.readFile(wwwDir + filePath, function (err, data) { if (err) { return res.end('404'); } else { res.end(data); } }) }) ip地址与端口所有联网的程序都需要网络通信，计算机只有一个物理网卡，网卡的地址是唯一的（ip地址） 端口号用来定位具体应用程序（类似银行窗口号，服务器类似于银行） 一切需要联网通信的软件都会占用一个端口号 端口号在 0 - 65536 之间 在计算机中有一些默认端口号，最好不要去使用 例如http服务的80 可以同时开启多个服务，但是一定要确保不同服务占用端口号不一致（在一台计算机中，同一端口号同一时间只能被一个程序占用） 处理静态资源浏览器收到html响应内容之后，就要开始从上到下进行解析，当在解析过程中，如果发现： link script img iframe video audio 等带有src 或者 href（link）属性标签的时候（具有外链资源的时候），浏览器会自动对这些资源发起新的请求 我们为了方便统一处理这些静态资源，所以约定把所有静态资源存放在public目录中，即如果请求路径以 /public/开头，则认为你是要获取public的某个资源，所以我们这时可以直接把请求路径当作文件路径进行读取 这时哪些资源能否被用户访问可以达到一个可控的状态 （注意：在服务端中，文件的路径就要要写相对路径了，因为这个时候所有资源都是通过url标识来获取，这里服务器开放了/public/目录，所以这里请求路径写成 /public/xxx） html中的link ：&lt;link rel=&quot;stylesheet&quot; href=&quot;/public/lib/bootstrap/dist/css/bootstrap.css&quot;&gt; nodeJs代码： var http = require('http'); var fs = require('fs'); var rg = /^\\/public\\//; http.createServer(function (req, res) { var url = req.url; if (url === '/') { fs.readFile('./views/index.html', function (err, data) { if (err) { return res.end('404 Not Found.'); } res.end(data); }) } else if (rg.test(url)) { // 如 ：/public/lib/bootstrap/dist/css/bootstrap.css // url.indexOf('/public/') === 0也可以 fs.readFile('.' + url, function (err, data) { if (err) { return res.end('404 Not Found.'); } res.end(data); }); } }).listen(5208, function () { console.log('running!!...'); }); 7.事件nodeJs它基本上，所有事件机制，都是基于设计模式种“观察者模式”来实现的 简单来说，nodejs使用事件驱动的模型，每当接收到一个请求，就把他关掉进行处理，当这个请求完成，就把它放到处理队列当中，最后把结果返回给用户 因为它的服务一直是处理接收请求，但不等待任何读写操作，所以性能很高，这也叫做“非阻塞式IO或是事件驱动IO” nodeJS事件使用events模块，通过实例化它里面的EventEmitter类来绑定和监听事件 使用事件模块：var eve = require(&#39;events&#39;) 实例化EventEmitter类：var event = new eve.EventEmitter() ​ 实例化对象里有个_eventsCount属性，显示绑定事件数量 （也可以： var eventEmitter = require(&#39;events&#39;).EventEmitter; ​ var event = new eventEmitter(); ） 绑定事件：event.on(事件名, callback)（jquery也用on绑定事件） ​ 事件名可以自定义，因为这里的事件名完全不同于浏览器上的各种事件，这里的事件名就是一个“标识”，实际上绑定了一个回调函数 监听事件的触发：event.emit(事件名) // 绑定一个事件 event.on('one', function () { console.log(\"no.1事件被触发了\"); }); // 触发一个事件 event.emit('one'); 所有nodejs里面的异步io操作，都会在完成时，发送一个事件到事件队列 8.Stream流Stream流是一个抽象的接口，在nodejs当中，很多方法，对象，他们都实现了这个接口，例如之前创建一个服务，向服务器发送一个请求，request对象，他其实就是一个流（流简单粗暴的理解就是在线看电视） 在nodeJS中，Stream有四种流类型： ​ Readable -可读操作 ​ Writable -可写操作 ​ Duple -可读可写操作 ​ Transform -操作被写入数据，然后读出结果 所有的Stream对象都是EventEmitte（events模块）r的实例 常用事件： ​ -data 当有数据可读取时触发 ​ -end 没有更多数据可读取时触发 ​ -error 在接收和写入过程中，发生错误时触发 ​ -finish 所有数据已经被写入之后触发 流式读取文件的方法在 5.文件系统fs中 链式流就是从一个输出流当中，读取数据，创建多个流来操作这个输出流数据的机制 链式流一般来操作管道流 常见的例子就是压缩和解压缩的例子 // 链式流 var fs = require('fs'); var zlib = require('zlib'); // 压缩文件 fs.createReadStream('cool.jpg') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('cool.jpg.gz')); console.log(\"解压完毕！！！\"); // 链式流 var fs = require('fs'); var zlib = require('zlib'); // 解压缩 fs.createReadStream('cool.jpg.gz') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('copy2.jpg')); console.log(\"解压缩完毕！！！\"); 9.模板引擎最早诞生于服务器领域，后来发展到前端 官方文档：https://aui.github.io/art-template/ 安装npm install art-template 浏览器应用引入 &lt;script src=&quot;./node_modules/art-template/lib/template-web.js&quot;&gt;&lt;/script&gt; 类型改为 type = &quot;text/template&quot; 模板引擎不关心字符串内容，只关心自己能认识的模板标记语法，例如(包含if语句判断) {{ 变量名 }} {{ if user }} {{ else }} {{ /if }}{{ each 遍历数组 }} &lt;li&gt;{{ $index + 1 }}&lt;/li&gt; &lt;li&gt;{{ $value }}&lt;/li&gt; {{/each}}该语法被称之为mustache语法，八字胡 template(&#39;script 标签 id&#39;, {对象}) &lt;script src=\"./node_modules/art-template/lib/template-web.js\">&lt;/script> &lt;script type=\"text/template\" id=\"tql\"> hello{{ name }} 今年 {{ age }} 岁了 &lt;/script> &lt;script> var ret = template('tql', { name: 'jack', age: 18 }) console.log(ret); document.querySelector('#表单id号').innerHTML = ret; &lt;/script> nodejs应用核心方法 引入： var template = require(&#39;art-template&#39;); 基于模板名渲染模板template(filename, data); 将模板源代码编译成函数template.compile(source, options); 将模板源代码编译成函数并立刻执行template.render(source, data, options); var ret = template.render('hello {{ name }}', { name: 'Jack' }) 服务端和客户端渲染客户端渲染 服务端渲染 服务端渲染更快，但是会增大服务端的压力（右键查看网页源代码可以看得到具体内容就是服务端渲染），可以被爬虫抓取到 客户端渲染有利于用户体验，但是不利于SEO搜索引擎优化 很多网站是结合两者进行渲染的 10.PathPath是一个核心模块 var path = require(&#39;path&#39;) path.basename(path[,ext]) 获取给定路径当中文件名部分，第二个参数可以用来去除指定的后缀名 console.log(path.basename('c:/a/b/c/index.js')); //index.js console.log(path.basename('c:/a/b/c/index.js', '.js')); //index console.log(path.basename('c:/a/b/c/index.js', '.html')); //index.js path.dirname(path) 方法会返回 path 的目录名 path.extname(path) 返回 path 的扩展名 console.log(path.extname('c:/a/b/c/index.html');); //.html path.isAbsolute(path) 检测 path 是否为绝对路径。(‘./c/index.js’是相对路径， ‘/c/index.js’是绝对路径) path.join([...paths]) 方法会将所有给定的 path 片段连接到一起，生成规范化路径 path.join('/目录1', '目录2', '目录3/目录4', '目录5'); // \\\\目录1\\\\目录2\\\\目录3\\\\目录4\\\\目录5' path.resolve([from...],to) 把一个路径或路径片段的序列解析为一个绝对路径，有点像join，但是解析结果一定是绝对路径 更多知识点可查看nodejs官方文档的Path部分 在文件操作路径中，使用相对路径是不可靠的，因为相对路径设计就是相对于执行node 命令所处的路径， 所以我们要利用好（以下在node中为全局变量，直接用） __filename 当前模块的完整路径 __dirname 当前模块所在文件夹完整路径（所属目录的绝对路径） 配合Path进行操作（比如拼接路径过程中，防止手动拼接带来低级错误，可以使用path.join），把相对路劲变成绝对路径（注意是动态绝对路径）就好了 //express框架公开指定目录 app.use('/node_modules/', express.static(path.join(__dirname, './node_modules/'))); 特殊 ：模块中的路径标识（比如：require(&#39;./a.js&#39;)）是相对于当前文件模块，不受到node命令所处路径影响 其他进程为我们程序的运行提供一个必备的环境（进程是资源分配的最小单位） 线程是计算机中最小的计算单位，线程负责执行保存到进程中的程序（线程是CPU调度的最小单位） JS、浏览器、nodejs是单线程 修改完自动重启服务器我们这里可以使用一个第三方工具：nodemon来帮我们解决修改代码重启服务器问题 #--global 来安装则可以在任意目录执行 npm install --global nodemon 原来我们在命令行输入：node xxx.js 现在：nodemon xxx.js， 他会监视你的文件变化，当文件变化时，会自动帮你重启服务器","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript进阶ES5+面向对象","slug":"JavaScript进阶ES5+面向对象","date":"2020-12-08T09:52:15.778Z","updated":"2021-03-20T16:12:01.054Z","comments":true,"path":"2020/12/08/javascript-jin-jie-es5-mian-xiang-dui-xiang/","link":"","permalink":"https://taylor12138.github.io/2020/12/08/javascript-jin-jie-es5-mian-xiang-dui-xiang/","excerpt":"","text":"1.编程思想介绍面向过程（POP）：分析解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一步一步调用就行了 面向对象（OOP）：把事物分解成一个个对象，然后由对象之间分工合作（找出对象出来，然后写出这些对象的功能） 面向过程的性能比较高，适合和硬件联系很紧密的东西，如单片机，缺点是难维护、难拓展、难复用 面向对象的代码灵活，代码可复用性高，容易维护和开发，更适合多人合作的大型软件项目 面向对象：封装性（直接使用，不需要了解内部）、继承性、多态性（多功能） 2.面向对象1.抽取对象公共属性和行为组织封装成一个类（class） class name { class body } 2.对象实例化，获取类的对象（对象是特指某一个，实例化的具体对象） var xx = new name() 利用类创建对象 对象由属性和方法构成 tip： （1）class关键字创建类，类名习惯定义首字母大写 （2）constructor()是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有明显定义，类内部会自动给我们创建一个constructor()（最好自己写上constructor） class Star { constructor(uname, age) { this.name = uname; this.age = age; } } var xxx = new Star('xxx', 20); 类里添加方法1.在类里面构造函数，不需要加function 2.多个方法、函数之间不需要添加逗号进行分割 class Star { constructor(uname) { this.name = uname; } init() { //xxxx } } 类的继承使用extends进行继承 super关键字用于访问和调用对象父类上的函数，可以调用父类的构造函数，也可以调用父类的普通函数（super必须在字类this的之前进行调用，即必须先调用父类的构造函数，再使用子类的构造函数） 不过要注意的是：（错误❌） class Father { constructor(x, y){ this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } class Son extends Father { constructor(x, y) { this.x = x; this.y = y; } } var son = new Son(1, 2); son.sum(); //会报错 因为此时参数传递给子类的constructor的x和y，而父类的sum函数用的是父类的constructor的x和y，所以应该改为以下函数： class Father { constructor(x, y){ this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } class Son extends Father { constructor(x, y) { //调用父类的构造函数 super(x, y); } } var son = new Son(1, 2); son.sum(); //success 继承中属性或者方法的查找原则：就近原则 在继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就执行子类的 如果没有，就去查找父类有没有此方法，如果有就执行父类的 如果子类想要直接调用父类的方法，则： class Father { say() { //xxx } } class Son extends Father { say() { //调用父类的普通函数 super.say(); } } var son = new Son(); son.say(); 需要注意的三点1.ES6中类没有变量提升，所以必须先定义类，才能通过实例化对象 2.类里的共有属性和方法一定要加this进行使用 （this指向我们创立的·实例化对象） var that; class Father { constructor(uname, age) { //that = this; this.uname = uname; this.age = age; //this.sing(); 加小括号会立即调用 this.btn = document.querySelector('button'); this.btn.onclick = this.sing; this.init(); } init() {} sing() { //这里的this指向的是调用者，所以btn点击事件发生时，this.uname指向的是btn的uname console.log(this.uname); //所以可以外面定义变量，然后让btn固定打印的是该对象的uname //console.log(that.uname) } } 3.构造函数和原型在ES6（ECMAScript6.0）之前，JavaScript没有类的概念，在ES6之前，对象不是基于类创建的，而是用一种称为构造函数的特殊函数来定义对象和他们的特征的。 创建对象：(JavaScript基础也有做过笔记) 1.对象字面量 var obj = {} 2.new Object() var obj = new Object() 3. 自定义构造函数function 构造函数名(){ this.属性=值; this.方法=function (){} } 1.使用构造函数，构造函数名字首字母最好大写如 function Star()2.构造函数不需要return3.使用函数new 构造函数名();即构造一个对象，如new Array()，创建一个数组对象4.属性方法前必须加this如this.name=传参name this.song = function（传参）{} 构造函数中属性和方法我们称之为成员，成员可以添加 实例成员：实例成员就是构造函数内部通过 this 添加的成员 ，实例成员只能通过实例化的对象来访问，不可以通过构造函数访问实例成员，如 function Star(uname){ this.uname = uname; } let star = new Star('xxx'); console.log(star.uname); 静态成员：在构造函数本身上添加的成员，静态成员只能通过构造函数来访问，不能通过对象来访问，如 function Star() {}; Star.sex = 'male'; console.log(Star.sex); 构造函数虽然好用，但是存在浪费内存的问题 构造函数原型对象prototype构造函数通过原型分配的函数是所有对象所共享的 JavaScript规定，每个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype（原型）就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有 因此，我们把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这个方法 使用方法： function Star(uname){ this.uname = uname; } //第一种写法： Star.prototype.sing = function() {} // Star.prototype.sex = 'male'; //第二种写法： Star.prototype = { constructor: Star, //不可省略，因为这种写法覆盖掉原来的constructor方法 sing: function() {}, movie: function() {} } 所以一般情况，我们的公共属性定义到构造函数里面，公共的方法我们放到原型对象的身上 原型对象的this指向谁调用，指向谁 1.在构造函数中，this指向的是对象实例 2.原型对象里面的this指向的也是调用它的实例对象 对象原型: __proto__对象都会有一个属性 __proto__ 指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为 __proto__ 的存在 实例化的对象.__proto__ === 构造函数名.prototype 返回true constructor构造函数对象原型（__proto__）和构造函数原型对象（prototype）里面都有一个constructor属性，constructor我们称为构造函数，因为它指回构造函数本身 主要目的：用于记录该对象引用于哪个构造函数（很多情况下我们需要用它来指回原来的构造函数） 原型链任何构造函数原型对象prototype，它作为一个对象，也有它自己的对象原型 __proto__ ，而此时原型对象的 __proto__ 指向的是Object.prototype， 即某构造函数名.prototype.__proto__ === Object.prototype 而我们Object也有prototype原型对象，而它作为一个对象，也有它自己的对象原型 __proto__ ，而此时指向null（到达了终点） 即Object.prototype.__proto__ === null JavaScript成员查找机制： 所以在成员查找时，先查找最底层，没有则根据它 的__proto__查找至他的原型对象，看看有没有该成员，没有的话继续一层一层往上查找，如果找不到该成员 ，最后返回undefined (undefined是由null派生而来的) 而根据查找规则，使用就近原则来处理重复成员定义问题（即先找到，先使用） 拓展内置对象可以通过原型对象，对原来的内置对象进行拓展自定义的方法，比如给数组增加自定义求偶数和的功能 //在Array原型对象上追加函数，不能采取Array.prototype = {}形式 Array.prototype.sum = function() { let sum = 0; for(let i = 0; i &lt; this.length; i++){ sum+=this[i]; } return sum; } 4.继承在ES6之前没有给我们提供extends，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承 call()fun.call(thisArg, arg1, arg2....) （arg n那些指的是传递的其他参数） 功能：调用这个函数，并且修改函数运行时this的指向 thisArg: 当前调用函数的this的指向对象（一般在JavaScript中直接调用函数时，函数的this指向window） ES5继承的两大步借用构造函数继承父类型的属性 核心原理：通过call() 把父类型的this指向子类型的this，这样就实现了子类型继承父类型的属性 利用原型对象继承父类型的方法 实现如下： // 借用父构造函数继承属性 function Father(uname, age) { this.uname = uname; this.age = age; } //接用父构造函数继承方法 Father.prototype.teach = function () { console('father') } function Son(uname, age) { Father.call(this, uname, age); } // 这样直接赋值会出问题，因为是赋值父原型对象的地址，如果修改了子原型对象，父原型对象也会随之改变 // Son.prototype = Father.prototype; × // 正确方法： Son.prototype = new Father(); // 如果利用了对象形式修改了原型对象，别忘了利用constructor指回原来的构造函数 Son.prototype.constructor = Son; Son.prototype.exam = function () { console('son') } let son = new Son('xxx', 18); console.log(son); 类的本质class本质还是function（用typeof查看），所以我们可以认为类就是构造函数的另一种写法 但是新的class写法只是让对象原型的写法更加清晰，更像面向对象编程的语法 和构造函数相同点： 1.类也有原型对象prototype，而prototype里的constructor也是指回类的本身 2.类也可以利用原型对象添加方法 3.类创建的实例对象中的 __proto__ 原型指向类的原型对象 5.ES5新增的方法数组方法1.forEach() ： arr.forEach(function(vlaue, index, [array])) 分别对应数组的value（值）、index（索引号）、数组本身 （遍历数组的全部元素，即使return true也不会终止迭代） （因为forEach本质是一个函数，参数是一个回调函数，回调函数的return只是终止了回调函数而已，不是终止forEach，而forEach内部应该是多次调用了那个函数） 2.filter(): filter() 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组 （注意它直接返回一个新数组） array.filter(function(currentValue, index, [arr])) 分别对应currentValue（数组当前项的值），index（索引号），arr（数组本身），它的回调函数返回的必须是一个Boolean值，返回true自动将value加入新数组中，false则过滤掉，最后整体返回一个新数组 var newArr = arr.filter(function(value, index) { return value >= 20; }) 3.some() ：some()方法用于检测数组中的元素是否 存在 满足指定条件，通俗点就是查找数组中是否有满足条件的元素，找到第一个满足条件的元素则停止 （注意它返回的是布尔值）在some里设置return true 以终止遍历 array.some(function(currentValue, index, [arr])) 分别对应currentValue（数组当前项的值），index（索引号），arr（数组本身） 4.map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。和forEach相似，不同在于： ​ 如果更改数组内的值，forEach 不能确保数组的不变性。这个方法只有在你不接触里面的任何值时，才能保证不变性。 ​ 由于它们之间的主要区别在于是否有返回值，所以你会希望使用 map 来制作一个新的数组，而使用 forEach 只是为了映射到数组上(修改原来的数组) 返回值加入新数组中 let newarr = arr.map(function(value, index) { return value * 2; }) map的不变性：当数组为基础类型时原数组不变 let array=[1,2,3,4,5] let newArray=array.map((item) => item*2) console.log(array); // [1,2,3,4,5] console.log(newArray);//[2, 4, 6, 8, 10] 当数组为引用类型时原数组发生改变： let array = [{ name: 'Anna', age: 16 }, { name: 'James', age: 18 }] let newArray=array.map((item) => { item.like='eat'; return item; }) console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}] console.log(newArray);//[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}] 5.every() 方法用于检测数组所有元素是否都符合指定条件 6.arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 参数分别对应回调函数和初始值 对数组中所有内容进行汇总，点像递归 let total = a.reduce(function (preValue, currValue) { return preValue + currValue; }, 0); // 遍历到第一次时，preValue为初始值，currValue为数组里的第一个值 // 遍历到第二次时，preValue为第一次返回的值，currValue为数组里第二个数 以上ES5数组方法有助于链式编程（函数式编程），比如： //this.$store.state.cartList 是一个数组 this.$store.state.cartList .filter((item) => item.checked === true) .reduce((preValue, item) => { return preValue + item.count * item.price; }, 0) .toFixed(2); 字符串方法trim()方法会从一个字符串的两端删除空白字符，它并不影响本身的字符串，它返回的是一个新的字符串 str.trim() 对象方法Object.defineProperty() 定义对象中新属性或修改原有的属性（应用于vue响应式双向绑定，还有es5实现const的原理） Object.defineProperty(obj, prop,desciptor) obj：必须，目标对象 prop： 必需，需定义或修改的属性名 descriptor： 必须，目标属性所拥有的特性，一对象的形式{ }进行书写， value设置属性的值，默认undefined； writable值能否重写（修改），默认为false； enumerable：目标属性是否可以被枚举(是否可以被遍历，显示出来)，默认false； configurable目标属性是否可以被删除，或者再次修改特性（是否可以再次更改这个descriptor），默认false； 除此外还具有以下可选键值： get：当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。 set：当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象(修改后的值)。 var obj = { id: 1, pname: '小米', price: 1999 } //以前的对象添加修改方式 //obj.num = 1000; //obj.price = 99; Object.defineProperty(obj, 'num', { value = 999, enumerable = true }) Object.keys(obj) 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。 6.函数定义和调用函数定义： 1.自定义函数：function fn() {}; 2.匿名函数： var fun = function() {}; 3.new Function(&#39;参数1&#39;, &#39;参数2&#39;, &#39;函数体&#39;)形式调用 像构造函数, Function里面的参数都必须是字符串格式 var f = new Function('a', 'b', 'console.log(a + b)'); 实际上所有的函数都是Function的实例 函数也属于对象 函数调用： 1.普通函数调用 function fn() { //something } fn(); 2.对象方法 var o = { say: function() { //something } } o.say(); 3.构造函数 function Star() {}; new Star(); 4.绑定事件函数btn.onclick = function() {} 5.定时器函数 setInterval(function() {}, 1000); 6.立即执行函数（自动调用） (function() {} )(); 7.this的指向函数内this的指向是当我们调用函数时确定的，调用方式不同导致this指向不同 1.普通函数调用：window 2.构造函数调用：实例对象，原型对象也是指向实例对象 3.对象方法：该方法所属对象 4.事件绑定：绑定事件对象 5.定时器函数：window 6.立即执行函数：window 但是立即执行函数还得看这时this是否在对象方法或者构造函数中，第二个虽然是立即执行函数，但是它先找的是全局变量foo，再找到foo.bar，所以this返回的是foo作用域的a var a = 1; var foo = { a: 2, bar: function () { return this.a; } }; console.log(foo.bar()); //2 console.log((foo.bar)()); //2 console.log((foo.bar=foo.bar)()); //1 “匿名函数的执行环境具有全局性”，所以最里层那个函数中this指向全局环境，全局环境没有定义foo变量所以输出undefined。在匿名函数外部将this保存到一个内部函数可以访问的变量self中，可以通过self访问这个对象，所以self.foo为bar var myobject = { foo: \"bar\", func: function () { var self = this; console.log(this.foo); console.log(self.foo); (function () { console.log(this.foo);//undefined console.log(self.foo);//bar })(); } }; myobject.func(); 类的this指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 class Logger { printName(name = 'there') { this.print(`Hello ${name}`); } print(text) { console.log(text); } } const logger = new Logger(); const { printName } = logger; printName(); // TypeError: Cannot read property 'print' of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错。 （1）一个比较简单的解决方法是，在构造方法（constructor）中绑定this，这样就不会找不到print方法了。 class Logger { constructor() { this.printName = this.printName.bind(this); } // ... } （2）另一种解决方法是使用箭头函数。 class Obj { constructor() { this.getThis = () => this; } } const myObj = new Obj(); myObj.getThis() === myObj // true 改变this指向JavaScript为我们专门提供了一些函数方法来帮助我们处理函数内部this指向问题，常用的有bind()、call()、apply()三种方法 1.call()前面讲过，call的主要作用可以实现继承 2.apply()方法调用一个函数，简单理解为调用函数的方式，但是它可以改变this的指向 fun.apply(thisArg, [argsArray]) thisArg：在函数执行时指定的this对象 argsArray: 传递的值，必须包含在数组（伪数组）里面（这个是和call的不同点） 返回值为函数的返回值，因为它就是调用函数 应用方面：apply传递数组参数，所以可以借助数学内置对象求最大值 Math.max.apply(Math,arr) （es6拓展运算符…Math.max(...arr)也可以，但是不能 MAth.max(arr)，因为max不接受数组，只接受一个一个的参数） 3.bind()方法不会调用函数，但是能改变函数内部this指向 fun.bind(thisArg, arg1, arg2....) 返回指定this值和初始化参数改造的原函数拷贝（即创造新的函数 var f = fn.bind(xx)） 应用方面：定时器等不想立即调用的函数（或者处理其他只能用that来暂时储存对象的情况） btn.onclick = function() { this.disabled = true; //var that = this; //old way: /*setTimeout(function() { //that.disabled = false; }, 3000)*/ //new way: setTimeout(function() { this.disabled = false; }.bind(this), 3000) //这个this指向btn } 巧妙运用： 传参的时候可以传递其他对象过来 class Tab { constructor(id) { this.main = document.querySelector(id); //tabsbox this.lis = this.main.querySelectorAll('li'); } // 初始化 init() { for (let i = 0; i &lt; this.lis.length; i++) { this.lis[i].onclick = this.toggleTab.bind(this.lis[i], this); } } // 切换功能 toggleTab(that) { that.clearTab(); this.className = 'liactive' that.sections[this.index].className = 'conactive'; } } 8.严格模式ie10以上版本才支持 它是让JavaScript以严格的条件下运行代码 1.消除了JavaScript一些语法不严谨的地方，减少怪异行为 2.消除代码一些不安全之处，保证代码运行的安全 3.提高编译器效率，增加运行速度 4.禁用了ECMAscript在未来版本中可能会定义的一些语法，为未来JavaScript做好铺垫，比如class、enum、super等 开启严格模式应用到整个到整个脚本或个别函数中，因此，我们可以讲严格模式分为脚本开启严格模式和为函数开启严格模式两种情况 为脚本开启严格模式： &lt;script> \"use strict\"; //xxxx &lt;/script> 方法二：（写在立即执行函数里的都要按照严格模式） &lt;script> (function() { \"use strict\"; /xxxx })(); &lt;/script> 为函数开启严格模式：(只在此函数内部有严格模式) &lt;script> function fn(){ \"use strict\"; /xxxx } &lt;/script> 变化1.严格模式禁止变量为声明就赋值 2.严禁删除已声明的变量，比如delete x; 是错误的 3.在严格模式下，全局作用域中函数中的this不再是window，而是undefined（但是定时器之类的还是指向window） 4.严格模式下，如果构造函数不配合new来使用，this就会报错 5.函数不能有重名参数 6.函数必须声明在顶层，因为新版本的JavaScript引入了块级作用域，所以不允许在非函数代码块内声明函数 9.变量的作用域Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量。 另一方面，在函数外部自然无法读取函数内的局部变量。 var n=999; function f1(){ alert(n); } f1(); // 999 function f1(){ var n=999; } alert(n); // error 一定要使用var命令，如果不用的话，你实际上声明了一个全局变量 function f1(){ n=999; } f1(); alert(n); // 999 如果想要从外部读取内部的局部变量，则需要使用到：闭包！ 10.闭包闭包指有权访问另外一个函数作用域中变量的函数，简单理解就是一个作用域可以访问另外一个函数内部的局部变量 （被访问作用域的函数就是闭包函数） //在此处fun函数作用域访问了另外一个函数fn里面的局部变量num，形成了闭包，此时fun就是闭包 //fun被赋予了一个全局变量，所以fun始终保存在内存中，而fun依赖fn的num，因此num也始终在内存中 function fn() { var num = 10; function fun() { console.log(num); } fun(); } fn(); 在fn外部作用域访问fn内部局部变量（它返回了当时的作用域）： //所以闭包就是典型的高阶函数 function fn() { var num = 10; return function() { console.log(num) } } var f = fn(); f(); 闭包的主要作用： 延伸了变量的作用范围（读取函数内部的变量） 让这些变量的值始终保持在内存中 闭包缺点： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 利用闭包解决异步问题：（因为函数是一个作用域） //立即执行函数也成为了小闭包，因为立即执行函数里面任何一个函数都可以使用它的i变量，此时里面使用外层i的函数，都是闭包 for (var i = 0; i &lt; lis.length; i++) { (function (i) { lis[i].onclick = function () { console.log(i) } })(i); } 回调函数：获取异步操作的结果 一般情况下，把函数作为参数的目的就是为了获取函数内部的异步操作的结果 //如果需要获取一个函数中异步操作的结果，则必须通过回调函数来获取 function fn(callback) { setTimeout(function () { var data = 'hello'; callback(data); }, 1000) } fn(function (data) { console.log(data); }) 11.递归如果一个函数在内部可以调用其本身，则这个函数是递归（俄罗斯套娃） 但是容易发生“栈溢出”错误，所以必须加退出条件“return” 浅拷贝和深拷贝（jQuery篇目有提及到（$.extend([deep], target, object1, [objectN])）） 1.浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用 2.深拷贝拷贝多层，每一级别的数据都会拷贝 ES6中浅拷贝的语法糖：Object.assign(target, ...source)（把source拷贝给target） 利用循环写浅拷贝 var obj = { id: 1, name: 'andy', msg: { age: 18 } }; var o = {}; for (var k in obj) { // k是属性名， obj[k]是属性值 o[k] = obj[k]; } 利用递归写深拷贝 var obj = { id: 1, name: 'andy', msg: { age: 18 } }; var o = {}; function deepcopy(newobj, oldobj) { for(var k in oldobj) { // 获取属性值 var item = oldobj[k]; // 判断该值是否属于数组(数组也属于object，所以要先写) if(item instanceof Array) { newobj[k] = []; deepcopy(newobj[k], item); } else if(item instanceof Object) { // 判断该值是否为对象 newobj[k] = {}; deepcopy(newobj[k], item); } else { // 所以剩下的属于简单数据类型 newobj[k] = item; } } } deepcopy(o, obj); console.log(o); 12.正则表达式概述正则表达式（regular expression）是用于匹配字符串中字符组合的模式，再JavaScript，正则表达式也是对象 正则表达式通常用来做检索，替换那些符合某个模式（规则）的文本，例如昵称输入框里的对中文的匹配；此外，正则表达式还常用于过滤掉页面一些敏感（替换），或者从字符串获取我们想要的特定部分（提取）等 特点：1.灵活性、逻辑性、功能性非常强 2.可以迅速用极简的形式达到对字符串复杂的控制 3.对刚接触的人来说，比较晦涩难懂 4.一般实际开发，都是直接复制写好的正则表达式，但是要求会使用正则表达式且根据实际情况修改正则表达式 应用1.通过调用RegExp对象的构造函数创建 var 变量名 = new RegExp(/表达式/修饰符) var 变量名 = new RegExp(&#39;表达式&#39;, &#39;修饰符&#39;) 2.通过字面量创建 var 变量名 = /表达式/修饰符（正则表达式不需要加引号，不管是数字型还是字符串型） 测试正则表达式是否符合语法规范：test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数是测试字符串 regexObj.test(str) （只要包含有str这个字符串，返回的都是true） var rg = /123/; var rg2 = /123/g; console.log(rg.test(123)); //true console.log(rg.test(12123)); //true g：全局模式，查找字符串全部内容，不是找到第一个匹配就结束 i：不区分大小写 m：多行模式，表示查找到一行末尾会继续查找 y：粘附模式，表示只查找从lastIndex开始之后的字符串 u：Unicode模式 s：dotAll模式，表示元字符 . 可以匹配任何字符 let a = \"address_address\"; let rg = /a/g; let reg = new RegExp(a, \"g\") //在正则中使用变量 rg.test(\"字符串\"); //是否包含该字符串，返回布尔值 eval(`/a${a}/`).test(\"字符串\") //在正则中使用变量 + 其他字符 a.match(rg); //返回匹配的字符串 + 具体信息，若正则启用全局模式，则返回一个数组，返回所有匹配的字符串 rg.exec(a); //和match差不多，只不过不受全局模式的影响，如果开全局模式，下次再匹配一次，则从lastIndex //开始匹配，在这里也就是从 下标为1的d 开始匹配 特殊字符一个正则表达式可以由简单的字符构成，比如/abc/， 也可以是简单和特殊字符串的组合，比如/ab*c/。其中特殊字符也被称为元字符，在正则表达式中具有特殊意义的专用符号，如^ 、$ 、+ 等 （匹配特殊字符前面增加 \\就可以了） 正则表达式速查表：https://www.runoob.com/regexp/regexp-metachar.html 边界符：^ 表示匹配行首的文本（以谁开始） $ 表示匹配行尾的文本（以谁结束） var rg = /^abc/; console.log(rg.test('abcd')); //true console.log(rg.test('babc')); //false //必须是abc,类似全等 var rg2 = /^abc$/; console.log(rg.test('abcd')); //false console.log(rg.test('abcabc')); //false 字符类：[]表示有一系列字符可供选择，只要匹配到其中一个就可以了 var rg = /[abc]/; //只要包含有a或者b或者c就返回true console.log(rg.test('andy')); //返回true //var rg = /^[abc]$/ 是三选一，只有是单个a或者b或者c才返回true []使用范围符号 - var rg = /^[a-z]$/; //26个英文小写字母任何一个字母都返回true var rg1 = /^[a-zA-Z]$/; //26个英文字母任何一个字母都返回true var rg2 = /^[a-z0-9_-]$/; //任何单个26小写字母，0-9数字，_, -,都返回true []里使用^：如果中括号里有^表示取反的意思，千万别和边界符^混淆，要区分开来 var rg = /^[^a-z]$/; //26个英文小写字母任何一个字母都返回false 量词符：用来设定某个模式出现的次数，有*、 +、 ？、 {}，{}的量词间不要有空格，可以用test来检测下方正则表达式 var rg = /^a*$/; //a可以出现0-n次，n>=0 var rg1 = /^a+$/; //a可以出现1-n次，n>=1 var rg2 = /^a?$/; //a可以出现1或0次 (?也可以表示禁止贪婪，往最少的匹配方式去选择) var rg3 = /^a{3}$/; //a只能可以出现3次 var rg4 = /^a{3,}$/; //a只可以出现3-n次 n>=3 var rg5 = /^a{3,16}$/; //a只可以出现3-16次 //普遍的用户名规定： var name = /^[a-zA-Z0-9_-]{6, 16}$/ 括号总结 []中括号：字符集合，匹配方括号中的任意字符 {} 大括号：量词符，里面表示重复次数，但只让大括号前面一个字符重复 （注意：/^abc{3}$/，只让c重复三次，即abccc） () 小括号：表示优先级 可以用来：/^(abc){3}$/，表示让abc重复三次，即abcabc 预定义类\\d 匹配到0-9任意一数字，相当于[0-9] (var rg = /\\d/; 或者 let reg = new RegExp(&quot;\\\\d&quot;)) \\D 匹配到0-9以外的数字，相当于[^0-9] \\w 匹配任意字母、数字、下划线，相当于[A-Za-z0-9_] \\W匹配除字母数字下划线以外的字符，相当于[^A-Za-z0-9_] \\s 匹配空格（包括换行符、制表符、空格符等），相当于[\\t\\r\\n\\v\\f] \\S匹配非空格字符，相当于[^\\t\\r\\n\\v\\f] 正则里的 “或者符号”：| (var rg = /^\\d{3}-\\d{8}|\\d{4}-\\d{7}$/;) . 除了换行外的任何字符 正则替换replace()方法可以实现替换字符串的操作，用来替换的参数可以是一个字符串或者是一个字符表达式 stringObject.replace(regexp/substr, replacement) var str = 'red and blue and red'; var newstr = str.replace('red', 'yellow'); //结果为yellow and blue and red //var newstr = str.replace(/red/, 'yellow'); 同理 但是replace只能替换掉第一个匹配的字符/正则表达式，无法满足替换掉多个敏感词 可以使用: /表达式/[switch] swtich也成为修饰符，即按照什么样的模式来匹配 var str = 'red and blue and red'; var newstr = str.replace(/red/g, 'yellow'); //结果为yellow and blue and yellow","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JQuery","slug":"JQuery","date":"2020-11-29T16:15:30.028Z","updated":"2020-12-23T16:36:12.611Z","comments":true,"path":"2020/11/30/jquery/","link":"","permalink":"https://taylor12138.github.io/2020/11/30/jquery/","excerpt":"","text":"1.JQuery概述JavaScript库：即library，是一个封装好的特定集合（方法和函数），使得我们可以快速高效的使用这些封装好的功能，而jQuery 就是一个 JavaScript函数库 其他常见地js库还有Prototype、YUI、Dojo、ExtJS和移动端的zepto 优点： 1.轻量级，文件够小 2.跨浏览器兼容，基本兼容主流浏览器 3.链式编程、隐式迭代 4.对事件、样式、动画支持，极大地简化了dom的操作，支持插件扩展开发，有丰富的第三方插件 4.免费、开源 官网下载：https://jquery.com/ 最新版本早已不兼容ie6、7、8 等页面dom加载完毕再去执行代码（类似于DOMContentLoaded） //入口函数 $(function() { xxxx }) 要在页面引入官网下载的jQuery的js文件才能使用 2.jQuery的基本使用$是jquery的简称，一般在代码中用$替代jQuery $(function() { $(&#39;div&#39;).hide() }) 相当于 jQuery(function( jQuery(&#39;div&#39;).hide() ) {}) $是jQuery的顶级对象，相当于JavaScript的window，把元素$包装成jQuery对象，就可以调用jQuery方法 jQuery和dom用原生js获取的对象就是dom对象 用jQuery方式获取的对象就是jQuery对象 这两个对象是不一样的 jQuery对象的本质就是利用$对DOM对象包装后产生的对象（伪数组的形式储存） jQuery对象只能用jQuery方法，DOM对象则只能使用原生的JavaScript属性和方法 但是DOM对象和jQuery对象可以相互转换，因为原生js比jQuery更大，原生的一些属性和方法jQuery没有为我们进行封装，想要使用这些属性和方法需要把jQuery转换成DOM对象才能使用 //DOM转jQuery let myvideo = document.querySelector('video'); $(myvideo); //jQuery转DOM $('video')[index]或者$('video').get(index) $('video'); //获取元素 $('video')[0].play(); //将只有一个元素的视频过来并且使用DOM功能 3.jQuery的APIjQuery选择器$(&quot;选择器&quot;) 语法和CSS选择器一样即可 子代选择器 $(&quot;ul&gt;li&quot;) 后代选择器$(&quot;ul li&quot;) jQuery修改样式：$(&quot;div&quot;).css(&quot;属性&quot;, &quot;值&quot;) jQuery有隐式迭代，它会给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再循环，简化我们的操作 //一次性将所有选中的div元素背景颜色改为pink，不再需要for循环一个一个遍历更改 $(\"div\").css(\"background\", \"pink\"); jQuery筛选选择器 $(&quot;li:first&quot;) 选中第一个 $(&quot;li:last&quot;) 选中最后一个 $(&quot;li:eq(x)&quot;) 选中索引号为x的元素 $(&quot;li:odd&quot;) 选中索引号为奇数的元素 $(&quot;li:even&quot;) 选中索引号为偶数的元素 $(&quot;div&quot;).parent(); 返回的是最近一级的父元素 $(&quot;div&quot;).parents(); 返回的是所有祖先元素的数组，可以制定”()”里的类名单独指定是哪个祖先 $(&quot;div&quot;).children(&quot;ul&quot;); 返回指定的亲儿子，类似于子代选择器div&gt;ul $(&quot;div&quot;).find(&quot;li&quot;); 可以选定指定的所有孩子，类似于后代选择器 div li $(&quot;.item&quot;).sibling(&quot;li&quot;); 可以选定除本身外所有亲兄弟元素 $(&quot;li&quot;).eq(x); 选中索引号为x的元素, 类似$(&quot;li:eq(x)&quot;) ，但是此方法更推荐 $(&quot;li&quot;).hasCLass(&quot;类名&quot;); 查看是否有该类名，返回true或false jquery中的快速实现排他思想： $(function() { $(\"button\").click(function() { $(this).css(\"background\",\"pink\"); $(this).siblings(\"button\").css(\"background\", \"\") }) }) jQuery可以快速得到当前元素索引号，不再需要自己添加自定义属性index $(this).index() $(&quot;xxx:checked&quot;) 选择复选框中被选择的元素（$(&quot;xxx:checked&quot;).length为被选中复选框个数） jquery样式操作使用css方法： 1.参数只写属性名，返回属性值 $(this).css(&quot;color&quot;) 2.设置样式，属性名必须加引号，如果属性值值如果是数字可以不用跟单位和引号 $(this).css(&quot;color&quot;, &quot;red&quot;) 3.参数可以用对象的形式(里面的属性名不用加引号，如果如果属性值值如果是数字可以不用跟单位和引号) 如果是复合属性必须采取驼峰命名法（和DOM一样） $(this).css({ width: 400, height: 400, backgroundColor: \"green\" }) 直接设置类方式： 再写一个类，里面包含了所有你想要改变的样式，然后利用jQuery添加类功能，将其添加进去（注意直接添加类名，不需要 “.类名”） (原生js的className进行更改会覆盖原先的类名) // 1. 添加类 addClass() $(\"div\").click(function() { $(this).addClass(\"current\"); }); // 2. 删除类 removeClass() $(\"div\").click(function() { $(this).removeClass(\"current\"); }); // 3. 切换类 toggleClass() $(\"div\").click(function() { $(this).toggleClass(\"current\"); }); jQuery效果显示和隐藏效果 show([speed, [easing], [fn]]) 显示功能，参数可以省略， speed：三种预定字符串（”speed”,”normal”,”fast”）、或者使用毫秒数表示 easing：swing（在开头/结尾移动慢，在中间移动快）、linear（匀速） fn：回调函数 hide([speed, [easing], [fn]]) 隐藏功能，同上 toggle([speed, [easing], [fn]]) 切换（原本显示则隐藏，原本隐藏则显示） 滑动 slideDown([speed, [easing], [fn]]) 下拉显示，类似于手机官网那些下拉菜单，参数功能同上 slideUp([speed, [easing], [fn]]) 上拉隐藏，参数同上 slideToggle([speed, [easing], [fn]]) 拉动切换，参数同上 事件切换 hover([over],out) over: 鼠标移到元素上触发的函数（相当于mouseenter） out：鼠标移出元素触发的函数（类似于mouseleave） 简洁下拉菜单 $(\".nav>li\").hover(function() { $(this).children(\"ul\").slideDown(200); }, function() { $(this).children(\"ul\").slideUp(200); }); 或者 $(\".nav>li\").hover(function() { $(this).children(\"ul\").slideToggle(); }); 动画队列和其停止方法 上述下拉菜单代码有一个问题 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果的排队执行（即鼠标一次性经过多个选项，导致鼠标在一边停下来了之后，动画还在执行（因为还没执行完毕）） 停止排队： stop() stop()用于停止动画或者效果，将其写在动画或者效果的前面，相当于停止结束上一次的动画 //上述示例改进： $(\".nav>li\").hover(function() { $(this).children(\"ul\").stop().slideToggle(); }); 淡入淡出 fadeIn([speed, [easing], [fn]]) 淡入功能，参数可以省略， speed：三种预定字符串（”speed”,”normal”,”fast”）、或者使用毫秒数表示 easing：swing（在开头/结尾移动慢，在中间移动快）、linear（匀速） fn：回调函数 fadeOut([speed, [easing], [fn]]) 淡出 fadeToggle([speed, [easing], [fn]]) 淡入淡出切换 fadeTo([speed, opacity, [easing], [fn]]) 以渐进的方法修改透明度，opacity为透明度，必须写，取值范围0~1，speed也必须写 自定义动画animate animate(params, [speed], [easing], [fn]) params：想要更改的样式属性，以对象的形式传递，必须写，属性名可以不带引号，如果是复合属性需要采取驼峰命名法 其他的speed、easing、fn和之前相同 $(&quot;div&quot;).animate({ left: 500, top: 300, opacity: .4, width: 500 }, 500);4.jQuery属性操作element.prop(&quot;属性名&quot;) 获取属性值（固有的属性值） element.prop(&quot;属性名&quot;, &quot;属性值&quot;) 设置属性值 element.attr(&quot;属性名&quot;) 获取属性值（自定义属性），类似原生的getArribute element.attr(&quot;属性名&quot;, &quot;属性值&quot;) 设置属性值（自定义属性），类似原生的setArribute element.data(&quot;属性名&quot;, &quot;属性值&quot;) 设置数据缓存，data里的数据是存放在元素的内存中，而不是作为属性（这个方法可以获取data-index 即h5自带的自定义属性，不用写data-，写成$(“div”).data(“index”)） 5.jQuery内容文本值element.html() 获取元素内容（包含标签） 相当于原生的innerHTML element.html(&quot;内容&quot;) 设置元素内容 element.text() 获取元素内容（不包含标签） 相当于原生的innerText element.text(&quot;内容&quot;) 设置元素内容 element.val() 获取表单值 element.val(&quot;表单值&quot;) 设置表单值 6.jQuery的元素操作虽然jquery有隐式迭代，但是只是对同类元素做相同操作，如果想要给不同元素进行不同的操作，就需要使用到遍历 jQuery的遍历$(&quot;div&quot;).each(function (index, domEle) { xxxx; }) index（第一个参数）是每个元素的索引号，domELe（第二个参数）是遍历后的每个DOM元素对象，不是jQuery对象，如果想使用jQuery方法，需要给这个dom元素转换为jQuery对象（$(domEle)） $.each(object, function(index, element) { xxx; }) $.each() 方法可以用于遍历任何对象，主要用于数据处理，如数组、对象，index（第一个参数）为索引号（如果是对象，则为属性名），element（第二个参数）为遍历内容（如果是对象，则为属性值） 创建元素 $(&quot;&lt;li&gt;&lt;/li&gt;&quot;) 动态创建一个li标签 添加元素（创建完之后需要添加元素） 内部添加：（生成后它们是父子关系） element.append(&quot;内容&quot;) 放到匹配元素的最后面，类似于原生的appendChild element.prepend(&quot;内容&quot;) 放到匹配元素的最前，类似于原生的ul.insertBefore(xx, ul.children[0])(指定元素的前面) 外部添加：（生成后它们是兄弟关系） 外部添加：element.after(&quot;内容&quot;) 把内容放入目标元素的后面 element.before(&quot;内容&quot;) 把内容放入目标元素前面 删除元素element.remove() 删除匹配元素 element.empty() 删除匹配元素的所有子节点 element.html(&quot;&quot;) 清空匹配元素的内容（孩子） 7.jQuery事件事件注册element.事件(function() {}) 单个事件注册 如 $(&quot;div&quot;).click(function() {事件处理}) 其他事件和原生基本一致 事件处理on(可以绑定多个事件)on() 方法在匹配元素上绑定一个或多个事件的事件处理函数 element.on(events, [selector], fn) 1.events: 一个或多个用空格的事件类型，如”click” 2.selector: 元素的子元素选择器 3.fn：回调函数，即绑定在元素身上得到侦听函数 如 $(\"div\").on({ mouseenter: function() { //xxxxx }, click: function() { //xxxxx }, mouseleave: function() { //xxxx } }) 不同事件类型触发同一处理函数： $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() {}) on的优势2：可以进行事件委托如 //传统，但是给每个li都添加了一个事件，比较麻烦 $(\"ul li\").click(); //事件是绑定在ul身上，但是触发对象时li，li事件冒泡，冒泡到父级的点击事件然后执行程序 $(\"ul\").on(\"click\", \"li\", function() { }) 此前有blind()、live()等方法处理事件绑定或事件委托，但是我们最新版本用on就行了 on的优势3：动态创建元素，on可以给未来动态创建的元素绑定事件//传统，前面绑定事件，后面创建的标签没有绑定该事件 $(\"ol li\").click(function() {}) let li = $(\"&lt;li>xxx&lt;/li>\"); $(\"ol\").append(li); //使用on,之后创建的也能被给予绑定效果 $(\"ol\").on(\"click\", \"li\", function() {}) let li = $(\"&lt;li>xxx&lt;/li>\"); $(\"ol\").append(li); 事件off解绑off()方法可以移除通过on()方法添加的事件处理程序 element.off() 解绑该元素上所有事件 element.off(&quot;click&quot;) 解绑该元素上点击事件 $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() {}) $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;) 解除事件委托 只使用一次: 用one()来绑定有的事件只想触发一次，可以使用one来绑定 element.one(event, fn) 自动触发事件trigger比如click事件： 1.element.click() 2.element.trigger(&quot;click&quot;) 和上面的差不多 3.element.triggerHandler(&quot;click&quot;) triggerHandler不会触发元素默认行为（包括该元素绑定的其他行为），只触发”click” 事件对象element.on(events, [selector], function(event) {}) 中的event为事件对象 event.preventDefault() 或者return false 用于阻止默认行为 event.stopPropagation() 将其写于事件函数中，可以用于阻止冒泡 8.jQuery的其他方法jQuery拷贝对象$.extend([deep], target, object1, [objectN])（如果有冲突的，会覆盖掉targetObj 里面原来的数据） 1.deep: 如果为true为深拷贝，默认false为浅拷贝 （注意是复杂数据类型）浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝的对象，如果该复杂数据类型对象有冲突，直接覆盖掉 深拷贝，完全克隆，对于复杂数据类型拷贝的是对象，不是地址，修改目标对象不会影响被拷贝的对象（如果该复杂数据类型对象有冲突，但是里面的属性不冲突，则属性会合并在一起） //深拷贝时targetObject的msg会与obj的msg合并 //此时都有id，obj的id会覆盖掉targetObject的id var targetObject = { id: 0, msg: { sex: '男' //对象复杂数据类型 } }; var obj = { id: 1, name: 'andy', msg: { age: 18 } } $.extend(targetObject,obj); 2.target：要拷贝的目标对象 3.object1：待被拷贝到第一个对象的对象 （object拷贝给target） jQuery·多库共存随着jquery的流行，其他js库也会使用$作为标识符，这样一起使用会起冲突 需要一个解决方案，让jQuery和其他js库不存在冲突，可以同时存在，这就叫做多库共存 jquery解决方案： 1.把里面的$符号统一改为jQuery ，比如jQuery(“div”) 2.自定义，释放对$对控制权 var suibian = $.noConflict(); //var suibian = jQuery.noConflict(); suibian(\"span\") //原本是$(\"span\") jQuery插件jQuery功能比较有限，想要更加复杂的效果，可以借助jQuery插件（注：这些插件是依赖于jQuery，所以必须先引入jQuery文件，因此也成为jQuery插件） jquery常用网站： 1.jQuery插件库：http://www.jq22.com/ 2.jQuery之家：http://www.htmleaf.com/ (推荐) jQuery插件使用步骤：1.引入相关文件（jQuery、插件文件） 2.赋值相关html、css、js 图片懒加载: 在jQuery·插件可以找到，图片只加载到可视区域，减缓服务器压力 全屏滚动：jQuery的fullPage.js也十分好用 bootstrap也是依赖于jQuery开发的，因此里面的js插件使用，也必须引入jQuery文件 jQuery的位置位置主要有三个：offset()可设置、 position()只读、 scrollTop()/scollLeft()可设置 element.offset() 返回一个对象，里面包含left和top，用于设置或获取相对于文档document的偏移坐标 但是和原生不同的是，它可以设置偏移：element.offset({top: 10, left: 30})，且原生js的offset返回的是相对于父元素的偏移量 element.position() 获取带有相对于父级的偏移距离，如果没有定义父级，则以文档为准，但是此方法只能获取不能设置 element.scrollTop()/element.scrollLeft()设置或获取被卷去的头部和左侧，类似于原生js自带的元素滚动scroll","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"前端关于存储","slug":"前端关于存储","date":"2020-11-27T16:00:00.000Z","updated":"2021-03-26T09:06:39.000Z","comments":true,"path":"2020/11/28/qian-duan-guan-yu-cun-chu/","link":"","permalink":"https://taylor12138.github.io/2020/11/28/qian-duan-guan-yu-cun-chu/","excerpt":"","text":"本地存储1.数据存储于自己的浏览器当中 2.设置、读取十分方便，页面刷新数据不丢失 3.容量较大，sessionStorage约5M，localStorage约20M（可是我测试得到我chrome浏览器localStorage才5M） 4.只能存储字符串，可以将对象JSON.stringify() 编码后存储 cookie是网站为了标示用户身份而储存在用户本地终端上的数据；cookie数据始终在同源的http请求中携带（即使不需要），也会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存； window.sessionStorage1.生命周期为关闭浏览器窗口 2.同一个窗口下数据可以共享 3.以键值对的形式存储使用 window.sessionStorage.setItem(key, value) 分别对应键和值，设置（添加或更改） window.sessionStorage.getItem(&#39;key&#39;) 获取 window.sessionStorage.removeItem(&#39;key&#39;) 删除 window.sessionStorage.clear() 删除所有数据(慎用) window.localStorage1.生命周期永久生效，除非手动删除，不然关闭页面仍然存在 2.多窗口共享（同一浏览器才能共享） 3.以键值对的形式存储使用 window.localStorage.setItem(key, value) 分别对应键和值，设置（添加或更改） window.localStorage.getItem(&#39;key&#39;) 获取 window.localStorage.removeItem(&#39;key&#39;) 删除 window.localStorage.clear() 删除所有数据(慎用) cookiehttp协议是无状态的，但是在实际工作中，一些万维网网站希望能识别用户（给用户推销产品）=&gt;诞生了cookie小饼干，cookie是存储在用户主机的文本文件，记录一段时间内某用户的访问记录 工作中识别用户给用户推销产品，用来保存一些不太敏感的数据 cookie数据大小不能超过4k cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 Sessioncookie和session都是用来跟踪浏览器用户身份的会话方式，通常使用cookie方式存储session ID到客户端 保持状态：cookie保存在浏览器端，session保存在服务器端 存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。 安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。 应用： cookie判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）；保存上次登录的时间等信息。 Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。 （1）网上商城中的购物车 （2）保存用户登录信息 （3）将某些数据放入session中，供同一用户的不同页面使用 （4）防止用户非法登录 session缺点： Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"PC&移动端网页特效(JS)","slug":"PC&移动端网页特效(JS)","date":"2020-11-17T16:00:00.000Z","updated":"2021-03-16T06:33:16.669Z","comments":true,"path":"2020/11/18/pc-yi-dong-duan-wang-ye-te-xiao-js/","link":"","permalink":"https://taylor12138.github.io/2020/11/18/pc-yi-dong-duan-wang-ye-te-xiao-js/","excerpt":"","text":"PC端1.offset元素偏移量我们使用offset系列相关属性可以动态获取元素的位置（大小）（父亲要定位此功能才有用 element.offsetTop 返回元素相对带有定位父元素上方的偏移，不带单位，如果没有定位或者没有父元素则以body为准 element.offsetLeft 返回元素相对带有定位父元素左方的偏移，情况同上 element.offsetWidth 返回自身宽度大小，自身宽度+padding+border element.offsetHeight 返回自身高度大小，同上 element.offsetParent 返回带有定位的父亲，否则返回body（element.parentNode 直接返回最近一级的父节点，不管父节点是否有定位） offset和style的区别：offset可以得到任意样式表的样式值 style只能得到行内样式表的样式值 offset系列获得的数值没有带单位 style.width获得的是带单位的字符串 offsetWidth等是包含padding+border style.width获得不包含padding和border的值 offsetWidth等属性是只读属性，只能获取不能赋值 style.width是可读写属性，可以赋值 所以offset适合读值，style适合赋值改值 2.元素可视区client通过client系列的相关属性可以动态得到该元素的边框大小、元素大小等（与offset不同点是边框是否囊括其中） element.clientTop 返回元素上边框的大小 element.clientLeft 返回元素左边框的大小 element.clientWidth 返回自身包括padding、内容区的宽度，不包含边框，返回数值不带单位 element.clientHeight 同上，返回高度 （番外）立即执行函数立即执行函数，不需要调用，直接执行 传统： function fn() {} fn(); 立执： (function(a, b) {}(1, 2)) //第一种 (function(a, b) {})(参数1, 参数2) //第二种 立即执行函数最大的优点就是独立创建了一个作用域 3.元素滚动scroll获取或设置一个元素的内容垂直滚动的像素数 有点像client，但是client是盒子的大小宽高，即使内容溢出后保持不变，但是scroll面对溢出状态的盒子，它提供的宽高与内容溢出的宽高相互关联。 element.scrollHeigh 返回自身高度，不含边框，不带单位 element.scrollWidth 返回自身宽度，不含边框，不带单位 element.scrollTop 返回被滚动条卷上去的上方距离，返回数值不带单位（要有滚动条，且内容大于盒子，往下拉的时候才会有） element.scrollLeft 返回被滚动条卷左的左侧距离，同上 滚动条在滚动时发生的事件：onscroll事件 检测整个页面的滚动属性： window.pageYOffset window.pageXOffset等 (ie9以上才支持) 让窗口滚动事件：window.scroll(x, y) 三大系列总结：offset常用于获取元素位置 element.offsetTop element.offsetLeft 只读的 client常用于获取元素大小 element.clientWidth element.clientHeight 只读的 scroll常用于获取滚动距离 element.scrollTop element.scrollLeft 可设置 4.动画函数封装原理：获取盒子当前位置（position），通过定时器setinterval()不断移动盒子位置，利用定时器不断让盒子当前位置加上一个移动距离，最后加一个结束定时器条件（其实也可以用CSS animation 定义动画） &lt;div>&lt;/div> &lt;script> //简单动画函数封装obj目标函数，target目标位置 //给不同的元素制定了不同的定时器 //不过再js中尽量避免这一种“先创建再补充”的动态属性赋值 function animate(obj, target) { obj.timer = setInterval(function () { if (obj.offsetLeft >= target) { clearInterval(obj.timer); } else { obj.style.left = obj.offsetLeft + 5 + 'px'; } }, 30); } // 调用函数 let div = document.querySelector('div'); animate(div, 300); &lt;/script> 缓动动画：让元素运动速度有所变化 ，即让它每次移动的距离有所变化（如慢慢变小）就可以达到效果 比如可以：（目标值-现在位置）/10 作为每次移动的步长 停止条件：让盒子位置等于目标位置 动画函数添加回调函数：回调函数原理为函数作为一个参数，即将这个函数作为参数传到另一个函数里，当那个函数执行完毕之后，再执行传进去的这个函数，这个过程叫做回调 添加了一点细节和回调函数后的改进代码 //简单动画函数封装obj目标函数，target目标位置 //给不同的元素制定了不同的定时器 //不过再js中尽量避免这一种“先创建再补充”的动态属性赋值 function animate(obj, target, callback) { // 当我们不断点击按钮，元素速度会越来越快，因为开启了太多定时器 // 解决方案就是让我恩的元素只有一个定时器执行,清楚之前的定时器 clearInterval(obj.timer); obj.timer = setInterval(function () { // 把步长值改为整数，不要出现小数的问题 let step = (target - obj.offsetLeft) / 10; // 正值往小的取整，负值往大的取证, 保证数值刚好等于target（） step = step > 0 ? Math.ceil(step) : Math.floor(step); // 可以让800回到500，所以用== 而不是>= if (obj.offsetLeft == target) { clearInterval(obj.timer); // 如果有回调函数，在定时器结束时调用 /*if (callback) { callback(); }*/ //更棒写法 callback &amp;&amp; callback(); } else { obj.style.left = obj.offsetLeft + step + 'px'; } }, 30); } // 调用函数 let div = document.querySelector('div'); let btn500 = document.querySelector('.btn500'); let btn800 = document.querySelector('.btn800'); btn500.addEventListener('click', function () { animate(div, 500, function () { alert('hello') }); }) btn800.addEventListener('click', function () { animate(div, 800); }) 5.节流阀控制速度，用于类似于防止轮播图按钮连续点击，导致播放过快的后果 即当上一个函数动画内容执行完毕再去执行下一个函数动画，让事件无法连续触发 核心思路是：利用回调函数，添加变量进行控制。锁住函数和解锁函数 // 设置节流阀 let flag = true; arrow_r.addEventListener('click', function () { if (flag) { flag = false; fun(x, y, function () { flag = true; }); } }) 移动端移动端兼容性较好，我们不需要考虑以前js的兼容问题，可以放心使用原生的JS书写，但是移动端也有自己独特的地方，如touch事件等 1.touch事件响应用户手指对屏幕的操作 touchstart 手指触摸到一个dom元素 （像mousedown） touchmove 手指在一个dom元素上滑动 （像mousemove） touchend 手指从一个dom元素上移开 （像mouseup） div.addEventListener('touchstart', function() {}) 移动端拖动原理：盒子原来的位置+手指移动的距离 拖动三部曲：（手指移动会触发滚动屏幕，所以要在这里阻止的屏幕滚动e.preventDefault()） 触摸 touchstart 获取初始坐标 移动手指 touchmove 计算手指滑动距离，并且移动盒子 离开手指 touchend //div加了绝对定位 &lt;div>&lt;/div> &lt;script> let startX = 0; let startY = 0; let x = 0; let y = 0; let div = document.querySelector('div'); div.addEventListener('touchstart', function (e) { // 获取第一个触碰的坐标 startX = e.targetTouches[0].pageX; startY = e.targetTouches[0].pageY; // 获取盒子的位置 x = this.offsetLeft; y = this.offsetTop; }) div.addEventListener('touchmove', function (e) { // 计算手指移动的距离，手指移动后坐标-手指初始坐标 let moveX = e.targetTouches[0].pageX - startX; let moveY = e.targetTouches[0].pageY - startY; // 移动盒子 this.style.left = x + moveX + 'px'; this.style.top = y + moveY + 'px'; // 阻止屏幕滚动 e.preventDefault(); }) &lt;/script> 2.移动端常见特效transitionend 事件移动端兼容性较强，在js制作时可以穿插 transform:translate(x, y) 、transition 等， 对于transition ，此时需要用到 transitionend 事件 ，等待过渡完成之后，再去判断是否到达最后一张，监听过渡完成事件 classList 属性它是h5新增的属性，返回元素的类名（返回形式为数组，因为一个元素可能包含多个类），但是ie10以上才支持（移动端也支持） let div = document.querySelector('div'); //返回第一个类的类名 console.log(div.classList[0]); 添加类名, 是追加，不会覆盖以前的类名，注意xx前面不用加 ‘.’ element.classList.add(&#39;xx&#39;) 移除类名 element.classList.remove(&#39;xx&#39;) 切换类名（原来有，就给你删除掉，原来没有，就给你加上） element.classList.toggle(&#39;xx&#39;) 移动端click问题移动端click事件会有300ms的延迟，原因是移动端双击会缩放页面 解决方案1：禁用缩放功能 &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt; 在最顶端的视口标签处写下user-scalable=no 解决方案2：利用touch事件自己封装： 手指触屏记录触摸时间 手指离开屏幕，用离开时间减去触摸的时间，若时间小于150ms则没有滑动屏幕，定义为点击事件 解决方案3：使用fastclick插件 在 vue 中 npm i fastclick -S 在 main.js 中 import fastClick from 'fastclick' fastClick.attach(document.body) 3.插件js插件就是js文件，它遵循一定规范进行编写，方便程序展示效果，拥有特定功能且方便调用，功能单一且文件小 插件的使用： 1.引入js文件 2.按照语法规范进行使用 比较常见的还有swiper插件（轮播图）、supersilide插件（无缝滚动等）、iscroll插件、视频插件等等 4.框架比如bootstrap，同样 来自于twitter，目前最受欢迎的前端框架(拿来主义) 中文官网：https://www.bootcss.com/ 官网：https://getbootstrap.com/ 2.x.x 已经停止维护，功能不够完善 3.x.x 目前使用最多，但已经放弃了ie6，ie7，对ie8支持但是界面效果不好，偏向于开发响应式布局，移动设备优先的web项目 4.x.x 最新版，但是目前不流行 根据官网的介绍引入js和结构即可使用 5.移动端滚动默认的滚动原理，在移动端十分卡顿 可以在github上安装 better-scroll 框架 让你的滚动更加丝滑 原生 JS 实现局部滚动：给定盒子高度，使用 overflow:scroll 使用better-scroll :（老师用的版本1.13.2） 安装 npm i better-scroll 基本使用在滚动内容外面套上一个 div 标签， class=&quot;wrapper&quot; 在js里引入并且使用 import BScroll from 'better-scroll' let wrapper = document.querySelector(\".wrapper\"); //滚动内容部分的元素 let scroll = new BScroll(wrapper, {}); //创建BScroll实例 如果在vue内使用，可以把创建BScroll对象放在 mounted生命周期钩子里 html部分： 注意：wrapper子元素只能有一个，所以不能直接绑定在ul上 注意：wrapper 在CSS里必须要有一个固定的高度 &lt;div class=\"wrapper\"> &lt;ul> &lt;!--许多的li --> &lt;/ul> &lt;/div> 事件监听BScroll创建出来的实例可以使用 on 监听事件 sroll是滚动事件 pullingUp是上拉事件 但是 *默认 *情况下 BScroll是不能实时监听滚动位置的，需要配置probeType better-scroll 管理的标签内部默认会阻止浏览器原生的click事件，需要配置click 必须在实例对象里开启pullUpLoad才能使用pullingUp事件，pullingUp事件只会触发一次，想要在发送网络请求，将新数据展示完毕继续使用该功能的话，需要 scroll.finishPullUp() new BScroll(wrapper, {配置option}) 1.重要配置属性probeType, probe：侦测, 默认值0（用scroll事件监听） 0、1都表示不侦测 1：非实时（屏幕滑动超过一定时间后）派发scroll 事件； 2：手指滑动时侦测，惯性滑动不侦测 3：只要滚动都进行侦测 2.click，默认值false better-scroll管理的标签内部默认会阻止浏览器原生的click事件 当设置为true的时候，better-scroll会派发一个click事件 3.pullUpLoad常用于上拉加载更多 默认值false 用pullingUp进行事件监听，传入boolean / Object ，设置为true或object开启功能 还有很多option配置，详情看官网 let wrapper = document.querySelector(\".wrapper\"); this.scroll = new BScroll(wrapper, { probeType: 2, click: true, pullUpLoad: true, }); //监听滚动事件 this.scroll.on(\"scroll\", (position) => { console.log(position); }); //回拉至x,y位置 //this.scroll.scrollTo(x, y[, time]); //监听上拉事件 this.scroll.on(\"pullingUp\", () => { console.log(\"上拉加载更多\"); }); //监听加载一次上拉事件，需要使用此函数才可以重新开启监听上拉事件 pullingUp this.scroll.finishPullUp(); // 修复better-scroll 因异步的网络请求图片到达，却未计算可滚动高度而无法滑动产生的bug，使用refresh进行刷新 this.scroll.refresh(); //输出滚条当前的x和y console.log(this.scroll.x); console.log(this.scroll.y); 解决better-scroll可滚动区域产生的bugbetter-scroll滚动区域是由 scrollHeight属性决定的，也就是content中子组件的高度 但有时因为异步操作（比如网络请求），导致 scrollHeight未能够计算出正确的组件高度 解决： 监听没一张图片加载完成（每一次的网络请求），只要有一张图片加载完成，就调用 refresh()一次 img.onload() = funciton(){}（vue中，监听加载则 @load=&quot;函数名&quot;） 使用事件总线 eventBus，管理、传递该加载事件到对应的组件，然后进行 refresh() 防抖函数有点像节流阀，节流阀：将多次执行变为在规定时间内只执行一次 防抖：在规定的时间内执行多次事件只执行最后一次 上述 “解决better-scroll可滚动区域产生的bug” 操作我们可以看到，每有一张图片加载完成，则发送一次请求，这样会大大降低参加程序效率、性能 为此我们可以封装一个防抖函数 debounce(func, delay) { let timer = null; return function (...args) { if (timer) clearTimeout(timer); timer = setTimeout(() => { // 这里的apply只用一个传入多个参数作用，箭头函数已经指向环境this，不需要用apply绑定 func.apply(this, args); }, delay); }; } 在vue中，我们可以在mounted里调用该函数 mounted() { // 监听goodListItem中图片加载完成 // 修复better-scroll 因异步的网络请求图片到达，却未计算可滚动高度而无法滑动产生的bug，使用refresh进行刷新 // 然后用防抖函数优化,减少函数调用频率 const refresh = this.debounce(this.$refs.scroll.refresh, 50); //得到一个带计时器的函数，里面保存着闭包的timer this.$bus.$on(\"itemImageLoad\", () => { refresh(); //调用refesh进行更新 }); },","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"BOM","slug":"BOM","date":"2020-11-13T16:17:20.669Z","updated":"2021-03-26T03:30:10.954Z","comments":true,"path":"2020/11/14/bom/","link":"","permalink":"https://taylor12138.github.io/2020/11/14/bom/","excerpt":"","text":"1.BOM概述BOM是浏览器对象模型，他提供独立于内容而与浏览器窗口进行交互的对象，其核心对象是window BOM缺乏标准，Javascript语法的标准化组织是ECMA，DOM标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分，所以它的兼容性比较的差 BOM比DOM更大，它包含着DOM window对象是浏览器的顶级对象，它是JS浏览器的一个接口，是一个全局对象，定义在全局作用域的变量（var）、函数都会变成window对象的属性和方法（alert()、prompt() ），在调用的时候可以省略window 2.window对象常见事件（1）onload本来我们的内嵌式&lt;script&gt;&lt;/script&gt;只能放在所有标签标签下方 而window.onload可以解决，它是窗口加载事件，当文档内容完全加载以后才会触发该事件（包括图像、脚本、CSS），就调用该函数 &lt;script> window.onload = function() { var btn = document.querySelector('button'); btn.onclick = function() { } } &lt;/script> &lt;button>&lt;/button> 但是window.onlaod传统注册方式只能写一次，如果写多个，只以最后一个onload为准，所以推荐 window.addEventListener('load', function() {}) 所以一般情况下引入js文件，则该js文件都要添加 ↑ pageshow事件下面三种情况会触发load事件： 1.a标签的超链接 2.F5刷新（或者强制刷新） 3.前进或后退 但是在火狐中有个“往返缓存”，它不仅保留着页面数据，还保存着DOM和Javascript的状态，实际上将整个页面保存在内存里，导致后退按钮不能刷新页面（无法触发load事件） 所以此时可以用pageshow事件来触发，它有点像load，但是事件在页面显示时就会触发，无论页面是否来自缓存（注意这个事件是给window添加的） window.addEventListener(&#39;pageshow&#39;, fucntion(e){ //e.persisted返回的是true，就是说如果这个页面是从缓存取过来的页面，也需要重新计算一下rem if(e.persisted) { setRemUnit(); //这个函数是设置rem的 } })new : DOMContentLoaded当DOM加载完毕时触发，不包括样式表，图片，flash等，ie9以上支持，如果页面图片很多，onload的出发会比较久，用户体验不佳 ，此时DOMContentLoaded比较合适，执行顺序DOMContentLoaded &gt; onload document.addEventListener('DOMContentLoaded',function(){ }); load和ready（jQuery） 一般情况下一个页面响应加载的基本顺序是：域名解析 -&gt; 加载html -&gt; 加载js和css -&gt; 加载图片等其他信息 $(document).ready()（在原生的jS中不包括ready()） 从字面的意思上理解，就是文档准备好了。也就是浏览器已经加载并解析完整个html文档，dom树已经建立起来了,然后执行此函数（不包含图片，css等） load 是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数，load方法就是onload事件。 所以对应的缺点是：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响 （2）调整窗口大小只要窗口发生变化，就会触发这个事件 window.onresize = function() {} window.addEventListener(&#39;resize&#39;, function() {}) 响应式布局原理 &lt;div>&lt;/div> &lt;script> var div = document.querySelector('div'); window.addEventListener('resize', function() { if (window.innerWidth &lt;= 800) { div.stye.display = 'none'; } else { div.style.display = 'block'; } }) &lt;/script> （3）定时器window.setTimeout(调用函数, 延时时间) 这个window在调用时可以省略，延时时间单位是毫秒，默认省略为0 延时xx毫秒后，执行该函数，写函数名不加括号、不带参数 var a = setTimeout(function() {}, 1000); var b = setTimeout(callback, 1000); //callback为一个函数 页面中时常有很多定时器，我们经常给定时器加标识符（名字） setTimeout() 这个调用函数我们也称之为回调函数（需要等待时间，时间到了才去调用该函数） callback ，以前onclick之类的函数也是回调函数 停止定时器window.clearTimeout (timeoutID) timeID为定时器的名字（所以我们上方说明了经常要给定时器加名字），这里的window也可以省略，调用该停止定时器方法后，定时器的调用函数不执行，时间被停止了 setInterval() 定时器window.setInterval(回调函数, [间隔毫秒数]) 重复调用一个函数，每隔这个时间就去调用一次，写函数名函数不加括号、不带参数；window也可以省略，默认省略的话为0，同样我们也经常给该定时器加标识符（名字） 停止setInterval定时器window.clearInterval(intervalID) 同停止定时器 利用定时器自动调用事件例如调用在js中的某点击事件 // 自动播放轮播图 let timer = setInterval(function () { arrow_r.click(); }, 2000); }) （4）thisthis的指向在函数定义的时候是确定不了的，只有函数执行的时候才能知道this的指向，一般this最终指向调用它的对象 全局作用域或者普通函数中this指向window, 如 function Fn() { console(this); } Fn(); 方法调用中，谁调用this指向谁（xx = function() {}, 此时function中的this指向xx） 构造函数中this指向的是构造函数的实例对象，如 function Fun() { console.log(this); } var fun = new Fun(); （5）dpr 物理像素比pc端一般都是1，移动端比如iPhone6/7/8都是2，移动端不尽相同 var dpr = window.devicePixelRatio || 1 3.JS执行队列JS原先是单线程，也就是说同一时间只能做一件事，但是单线程就意味着，所有任务需要排队，钱一个任务结束后，才能执行下一个任务，如果JS执行时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞 为了解决这个问题，H5提出Web Worker标准，允许JS创建多个线程，于是JS出现了同步（单线程）和异步（现在的JS可以同时多个任务） 他们本质的区别是，这条流水线上各个流程执行的顺序不同 （1）同步和异步同步任务都放在一个主线程上执行，形成一个执行栈，按顺序执行 异步任务：JS的异步是通过回调函数实现的，一般而言，异步任务有以下三种类型 1.普通事件，如click、resize等 2.资源加载，如load、error等 3.定时器，如setTimeout、setInterval等 （2）宏任务和微任务这里需要注意的是new Promise是会进入到主线程中立刻执行（promise本身不是异步，只是里面的任务是异步的罢了），而promise.then则属于微任务 宏任务(macro-task)：是由宿主（Node、浏览器）发起的，比如整体代码script、setTimeOut、setInterval 微任务(mincro-task)：由JavaScript自身，比如promise.then、process.nextTick(node) 微任务先执行，宏任务后执行 （3）执行机制1.先执行执行栈中的同步任务 2.异步任务（回调函数）放入任务队列中 3.一旦执行栈所有同步任务执行完毕，系统就会按次序读取任务队列的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 有异步任务交给异步进程处理（新开一个线程用来执行那些异步任务，我们暂且称为工作线程），异步任务执行完毕后推入任务队列 当主线程执行完毕就来查询任务队列，取排在第一位的事件推入主线程处理，执行完再来取，不断循环，这个过程叫作事件循环 （实际上细分异步事件的优先级有宏任务和微任务，优先级：微任务&gt;宏任务） 异步任务执行顺序不一定按照原来顺序，要取决于文件大小、操作系统调度机制等多方面原因 4.location对象location是window对象提供给我们的一个属性，用于获取或设置窗体的URL，并且可以用于解析URL，返回的是一个对象 URL：统一资源定位符是互联网上标准资源的地址，互联网上每个文件都有唯一的URL，它包含的信息支持文件的位置以及浏览器该如何使用它（URL也就是我们的网址） 组成： protocol://host[:port]/path/[?query]#fragment protocol：通信协议，即http、ftp等 host：主机（域名） port：端口号，可选 path：路径，用 / 分隔 query：参数，以键对的形式，通过 &amp; 分隔 fragment：片段， # 后面内容，常见于链接锚点 location对象属性： location.href 获取或设置（实现页面跳转） 整个URL location.search 返回参数（即query部分 ） location.assign() 跟href一样，可以跳转页面，但是可以后退 location.replace() 同上，但是不能记录历史，不能实现后退功能 location.reload() 类似于F5刷新 （location.reload(true)为强制刷新，缓存一起没了） 还有host、port、pathname、hash（链接锚点）等 5.navigator对象navigator对象包含浏览器的信息，它可以知道你是用的是pc端浏览器还是移动端浏览器，有很多属性，最常用的是userAgent，该属性值返回又客户机发送服务器user-agent头部的值 &lt;script> if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href = \"../H5/index.html\"; //手机 } &lt;/script> 引入以上代码可以自动判断是进入了pc端浏览器还是移动端浏览器 6.history对象用于与浏览器历史记录进行交互（实际上和浏览器自带的页面后退，前进功能一样） 实际开发用的少，但是一些OA办公系统会用到 history.back() 后退功能 history.forward() 前进功能 history.go(参数) 前进后退功能，参数是1前进一个页面，-1后退一个页面","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"DOM","slug":"DOM","date":"2020-11-08T08:47:54.905Z","updated":"2021-03-26T17:20:04.046Z","comments":true,"path":"2020/11/08/dom/","link":"","permalink":"https://taylor12138.github.io/2020/11/08/dom/","excerpt":"","text":"DOM基础W3C已经定义了一系列的dom接口，可以改变网页内容、结构、样式 文档：一个页面就是一个文档，用document表示 元素：页面内的所有标签都是元素，用element表示 节点：网页中所有内容都是一个节点（注释，文本，属性等），用node表示 顶级对象是document 注意：因为文档是从上往下加载，所以script要写到文档标签的下面 （1）获取页面元素id获取（id是大小写敏感的字符串组成） &lt;div id=\"time\">2019&lt;/div> &lt;script> var timer = document.getElementById('time'); /*返回的是一个元素对象*/ console.dir(timer); /*dir是打印返回的元素对象，更好的查看里面的属性方法*/ &lt;/script> &lt;/body> 根据标签名获取 &lt;script> // 返回的是获取过来的元素对象的集合，（无论多少个）以伪数组的形式储存 var lis = document.getElementsByTagName('li'); console.log(lis); console.log(lis[0]); // 可以使用element.getElementsByTagName('标签名')获取，但是父元素必须是单个对象，不能是伪数组之类的 var oll = document.getElementsByTagName('ol'); console.log(oll[0].getElementsByTagName('li')); &lt;/script> H5新增获取元素方法，根据类名获取 document.getElementsByClassName(&#39;类名&#39;); H5新增的万能选择器，querySelector返回选择器的第一个元素对象，切记里面选择器需要加符号 querySelectorAll 返回指定选择器的所有对象集合（伪数组） 伪数组可以使用es6的扩展运算符转化为数组：let lis2 = [...lis] // 选择类名 var firstbox = document.querySelector('.box'); // 选择id var secondbox = document.querySelector('#nav'); // 选择标签名 var thirdbox = document.querySelector('li'); //选择全部 var fourth = document.querySelectorAll('li'); 多重嵌套进行选择 var firstbox = document.querySelector('.box').document.quertSelector(li); 获取body标签和html标签比较简单特殊 //获取html var htmlEle = document.documentElement; // 获取body元素 var bodyEle = document.body; 注意：获取到的每个DOM元素都作为一个对象来使用！ （2）事件基础事件是可以被js侦测到的行为，触发–响应机制 事件由三部分组成：事件源（被触发对象） 事件类型（触发类型） 事件处理程序 一个简单的事件例子： &lt;button id=\"btn\">哈哈哈&lt;/button> &lt;script> var btn = document.getElementById('btn'); btn.onclick = function() { alert('哈哈哈'); } &lt;/script> （3）操作元素我们可以利用dom操作元素来改变元素里面的内容 element.innnerText 从起始位置到终止位置的内容，但它除去html标签，空格换行也会去掉（非标准） element.innerHTML 从起始位置到终止位置的内容，保留（识别）html标签和空格，换行（W3C标准） （element.textContent 相当于innerText，只不过 textContent 会获取style= “display:none” 中的文本，而innerText不会 textContent 会获取style标签里面的文本、script标签里的文本，而innerText 不会 ） 同时，这两个标签是可读写的，可以获取元素里面的内容 btn.onclick = function() { div.innerText = '2020'; /*点击后修改它的文字*/ img.src = 'xxxx'; /*改变图片的src*/ img.title = 'xxxx'; /*改变图片的文字提示*/ input.value = 'xxx' /*改变表单的值*/ this.disabled = true; /*点击后此按钮后，此按钮被禁用，this指向的是事件函数的调用者*/ } p.innerText = 'pp'; /*刷新页面直接修改它的文字*/ console.log(p.innerText); 修改样式（通过JS修改后，变成行内样式，权重比较高） div.onclick = function() { //1.样式比较少的话使用此方法 //采用驼峰命名，原来的 background-color -> backgroundColor this.style.backgroundColor = 'purple'; //2.另一个方法就是再写一个类，里面包含了所有你想要改变的样式，但是注意，它会覆盖原先的类名 this.className = '样式名'; //3.保留原先得类 this.className = '原先样式名 新样式名' } 表单的获取焦点 var text = document.querySelector('input'); text.onfocus = function () { //获得焦点 if (this.value) { this.value = ''; } this.style.color = '#333' } text.onblur = function () { //失去焦点 if (this.value === '') { this.value = '手机'; } this.style.color = '#999' } 表单经过事件（类似于“ :hover ”） // 1.获取元素 获取的是 tbody 里面所有的行 var trs = document.querySelector('tbody').querySelectorAll('tr'); // 2. 利用循环绑定注册事件 for (var i = 0; i &lt; trs.length; i++) { // 3. 鼠标经过事件 onmouseover trs[i].onmouseover = function() { this.className = 'bg'; } // 4. 鼠标离开事件 onmouseout trs[i].onmouseout = function() { this.className = ''; } } 全选框小案例： // 获取元素 var Btn_All = document.getElementById('Btn_All'); // 全选按钮 var Btns = document.getElementById('Btns').getElementsByTagName('input'); // 下面所有的复选框 //1.让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可 Btn_All.onclick = function () { for (var i = 0; i &lt; Btns.length; i++) { Btns[i].checked = this.checked; } } // 2. 每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。 for (var i = 0; i &lt; Btns.length; i++) { Btns[i].onclick = function () { var flag = true; for (var i = 0; i &lt; Btns.length; i++) { if (!Btns[i].checked) { flag = false; break; } } Btn_All.checked = flag; } } （4）自定义属性js的两种元素属性获取方法： element.属性获取属性 element.getArribute(&#39;属性&#39;)也是获取属性，不过这个可以获取自定义属性 自定义属性：&lt;div id=&quot;demo&quot; index=&quot;1&quot;&gt;&lt;/div&gt; 中的index 设定属性值： element.属性 = 值 设置内置属性 element.setArribute(&#39;属性&#39;,&#39;值&#39;) 同上，主要设置自定义属性，它的class比较特殊，不使用className，使用class，如 div.setAttribute(‘class’, ‘footer’); 移除属性：element.removeAttribute(&#39;属性名&#39;) Hs规范：H5规定自定义属性以“data-”作为开头，并且赋值，比如 &lt;div data-index=&quot;1&quot;&gt;&lt;/div&gt; H5新增获取自定义属性的方法：div.dataset.index（属性名为data-index）， div.dataset.listName(属性名为data-list-name) ，dataset是一个集合里面存放了所有以data开头的自定义属性 （5）节点操作dom提供的获取元素方法比较繁琐，利用节点父子兄弟关系获取元素比较方便，但是兼容性差 一般的，节点至少拥有节点类型（nodeType）、节点名称（nodeName）、节点值（nodeValue） 元素节点 nodeType = 1 节点操作一般都是操作元素节点 属性节点 nodeType = 2 文本节点 nodeType = 3 父亲节点： node.parentNode (得到的是离元素最近的父节点，找不到父节点返回空值) 孩子节点： parentNode.childNodes 返回包含节点的子节点的集合，包含元素节点，文本节点等等，该集合为及时更新的集合，若只想获取元素节点：(因为繁琐，所以实际开发不提倡使用childNodes) var ul = document.querySelect(&#39;ul&#39;); for (var i = 0; i &lt; ul.childNodes.length; i++) { if(ul.childNodes[i].nodeType == 1) { console.log(lu.childNodes[i]); } }(new) 孩子节点： parentNode.children 返回所有子元素节点 （常用） parentNode.firsElementtChild 返回第一个元素子节点，找不到返回null parentNode.lastChild 返回最后一个元素子节点，找不到返回null 这两个方法有兼容问题ie9以上才能使用 所以推荐写法： parentNode.children[0] parentNode.children[parentNode.children.lenth-1] 下一个兄弟元素节点：node.nextElementSibling 找不到返回null 上一个兄弟元素节点：node.previousElementSibling 找不到返回null 这两个方法有兼容问题ie9以上才能使用 创建节点 document.createElement(&#39;targetName&#39;) 动态创建节点 添加节点 node.appendChild(child) 创建完后需要添加节点，此方法是将一个节点添加到指定父节点的子节点列表末尾，类似于CSS中的after伪元素 ,child写名称不用加 ‘ ’（不支持追加字符串子元素） or： node.insertBefore(child, 指定元素（子节点）) 将一个节点添加到父节点指定的子节点前面 var li = document.createElement('li'); var ul = document.querySelector('ul'); ul.appendChild(li); var li_2 = document.createElement('li'); ul.insertBefore(li_2, ul.children[0]); /*添加至开头*/ 发表评论案例： &lt;textarea name=\"\" id=\"\">&lt;/textarea> &lt;button>发布&lt;/button> &lt;ul>&lt;/ul> &lt;script> var btn = document.querySelector('button'); var text = document.querySelector('textarea'); var ul = document.querySelector('ul'); btn.onclick = function() { if (text.value == '') { alert('您没有输入内容'); return false; } else { var li = document.createElement('li'); //并且添加删除功能 li.innerHTML = text.value + \"&lt;a href='javascript:;'>删除&lt;/a>\"; //javascript:;意思是页面不发生跳转 ul.insertBefore(li, ul.children[0]); //删除元素 var as = document.querySelectorAll('a'); for(var i = 0; i &lt; as.length; i++) { as[i].onclick = funciton() { ul.removeChild(this.parentNode) } } } } &lt;/script> 删除节点：node.removeChild(child) 返回删除的节点 node.remove() 返回删除的节点（）删除本身 复制节点： node.cloneNode() 克隆完节点之后，和创建节点一样也必须要添加节点才能显示出来 1.如果括号参数为空，是浅拷贝，只克隆该节点本身，不克隆其子节点，即没有任何内容 node.cloneNode(true) 深拷贝 复制标签并且复制里面的内容 （6）创建标签的四种方法：1.element.write() 写入内容（标签），但是页面文档流加载完毕，再调用会导致页面重绘，不好用 2.element.innerHTML 从起始位置到终止位置的内容，保留（识别）html标签和空格，换行（W3C标准） 同时，这两个标签是可读写的，可以获取元素里面的内容 3.document.createElement(&#39;targetName&#39;) 动态创建节点 document.createElement(&#39;targetName&#39;)对比使用element.innerHTML 写多个标签会更省时，省空间，因为他创建多个标签时不用开辟新的空间，而innerHTML使用拼接的原理，所以每次都要要开辟新的空间 但是，如果element.innerHTML 不用拼接字符串的方法来实现创建多个标签，而是采用数组的形式拼接，结构写麻烦一点： var arr[]; for(var i = 0; i &lt; 100; i++) { arr.push('&lt;a href=\"#\">百度&lt;/a>'); } //以''进行拼接，并且转化为字符串 xx.innerHTML = arr.join(''); 执行起来会比 document.createElement(&#39;targetName&#39;) 更快，但是结构不太清晰 element.insertAdjacentHTML(插入的位置, 插入的字符串)可以直接把字符串格式元素添加到父元素中 (如：&quot;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&quot;) 插入位置：beforebegin 元素自身前面 afterbegin 插入元素内部第一个子节点之前 ​ beforeend 插入元素内部的最后一个子节点之后 afterend 元素自身的后面 （注意：appendChild不支持追加字符串子元素，insertAdjacentHTML支持追加字符串子元素） document.createDocumentFragment() 有点类似 document.createElement(&#39;targetName&#39;) ，区别在于： （1）需要很多的插入操作和改动，使用createElement效率是比较低的，而innerHTML拼接方法灵活性比较差，利用DocumentFragment，可以弥补这两个方法的不足 （2）createDocumentFragment创建的元素使用innerHTML并不能达到预期修改文档内容的效果 （3）createDocumentFragment创建的元素是一次性的，添加之后再就不能操作了 （4） 通过createElement新建元素必须指定元素tagName,因为其可用innerHTML添加子元素。通过createDocumentFragment则不必。 （5）通过createElement创建的元素插入文档后，还可以取到创建时的返回值 事件部分1.注册事件传统方式： btn.onclick = function() {} 注册事件唯一性，最后注册处理的函数会覆盖掉前面注册处理的函数，即一个元素只能设置一个处理函数 w3c标准的推荐方式：（ie9以前不支持此方法） eventTarget.addEventListener(type, listerner[, useCapture]) （ie9以前使用的是eventTarget.attachEvent(type, listener[, useCapture]);） type：事件类型，如click，mouseover，不带on listener：事件处理，事件发生时会调用其监听函数 useCapture：可选参数，默认false btn.addEventListener('click', function() { //必须要字符串 alert(xxx); }) btn.addEventListener('click', function() { //必须要字符串 alert(yyy); }) 同一个元素同一个事件可以添加多个监听器，不会覆盖掉 2.解绑事件传统方式： eventTarget.onclick = null 如 div.onclick = function() {alert(); div.onclick = null;} 在点击一次之后删除该事件 方法监听方式：eventTarget.removeEventListener(type, listener[, useCapture]); （ie9以前使用的是eventTarget.detach(type, listener[, useCapture]);） 方法监听方式来解绑事件不能用匿名函数的方法，即 var fun=function(){} 所以使用以下策略 div.addEventListener('click', fn); function fn() { alert(xx); div.removeEventListener('click', fn); } 使得目标div在点击一次之后解绑事件 3.dom事件流事件发生时会在元素节点之间按照特定的顺序传播（document-&gt;Element gtml-&gt;Element body-&gt;Element div），这个传播过程即DOM事件流 DOM事件流分为三个阶段 ：（执行顺序也是如此 捕获 - &gt; 当前 -&gt; 冒泡） 1.捕获阶段（从大往小传播，从最顶层开始，然后逐级向下传播到具体元素接收的过程） 2.当前目标阶段 3.冒泡阶段（从小到大，从里到外的传播，由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程） 注意： JS代码只能执行捕获或者冒泡其中一个阶段（除非你设置两个监听函数，一个执行捕获，一个执行冒泡）； 传统注册事件方式（onclick、attachEvent）只能得到冒泡阶段，eventTarget.addEventListener(type, listerner[, useCapture])第三个参数如果是true，则在事件捕获阶段调用程序，如果是false（默认），则在冒泡阶段调用事件 如果事件触发在“当前目标阶段”，则当前目标会根据事件注册的先后顺序执行，而不是上面提及到的 捕获 - &gt; 当前 -&gt; 冒泡，比如：爷节点，父节点，子节点都绑定了 捕获事件和监听事件，而触发子节点的事件，执行爷、父的事件执行顺序一定是 捕获 - &gt; 当前 -&gt; 冒泡；而子节点是根据事件注册的先后顺序来执行捕获 or 冒泡事件，说白了就是无关了。 以下代码，son包含于father内，使用捕获阶段（true），则点击son后先执行father再执行son，冒泡阶段则相反 &lt;div class=\"father\"> &lt;div class=\"son\">son盒子&lt;/div> &lt;/div> &lt;script> var son = document.querySelector('.son'); son.addEventListener('click', function() { alert('son'); }, true); var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, true); &lt;/script> 但是实际开发中我们更关注的是冒泡，且有些事件是没有冒泡的，如onblur，onfocus，onmouseenter，onmouseleave 4.事件对象div.addEventListener(&#39;click&#39;, funciton(event){} ) 中的event为事件对象，写到我们监听函数的小括号里，当形参看 事件对象只有有了事件才会存在，它是系统自动为我们创建的，不需要我们传递参数 事件对象是我们事件一些列相关数据的集合 事件对象也有兼容性问题，比如ie6、7、8，通过window.event获取 常见事件对象属性（对低版本浏览器有兼容性问题）： div.addEventListener('click', function(e) { console.log(e.target); console.log(this); /*两者有些许相似，但是e.target返回的是触发事件的元素，this返回的是绑定事件的对象（元素）*/ console.log(e.type); //返回事件类型 e.preventDefault(); //阻止默认事件，让它成为一个普通盒子，比如让链接不跳转，让input不提交等 e.stopPropagation(); //阻止事件冒泡，使得触发子事件后，不会相应触发父事件，不会向外传播 }) ie6\\7\\8 div.onclick = function() { console.log(e.srcElement); //返回的是触发事件得元素 e.returnValue; // 阻止默认事件 /*我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式*/ return false; window.e.cancelBubble = true; //阻止冒泡 } 5.事件委托事件委托也称为事件代理，再JQuery称为事件委派，它提高了程序性能 若多个子节点同时有事件，不需要将每个子结点单独设置事件监听器，而是将事件监听器设置在父节点上，然后利用冒泡原理影响每个子节点，使得每个子节点反馈到父节点，触发父节点的事件 6.常用的鼠标事件鼠标右键菜单： contextmenu 鼠标选中：selectstart dblclick 鼠标双击事件 mousedown 鼠标按下 mousemove 鼠标移动 ，mousemove是鼠标指针在元素内部移动式重复触发的事件，可用于鼠标指针定位实时变化的案例 mouseup 鼠标松开 mouseover 鼠标经过， 类似于“ :hover ” 它不仅经过自身盒子会触发，经过子盒子还会再触发一次 mouseout 鼠标离开元素，和mouseover相互搭配 mouseenter 鼠标移动到元素上，只会经过自身盒子才触发一次，之所以会这样，是因为mouseenter不会冒泡 mouseleave 鼠标离开元素，和mouseenter相互搭配，同样不会冒泡 //禁用鼠标右键 document.addEventListener('contextmenu', function(e) { e.preventDefault(); }) //禁止选中文字 document.addEventListener('selectstart', function(e) { e.preventDefault(); }) （e代表事件对象） e.clientX 返回鼠标对于浏览器窗口可视区域的X坐标 e.clientY 返回鼠标对于浏览器窗口可视区域的Y坐标 e.pageX 返回鼠标相对于文档页面的X坐标，ie9+支持 e.pageY 返回鼠标相对于文档页面的Y坐标，ie9+支持 e.screenX 返回鼠标相对于电脑屏幕的X轴坐标 e.screenY 返回鼠标相对于电脑屏幕的Y轴坐标 pink老师天使跟随鼠标案例 &lt;style> img { position: absolute; } &lt;/style> &lt;body> &lt;img src=\"images/angel.gif\" alt=\"\"> &lt;script> var pic = document.querySelector('img'); document.addEventListener('mousemove', function(e) { /*核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的top和left 值就可以移动图片*/ var x = e.pageX; var y = e.pageY; //千万不要忘记给left 和top 添加px 单位 pic.style.left = x - 50 + 'px'; pic.style.top = y - 40 + 'px'; }); &lt;/script> &lt;/body> 7.常用键盘事件onkeyup 某个按键松开时被触发 （松开瞬间） onkeydown 某个按键被按下时被触发 （按下瞬间） onkeypress 同onkeydown 但是它不识别功能键如ctrl shift等 执行顺序down&gt;press&gt;up 使用addEventListener不需要加on keyon和keydown不能区分大小写 keyon和keydown不能区分大小写 （a和A得到的ASCII码值得到的都是65） 键盘事件 （e代表事件对象） e.keyCode 返回该键ASCII码值 注意（）：keydown 和 keypress 在文本框（input）比较特殊，当它们两个事件触发的时候，文字还没落入文本框中 而keyup事件触发的时候，文字已经落入文本框， 8.input事件onchange 当input失去焦点并且它的value值发生变化时触发，它也可用于单选框与复选框改变后触发的事件。 比如复选框发生改变（单击鼠标切换“打勾”/“不打勾”状态） oninput 当input的value值发生变化时就会触发，（与onchange的区别是不用等到失去焦点就可以触发了） 此时通过 event.target.value;事件对象中的target的value可以获取input输入的值 onfocus 获得焦点事件 onblur 失去焦点事件 input.select() 让文本框里的文字处于选定状态 remember.addEventListener('change', function () { // 勾选上 if (this.checked) { localStorage.setItem('username', username.value); } else { localStorage.removeItem('username') } })","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"移动Web开发及其常见布局(CSS)","slug":"移动Web开发及其常见布局(CSS)","date":"2020-10-01T16:00:00.000Z","updated":"2021-03-16T09:23:59.831Z","comments":true,"path":"2020/10/02/yi-dong-web-kai-fa-ji-qi-chang-jian-bu-ju-css/","link":"","permalink":"https://taylor12138.github.io/2020/10/02/yi-dong-web-kai-fa-ji-qi-chang-jian-bu-ju-css/","excerpt":"","text":"兼容移动端主流浏览器，处理Webkit内核浏览器即可 1.视口视口分类视口可以分为布局视口，视觉视口和理想视口 布局视口：一般移动设备浏览器都默认设置一个布局视口（980px），用于早期PC端页面在手机上显示的问题 缺点：使得元素看上去很小，字体小 视觉视口：用户正在看的网站区域，我们可以通过缩放操作视觉视口，但是不影响布局视口 理想视口：设定最理想的浏览和阅读宽度，与要手动添加meta视口标签通知浏览器（乔布斯发明） &lt;meta name=\"viewport\" content=\"width-device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"> content=”width-device-width 适应窗口大小 user-scalable=no 不允许用户缩放 maximum-scale=1.0 初始的最小缩放比 minimum-scale=1.0 初始的最大缩放比 2.二倍图在移动端，1px=一个物理像素，但是移动端不尽相同 移动端有物理像素比，可从px转化移动端时，（开发尺寸）px × 物理像素比 = 移动端显示的像素 此做法可以使得在移动端上显示更加高清 背景缩放background-size注意：background-size一定要放在background属性后设置 background-size用于规定背景尺寸 /*现有background: 才能设置*/ background-size: 图片宽度,图片高度; /*可以px，可以百分比（相对于父盒子）*/ background-size: cover; /*完全盖住盒子，可能图片显示不全*/ background-size: contain; /*宽高完全适应父盒子，父盒子可能有空白区域*/ 切图时可以用ps里的cutterman多倍切图 精灵图缩放1.使用工具（如firework）把精灵图缩放为原来的一半 2.根据大小测量坐标 3.注意代码里面的background-size也要写：精灵图原来的一半 （原图进行修改查看， 但是不要保存） （或者直接上，用chrome调试就行了） background-size: 宽度（原来的大小/倍数） 高度auto 3.移动端开发的选择1.单独移动端页面（主流）：京东、淘宝 pc和手机打开后显示的网页布局不同 2.响应式页面兼容移动端：三星官网 响应屏幕宽度，制作麻烦，需要大量调整兼容性 CSS的初始化推荐使用 normalize.css CSS3盒子模型传统盒子计算方式：CSS设置的width+border+padding CSS3盒子模型：盒子宽度=CSS设置的宽度width包含了border+padding 设置方式：(CSS高级部分讲过，但是使用此方法后文字使用line-heigh居中会有所影响,原因是我们要对其的是盒子内部中间的位置，即去除掉边框的高度的中间位置，但是line-heigh会把所有方框所有高度算进去) box-sizing:border-box; 移动端链接清除高亮移动端点击完链接 &lt;a&gt; 会出现高亮 ，清除高亮可用 -webkit-tap-highlight-color:transparent; 移动端链接清除外观效果在移动端浏览器默认的外观上在ios上加上这个属性才能给按钮和输入框自定义样式（清除原来的样式） -webkit-appearance: none; 禁用长安页面弹出菜单img, a {-webkit-touch-callout: none; } 4.移动端常见布局不需要像pc端一样排列版心 单独移动端页面（主流）：流式布局（百分比布局）（京东）、flex弹性布局（新闻网，强烈推荐）、less+rem+媒体查询布局（苏宁）、混合布局 流式布局也就是百分比布局，非固定像素布局，可自由伸缩 为了保护屏幕不被拉过宽（缩过窄），导致里面的元素显示出现问题，设置最大最小宽度 max-width: xxpx; min-width: xxpx; flex布局传统布局：兼容性好，布局繁琐，有一定局限 flex布局：操作方便，pc端浏览器支持差，IE11或者更低版本不支持或仅部分支持 flex可以让原本span（无法设置宽高）成功使用宽高属性，即不需要浮动，更不用清除浮动 （1）flex原理flex是flexible box的缩写，意为弹性布局，任何一个容器都可以指定为flex布局（谁都可以用，除了IE） 父盒子设置为flex后，子元素的float、clear、vertical属性都失效 采用flex布局的元素称为flex容器，他的所有子元素自动成为容器成员，称为flex项目，即它是通过给父盒子添加flex属性，来控制子盒子的位置和排列 （2）flex常见父项属性默认主轴方向是x轴，水平向右 侧轴方向是y轴 水平向下，我们的元素是跟着主轴排列地 flex-direction 设置主轴方向，剩下那个就自动变成侧轴 1.默认值row从左到右 2.row-reverse从右到左 3.column从上到下 4.column-reverse从下到上 justify-content 设置主轴上子元素的排列方式 1.flex-start默认 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.space-around平分剩余空间 5.space-between先两边贴边，再平分剩余空间 flex-wrap 设置子元素是否换行 默认不换行，装不开会缩小子元素的宽度，自动适应 wrap：换行 align-content 设置侧轴上的子元素的排列方式（多行）（即有换行情况）（单行情况下没用） 1.flex-start 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.stretch拉伸，默认 5.space-around平分剩余空间 6.space-between先两边贴边，再平分剩余空间 align-items 设置侧轴上的子元素的排列方式（单行） 1.flex-start 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.stretch拉伸，默认，但是子盒子不要带高度 flex-flow 复合属性，相当于同时设置flex-direction和flex-wrap flex-flow: column wrap; （3）flex常见子项属性flex属性，定义子项目分配剩余空间，用flex表示占有份数 flex: number;/*默认为0*/ 如果是flex：1的话，则将改行剩余空间全部划分给该子元素，不用设置宽高，且类似于百分比流式布局，可以根据窗口大小调节剩余空间大小 如果该行没有设置任何子元素在该行（假设当前主轴为x轴），然后将三个子元素设置flex：1，则每个盒子占33.33%的宽度（即设置该盒子的主轴长度） A设置flex:2 ， B设置flex:1 则A占比2/3，B占比1/3 (其实可以写百分比 即flex: 20%, 相对父级来说) align-self，控制子项自己在侧轴上的排列方式。 它允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items属性，默认值为auto，表示继承align-items的属性 span:nth-child(3) { align-self: flex-end; /*只让第三个盒子在侧轴上从尾部开始排列*/ } oder定义项目的排列顺序，数值越小，排名越靠前，注意，和z-index不一样（定位属性） span:nth-child(2) { order:-1; /*让2号盒子跑到1号盒子前面，因为默认是0，0&lt;1*/ } Rem适配布局（1）rem基础rem是一个单位（root em），是一个相对单位，类似于em，em是父元素的字体大小，如父元素的font-size为12px，子元素设置宽高为10em，则大小实际为10*12=120px；而不同的地方在于rem是相对于html元素的字体大小，rem的优点是可以通过修改html的文字大小来改变页面中的元素大小 （2）媒体查询媒体查询是CSS3的新语法，使用@media可以针对不同屏幕尺寸设置不同的屏幕样式 /*用@media开头，mediatype是媒体类型，关键字and、not、only，media feature是媒体特性，要用小括号包含*/ @media mediatype and|not|only (media feature) { CSS-Code; } mediatype查询类型： all 用于所有设备 print 用于打印机和打印预览 screen用于电脑屏幕，智能手机 媒体特性：暂且先了解三个 1.width 定义输出设备页面可见区域的宽度 2.min-width 定义输出设备页面最小可见区域宽度 3.max-width 定义输出设备页面最大可见区域宽度 @media screen and (max-width: 800px) and (min-width: 540px) { /*在屏幕上且最大宽度为800px且最小宽度为540px则设置该样式*/ body { background-color: pink; } } 当样式改变比较多的时候（如三星官网首页根据页面不同大小的变化样式的改变），可以针对不同的媒体使用不同的stylesheets（样式表）原理，直接在link中判断设备的尺寸，引用不同的CSS文件 &lt;link rel=\"stylesheet\" href=\"style320.css\" media=\"screen and (min-width: 320px)\"> 媒体查询最好的方法是从小到大 less基础CSS的冗余度比较高，需要书写大量看似没有逻辑的代码，不方便维护，且无计算能力 而Less是CSS的拓展语言，也成为CSS预处理器（常见的CSS预处理器：Less、Sass、Stylus），可以计算（运算符的左右两侧必须加一个空格， 两个数参与运算，如果只有一个数有单位，最后结果以这个单位为准 两个数参与运算，如果两个数都有单位，以前面那个数字单位为准） Less的文件后缀名：.less （1）less变量@color: pink; /*@变量名:值;*/ @font: 14px; 使用： background-color: @color ; （2）less的编译需要把less编译成CSS才能放入H5使用 在VScode中安装easy-less插件，less文件保存后一键生成CSS文件 （3）less镶套在less不需要再 .header a {} 去选择后代选择器(再见) 可以直接： .header { width: 100px; a { color: red; } } 伪类选择器： .nav { &amp;:hover { color: blue; } &amp;::before { content: \"\"; } } 在一个less中可以引入另外一个less（套娃） @import \"common\"; /*导入conmon.less*/ rem的实际适配1.按照设计稿与设备宽度比例，动态计算并设置html根标签font-size大小（屏幕宽度/划分的份数=font-size的大小）（划分份数有15、20、10都有可能，苏宁移动端网页是15） 2.CSS中，设计稿元素宽、高、相对位置等取值，按照同等比例换算为rem rem适配方案一：less 媒体查询 rem 适配方案二：flexible.js rem (推荐) 适配方案二：rem适配之flexible.js再也不用太过繁琐的写下多个媒体查询，使用js做了处理 它的原理是把当前设备自动划分为10等份 会根据屏幕自动修改文字大小 github下载地址：https://github.com/amfe/lib-flexible 但是需要加一个限定弥补不足： /* 如果屏幕超过了750px, 那么我们按照750的设计稿走，不让我们的页面超过750px*/ @media screen and (min-width: 750px) { html { font-size: 75px!important; /*提权重*/ } } 适配方案（add）：Vscode px转换rem插件cssrem（堪称外挂），及其好用 可以使得px直接转换rem 该插件默认的html字体大小为16px（根据当前页面大小（正常大小状态）/划分份数=得到我们应该设置的字体大小）,需要在设置里更改setting.json里的&quot;cssrem.rootFontSize&quot;: 16才可以 响应式布局其原理就是根据媒体查询对不同宽度设备进行布局和样式设置，从而适配不同设备的目的 小屏幕（手机）&lt;768px 小屏设备（平板） &gt;=768px~&lt;992px 中等屏幕（桌面显示器）&gt;=992px~&lt;1200px 宽屏设备（大桌面显示器）&gt;=1200px @media screen and (max-width: 767px) { .container { width: 100%; } } @media screen and (min-width: 768px) { .container { width: 750px; } } @media screen and (min-width: 992x) { .container { width: 970px; } } @media screen and (min-width: 1200px) { .container { width: 1170px; } } (1)Bootstrap前端开发框架来自于twitter，目前最受欢迎的前端框架(拿来主义) 中文官网：https://www.bootcss.com/ 官网：https://getbootstrap.com/ 2.x.x 已经停止维护，功能不够完善 3.x.x 目前使用最多，但已经放弃了ie6，ie7，对ie8支持但是界面效果不好，偏向于开发响应式布局，移动设备优先的web项目 4.x.x 最新版，但是目前不流行 样式库的使用：1.创建文件夹结构（复制bootstrap的文件夹）-&gt; 2.创建html骨架结构（在bootstrap中文文档官网中找到bootstrap入门-基础模板）-&gt; 3. 引入相关样式文件 -&gt; 使用 (2)Bootstrap的布局容器bootstrap需要为页面内容和栅格系统包裹一个.container容器，Bootstrap预先定义好了这个类 .container已经定义好了响应式布局，如@media screen and (max-width: 767px)之类的 而.container-fluid类定义了流式布局（百分比布局） (3）Bootstrap的栅格系统亦称为网络系统，它指页面布局划分为等宽的列，通过样式定义来模块化页面布局（rem是把整个屏幕划分多个等份，这个是页面内容），bootstrap自动拓展到最多12等份 bootstrap里面的CSS已经包含了normalize.css即关于网页初始化的内容，所以不用再引入normalize.css进行初始化 栅格系统用于通过一系列的行row和列coloum的组合来创建页面布局 （行缩小到一定程度，模块进入下一个列）,实现列的平均划分，需要给列添加类前缀（添加类名），分别对应着响应式布局上面定义的四种媒体查询代码 超小屏幕列前缀.col-xs-小屏设备列前缀.col-sm-中等屏幕列前缀.col-md-宽屏幕列前缀.col-lg-有12份，让其占4分之一，即3份,所有盒子总和没达到12，则占不满，超过12，则另起一行（像浮动）.col-lg-3 大屏幕占4分之一，即3份，中等屏幕占3分之一，即4份，小屏幕占2分之一，即6份 .col-lg-3 col-md-4 col-sm-6 每一列的盒子里有默认左右15px的padding Bootstrap的列嵌套：父盒子会产生一个padding值，使得子盒子划分的时候没有按照父盒子的宽高划分，而是按照父盒子的宽高-padding值划分，所以在嵌套的时候最好加多一个盒子进行包装，并且此时子盒子和父级一样高： &lt;div class=\"col-md-4\"> &lt;div> &lt;div class=\"col-md-6\">&lt;/div> &lt;div class=\"col-md-6\">&lt;/div> &lt;/div> &lt;/div> &lt;div class=\"col-md-4\">&lt;/div> &lt;div class=\"col-md-4\">&lt;/div> &lt;div class=&quot;col-mid-4 col-md-offset-4&quot;&gt;&lt;/div&gt;的offset功能，在中间增加了4份的空格（1/3），实现每个盒子不必紧密相连的模型格式，其实可以把offset当成空盒子来看待 &lt;div class=&quot;col-md-4 colmd-push-8&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;col-md-4 colmd-pull-4&quot;&gt;右侧&lt;/div&gt;可以实现左右盒子颠倒的状态（做盒子推，右盒子拉） (4）响应式工具利用媒体查询功能，使用工具类可以方便针对不同设备展示或者隐藏页面内容（类似淘宝首页某类商品的隐藏） hidden-xs 超小屏：隐藏 小屏：可见 中屏：可见 大屏：可见 hidden-sm 超小屏：可见 小屏：隐藏 中屏：可见 大屏：可见 hidden-md 超小屏：可见 小屏：可见 中屏：隐藏 大屏：可见 hidden-lg 超小屏：可见 小屏：可见 中屏：可见 大屏：隐藏 &lt;div class=\"col-md-3 hidden-xs\">&lt;/div> 与之相反的是visible-xs，visible-sm等，可以实现广东财经大学首页的搜索栏隐藏模块功能 bootstrap官网里还有字体图标供给使用 bootstrap已经帮你写好清除浮动，只需添加类名clearfix 5.线性渐变颜色（针对于移动端）pc端需要很多私有前缀，特别麻烦，但是移动端只需要添加webkit就可以了 background: linear-gradient(起始方向,颜色1,颜色2); /*起始方向默认top*/ background: -webkit-linear-gradient(left,red,blue); /*一般都要添加-webkit-私有前缀*/ background: -webkit-linear-gradient(left top,red,blue); 6.CSS变量除了less可以声明变量，其实css自身也可以声明变量 CSS全局变量的声明是在变量名称前加两个中横线--，通常用于设置全局的主题颜色，主题背景颜色，字体大小等 :root { /* css定义变量的方式 */ /* 使用：var(变量名) */ --color-text: #666; --color-high-text: #ff5777; --color-tint: #fd5d7b; --color-background: #fff; --font-size: 20px; --line-height: 1.5; } /*使用*/ div { background-color: var(--color-tint); }","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"matlab期末知识点汇总","slug":"matlab期末知识点汇总","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-06T09:30:41.436Z","comments":true,"path":"2020/08/06/matlab-qi-mo-zhi-shi-dian-hui-zong/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/matlab-qi-mo-zhi-shi-dian-hui-zong/","excerpt":"","text":"regress命令 用于一元及多元线性回归 B = regress(Y,X)[B,BINT] = regress(Y,X)[B,BINT,R] = regress(Y,X)[B,BINT,R,RINT] = regress(Y,X)B,BINT,R,RINT,STATS] = regress(Y,X)[…] = regress(Y,X,ALPHA) B：回归系数，类似于斜率，是个向量（“the vector B of regression coefficients in the linear model Y = X*B”）。BINT：回归系数的区间估计（“a matrix BINT of 95% confidence intervals for B”）。R：残差（ “a vector R of residuals”）。RINT：置信区间（“a matrix RINT of intervals that can be used to diagnose outliers”）。STATS：用于检验回归模型的统计量。有4个数值：判定系数R^2，接近1，回归方程越显著，F统计量观测值，F越大，回归方程越显著，检验的p的值，误差方差的估计。ALPHA：显著性水平（缺少时为默认值0.05）。 %导入数据 y=[7613.51 7850.91 8381.86 9142.81 10813.6 8631.43 8124.94 9429.79 10230.81 ... 10163.61 9737.56 8561.06 7781.82 7110.97]&#39;; x1=[7666 7704 8148 8571 8679 7704 6471 5870 5289 3815 3335 2927 2758 2591]&#39;; x2=[16.22 16.85 17.93 17.28 17.23 17 19 18.22 16.3 13.37 11.62 10.36 9.83 9.25]&#39;; X=[ones(size(y)) x1.^2 x2.^2 x1 x2 x1.*x2]; % size（）：获取矩阵的行数和列数 % s=size(A), 当只有一个输出参数时，返回一个行向量，该行向量的第一个元素时矩阵的行数，第二个元素是矩阵的列数。 % ones(M,N)产生一个M*N的矩阵 %开始分析 [b,bint,r,rint,stats] = regress(y,X);创建残差的置信区间图用regress返回的值r，rint：rcoplot（r，rint） 线性回归模型类线性回归模型类 wlb=LinearModel; %创建线性回归类对象，对象名wlb wlb=LinearModel.fit(x,y); %创建线性回归类对象，并对观测 数据做多元线性回归 wlb.plot %绘制wlb的效果图 wlb.anova %给出方差分析表 [y,ly]=wlb.predict(x) %给出x预测和置信区间 wlb.plotResiduals %绘制残差图 wlb. plotDiagnoisetics(method) %绘制不同统计量的残差图分 析 properties(wlb) %显示所有统计量属性t值和显著性水平有什么样的对应关系t-检验：可以用于比较两组数据是否来自同一分布。（可以用于比较两组数据的区分度） 在统计检验中，统计量t值和显著性水平具有什么样的对应关系？一般来说，大样本和正态分布情况下的数据，当1.65&lt;|t|&lt;1.96时,p&lt;0.10;当1.96&lt;|t|&lt;2.58时，p&lt;0.05；|t|大于2.58时，p&lt;0.01。 但是要注意的是，当样本量很小（小于30），数据分布形态不明或明显不服从正态分布（一座山一样的分布）时，t值和显著性水平不一定完全对应，例如t值绝对值大于2时，p值有可能大于0.05，也就是不显著。这种情况一般要采用非参数检验的方法，而不是t检验。 1、t值，指的是T检验，主要用于样本含量较小（例如n&lt;30），总体标准差σ未知的正态分布资料。T检验是用t分布理论来推论差异发生的概率，从而比较两个平均数的差异是否显著。 2、P值，就是当原假设为真时，所得到的样本观察结果或更极端结果出现的概率。如果P值很小，说明原假设情况的发生的概率很小，而如果出现了，根据小概率原理，我们就有理由拒绝原假设，P值越小，我们拒绝原假设的理由越充分。 p值代表的是不接受原假设的最小的显著性水平，可以与选定的显著性水平直接比较。例如取5%的显著性水平，如果P值大于5%，就接受原假设，否则不接受原假设。这样不用计算t值，不用查表。 3、P值能直接跟显著性水平比较；而t值想要跟显著性水平比较，就得换算成P值，或者将显著性水平换算成t值。在相同自由度下，查t表所得t统计量值越大，其尾端概率P越小，两者是此消彼长的关系，但不是直线型负相关 怎么得到检验回归系数显著性的T值对于X、Y两个正态总体的样本，其t检验应使用ttest2()函数来检验假设。[H,P,CI]=ttest2(X,Y) ttest2（）函数是用来检验具有相同方差的两个正态总体均值差的假设检验（即两正态总体的检验法）。 基本调用格式： h=ttest2（x，y）判断来自不同正态总体的样本数据x与y是否有相同的均值。当h=0表示接受原假设，当h=1表示拒绝原假设。 h=ttest2（x，y，alpha）调用格式表示执行显著性水平为（100*alpha）%的假设检验。没有给出alpha值，默认alpha=0.05。 h=ttest2（x，y，alpha，tail）调用格式表示执行以tail指定的备择假设作假设检验，原假设为均值等于m，当tail=‘both’时表明备择假设为“x与y均值不相等”，当tail=‘right’时表明备择假设为“x的均值大于y的均值”，当tail=‘left’时表明备择假设为“x的均值小于y的均值”。regstats函数（回归系数显著性检测？）MATLAB统计工具箱中提供了regstats函数，也可用来作多重线性或广义线性回归分析，它的调用方式如下：regstats(y,X,model)stats = regstats(…)stats = regstats(y,X,model,whichstats) 非线性用nlinfit函数或者开启cftool工具箱 eye函数该函数返回单位矩阵。 Y = eye(n)：返回n*n单位矩阵； Y = eye(m,n)：返回m*n单位矩阵；","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"模拟退火算法","slug":"模拟退火算法","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-07T03:16:44.061Z","comments":true,"path":"2020/08/06/mo-ni-tui-huo-suan-fa/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/mo-ni-tui-huo-suan-fa/","excerpt":"","text":"1.模拟退火算法可能的情况很多，数据量太大，用模拟退火搜索出需要的解（求最值）（最大值问题可以添加负号转换成求最小值问题） 启发式搜索：利用搜索过程中获取的信息改进搜索策略。启发式搜索有利于找到问题最优解，且有助于加速求解过程。 模拟退火可以说是最简单（应用）的启发式搜索之一 相比起爬山法（找到局部最优解），模拟退火算法有一定概率能接受比当前还要差的解，概率p位于[0,1]，旧解和新解的函数值越接近，p值就越大（概率为0对应爬山法，概率为1对应蒙特卡洛算法）；时间越长，p值越小；搜索前期p大，后期p小 2.搜索过程1.随机生成一个解A，计算F(A) 2.在A附近随机生成一个解B，计算F(B) 3.对比F(A)和F(B)，进行对比，若F(B)&gt;F(A)（求最大值）,B赋值A，F(B)&lt;F(A)，计算接受B的概率，接受则B赋值A，且重复以上操作，否则返回第2步，在原来A附近再生成一个B继续下去 如果优化问题有约束条件： 1.生成B是查看是否符合要求 2.使用罚函数 与时间相关的系数Ct如何设置：Ct是温度t的倒数（模拟退火） 如何再A附近随机生成一个解B：没有统一规定，需要具体问题具体分析 停止搜索1.达到迭代次数 2.达到指定温度 3.找到连续最优解，M（如30次）次迭代还未改变 3.实现产生新解： 1.matlab内置工具 根据温度不同，新解距离旧解的步长改变，温度高步长高，温度低步长短，由全局缩短为 x_new=x_i+T×z_i 然后检查x_new是否位于上下界 2.旅行商问题 交换法，位移法，倒置法","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"数学建模国赛matlab知识点","slug":"数学建模国赛matlab知识点","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-22T07:55:04.587Z","comments":true,"path":"2020/08/06/shu-xue-jian-mo-guo-sai-matlab-zhi-shi-dian/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/shu-xue-jian-mo-guo-sai-matlab-zhi-shi-dian/","excerpt":"","text":"1.基础命令行太长，可加上三个小数点：“…” 进行分割（续行符），如 s=1-1/2+1/3-1/4... +1/5-1/6+1/7数值数据默认双精度double clear命令，清除工作区的所有变量 class(变量)得到变量类型 复型数据，虚数部分用i或j表示，如6+5i ，real函数求复数实部，imag函数求复数的虚部 以角度为单位的函数，在函数名后加“d”，如sin(pi/2)=sind(90) abs(xx)可求实数绝对值，复数的模，字符串的ascii码 rem(m,10)求m/10的余数 isprime(n)求n是否为素数，是返回1，否返回0 exp(pi/2)为e的2/Π次方 整形转换x=int8(129) //转有符号的int，最大127，即这里x=127 x=uint(129) //转无符号uint，即x=129 取整函数round()函数按照四舍五入 ceil()向上取整 floor()向下取整 fix()取靠近0的整数矩阵的建立//no.1 A=[1,2,3;4,5,6;7,8,9] //第一行1，2，3，第二行4，5，6冒号表达式e1:e2:e3 //分别为初始值，步长（两两之间间隔的大小，如果省略步长，则步长为1），终止值 inspace(a,b,n)//分别对应第一个元素，最后一个元素，元素总数（省略时为100）结构矩阵&amp;单位矩阵//结构矩阵 结构矩阵元素.成员名=表达式 a(1).x1=10; a(1).x2=&#39;liu&#39;; a(1).x3=[11,21;34,78]; //单元矩阵，用大括号 b={10,&#39;liu&#39;,[11,21;34,78]}2.矩阵引用矩阵元素A(3,2)表示A矩阵第三行，第二列元素 可用序号引用，如在A=[1,2,3;4,5,6;7,8,9]中，A(3)=7 (矩阵元素按列储存) D=sub2ind(S,I,J),分别为行数和列数组成的向量，转换矩阵元素的行下标，转换矩阵元素的列下标，D为序号（下标转序号） size(A)求矩阵A的行列数 [I,J]=ind2sub(S,D),分别为行数和列数组成的向量，序号（序号转下标） k=find(ch&gt;=&#39;a&#39;&amp;ch&lt;&#39;z&#39;) 找到符合条件的元素的序号 利用冒号获得子矩阵A(i,:) 第i行的所有元素 A(:,j) 第j列的所有元素 A(i:i+m,k:k+m) 第i~i+m行且在第k~k+m行的所有元素end运算符：表示某一维末尾下标 如：A(end,:)，是指A矩阵最后一行所有元素 利用空矩阵删除矩阵的元素将想要的元素范围赋值空矩阵[]即可，如A(:,[2,4])=[]，删除第二列，第四列元素 改变矩阵形状reshape(A,m,n)：在矩阵综援素不变的情况下，将A重新排列成m×n的二维矩阵 注意：并不改变元素个数及其储存顺序 A(:)：将矩阵A每一列元素堆叠起来成为一个列向量 3.算术运算&amp;字符串须知：加减运算两矩阵必须同型，乘法运算要求A行数和B的列数相同 点运算：两矩阵进行点运算是指它们对应元素进行运算，要求两矩阵同型 逻辑运算符：&amp;，|，~ 字符串和数值之间的转换：数值（ASCII码）=abs(字符串) 字符串=char(ASCII码) strncmp(s1,s2)：用于比较字符串s1，s2是否相等 strncmp(s1,s2,n)：用于比较字符串s1，s2前n个字符是否相等 strcmpi(s1,s2)：忽略大小写 4.特殊矩阵zeros函数：产生全零矩阵 ones函数：产生全1矩阵 eye函数：产生对角线为1的函数 rand函数：产生（0,1）区间均匀分布的随机矩阵 randn函数：产生均值为0，方差为1的标准正态分布随机矩阵 inv(矩阵)：求其逆矩阵 zeros(m):产生m×m零矩阵 zeros(m,n):产生m×n零矩阵特殊矩阵介绍： 魔方矩阵M=magic(8) (8行8列) 范德蒙矩阵vander(1:5) 希尔伯特矩阵：H=hilb(4) 伴随矩阵：A=compan(P) 帕斯卡矩阵：P=pascal(5) 对角阵对角矩阵：对角线上元素非零 数量矩阵：对角线上元素相等 对角矩阵：对角线上元素为1 diag(A)：提取矩阵A对角线元素，产生一个列向量 diag(A,k)：提取矩阵A第k条对角线元素，产生一个列向量 构造对角矩阵：diag(V)：以向量V为主对角线元素，产生对角矩阵 三角阵triu(A)：提取矩阵A的主对角线及以上的元素 tril(A)：提取矩阵A的主对角线及以下的元素 triu(A,k)：提取矩阵A的第k条主对角线及以上的元素 矩阵的转置A=[1,3;3+4i,1-2i] 转置：A.’ 共轭转置：A’ 若矩阵为实数，转置和共轭转置是一样的 矩阵旋转：rot90(A,k)，将矩阵A逆时针旋转90°的k倍，k为1可省略 矩阵左右翻转：fliplr(A) 矩阵上下翻转：flipud(A) 矩阵其他功能把一个方阵看作一行列式，并对其按行列式的规则求值：det(A) 求矩阵的秩：rank(A) 求矩阵的迹，即对角线元素之和：trace(A) 求矩阵A全部特征值，构成向量E：E=eig(A) 或者 [X,D]=eig(A) A的全部特征值构成对角阵D，X的各列是对应的特征向量 5.subplot画图subplot（m,n,p）或者subplot（mnp）此函数最常用：subplot是将多个图画到一个平面上的工具。其中，m表示是图排成m行，n表示图排成n列，也就是整个figure中有n个图是排成一行的，一共m行，如果第一个数字是2就是表示2行图。p是指你现在要把曲线画到figure中哪个图上，最后一个如果是1表示是从左到右第一个位置。 ） 6.MatLab中关于程序的操作建立函数，新建脚本，开头为： function C = 函数名( 参数A,参数B)，并且通过C返回（当有多个形参时，可用逗号分隔，而C为输出形参表，多个输出形参需要用方括号[] 括起来） 数据的输入：A=input(‘请输入A的值：’); 数据的输出：disp(输出项) 程序暂停：pause(延迟数秒),如果省略参数，则一直暂停，除非用户按任意键就可以继续执行 x^(1/3)=power(x,1/3) matlab中的switch case相对于C，java不需要break，且最后一个的default改成otherwise 匿名函数：简化了函数的过程：如f=@(x,y)x^2+y^2，f(3,4)进行调用，但是不适用于复杂函数 7.Plot函数plot(x,y)，x，y分别存储x，y坐标的数据 最简单的plot调用格式：plot(x)，下标为横坐标，值为纵坐标 x,y为同型矩阵，则分别对应x，y坐标绘画出曲线图 多条曲线可以plot(x1,y1,x2,y2,x3,y3……) x=linspace(0,2*pi,100) ,位置0到2pi的100个元素存于x plot（x,y,选项）选项有线性，颜色，数据点标记 线型：“ - ” 实线, “ : ”虚线, “ -. ”点画线, “ – ” 双画线 颜色：“ r ”红，“ g ”绿，“ b ”蓝。。。。。。 数据点标记：“ * ”星号，“ o ”圆圈，” s “方块。。。。 8.fplot函数fplot（f,lim,选项），f是函数，lim是x的取值范围，用二元向量[xmin,xmax]表示，默认[-5,5]，选项和plot相同 自变量无法间隔采样时使用fplot（函数变化趋势未知，或者在不同区间函数变化频率过大，如sin（x/1）） 9.曲线拟合polyfit（）进行拟合，找一个函数去逼近数据，再根据找到的函数预测下一个点的值（如 人口预测问题）（它实际上是求得最小二乘法拟合的多项式系数） p=ployfit（x,y,3）生成三次多项式函数，调用ployval（p,2020）进行计算（求2020年的人口）","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"JavaScript基础","slug":"JavaScript基础","date":"2020-07-21T14:14:19.766Z","updated":"2021-03-24T07:39:35.191Z","comments":true,"path":"2020/07/21/javascript-ji-chu/","link":"","permalink":"https://taylor12138.github.io/2020/07/21/javascript-ji-chu/","excerpt":"","text":"1.JS的介绍JS是脚本语言，不需要编译，直接由js解释器逐行进行解释并执行，现在也可以基于node.js技术（后台）进行服务器编程 实现业务逻辑和页面控制功能，浏览器的JS引擎，也就是JS解释器，用来读取JS代码 JS的组成JavaScript语法：ECMAScript 页面文档对象模型：DOM 浏览器对象模型：BOM ECMAScript它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和拓展 DOM它是标准编程接口，通过DOM提供的接口可以对页面上各种元素进行操作（大小位置颜色） BOM它提供了独立于内容，可以与浏览器窗口进行互动的对象，操作浏览器窗口比如弹出窗，控制浏览器跳转，获取分辨率等 JS的三种书写 类似于CSS，有行内式，内嵌式&lt;script&gt;xxxx&lt;/script&gt; 还有从外部引入：(script标签中间别写代码) &lt;script src=\"xx.js\">&lt;/script> 2.JS基本功能介绍输入输出alert(msg); //弹出警示框 console.log(msg) //打印输出信息，是控制台输出，给程序猿测试用的 prompt(info) //弹出输入框，提供用户输入 但是都是以字符的形式输入console.log()会在浏览器控制台打印出信息 console.dir()可以显示一个对象的所有属性和方法 定义使用var，自动确定类型（JS拥有动态类型） var 如果没有事先声明var，直接使用，会创建一个全局变量 var存在声明提升 功能isNaN() 判断是否非数字 typeof 变量名 查看数据类型 转换转字符串： ​ 变量名.toString() number类型时，变量名.toString(16) 转换成16进制字符串 ​ 强制转换：String(变量名) ​ 隐式转换：变量名+”xxxx”(拼接字符串) String转数字类型： （1）String-&gt;int： parseInt(String)； （2） String-&gt;float: parseFloat(String)； （3）Number强制转换（String转数值）：Number(String) （4）利用加减乘除：String-String或String-int之类的 运算符18==‘18’ 成立true，默认转换数据类型 ===为全等需要完全一致， 18===‘18’为false 逻辑与短路运算：123&amp;&amp;456，返回456，左式为真返回右式子，为假返回左式 逻辑或短路运算：123||456，返回123，左式为真返回左式子，为假返回右式 三元表达式： 条件表达式？表达式1：表达式2，条件为真返回表达式1，为假返回表达式2 数组数组名.length为数组的长度 数组增加元素 （1）直接设定数组长度arr.length=xx,多出来的变成空 （2）arr数组有三个元素，直接arr[3]=xx，进行新增元素 基本数据类型： Boolean Null Undefined Number BigInt：BigInt数据类型的目的是比Number数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用BigInt，整数溢出将不再是问题。 String Symbol Object 总结：USONB （you are so niubi） u：undefined s：string、symbol o：object n：null、number b：boolean 判断JS数据类型的四种方法 typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。返回值是一个字符串，该字符串说明运算数的类型。注意：typeof null 返回 object 所以经常搭配使用：if(typeof target === &#39;object&#39; &amp;&amp; target !== null){} instanceof 用于判断一个变量是否某个对象的实例，如 var a=new Array();alert(a instanceof Array); 会返回 true constructor alert(c.constructor === Array) ----------> true alert(d.constructor === Date) -----------> true alert(e.constructor === Function) -------> true 注意： constructor 在类继承时会出错， null 和 undefined 是无效的对象，因此是不会有 constructor 存在的 toString，利用toString打印出原型对象 Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ;// [object Boolean] 3.函数//1.利用函数关键字自定义函数 function 函数名(参数) { 函数体 } //如下： function sort(arr){ } //2.匿名函数 var fun=function(){ } //调用 fun(); 函数没有return，则返回的是undefined 注意在函数内部没有声明直接赋值的变量，也属于全局变量 预解析js引擎运行js，分为两步：1.预解析 2.代码执行 预解析：js会把里面所有var还有function提升到当前作用域的最前面（分别为变量提升和函数提升） 变量提升：把所有变量声明提升至当前作用于最前，但是不提升赋值操作 4.对象对象一定是一个具体的对象，而不是泛指的东西 属性：事物的特征，用对象的属性表示 方法：事物的行为，在对象中方法来表示 利用对象字面量创建对象var obj ={ uname:'xx', age:18, sex:'man', say:function(){ console.log('good'); } } //调用对象属性(2种) obj.uname obj['uname'] (1)键 属性名: 值 属性值 (2)用逗号隔开 (3)方法冒号后面跟的一个匿名函数 利用new Object创建对象再赋值的时候创建属性，因此此方法效率不高 var obj = new Object obj.uname='xx'; obj.age=18; obj.say=funciton(){} （1）利用等号赋值添加对象的属性和方法 （2）每个属性和方法用分号 利用构造函数创建对象其过程也称为对象的实例化,构造函数是泛指的某一大类，对象是具体的事物 function 构造函数名(){ this.属性=值; this.方法=function（）{} } 1.使用构造函数，构造函数名字首字母最好大写如 function Star()2.构造函数不需要return3.使用函数new 构造函数名();即构造一个对象，如new Array()，创建一个数组对象4.属性方法前必须加this如this.name=传参name this.song = function（传参）{} 遍历对象for (var k in obj){ //obj为对象 console.log(k); //k输出的是属性名 console.log(obj[k]);//得到的是属性值 } //我们使用for in 喜欢var k或者key //或者使用 for (let item of obj) { console.log(book); //每个属性的属性值 } 对象删除键值对var json = { name:'张三', age:'23' }; delete json.age; 5.内置对象JavaScript中对象分为自定义对象，内置对象，浏览器对象，前两种属于ECMAScript；第三个浏览器对象是js特有的 Javascript提供了多个和内置对象：Math、Date、Array、String 可以通过MDN/W3C来查询内置对象的使用 MDN的网址：https://developer.mozilla.org/zh-CN/ （1）Math对象//绝对值方法： Math.abs(-1) //1 Math.abs('-1') //1,隐式转换 Math.abs('pink') //NAN Math.PI //圆周率 Math.floor(x) //向下取整 Math.ceil(x) //向上取整 Math.round(x) //四舍五入 Math.max(x) //最大值 Math.min(x) //最小值 Math.random() //随机 0&lt;=x&lt;1 Math.floor(Math.random()*(x_max-x_min+1))+x_min//得到两个数之间的随机整数 无穷大：Number.MAX_VALUE 函数 toFixed(n) 将数字舍入到小数点后 n 位，并以字符串形式返回结果。 let num = 12.34; alert( num.toFixed(1) ); // \"12.3\" （2）Date对象是一个构造函数，必须使用new调用 var date = new Date(); //无参数，返回当前系统的时间 //常用的两种时间写法 var date = new Date(2020, 10, 1); //指定固定日期 var date = new Date('2020-10-1 8:8:8'); //返回年份，月份，日期 date.getFullYear(); date.getMonth()+1; //0-11 + 1 = 1-12 date.getDate(); //距离1970年 1.1经历的毫秒数，用来：d=parsent（总秒数/60/60/24）得到天数等单位 date.valueOf() date.getTime() var date1= +new Date(); //最常用 Date.now() //H5新增 由于开发中时间戳转换为日期太过于常见，所以网上有直接封装好的（使用的是正则表达式）的函数，直接格式化即可 （3）数组对象数组的每个槽位可以储存任意类型数据 var arr1 = new Array(2,3); //相当于[2,3]的数组 var arr = new Array(5).fill(); //创造一个数组长度为5的数组，但是此方法会自动往里面填undefined值，让数组最起码有值了！ var arr = new Array(5).fill(0);//也可以填写你想要的值，比如0 但是如果想创建一个用空对象填充的数组话，实际上我们在使用同一个 空对象 / 空数组进行提埃填充，这样会造成他们都是联动的，牵一发而动全身 let a = new Array(5).fill({}); console.log(a); // [{}, {}, {}, {}, {}] a[0].name = '张三'; console.log(a); // [{name: \"张三\"}, {name: \"张三\"}, {name: \"张三\"}, {name: \"张三\"}, {name: \"张三\"}] arr1 instanceof Array //检验是否为数组，是返回true，否则false Array.isArray(arr1); //同上,H5新增,但这个效果好，防止多个不同版本的Array构造函数 arr1.push(xx); //在数组末尾增加数组元素，push完毕之后，返回结果是新数组的长度,push实际上可以接收多个参数一次增加 arr1.unshift(xx); //在数组开头增加数组元素，unshift完毕之后，返回结果是新数组的长度 arr1.pop(); //删除数组的最后一个元素 返回值为被删除的元素值 arr1.shift(); //删除数组的第一个元素 返回值为被删除的元素值 arr1.reverse(); //翻转数组 arr1.sort(function(a,b) { return a-b; }); //该排序可能是快排等结合的很优算法。升序 如果不加function则为按照字符串排序 arr1.indexOf(xx); //返回该数组元素的索引号（只返回第一个满足条件的索引号），找不到返回-1 //indexOf还可以用于判断对象是否存在 arr1.includes(xx); //是否含有该元素，判断对象是否存在 arr1.lastindexOf(xx);//同上，只返回倒数第一个满足条件的索引号 arr1.toString(); //转换成字符串，逗号分隔 arr1.join('你想要的分隔符'); //用指定分隔符分割不同的数组元素，并转换成字符串 array.splice(开始的指针下标,删除的个数[, item1[, item2[, ...]]]); //用于删除多组元素并且添加新元素 arr.splice(2,1,\"William\"); //从index序号为2地开始，删除掉一个，并添加william元素 arr.slice(start,end) //slice() 方法可从已有的数组中返回选定的元素。 //这里是指从start到end-1，不包含end arr.concat(arrayX,arrayX) //concat() 方法用于连接两个或多个数组。 //该方法不会改变现有的数组，而仅仅会返回被连接数组的一 //个副本。 //案例，数组去重 //利用indexoOf，返回-1则添加入新数组 function unique(arr) { var newArr = []; //另一种创建数组方式 for(int i = 0; i &lt; arr.length; i++){ if(newArr.indexOf(arr[i]) == -1) { newArr.push(arr[i]); } } } 6.基本包装类型基本数据类型是没有属性和方法的，而对象才有属性和方法 //String var str = 'andy'; //但是str可以使用str.length,因为jshui把基本数据类型包装成复杂数据类型，操作如下 var temp = new String('andy'); str = temp; temp = null; //因为字符串不可变，所以每次str += i ，拼接字符串会开辟另外一个内存空间，字符串赋值同理 //String 同样有很多很多数组对象的属性功能 str.indexOf('xx'); str.indexOf('查找的字符',[起始的位置]); //这个也可以 str.charAt(位置); //根据位置返回字符 str.charCodeAt(位置); //根据位置返回字符的ASCII码 str[index]; //同str.charAt，H5新增 str.replace(被替换的字符,替换的字符); //只替换掉里面第一个字符 判断一个对象是否有该属性 可使用对象[‘属性名’], 返回true则有，反则返回false 截取字符串str.substr(start,length); //start位置开始，length取的个数，省略length则默认取到最后 str.slice(start,end); //start开始，截取到end，但是end截取不到 数组对象转字符用join()，字符转数组用split var str = 'red, pink, blue'; console.log(str.spilt(',')); //用逗号分隔 str.toUpperCase() 转换大写， str.toLowerCase() 转换小写 7.简单类型和复杂类型如果有个数据类型打算作为存储对象，暂时没想好放什么，可以先放null 简单数据类型（值类型）：string（但是string数值不可变）、number、boolean、undefined、null 简单数据类型放入栈里面（操作系统），栈里开辟的空间存放的是值 （用函数传参是不会影响变量的值） 复杂数据类型（引用类型）：Object、 Array、 Date 复杂数据类型放入堆里面（操作系统），于栈里存放地址，十六进制表示，然后这个地址指向堆里的数值；一般由程序员分配释放，若程序员不释放，由垃圾回收机制释放 （用函数传参是会影响对象的值） 但是复杂数据类型null赋值时断了地址联系 var obj = new Object(); obj.name = 'allen'; var obj2 = obj; console.log(obj2.name); //allen obj.name = 'bllen'; //改对象 console.log(obj2.name); //bllen obj = null; //改变量 console.log(obj2.name); //bllen 但是JS里没有堆栈的概念，只是通过堆栈的方式理解代码的执行方式 8.APIs介绍Web APIs我们主要学习的是DOM和BOM，进行页面交互 API是预先定义的函数，提供给开发人员直接调用，无需访问源码工作细节 Web API 是浏览器提供的一套操作浏览器功能和页面元素的api（DOM和BOM） 9.其他swiper插件的使用官网地址：https://www.swiper.com.cn （1）下载并解压包后，把其中的swiper.min.js和swiper.min.css放入网页文件夹的js和css中 （2）官网找到类似的案例，复制html，css和js（进入官网swiper演示中，然后新窗口打开，查看网页源代码） （3）根据需求修改模块 模块JavaScript天生不支持模块化，node.js中才有 但是在浏览器中也可以像在node.js中模块进行编程，如果 &lt;scirpt&gt;标签进行引用加载，还得考虑加载顺序问题，这时需要第三方库： require.js（AMD）或sea.js（CMD） 为了上述方法都是民间自主创造出来的，为了解决模块化问题，官方自己发布了ES6标准，其中包含了官方对JavaScript模块化的支持，虽然标准已经发布，但是JavaScript运行环境还不支持 目前很多前端都是使用很多新技术，然后利用编译器工具打包，可以在低版本浏览器中运行，类似于less =&gt; css 浅拷贝和深拷贝深拷贝和浅拷贝是只针对object和Array这样的引用数据类型的 1.赋值当我们把一个对象赋值给一个新的变量时，赋的其实是该对象在栈中的地址，而不是堆中的数据，只要修改了里面的的值，原来都都会受到影响 2.浅拷贝他会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性基本类型，拷贝的基本类型的值（修改后原来的变量的值不会受到影响）；如果属性是内存地址（引用类型，比如数组、对象），拷贝的就是内存地址，即其中一个变量修改了这个地址存放的对象，则另外一个会受到影响 数组的浅拷贝可以使用：Array.prototype.concat()、Array.prototype.slice()，他们不会修改原数组，只是返回了一个浅拷贝的新数组 对象可以使用 ：Object.assgin() 3.深拷贝所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝，使得两个对象不会相互影响 具体深拷贝的手写我在 “JavaScript进阶ES5+面向对象”篇章中写过","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"CSS高级","slug":"CSS高级","date":"2020-05-30T16:00:00.000Z","updated":"2021-03-19T12:43:38.516Z","comments":true,"path":"2020/05/31/css-gao-ji/","link":"","permalink":"https://taylor12138.github.io/2020/05/31/css-gao-ji/","excerpt":"","text":"1.精灵图为了有效减少服务器接收和发射请求次数，提高速度出现的CSS技术。即将网页小背景图合成一张大图。 主要针对于背景图片（非产品类等更新换代图片） 主要使用background-position+x和y轴配合使用，x轴向右，y轴向下 background: url()no-repeat -182px 0; //分别对应x轴，y轴,基本都是负值缺点：文件大，放大缩小会失真，更换复杂 2.字体图标iconfont常用于一些小图标（样式简单），展示状态时图标，实际上是字体 优点1.轻量级，够小 2.灵活性，可改多种效果 3.几乎支持所有浏览器 下载：相应网站（如https://icomoon.io/）下载后得到压缩包，解压后，把下载包里的fonts放入页面根目录下 使用：在CSS中根据说明引用全局声明，然后再在个体css中再次引用你想要的声明，同时可以自己调色和字体大小（font-size） 这里以阿里的图标为例子，把项目添加好之后，根据操作https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.16&amp;helptype=code一步一步来（这里是unicode引用），注意：**复制代码的时候，一定要在url的值中补充 “http:”** （使用bootstrap框架，可以直接使用其官网给的图标） 3.三角形若盒子设置宽高为0；此时又设置边框，则会形成组成一个正方形的4个三角形，实际上我们写三角形可以利用这个原理，把其他三个三角形隐藏起来则就只有一个三角形了 width: 0; height: 0; /*line-height: 0; font-size: 0; 有时需要添加，看浏览器*/ /*先设置一个边框，尽量大，以边框概括盒子大小*/ border: 50px solid #ccc; border-color: transparent red transparent transparent //上右下左的颜色 4.用户界面鼠标样式 cursorcursor: defalut 默认无样式 cursor: pointer 小手 cursor: move 移动 cursor: text 文本 cursor: not-allowed 禁止 轮廓线给表单（input）添加 outline: 0;，点击表单时，会去掉默认的l蓝色光标 防止拖拽文本域textarea{ resize: none }可以使文本框没有拖拽选项 5.Vertical-align(图片)css常用vertical-align让图片和文字对齐（但是只能针对行内元素或者行内块元素） vertical-align: middle; 中线对齐（一般使用这个来对齐） 图片底侧放置于盒子内时，时常有一个空白缝隙，可以使用vertical-align: middle||top||bottom;将其解决 （其实还可以直接转成块元素，但是此方法不提倡） 6.文字溢出变省略号（推荐让后端写）单行文本：white-space: nowrap //强制一行内显示 ​ overflow: hidden; //溢出隐藏 ​ text-overflow: ellipsis ///变成省略号 多行文本：（有较大兼容性问题，适用于移动端或者webkit浏览器） ​ overflow: hidden; + text-overflow: ellipsis display: -webkit-box; /*单行伸缩盒子*/ -webkit-line-clamp: 2; /*限制其文本行数*/ -webkit-box-orient: vertical; /*设置盒子的子元素排列方式，（垂直居中）*/ 7.常见布局技巧可以使用margin的负值来消除浮动边框的重合（消除产生的巨大影子）如： margin-left: -Xpx; 想要移动到某个边框内自动变色可以使用hover，但是当排列方式为每个盒子的右边框被另外一个盒子的左边框压住时，变色效果会出bug，正确做法是：xx:hover{ position: relative; }添加相对定位使其马上覆盖当前所有单位 如果失败，有可能是因为当前已经添加了绝对定位了，此时只需要提高层级：z-index: 1; 8.CSS初始化为了照顾浏览器兼容，必须首先进行CSS初始化，即重新设定CSS个标签的初始默认值 9.CSS3新特性ie9+才支持 属性选择器可以不借助类选择器 input[att] {} 带有att属性值的被选中input[att=&quot;value&quot;] {} 带有att属性并且属性值等于value被选中 input[class^=icon]{} 选择类属性以icon开头的所有标签 input[class$=icon]{} 选择类属性以icon结尾的所有标签 input[class*=icon]{} 选择类属性含有icon的所有标签 如 .local-nav li [class^=\"local-nav-icon\"] { } 类选择器，伪类选择器，属性选择器（这个一般是11，因为包含标签名+属性名=1+10=11）它们权重都为10 结构伪类选择器first和last等可以来了解一下，实际开发不太建议使用，也比较少使用。 值得注意的是 nth-child(n)比较重要 n可以是数字，可以是关键字（even偶数，odd奇数），甚至公式 ul li:nth-child(even){ } //选择所有的偶数孩子 ul li:nth-child(n){ } //选择所有孩子,因为n是公式类似n++，依次施加CSS效果 ul li:nth-child(2n){ } //选择所有的偶数孩子 ul li:nth-child(-n+5){ } //选择前5个孩子 nth-of-type和nth-child的不同： section div:nth-child(1){ } //先排序，再看是否符合div，如果是div就渲染 section div:nth-type(1){ } //先看是否符合div，如果是就在div里排序，选择第一个就渲染 伪元素选择器通过CSS创建新的子标签（比较简单的），从而简化html结构，（还与之前清除浮动使用的伪元素方法有关） element::before{ content：'XX'; /*必须要有content属性，为内容*/ 样式 } /*在元素内部前面（左）插入内容*/ element::after{ content: 'XX'; 样式 } /*在元素内部后面（右）插入内容*/ 它和标签选择器一样，权重=1，且为行内元素，想要设置大小必须转行内块 （还可以有element:hover::before{}的操作） CSS3盒子模型只需增加如下代码 box-sizing: content-box; /*默认*/ box-sizing: border-box; /*只看盒子大小，不考虑border和padding因素*/ 即可不用考虑border和padding因素是否会将盒子本身撑大。 这里提及到盒子模型就讲一讲标准盒模型和怪异盒模型 W3C盒子模型(标准盒模型)和IE盒子模型(怪异盒模型)标准盒模型： 盒子实际内容（content）的width/height=我们设置的width/height; 盒子总宽度/高度=width/height+padding+border+margin。 怪异盒模型： 盒子的（content）宽度+内边距padding+边框border宽度=我们设置的width/heigh 盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin。 总结： 总大小其实是一样的，只是我们设置标准盒子宽高是设置内容宽高，设置怪异盒子宽高是内容 + padding + border 宽高 CSS3滤镜filter用于模糊图形效果，filter: 函数(); 如：filter:blur(5px); //模糊处理，数值越大越模糊 …… CSS3calc函数(计算函数)width: calc(100% - 80px); //宽度永远比父盒子宽度小30px CSS过渡（重点）一些变化的动画效果（时间缓滞），经常和 :hover 一起搭配 transition: 要过渡的属性 花费的时间（单位为s） 运动曲线（默认ease，可以省略） 何时开始（默认0s，可省略）; transition: width 0.5s,heigh 0.5s; /*多个属性\",\"分割，想要更多属性，直接属性值写all*/ xx:hover{width:100px;heigh:100px;} transition: all 0.xs; 使用的比较多 10.CSS的morecss的2D转换transform可以理解为变形 移动：translate 旋转：rotate 缩放：scale 2d为二维坐标，x轴向右，y轴向下 translate类似于定位transform:translate(x,y); transform:translateX(n); transform:translateY(n); /*单位是px，如果是百分号，则它的距离是盒子自身高宽对比出来的*/ translate最大的优点：不会影响其他元素的位置，绝对定位会脱标，margin会影响，（有点像相对定位，但是更方便，可以加过渡效果） 可用于定位父盒子的中间位置 使用： position: absolute; top: 50%; left: 50%; transform:translate(-50%,-50%);但是它对行内标签没有效果 rotate旋转transform:rotate(度数deg); transform-origin:x y; /*设置元素旋转依靠的中心点*/ x，y默认为50%，50%，设置x，y可以可是bottom，left等，如transform-origin:left bottom;为设置左下角为中心点 scale之缩放transform:scale(x,y);/*里面的数字不跟单位，是倍数，x，y分别是宽，高*/ transform-origin:x y; /*设置元素旋转依靠的中心点*/ 若只有一个参数，则同比放大 使用scale的优点：变大时不会影响其他盒子的位置，且放大是以中心向外扩张的放大，直接修改width和heigh放大是直接往下放大 动画用keyframes定义动画 @keyframes 动画名称 { 0%{ width:100px.... } 100%{ width:200px.... } }//可以设置25%，75%等多个状态，习惯上把0%也写了 //以下也可以 @keyframes 动画名称 { form{ width:100px.... } to{ width:200px.... } } 0%动画的开始 100%动画的结束 1.可以做多个状态变化 keyframe关键帧 2.里面的数字为整数 3.百分比为时间的划分 使用动画： div { animation-name:动画名称; animation-duration:持续时间; animation-iteration-count:播放次数，可以为infinite; animation-direction:xx; //默认normal，alternate为设置逆向播放 animation-fill-mode:xx; //默认backwards，动画结束后返回原来位置，forwards可取消该功能 animation-play-state:xx; //running/paused 是动画运行或者暂停 animation-timing-fuction: ease; //默认ease加速度，linear匀速，step分步。。。 }使用多个动画用“，”分隔，如animation: bear 0.7s steps(8) infinite, move 0.7s …… 3D转换x轴向右，y轴向下，z轴向外，最常用的是3d位移和3d旋转,以下许多功能与2d十分相似 3d移动transform: translate3d(x,y,z); transform:translateZ(n); /*translateZ一般采用px，3d的z轴显现出来需要透视功能*/ 透视透视我们也成为视距，即眼睛到屏幕的距离，透视的单位是像素，透视越小，盒子越大 透视写在被观察元素的父盒子上 perspective: xxpx;3d旋转一般加上透视效果会比较明显，3d旋转方向遵循左手定则： 左手大拇指指向x轴正方向，手指弯曲的方向则为旋转的方向 transform: rotateX(度数); /*沿着X轴旋转*/ transform: rotateY(度数); transform: rotateZ(度数); /*z轴旋转和2d普通rotate有点像*/ transform: rotate3d(x,y,z,度数); /*自定义轴旋转*/ 自定义旋转只对x轴选取为transform: rotate3d(1,0,0,度数); 对角线旋转为transform: rotate3d(1,1,0,度数) transform要看情况选择：先写旋转rotate再写移动translate或者相反情况 3d呈现transform-style控制子元素是否开启三维立体环境，代码要写给父级（一定是父级，不能爷爷级别，亲测过），此属性很重要 transform-style: preserve-3d /*此为开启立体空间，但是默认值为flat，不开启立体空间*/ 11.CSS动画和JS动画的对比CSS动画优点： 动画流畅 性能较优 动画效果对帧速不好的低版本浏览器 代码简单，调优方向固定 缺点： 运行过程控制较弱,无法附加事件绑定回调函数 代码冗长 JS动画优点： JavaScript动画控制能力很强，动画能力强 兼容性好 12.CSS的repaint和reflow 以上为浏览器解析流程图 1、解析HTML以构建DOM树：渲染引擎开始解析HTML文档，转换树中的html标签或js生成的标签到DOM节点，它被称为 – 内容树。 2、构建渲染树：解析CSS（包括外部CSS文件和样式元素以及js生成的样式），根据CSS选择器计算出节点的样式，创建另一个树 —- 渲染树。3、布局渲染树: 从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。4、绘制渲染树: 遍历渲染树，每个节点将使用UI后端层来绘制。 reflow对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算并根据计算结果将元素放到它该出现的位置，过程称为reflow 它一般在DOM元素位置发生改变后触发，比如JS添加 DOM元素，CSS width的改变、CSS3的animation、Scroll页面 repaint当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，过程称为repaint 它一般在改变 DOM 元素的视觉效果时触发，即不涉及任何排版布局的问题时触发，比如color、text-align、a:hover、`` 我们应该减少reflow和repaint的操作，提高渲染速度 reflow的成本比repaint高很多 下面操作可能导致高成本的消耗： 当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint。 当你移动 DOM 的位置，或是搞个动画的时候。 当你修改 CSS 样式的时候。 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。 当你修改网页的默认字体时。 display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint 优化方式 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className： 减少使用table布局 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"CSS定位&显示","slug":"CSS定位&显示","date":"2020-05-27T16:00:00.000Z","updated":"2021-03-15T17:09:32.830Z","comments":true,"path":"2020/05/28/css-ding-wei-xian-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/28/css-ding-wei-xian-shi/","excerpt":"","text":"CSS定位1.某个元素可以在盒子内移动位置，并且压住其他盒子。 2.滚动窗口时，盒子固定于屏幕某个位置。 定位=定位模式+边偏移量 定位选择器{ position: static; position: relative; position: absolute; position: fixed; position: sticky; top: 100px; //必备的指定位置，可以为left，right，bottom } position: static; //默认，无定位,标准流特性 position: relative; //相对定位，参照点是自己，移动位置后，原来的位置继续占有 position: absolute; //绝对定位，是相对于他的祖先元素。 1.没有祖先元素或者，祖先元素没有使用定位，则以浏览器为准直接偏移 2.如果祖先元素有定位（相对，绝对，固定），则以最近一级定位的祖先元素为参考点 3.绝对定位不再占有原来的位置（脱标） 4.加了绝对定位的盒子不能通过 margin: 0 auto; 来居中，让它居中的原理和fixed设置版心的原理差不多，都是left：50%+margin组合 position: fixed; //固定于浏览器可视区位置，不占有原先位置 1.还可以设置于版心附近，方法：让那个固定定位的盒子 left: 50%,然后让固定定位的盒子margin-left：版心的一半距离 position: sticky; //粘性定位，被认为相对定位和固定定位的混合体 relative -&gt; fixed 1.以浏览器可视窗口为参照移动的元素（固定特点） 2.粘性定位占有原先的位置 3.必须添加top，left等，不然相当于相对定位 4.常用于导航栏的滚动 缺点：很多比较老的浏览器都不支持（移动端不考虑） (子绝父相—–出自pink老师) -&gt;&gt;&gt;&gt;&gt;&gt;&gt; —–&gt; 子级使用绝对定位，父亲则需要使用相对定位 位置如果一个定位既设置了left，也设置了right，它默认会执行left。若及设置了top，也设置了bottom，会默认执行top（无关权重的事情） 定位叠放次序通过控制z-index来控制盒子的前后次序（叠放次序）z-index： 1; 1.数值越大盒子越靠上 2.如果值相同，按照书写顺序，后来居上 3.数字不能加单位 4.只有定位盒子才有z-index属性（还有flex） 定位的特殊性质1.行内元素添加绝对或固定定位，可以直接设置高度和宽度 2.块级元素添加绝对或固定定位，未设置宽高，会脱标，默认内容大小（类似浮动）（不会发生外边距合并） 3.和浮动不同，绝对或固定定位会压住你标准流文字等内容 元素的显示和隐藏1.displaydisplay: none; 隐藏对象（不再占有原来的位置，可以用于js的下拉菜单等功能） display: block; 显示对象（也可以是转换块元素） 2.visiblevisibility: visible; 元素可视 visibility: hidden; 元素隐藏（仍然占有原来位置） 3.overflowoverflow: visible; 超出你的标签部分（固定大小）可见 overflow: hidden; 超出你的标签部分（固定大小）隐藏，如果有定位的盒子慎用，他会切掉你溢出布局标签的部分 overflow: scroll; 可添加滚动条 overflow: auto; 需要的时候添加滚动条","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"基数排序","slug":"基数排序","date":"2020-05-17T12:55:49.418Z","updated":"2021-03-24T16:43:48.713Z","comments":true,"path":"2020/05/17/ji-shu-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/ji-shu-pai-xu/","excerpt":"","text":"基数排序使用的大致思路是：根据关键字进行分类，再次排序，在分类，在排序，以此类推直至完成结果 如扑克牌中根据分13类，排序，再根据花色分类，再排序； 对百位数排序，先根据个位分类，排，再根据十位分类，排，再根据百位分类，排 //算法8.12 基数排序 #include using namespace std; #include #include #include #define MAXNUM_KEY 8 //关键字项数的最大值 #define RADIX 10 //关键字基数，此时是十进制整数的基数 #define MAX_SPACE 10000 typedef char KeysType; //定义关键字类型为字符型 typedef int InfoType; //定义其它数据项的类型 typedef struct { KeysType keys[MAXNUM_KEY]; //关键字 InfoType otheritems; //其他数据项 int next; }SLCell; //静态链表的结点类型 typedef struct { SLCell r[MAX_SPACE]; //静态链表的可利用空间，r[0]为头结点 int keynum; //记录的当前关键字个数 int recnum; //静态链表的当前长度 }SLList; //静态链表类型 typedef int ArrType[RADIX]; //指针数组类型 void InitList(SLList *L) { //初始化静态链表L（把数组D中的数据存于L中） char c[MAXNUM_KEY],c1[MAXNUM_KEY]; int i,j,n,max; //max为关键字的最大值 max=-10000; cout","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"归并排序","slug":"归并排序","date":"2020-05-17T11:52:57.097Z","updated":"2020-05-17T12:32:39.626Z","comments":true,"path":"2020/05/17/gui-bing-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/gui-bing-pai-xu/","excerpt":"","text":"归并排序将相邻的两个记录（序列）排序，并成一个有序序列，并继续上述操作 //算法8.11 归并排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }RedType; typedef struct { RedType *r; int length; }SqList; void Create_Sq(SqList &L) { int i,n; cout","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"简单选择排序","slug":"简单选择排序","date":"2020-05-17T11:35:13.462Z","updated":"2020-10-26T09:00:27.784Z","comments":true,"path":"2020/05/17/jian-dan-xuan-ze-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/jian-dan-xuan-ze-pai-xu/","excerpt":"","text":"简单选择排序选择关键字储存最小的记录：和表中的记录进行一一对比，选出最小记录放在开头，接着从第二个记录继续开始 //算法8.6 简单选择排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void SelectSort(SqList &amp;L) { //对顺序表L做简单选择排序 int i,j,k; ElemType t; for(i=1;i&lt;L.length;++i) { //在L.r[i..L.length] 中选择关键字最小的记录 k=i; for(j=i+1;j&lt;=L.length;++j) if(L.r[j].key&lt;L.r[k].key) k=j; //k指向此趟排序中关键字最小的记录 if(k!=i) {t=L.r[i];L.r[i]=L.r[k];L.r[k]=t;} //交换r[i]与r[k] } //for } // SelectSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); SelectSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序，但如果是采用“交换记录”，则会导致不稳定现象 2.顺序，链式皆可以使用 3.时间复杂度O( n^2 ),比直接插入快。 空间复杂度为O(l1).","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"快速排序","slug":"快速排序","date":"2020-05-17T10:28:42.342Z","updated":"2021-03-24T16:39:07.650Z","comments":true,"path":"2020/05/17/kuai-su-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/kuai-su-pai-xu/","excerpt":"","text":"快速排序设置个关键字，将大的放在它后面，小的放在前面，分成两个子表，并且重复上述过程，直到每一个子表只有一个记录为止 //算法8.5 快速排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 int Partition(SqList &L,int low,int high) { //对顺序表L中的子表r[low..high]进行一趟排序，返回枢轴位置 int pivotkey; L.r[0]=L.r[low]; //用子表的第一个记录做枢轴记录 pivotkey=L.r[low].key; //枢轴记录关键字保存在pivotkey中 while(low","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-05-17T10:25:30.973Z","updated":"2020-12-18T15:59:54.939Z","comments":true,"path":"2020/05/17/mou-pao-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/mou-pao-pai-xu/","excerpt":"","text":"冒泡排序将关键字大的记录“下沉”,与小的记录进行交换 //算法8.4 冒泡排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void BubbleSort(SqList &L) { //对顺序表L做冒泡排序 int m,j,flag; ElemType t; m=L.length-1; flag=1; //flag用来标记某一趟排序是否发生交换 while((m>0)&&(flag==1)) { flag=0; //flag置为0，如果本趟排序没有发生交换，则不会执行下一趟排序 for(j=1;jL.r[j+1].key) { flag=1; //flag置为1，表示本趟排序发生了交换 t=L.r[j];L.r[j]=L.r[j+1];L.r[j+1]=t; //交换前后两个记录 } //if --m; } //while } //BubbleSort void Create_Sq(SqList &L) { int i,n; cout","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"希尔排序","slug":"希尔排序","date":"2020-05-17T09:07:40.698Z","updated":"2021-03-11T04:22:55.812Z","comments":true,"path":"2020/05/17/xi-er-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/xi-er-pai-xu/","excerpt":"","text":"希尔排序通过分组进行大浮动跳跃性排序，并且分组的形式是以设定的增量为基准 //算法8.3 希尔排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void ShellInsert(SqList &amp;L,int dk) { //对顺序表L做一趟增量是dk的希尔插入排序 int i,j; for(i=dk+1;i&lt;=L.length;++i) if(L.r[i].key&lt;L.r[i-dk].key) { //需将L.r[i]插入有序增量子表 L.r[0]=L.r[i]; //暂存在L.r[0] for(j=i-dk;j&gt;0&amp;&amp; L.r[0].key&lt;L.r[j].key;j-=dk) L.r[j+dk]=L.r[j]; //记录后移，直到找到插入位置 L.r[j+dk]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //for } //ShellInsert void ShellSort(SqList &amp;L,int dt[ ],int t){ //按增量序列dt[0..t-1]对顺序表L作t趟希尔排序 int k; for(k=0;k&lt;t;++k) ShellInsert(L,dt[k]); //一趟增量为dt[t]的希尔插入排序 } //ShellSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); int i,t;//增量数组的长度 int *dt=new int[MAXSIZE];//增量数组 cout&lt;&lt;&quot;请输入增量个数：\\n&quot;; cin&gt;&gt;t; for(i=0;i&lt;t;i++) { cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;个增量:\\n&quot;; cin&gt;&gt;dt[i]; } ShellSort(L,dt,t); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.不稳定排序 2.仅适用于顺序表 3.时间复杂度取决于增量的决定，最少可以减少到n(log2 n)^2, n^3/2等。 空间复杂度为O(1),只需要一个r[0] 对于增量的选取很重要，希尔自带的增量设定为 {N/2, (N / 2)/2, …, 1} ，叫做希尔增量，常用但是效果并不拔群，其余的有 Hibbard：{1, 3, …, 2^k-1}，Sedgewick：{1, 5, 19, 41, 109…} 等","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"折半插入排序","slug":"折半插入排序","date":"2020-05-17T08:36:10.446Z","updated":"2020-10-26T09:01:35.198Z","comments":true,"path":"2020/05/17/zhe-ban-cha-ru-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/zhe-ban-cha-ru-pai-xu/","excerpt":"","text":"折半插入排序其实就是直接插入排序引入了折半的思想 //算法8.2 折半插入排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表 void BInsertSort(SqList &amp;L){ //对顺序表L做折半插入排序 int i,j,low,high,m; for(i=2;i&lt;=L.length;++i) { L.r[0]=L.r[i]; //将待插入的记录暂存到监视哨中 low=1; high=i-1; //置查找区间初值 while(low&lt;=high) { //在r[low..high]中折半查找插入的位置 m=(low+high)/2; //折半 if(L.r[0].key&lt;L.r[m].key) high=m-1; //插入点在前一子表 else low=m+1; //插入点在后一子表 }//while for(j=i-1;j&gt;=high+1;--j) L.r[j+1]=L.r[j]; //记录后移 L.r[high+1]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //for } //BInsertSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); BInsertSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.仅适用于顺序表 3.时间复杂度为O(n^2)，但是平均性能&gt;直接插入。 空间复杂度为O(1),只需要一个r[0]","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"直接插入排序","slug":"直接插入排序","date":"2020-05-17T08:26:32.728Z","updated":"2020-10-26T08:58:13.811Z","comments":true,"path":"2020/05/17/zhi-jie-cha-ru-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/zhi-jie-cha-ru-pai-xu/","excerpt":"","text":"直接插入排序这里采用的是从后向前的比较方式，（从前向后其实也可以） 有点像打牌，抽牌，然后选择地方放好 //算法8.1 直接插入排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void InsertSort(SqList &amp;L) { //对顺序表L做直接插入排序 int i,j; for(i=2;i&lt;=L.length;++i) if(L.r[i].key&lt;L.r[i-1].key) { //&quot;&lt;&quot;，需将r[i]插入有序子表 L.r[0]=L.r[i]; //将待插入的记录暂存到监视哨中 L.r[i]=L.r[i-1]; //r[i-1]后移 for(j=i-2; L.r[0].key&lt;L.r[j].key;--j) //从后向前寻找插入位置 L.r[j+1]=L.r[j]; //记录逐个后移，直到找到插入位置 L.r[j+1]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //if } //InsertSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); InsertSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.适用于顺序表和链表 3.时间复杂度为O(n^2) 空间复杂度为O(1),只需要一个r[0]","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"CSS浮动+常见的网页布局","slug":"CSS浮动+常见的网页布局","date":"2020-05-16T16:00:00.000Z","updated":"2021-03-24T09:37:38.733Z","comments":true,"path":"2020/05/17/css-fu-dong-chang-jian-de-wang-ye-bu-ju/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/css-fu-dong-chang-jian-de-wang-ye-bu-ju/","excerpt":"","text":"浮动CSS三种传统布局：普通流 浮动 定位 标准流：标签按照默认排序 多个块级元素纵向排列用标准流，横向排列用浮动 选择器{ float: 属性值; //none不浮动 left向左浮动 right向右浮动 }//创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘 浮动特性：1.浮动元素会脱离标准流原来（排在浮动后面的）标准流的标签会顶上你原来的位置（但标准流之后的浮动挤不上去） （但是！！不会覆盖掉你的文字！，因为本身浮动是为环绕图片而设计的） 2.浮动元素会一行内显示并且元素顶部对齐紧贴在一起，不会有缝隙，装不开会另起一行 3.浮动元素具有行内块元素的特性添加浮动后自动附带行内块元素的特性 4.浮动自带文字环绕效果浮动的使用：一般采取先用标准流父元素排列上下位置，之后在子元素采取浮动，使得浮动在网页中间而不是左右侧 一般一个元素浮动了，他的兄弟标签最好也使用浮动 清除浮动布局1.父盒子不给高度，子盒子会自动撑开 2.父盒子不给高度的话，子盒子如果是浮动，父盒子会发生高度塌陷，导致高度变成0 所以总结：需要清除浮动！！！ clear: 属性值 一般属性值取both（常用）清楚两侧浮动，也有left，right 1.额外标签法，隔墙法，W3C推荐做法在浮动标签最后加多个一子标签（必须是块级元素），如： .clear{ clear: both; } &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;优点：通俗易懂，书写方便 缺点：结构化差 2.父级添加overflow（生成BFC元素） //父级盒子 .box{ overflow: hidden; //或者auto } 优点：代码简洁 缺点：无法显示出溢出部分 3.：after伪元素法额外标签的升级版，给父元素添加 .clearfix:after { content: \"\"; display: block; //伪元素默认是行内元素，所以得转 height: 0; clear: both; visibility: hidden; } .clearfix { *zoom: 1; //兼容ie6，ie7 } /*一般类名定义为clearfix*/ 优点：结构简单 缺点：需要照顾低版本浏览器 代表网站：百度，淘宝，网易 4.双伪元素清除浮动.clearfix:before, .clearfix:after { content: &quot;&quot;; display: table; //转化为块级，并且一行显示 } .clear:after { clear: both; } .clearfix { *zoom: 1; //兼容ie6，ie7 }优缺点同上，代表网站：小米，腾讯 li标签包含a标签实际开发中导航栏不会直接用a标签，而是用li（列表）包含a标签的做法，1.语义更加清晰 2.故意对其关键字有被搜索引擎降权的风险 导航栏不给宽度是不想定死，让其自动适应","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"字典排序","slug":"字典排序","date":"2020-05-14T11:30:26.797Z","updated":"2021-03-11T04:23:48.637Z","comments":true,"path":"2020/05/14/zi-dian-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/zi-dian-pai-xu/","excerpt":"","text":"字典排序实现“ 1 2 3 ， 1 3 2 ， 2 1 3 ， 2 3 1 ， 3 1 2 ， 3 2 1 ”的序列排序方法 代码实现如下 #include #define swap(a,b) {int temp=a;a=b;b=temp;} //交换a，b值 void sort(int arr[],int start,int end)//冒泡排序，从start到end的排序，使用时注意是数组的下标，如数组下标0-3排序，sort（arr,0,3） { int i,j; for(i=0;iarr[a]) //这是字典排序第二步，获取arr[b]的值 { b=j1; break; } } swap(arr[a],arr[b]); //这是第三步 sort(arr,a+1,n-1); //这是第四步 } } int main() { int arr[]={1,2,4,3}; permutation(arr,4); return 0; } 总结得出字典排序算法四步法： 字典排序：第一步：从右至左找第一个左邻小于右邻的数，记下位置i，值list[a]第二部：从右边往左找第一个右边大于list[a]的第一个值，记下位置j，值list[b]第三步：交换list[a]和list[b]的值第四步：将i以后的元素重新按从小到大的顺序排列 举例：125643的下一个字典序列第一步：右边值大于左边的3&lt;4,4&lt;6,6&gt;5,则i=2，list[a]=5第二步：从右往左找出第一个右边大于list[a]=5的值，找到6&gt;5,j=3;list[b]=6;第三步：交换list[a]和list[b]的值，序列125643-&gt;126543第四步：将位置2以后的元素重新排序,126543-&gt;126345;结束： 126345即125643的下一个序列————————————————版权声明：本文为CSDN博主「Hi,Mr.Wang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_34672688/article/details/79557380","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"牛客算法课personnel note","slug":"牛客算法课personnel note","date":"2020-05-14T11:30:26.797Z","updated":"2020-10-26T08:59:32.432Z","comments":true,"path":"2020/05/14/niu-ke-suan-fa-ke-personnel-note/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/niu-ke-suan-fa-ke-personnel-note/","excerpt":"","text":"小基础floor(x) 小于等于x的最大值整数（向下取整） ceil(x) 大于等于x的最小整数（向上取整）( #include&lt;math.h&gt; ) int 32位二进制 第一个是符号位正数为0，负数为1，后面是数值位 -2^31——2^31-1 long long 64位二进制 double 64位二进制 （float别用了，太垃圾了） ~ 取反 &gt;&gt;右移 &lt;&lt;左移 pow(a,b) a的b次方 一维前缀和拥有数组x和数组y，满足： y0=x0; y1=x0+x1; y2=x0+x1+x2; 即想要求某区间和，可用y数组来相减得到结果 枚举一一举例，不重复 先列举出（求第x数到第y数的和，先求数组所有和，直接减），（求四个点的位置，并且四个点组成正方形，先求四个点中的两个点，），（求一排树数量，部份树被整段移走（可能重叠），直接标记1，移走的树部分-1） 取尺法分L，R两个指针，求数组区域&lt;=s的连续数组的个数，&lt;s R右移， &gt;=s L右移 使用前提： 1.能够维护一个区间，保证这个区间能够获得答案。 2.维护的具体操作可以左边移动一位、右边移动一位。 3.区间的变化是连续的而不是跳跃的。问题1就是比较跳跃的，双指针比较好，问题2不能跳跃。 贪心算法局部最优解，然后发现局部最优=整体最优解 桶排序列出数组， 将数组分到有限数量的桶里，将数据对比，有则让数组对应的数据+1，每个桶再个别排序 ，然后依次输出 桶越多，时间效率就越高，而桶越多，空间就越大 这里有位大佬我觉得写得很好，外加动漫配图，可以看一下（简单桶排序） https://www.cnblogs.com/bqwzx/p/11029264.html 计数排序基数排序和计数排序都可以看做桶排序，计数排序的思路是开一个长度为 maxValue-minValue+1 的数组，进行分配+收集: 分配。扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1。 收集。扫描一遍计数器数组，按顺序把值收集起来。 计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序 ， 计数排序非常浪费空间 VECTORvector是一个不限制数组长度的数组 top()返回第一个元素 back()返回最后一个元素 erase（int index,int size）删除 vector a; 迭代器Iterator用于访问问一个容器内的数据的指针 vector:: iterator it; C++ STL的二分查找binary search 返回bool，是否存在 low_bound 返回可插入的最小位置的迭代器，即返回第一个符合条件的元素位置，low_bound(a,a+11,55), a[0]到a[10]找55，返回迭代器，可将结果 -a 得到它的下标 第一个&lt;=x的位置 upper_bound 返回可插入的最大位置的迭代器，即返回最后一个符合条件的元素位置 第一个&gt;x的位置","categories":[{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"}],"tags":[],"author":"Hello"},{"title":"C++类型转换&java的一些对象","slug":"C++类型转换&java的一些对象","date":"2020-05-13T09:10:17.923Z","updated":"2020-11-15T05:40:12.960Z","comments":true,"path":"2020/05/13/c-lei-xing-zhuan-huan-java-de-yi-xie-dui-xiang/","link":"","permalink":"https://taylor12138.github.io/2020/05/13/c-lei-xing-zhuan-huan-java-de-yi-xie-dui-xiang/","excerpt":"","text":"头文件#include &quot;iostream&quot; #include &quot;stdlib.h&quot; #include &quot;cstdlib&quot; #include &quot;string&quot;使用cstdlib中c_str()使其转换成char，再转int和float/double C 库函数 int atoi(const char *str) 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。 C 库函数 double atof(const char *str) 把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 double price=atof(new_str[2].c_str()); int count=atoi(new_str[3].c_str());; javaStringBuilder：动态StringStringBuilder str = new StringBuilder(“Hello World!”, 25)//最大长度，可有可无str.append//增加 str.insert(6,”Beautiful”);//在第6个位置插入str.toString转String 自带栈：import java.until.Stack1 boolean empty()测试堆栈是否为空。2 Object peek( )查看堆栈顶部的对象，但不从堆栈中移除它。3 Object pop( )移除堆栈顶部的对象，并作为此函数的值返回该对象。4 Object push(Object element)把项压入堆栈顶部。5 int search(Object element)返回对象在堆栈中的位置，以 1 为基数。 用栈Stack 创建对象（类型不同） Stack&lt;Integer> stack = new Stack&lt;>(); Stack&lt;Character> stack = new Stack&lt;>(); //Stack stack=new Stack()也可 Hashmap的特点： hashmap和hashset的区别：一个是使用键值对存放（快一点），一个是对象存放底层实现是 链表数组，JDK 8 后又加了 红黑树实现了 Map 全部的方法key 用 Set 存放，所以想做到 key 不允许重复，key 对应的类需要重写 hashCode 和 equals 方法map.put(“zhang”, “31”)//存放键值对map.containsKey(“zhang”);//键中是否包含这个数据map.get(“zhang”);//通过键拿值map.isEmpty();//判空map.remove(“zhang”);//从键值中删除 利用set帮List去重复：List list = new ArrayList(); 。。。。。。。List newList = new ArrayList(new HashSet(list)); 或者 Set set = new HashSet(); List newList = new ArrayList(); set.addAll(list); newList.addAll(set); String[] s = {“aa”,”bb”,”cc”}; List ebsCodes = new ArrayList();List strlist = Arrays.asList(s); 等同于 ebsCodes.add(“USERNAME”); 等同于 (Arrays.asList(“USERNAME”,”REAP”,”NLS”)但不支持add，remove ebsCodes.add(“REAP”); ebsCodes.add(“NLS”);","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"CSS样式","slug":"CSS样式","date":"2020-05-09T16:00:00.000Z","updated":"2021-03-24T10:03:18.668Z","comments":true,"path":"2020/05/10/css-yang-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/css-yang-shi/","excerpt":"","text":"声明：可以使用chrome的F12浏览学习别人的样式并且调试你的代码引入CSS&lt;link rel=\"stylesheet\" href=\"css文件路径\"> 1.主要定义/*是类型选择,标签选择器*/ 元素（标签） { } /*选择所有元素*/ * { } /*的选择 选择多个类可以 &lt;div class=\"类1 类2\">&lt;/div>*/ .class(类名) { } /*id的选择,有点类似class，只能调用一次，别人切勿使用*/ #(id名) { } /*复合，后代选择器*/ 元素1（可以是类名） 元素2（可以是类名） { } /*只选择亲儿子，孙子不选*/ 元素1（可以是类名）>元素2（可以是类名） { } /*并集选择器，多个统一*/ 元素1, 元素2{ } 文字font-size: 12px //12像素大小文字 谷歌默认16px font-size: 12px/1.5 //12像素大小文字 行高为12*1.5=18 font-weight: xxx //字体加粗 text-align: center //文字水平居中对齐 text-indent: 10px //文本首行缩进,最好使用em，如text-indent: 2em,em是相对单位，当前1个文字元素的大小 text-decoration: none//取消下划线 line-height: 26px //行间距，用QQ截图可以偷偷测量，等于盒子高度时垂直居中 背景background-color //背景颜色 background: rgba(red（数值）,green(数值),blue（数值），透明度（0-1）) //背景颜色 透明化 background-image: url(地址)//背景图片，常见于标志，logo或者超大背景图片，有点是便于控制位置 baackground-repeat: no-repeat//背景平铺，默认为平铺，可以改成取消平铺 background-position: x y//背景图片的位置 ，可以使用方位名词，前后顺序可可以不一样top，center ，botton，left等（只写一个另外一个默认居中）。也可以使用精确单位x轴长度，y轴长度，（只写一个另外一个默认居中） background-attachment: scroll||fixed//背景图像随对象内容滚动||背景图像固定 复合：background: 颜色 图片地址 平铺 图像滚动 图片位置 列表list-style: none//去掉无序列表里 li 列表前面的小圆点 阴影box-shadow: 10px 10px 5px #888888; 分别对应阴影的水平，垂直和阴影，颜色 text-shadow: 1px 1px rgba(0,0,0,.2); 文字阴影效果 inputoutline: none; 消除输入边框 border: 0; 消除输入框的自带边框 透明opacity: 0.5 半透明 opacity: 1 不透明 box-sizingbox-sizing 属性可以被用来调整这些表现: content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。 border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。 border-box不包含margin 2.伪类选择器/*a超链接类 或者写成 a的类名:XXX{}*/ a:link 选择所有未访问的链接 a:visited 选择所有已被访问的链接 a:hover 常用，选择鼠标指向的链接 a:ative 鼠标按下未弹起的链接 /*如果全部都写，请按照LVHA的顺序写*/ /*input类，把获得光标的inut选取出来改写CSS*/ input:focus 3.行块转换（块元素和行元素相互转换）display:block /*转块元素*/ display:inline /*转行内元素*/ display: inline-block /*转行内块*/ displat: table /*成为一个块级表格元素*/ display: table-cell /*使子元素成为表格单元格*/ /*使文字垂直居中 让文字行高=盒子的行高 行高>盒子高度偏下，&lt;偏上*/ line-height: 盒子高度 多行文字居中 父元素 display的table + 子元素：table-cell vertical-align: middle 配合可以实现多行文字居中 父元素设置对应的height和line-height 子元素设置display:inline-block + vertical-align:middle() + line-height (缺点：文本的高度不能超过外部盒子的高度。) .parent { height: 300px; line-height: 300px; } .son { display: inline-block; width: 300px; line-height: 20px; vertical-align: middle; } display和visibilitydisplay: none：该元素以及它的所有后代元素都会隐藏，无法使用屏幕阅读器等辅助设备访问，占据的空间消失 visibility: hidden：也可以隐藏这个元素，但是隐藏元素仍需占用与未隐藏时一样的空间，也就是说虽然元素不可见了，但是仍然会影响页面布局。（也就是仍然占据空间，只是隐藏起来） 除了占据空间这个重大的区别之外，还有2个区别： visibility具有继承性，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别 visibility: hidden不会影响计数器的计数，如图所示，visibility: hidden虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样 4.CSS的三大特性1.层叠性样式冲突选择就近原则，把前面的覆盖掉，不冲突的不覆盖 2.继承性子标签会继承父标签的属性 3.优先级1.选择器相同，执行层叠性 2.选择器不同，继承/*(0,0,0,0)&lt;元素(0,0,0,1)&lt;类(0,0,1,0)&lt;id(0,1,0,0)&lt;行内样式style(1,0,0,0)&lt;！important无限大 （属性选择器input[class^=icon]{} 是（0,0,1,0）） （！important加在某属性后面，如color: green!important） 继承的你加了！important，权值还是（0，0，0，0），毕竟是继承过来的 3.复合选择器有权重叠加的问题 ul li{}权重为(0,0,0,1)+(0,0,0,1) li为(0,0,0,1) .nav li为（0，0，1，1） 权重会叠加，但是永不进位，不是二进制 （a:hover为(0,0,1,1)） 5.CSS盒子border（会影响盒子大小）border-style: solid(实线边框，最常用) dashed(虚线) dotted（点线边框） border-width: XXpx border-color: XX 复写： border: 1px solid red 边框分开写法： border-top: 1px solid red border-collapse:collapse /*相邻边框合并*/ border-top-right-radius: 15px; /*右上方改圆角，无top，right则全部都改*/ padding，内边距（会影响盒子大小，要设置了盒子宽高才会撑开）适用于文字大小不一的盒子，不设置宽高，直接设置padding，字少空间小。字多空间大 子容器盒子没设置宽高，父容器盒子padding不会被撑开 padding: 5px; padding: 0 10px; /*分别对应上下和左右*/ padding-top: 5px; /*仅写上方内边距*/ margin，外边距，盒子和盒子之间的距离（不会撑开）使用方法和padding是一致的 margin可以让块级盒子水平居中：1盒子必须有宽度，盒子左右外边距设置为auto margin: 0 auto;(不适用于定位) 行内元素或者行内块元素居中只需在其父元素CSS样式中添加：text-align: center; 外边距合并问题1.外边距合并指的是，当两个垂直外边距（2个margin）相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。而左右外边距不合并。2.在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。3.注释：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 4.我们可以在a元素或者b元素再包裹一个容器并触发该容器生成一个BFC，就不会发生margin重叠了 关于text-indent：-999px这个是为了隐藏对象内的内容，然后在使用overflow: hidden进行隐藏 6.PSjpg： JPEG对色彩保留好，高清颜色多 gif：常用于小图片动画，可保留透明背景 png：结合jpg和gif，储存形式丰富，支持透明背景 PSD：保存PS设计稿 图层切图： 选定图层，右键，快速导出为png 切片切图： 切片工具—》选中—》左上角文件—》导出—》存储为Web所用格式—》JPEG（png可用于保存透明图）（保存的时候选”选中的切片“） ps插件切图：需要下载Cutterman插件 7.部署网站免费的远程服务器：http://free.3v.do/ 8.vhvh：viewport hetght 指当前可视窗口高度 100vh为100%的可视区域 height: 100vh; 9.BFC我们常说的文档流其实分为定位流、浮动流、普通流三种。而普通流其实就是指BFC中的FC Box 是 CSS 布局的对象和基本单位 Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 BFC：块级格式化上下文，我个人理解的是一种规则 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（margin外边距合并问题） 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 触发BFC 根元素（CSS 中的根元素是指 :root 选择器匹配到的元素，在 HTML 中是 html 元素） float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible https://segmentfault.com/a/1190000013023485 这个网址里面又生成BFC的小案例，很有趣，可以加深理解","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"emmet语法","slug":"emmet语法","date":"2020-05-09T16:00:00.000Z","updated":"2020-08-06T09:24:08.564Z","comments":true,"path":"2020/05/10/emmet-yu-fa/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/emmet-yu-fa/","excerpt":"","text":"Emmet语法插件于市面上大多前端编译软件，如VScode所带有的，便于快速写html和CSSh5想要生成多个标签：div*10，再回车（或者tab），即可生成10个div标签。 生成父子关系标签：div&gt;span,再回车（或者tab），即可生成包含span标签的div标签。 生成兄弟关系标签：div+span,再回车（或者tab）。 输入：.nav 直接生成一个class=“nav”的div标签。(默认div) 输入：#nav 直接生成一个id=“nav”的div标签。 输入：p.nav 直接生成一个class=“nav”的p标签。 输入：.nav$*5 直接生成5个class=“nav1”,class=“nav2”…..的div标签。($是自增符号) 输入：div{前端真好玩}*5 直接生成5个&lt;div&gt; 前端真好玩 &lt;/div&gt; CSS样式内输入：tac 直接生成text-align: center; 其他语法缩写同样类似，诸如w100—&gt;width: 100 格式化直接鼠标右键，格式化文档，即可直接让文档变整齐。 （或者想要每次保存后自动格式化，需要在首页—首选项—设置—搜索emmet.include,在setting.json下的用户，添加 “editor.formatOnType”: true, “editor.formatOnSave”: true 即可）","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"循环队列","slug":"循环队列","date":"2020-05-09T11:51:20.811Z","updated":"2020-10-26T08:58:48.437Z","comments":true,"path":"2020/05/09/xun-huan-dui-lie/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/xun-huan-dui-lie/","excerpt":"","text":"循环队列顺序定义typedef struct { QElemType *base;//初始化时动态分配存储空间 int front;//头指针 int rear;//尾指针 } SqQueue; 初始化//算法3.11 循环队列的初始化 Status InitQueue(SqQueue &Q) {//构造一个空队列Q Q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间 if (!Q.base) exit(OVERFLOW); //存储分配失败 Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空 return OK; } 求队列长度//算法3.12 求循环队列的长度 int QueueLength(SqQueue Q) {//返回Q的元素个数，即队列的长度 return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE; } 入队和出队（防止假溢出）（出头front，入尾rear）（rear无元素，front有元素）//算法3.13 循环队列的入队 Status EnQueue(SqQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满 return ERROR; Q.base[Q.rear] = e; //新元素插入队尾 Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1 return OK; } //算法3.14 循环队列的出队 Status DeQueue(SqQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 if (Q.front == Q.rear) return ERROR; //队空 e = Q.base[Q.front]; //保存队头元素 Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1 return OK; } 链队定义（还是像极了单链表，可知X链的形式一般都是单链表拓展）typedef struct QNode { QElemType data; struct QNode *next; } QNode, *QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 } LinkQueue; 链队的初始化Status InitQueue(LinkQueue &Q) {//构造一个空队列Q Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点 Q.front->next = NULL; //头结点的指针域置空 return OK; } 入队和出队（队头front无元素）//算法3.17 链队的入队 Status EnQueue(LinkQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 QueuePtr p; p = new QNode; //为入队元素分配结点空间，用指针p指向 p->data = e; //将新结点数据域置为e p->next = NULL; Q.rear->next = p; //将新结点插入到队尾 Q.rear = p; //修改队尾指针 return OK; } //算法3.18 链队的出队 Status DeQueue(LinkQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 QueuePtr p; if (Q.front == Q.rear) return ERROR; //若队列空，则返回ERROR p = Q.front->next; //p指向队头元素 e = p->data; //e保存队头元素的值 Q.front->next = p->next; //修改头指针 if (Q.rear == p) Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点 delete p; //释放原队头元素的空间 return OK; } 取队头元素//算法3.19 取链队的队头元素 SElemType GetHead(LinkQueue Q) {//返回Q的队头元素，不修改队头指针 if (Q.front != Q.rear) //队列非空 return Q.front->next->data; //返回队头元素的值，队头指针不变 }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"栈","slug":"栈","date":"2020-05-09T11:14:09.081Z","updated":"2020-05-17T12:35:55.947Z","comments":true,"path":"2020/05/09/zhan/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/zhan/","excerpt":"","text":"顺序栈定义typedef struct { SElemType *base;//栈底指针 SElemType *top;//栈顶指针 int stacksize;//栈可用的最大容量 } SqStack; 初始化Status InitStack(SqStack &S) { //构造一个空栈S S.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间 if (!S.base) exit(OVERFLOW); //存储分配失败 S.top = S.base; //top初始为base，空栈 S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE return OK; } 入栈和出栈（top无元素）//算法3.2 顺序栈的入栈 Status Push(SqStack &S, SElemType e) { // 插入元素e为新的栈顶元素 if (S.top - S.base == S.stacksize) return ERROR; //栈满 *(S.top++) = e; //元素e压入栈顶，栈顶指针加1 return OK; } //算法3.3 顺序栈的出栈 Status Pop(SqStack &S, SElemType &e) { //删除S的栈顶元素，用e返回其值 if (S.base == S.top) return ERROR;//栈空 e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e return OK; } 链栈定义，有点像链表typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack;初始化，无需链表的”头结点“Status InitStack(LinkStack &amp;S) { // 构造一个空栈 S，栈顶指针置空 S = NULL; return OK; }入栈和出栈//算法3.6 链栈的入栈 Status Push(LinkStack &S, SElemType e) {//在栈顶插入元素e LinkStack p; p = new StackNode; //生成新结点 p->data = e; //将新结点数据域置为e p->next = S; //将新结点插入栈顶 S = p; //修改栈顶指针为p return OK; } //算法3.7 链栈的出栈 Status Pop(LinkStack &S, SElemType &e) {//删除S的栈顶元素，用e返回其值 LinkStack p; if (S == NULL) return ERROR; //栈空 e = S->data; //将栈顶元素赋给e p = S; //用p临时保存栈顶元素空间，以备释放 S = S->next; //修改栈顶指针 delete p; //释放原栈顶元素的空间 return OK; }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"双向链表","slug":"双向链表","date":"2020-05-07T11:15:31.827Z","updated":"2020-05-17T12:35:32.455Z","comments":true,"path":"2020/05/07/shuang-xiang-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shuang-xiang-lian-biao/","excerpt":"","text":"双向链表的定义typedef struct DuLNode{ ElemType data; struct DuLNode *prior; struct DuLNode *next; //前驱和后继 }DuLNode，*DuLinkList 插入顺序 s=data; s->prior=p->prior; p->prior->next=s; s->next=p; p->prior=s;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"单链表","slug":"单链表","date":"2020-05-07T10:10:22.778Z","updated":"2020-05-17T12:35:13.050Z","comments":true,"path":"2020/05/07/dan-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/dan-lian-biao/","excerpt":"","text":"如定义单链表结构体，注意引用单链表元素用” -&gt; “,因为是*LinkList，使用单链表用的是LinkListtypedef struct LNode { ElemType data; //结点的数据域 struct LNode *next; //结点的指针域 }LNode,*LinkList; //LinkList为指向结构体LNode的指针类型 前插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头 } }后插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p,r; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 r=L; //尾指针r指向头结点 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=NULL; r-&gt;next=p; r=p; } }单链表的初始化，它的头节点（为了处理方便，在第一个节点之前增加的结点）没有赋值Status InitList_L(LinkList &L){ //功能1---算法2.5 单链表的初始化 //构造一个空的单链表L L=new LNode; //生成新结点作为头结点，用头指针L指向头结点 L->next=NULL; //头结点的指针域置空 return OK; } 它不能像顺序表一样随机取值，所以需要一一查找ElemType FindList(LinkList &amp;L,int i,ElemType &amp;x){ LinkList p=L; for(int j=0;j&lt;i;j++){ if(!(p-&gt;next))return ERROR; p=p-&gt;next; } x=p-&gt;data; return OK; }查找，按值查找int GetElem(LinkList &L,int &i,ElemType e) { LinkList p=L; int j=1; while(p->next) { p=p->next; if(p->data==e){ //查找成功 i=j; return OK; } j++; } return ERROR; //循环至查找失败 } 单链表的插入Status ListInsert_L(LinkList &amp;L,int i,ElemType &amp;e){ //功能3---算法2.8 单链表的插入 //在带头结点的单链表L中第i个位置之前插入元素e int j; LinkList p,s; p=L;j=0; while(p &amp;&amp; j&lt;i-1){p=p-&gt;next;++j;} //寻找第i-1个结点 if(!p||j&gt;i-1) return ERROR; //i大于表长+1或者小于1 s=new LNode; //生成新结点s s-&gt;data=e; //将结点s的数据域置为e s-&gt;next=p-&gt;next; //将结点s插入L中 p-&gt;next=s; return OK; }删除指定序号数据元素Status ListDelete(LinkList &L,int i){ LinkList p=L; int j=1; while(p->next&&jnext; j++; } if(!(p->next)||j>i)return ERROR; LinkList q=p->next; p->next=q->next; delete q; return OK; }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"顺序表","slug":"顺序表","date":"2020-05-07T09:31:08.736Z","updated":"2020-10-26T08:59:00.549Z","comments":true,"path":"2020/05/07/shun-xu-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shun-xu-biao/","excerpt":"","text":"如定义s顺序表结构体，注意引用顺序表元素用” . “,因为是SqList不是*S’q’Listtypedef struct{ ElemType *elem; //存储空间的基地址 int length; //当前长度 }SqList; 顺序表的初始化Status InitList_Sq(SqList &L){ //功能1--算法2.1 顺序表的初始化 //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) return OVERFLOW; //存储分配失败，overflow为-2 L.length=0; //空表长度为0 return OK; } 查找Status LocateElem(SqList *L, ElemType e) //按元素值查找 { int i=0; while (ilength && L->elem[i]!=e) i++; //查找元素e if (i>=L->length) //未找到时返回0 return 0; else return i+1; //找到后返回其逻辑序号 顺序表的插入Status ListInsert_Sq(SqList &amp;L,int i,ElemType e){ //功能3--算法2.3 顺序表的插入 //在顺序表L中第i个位置之前插入新的元素e //i值的合法范围是1&lt;=i&lt;=L.length+1 if(i&lt;1 || i&gt;L.length+1) return ERROR; //i值不合法,error为0 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length; //表长增1 return OK; }删除数据元素bool ListDelete(SqList &L,int i) //删除数据元素 { int j; if (iL.length) //参数错误时返回false return false; for (j=i-1;j","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"C++结构体初始化","slug":"C++结构体初始化","date":"2020-05-07T09:16:02.980Z","updated":"2020-05-17T12:35:02.720Z","comments":true,"path":"2020/05/07/c-jie-gou-ti-chu-shi-hua/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/c-jie-gou-ti-chu-shi-hua/","excerpt":"","text":"如定义药品结构体 typedef struct node{ //定义结构体 string name; float price; int count; float sale; int next; }Medicine; typedef struct{ //定义顺序表 Medicine r[MAX_Size+1]; int length; }SqList; 使用new的初始化 SqList *list_med=new SqList;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"C++求string数组元素个数","slug":"C++求String数组的元素个数","date":"2020-05-06T11:04:31.177Z","updated":"2020-07-27T13:28:02.604Z","comments":true,"path":"2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","link":"","permalink":"https://taylor12138.github.io/2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","excerpt":"","text":"不能使用str.length(),这个求的是单个字符串的大小，可以使用以下求得到长度 sizeof(str)/sizeof(str[0]) int[] a={1,2,3,4,5}; 数组长度为 a.length","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"finished gitee","slug":"finished gitee","date":"2020-05-04T17:01:10.659Z","updated":"2020-07-06T16:11:42.941Z","comments":true,"path":"2020/05/05/finished-gitee/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/finished-gitee/","excerpt":"","text":"原来是个人邮箱的设置必须得是公开的，我一直是设置为private，搞得一直错，终于搞出来了。 但是发现了gitee的一个缺点，每次部署完后都要去码云更新一次。。。","categories":[],"tags":[],"author":"Hello"},{"title":"HTML5的基本属性","slug":"HTML5的基本属性","date":"2020-05-04T16:25:58.368Z","updated":"2021-03-19T12:22:58.638Z","comments":true,"path":"2020/05/05/html5-de-ji-ben-shu-xing/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/html5-de-ji-ben-shu-xing/","excerpt":"","text":"1.基本标签介绍&lt;html&gt;&lt;/html&gt;``根标签 &lt;head&gt; &lt;/head&gt; 文档头部 &lt; title&gt; &lt;/title&gt; 文档标题 &lt;body&gt;&lt;/body&gt; 文档主体 2.在vscode里使用英文“！”可以直接生成基本结构ctrl+“+”可以放大（写代码）页面 &lt;!DOCTYPE html&gt; （） &lt;html lang=&quot;zh-CN&quot;&gt; (中文) &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;h1&gt;&lt;/h1&gt;---&lt;h6&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; &lt;br /&gt;&lt;strong&gt;&lt;/strong&gt;(字体加粗)&lt;del&gt;&lt;/del&gt;（字体删除线） &lt;em&gt;&lt;/em&gt; 标签告诉浏览器把其中的文本表示为强调的内容 3.盒子：类似于view，用于布局&lt;div&gt;&lt;/div&gt; //大盒子，独占一整行 &lt;span&gt;&lt;/span&gt; //小盒子 无法设置高度和宽度 4.img&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; height=&quot;&quot; width=&quot;&quot;&gt; //微信小程序是image alt为图片无法加载时显示的文字，title为鼠标移到图片上显示的文字提示, 但是对于height和width,一般只修改其中一个，另外一个就会跟着改变 src种绝对路径 \\ 相对路径 / （图片设置宽高一般设置为width：100%，heigh：100%，可以自动适应盒子） 5.超链接&lt; a&gt;&lt;a href=&quot;&quot; target=&quot;&quot; &gt;文本或者图像&lt;/a&gt; 类似于微信小程序中的navigator, href用于指定目标的url，可打开内部，外部链接 target用于来链接打开方式，默认_self _blank为在新窗口打开 锚点链接：设置href=#名字，如&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;可以快速跳转到第二集的页面位置 ​ 在于目标位置标签里添加id=”two” &lt;a href=&quot;&quot; title=&quot;&quot;&gt;移动到链接时会出现提示框 一般情况下，a如果包含有宽度的盒子，a需要转换为块级元素 &lt;a href=&#39;javascript:;&#39;&gt;xx&lt;/a&gt; 直接添加javascript:; 可以阻止链接跳转 6.特殊字符空格：&amp;nbsp (因无法识别大于号和小于号) 小于号：&amp;lt 大于号：&amp;gt 7.表格（用于数据）&lt;table&gt; ​ &lt;tr&gt; ​ &lt;td&gt;单元格文字&lt;/td&gt;或者&lt;th&gt;&lt;/th&gt; ​ &lt;/tr&gt; &lt;/table&gt; table是表格，tr是行，td是单元格（th可充当表头单元格）。还可以加入&lt;thead&gt;和 &lt;tbody&gt;来帮助CSS区分表格结构 单元格合并使用colspan=”（列）想要合并的单元个数”或者rowspan=”（行）想要合并的单元个数”，再删除多余的td（或th） 8.列表（用于布局）无序列表（ul里只能放li标签，所以其他容器放li里面就可以）&lt;ul&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ul&gt; 有序列表(规则同无序)&lt;ol&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ol&gt; 自定义列表(同上)&lt;dl&gt; ​ &lt;dt&gt;名词1&lt;/dt&gt; ​ &lt;dd&gt;名词1解释1&lt;/dd ​ &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 9.表单（用于填写信息，用户注册）&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot; maxlength=&quot;&quot;&gt;&lt;/form&gt;表单域 url地址为处理表单数据的地址，method有get，post 表单具有默认的提交行为，默认是同步的，同步表单提交，浏览器会锁死（转圈儿）等待服务端的响应结果。 表单的同步提交之后，无论服务端响应的是什么，都会直接把响应的结果覆盖掉当前页面。 表单中需要提交的表单控件元素必须有name属性 表单元素&lt;input&gt;&lt;input type=&quot;属性值&quot; name=&quot;&quot; value=&quot;&quot; check=&quot;&quot;&gt;输入 type可以为text，number，password，button，reset（重置）submit（用于提交），radio（单选框，必须添加name才能使用），checkbox（复选框）等 科普：submit是button的一个特例，用于处理大量表单数据，而此时input里的name是表单的名称，需要填写name才能提交表单数据 value为输入框内的提示语||充当提交给后台的数据||显示的文字 placeholder=&quot;Search...&quot; 显示提示的文字 check用于单选和复选的默认值 check=”checked” maxlength=“最大值” &lt;label for=&quot;sex&quot;&gt;男 &lt;/label&gt; label用于增加用户体验，点击范围内即可选中某input（一般一个label绑定一个input） &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; label中的for对应input里的id 或者把input标签放在label里面也能达到同样的效果，此时不需要for和id（隐式的联系） 表单元素&lt;select&gt; 下拉列表&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;选项3&lt;/option&gt; //默认选中选项3 ... &lt;select&gt;表单元素&lt;textarea&gt; 文本域，可以写大量文字（个人介绍，评论）输入的评论作为element.value &lt;textarea> 文字 &lt;/textarea> //如果没文字textarea必须写到同一行 10 元素分类块元素，独占一行，是一个容器或者盒子如 &lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &lt;h1&gt; &lt;h2&gt;等 但&lt;p&gt; &lt;h&gt; 不能内置块级元素，只能放文字行元素，不能设置宽高，只能容纳文本或者其他行内元素 &lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;span&gt; 等 但是&lt;a&gt;不能再放&lt;a&gt; 特殊情况&lt;a&gt;可以转块级行内块元素，能在同一行，也能设置宽高，但是行内块之间有缝隙 &lt;input/&gt; &lt;img/&gt; &lt;td&gt; &lt;button&gt;行块的转换详情请看CSS里的《行块转换》h5标签推荐网址： http://www.w3school.com.cn/ http://developer.mozilla.org/zh-CN/ 11.HTML5新特性i9以上版本浏览器才支持 &lt;header&gt;: 头部标签 &lt;nav&gt;: 导航标签 &lt;article&gt;: 内容标签 &lt;section&gt;: 定义文档某个区域 &lt;aside&gt;: 侧边栏标签 &lt;footer&gt;: 尾部标签 /*实质上都和div差不多，只是语义化了而已，主要针对搜索引擎*/ /*但是在i9中，需要把这些元素转换成块级元素，所以移动端更喜欢使用这些标签*/ 新增：&lt;audio&gt;音频，&lt;video&gt;视频，抛弃flash等插件功能video尽量使用mp4格式，谷歌把音频，视频自动播放禁止了 &lt;video src=&quot;文件地址&quot; autoplay=&quot;autoplay&quot;自动播放 谷歌需要添加muted=&quot;muted&quot;（静音播放）,才能实现自动播放 controls=&quot;controls&quot;添加播放组件 loop=&quot;loop&quot;循环播放 poster=&quot;图片地址&quot; 视频封面显示图片 &gt;&lt;/video&gt; 遇到不兼容的情况可以写成 &lt;video width=&quot;320&quot; height=&quot;240&quot;&gt; &lt;source src=&quot;&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;&quot; type=&quot;video/ogg&quot;&gt; &lt;/video&gt;兼容问题同上 &lt;audio src=&quot;文件地址&quot;&gt;&lt;/audio&gt; 其功能性同video，如autoplay，loop，controls新增input的类型type=&quot;email&quot; type=&quot;url&quot; type=&quot;date&quot; type=&quot;number&quot; type=&quot;search&quot; type=&quot;tel&quot;(手机号码) 限制用户只能使用&quot;X&quot;类型 /*表单属性*/ &lt;input type=&quot;search&quot; required=&quot;required&quot; 填写字段不能为空 placeholder=&quot;XX&quot; 表单的提示信息 autofocus=&quot;autofocus&quot; 页面完成时自动聚焦到指定表单 autocomplete=&quot;on&quot; 打开历史记录功能，需要加上name属性，放在表单内，成功提交过，可以可选择&quot;off&quot; mutiple=&quot;multiple&quot; 选择多个文件上传 &gt;12.网站的缩略图标一般使用favicon.ico作为图标，主要的浏览器都支持。 通过第三方网站将png图片转化成ico图标，如http://www.bitbug.net/ 转化成功后，在&lt;head&gt; &lt;/head&gt;之间引入代码： &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico type=&quot;XX&quot;&gt;(网页那里有代码直接copy) 在某网页的页面，在它的网址后输入”/favicon.ico” 可以直接获取它的ico 13.网站TDK三大标签优化SEOSEO是搜索引擎优化，目的为对网站深度优化，使得网站排名位于搜索引擎使用后较前的位置。 1.title网站名-网站介绍（不超过30字） 2.description简要概述网站内容 3.keywords页面关键字，搜索引擎的关注点 logo的SEO优化logo里首先放一个h1标签来提权，h1里再放一个链接，用于返回至首页，为了让搜索引擎收录我们，我们要在链接里放文字（网站名称），但是文字不要显示出来（文字大小设置为0，font-size: 0），最后给链接一个title属性","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"主题与2d人物","slug":"主题与2d人物","date":"2020-05-03T16:50:47.307Z","updated":"2020-05-05T17:03:19.452Z","comments":true,"path":"2020/05/04/zhu-ti-yu-2d-ren-wu/","link":"","permalink":"https://taylor12138.github.io/2020/05/04/zhu-ti-yu-2d-ren-wu/","excerpt":"","text":"Start人物使用命令安装npm：npm uninstall hexo-helper-live2d npm install –save hexo-helper-live2d此时在blog/node_modeles下多出了一个“live2d-widget”下载动画model：这里是套用别人（大佬）的仓库https://github.com/xiazeyu/live2d-widget-models.git下载好后将packages里的所有文件拷贝到blog/node_modeles最后在win使用padnote _config.yml，把以下：live2d: enable: true pluginModelPath: assets/ model: use: live2d-widget-model-epsilon2_1 #模板目录，在node_modules里 display: position: right width: 150 height: 300 mobile: show: false #是否在手机进行显示 复制进去 再使用hexo clean g d进行部署 主题下载好了之后放入blog/themes里面（整个文件）再在win使用padnote _config.yml把theme: xx改成theme: (你要的主题名)最后部署","categories":[],"tags":[],"author":"Hello"},{"title":"My First Blog","slug":"My First Blog","date":"2020-05-02T17:33:53.947Z","updated":"2020-05-05T17:02:29.455Z","comments":true,"path":"2020/05/03/my-first-blog/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/my-first-blog/","excerpt":"","text":"Quick Start打开win+R进入cmd，然后在正确目录下进入：cd source_post(指定blog下) 基本操作用typora修改完毕后，1.使用“hexo clean”进行清理（1.5.若是发生主题等修改后，要接上hexo g 来建立）2.接上“hexo s”即可进入网站查看（退出键位：control+C，y）（本地浏览）3.再次部署到远端：hexo d 关于主题1.可以使用git clone 网址.git themes\\新建目录名（或者使用码云gitee进行下载，然后复制到themes目录下）2.cd.. (回到blog目录下)notepad _config.yml把记事本里面的theme：xx修改成theme：主题目录名3.重新执行”基本操作” 参考文献 https://hexo.io/docs/one-command-deployment.html)","categories":[],"tags":[],"author":"Hello"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"},{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"},{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"},{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[]}