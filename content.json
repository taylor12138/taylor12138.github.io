{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://taylor12138.github.io","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-05-04T06:35:25.450Z","comments":true,"path":"about/index.html","permalink":"https://taylor12138.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-03T17:20:07.000Z","updated":"2020-05-04T06:33:11.259Z","comments":true,"path":"categories/index.html","permalink":"https://taylor12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-05-03T17:22:42.000Z","updated":"2020-05-04T06:34:25.403Z","comments":true,"path":"friends/index.html","permalink":"https://taylor12138.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-05-03T17:21:52.000Z","updated":"2020-05-04T06:33:52.664Z","comments":true,"path":"contact/index.html","permalink":"https://taylor12138.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-03T17:17:32.000Z","updated":"2020-05-04T06:33:28.454Z","comments":true,"path":"tags/index.html","permalink":"https://taylor12138.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基数排序","slug":"基数排序","date":"2020-05-17T12:55:49.418Z","updated":"2020-05-18T13:03:45.898Z","comments":true,"path":"2020/05/17/ji-shu-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/ji-shu-pai-xu/","excerpt":"","text":"基数排序使用的大致思路是：根据关键字进行分类，再次排序，在分类，在排序，以此类推直至完成结果 如扑克牌中根据分13类，排序，再根据花色分类，再排序； 对百位数排序，先根据个位分类，排，再根据十位分类，排，再根据百位分类，排 //算法8.12 基数排序 #include &lt;iostream&gt; using namespace std; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #define MAXNUM_KEY 8 //关键字项数的最大值 #define RADIX 10 //关键字基数，此时是十进制整数的基数 #define MAX_SPACE 10000 typedef char KeysType; //定义关键字类型为字符型 typedef int InfoType; //定义其它数据项的类型 typedef struct { KeysType keys[MAXNUM_KEY]; //关键字 InfoType otheritems; //其他数据项 int next; }SLCell; //静态链表的结点类型 typedef struct { SLCell r[MAX_SPACE]; //静态链表的可利用空间，r[0]为头结点 int keynum; //记录的当前关键字个数 int recnum; //静态链表的当前长度 }SLList; //静态链表类型 typedef int ArrType[RADIX]; //指针数组类型 void InitList(SLList *L) { //初始化静态链表L（把数组D中的数据存于L中） char c[MAXNUM_KEY],c1[MAXNUM_KEY]; int i,j,n,max; //max为关键字的最大值 max=-10000; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAX_SPACE&lt;&lt;&quot;个。\\n&quot;; cin&gt;&gt;n; while(n&gt;MAX_SPACE) { cout&lt;&lt;&quot;您输入的个数超过上限，请重新输入，不超过&quot;&lt;&lt;MAX_SPACE&lt;&lt;&quot;个。\\n&quot;; cin&gt;&gt;n; } int *D=new int[n]; cout&lt;&lt;&quot;请输入&quot;&lt;&lt;n&lt;&lt;&quot;个排排序的数据：\\n&quot;; for(i=0;i&lt;n;i++) { cin&gt;&gt;D[i]; if(max&lt;D[i]) max=D[i]; } (*L).keynum=(int)(ceil(log10(max))); //存放十进制的位数 (*L).recnum=n; for(i=1;i&lt;=n;i++) { itoa(D[i-1],c,10); //将10进制整型转化为字符型,存入c for(j=strlen(c);j&lt;(*L).keynum;j++) //若c的长度&lt;max的位数,在c前补&#39;0&#39; { strcpy(c1,&quot;0&quot;); strcat(c1,c); strcpy(c,c1); } for(j=0;j&lt;(*L).keynum;j++) (*L).r[i].keys[j]=c[(*L).keynum-1-j]; } } int ord(char c) { //返回k的映射(个位整数) return c-&#39;0&#39;; } void Distribute(SLCell *r,int i,ArrType &amp;f,ArrType &amp;e) { //静态链表L的r域中记录已按（keys[0], …, keys[i-1]）有序 //本算法按第i个关键字keys[i]建立RADIX个子表，使同一子表中记录的keys[i]相同。 //f[0..RADIX-1]和e[0..RADIX-1]分别指向各子表中第一个和最后一个记录（很重要！！！！） int j,p; for(j=0;j&lt;RADIX;++j) f[j]=0; //各子表初始化为空表 for(p=r[0].next;p;p=r[p].next) { j=ord(r[p].keys[i]); //ord将记录中第i个关键字映射到[0..RADIX-1] if(!f[j]) f[j]=p; //f[j]为空，则直接赋值 else r[e[j]].next=p; //若不为空，则将其排在之前已有被赋值相同映射关键字的r的next的next里 e[j]=p; //将p所指的结点插入第j个子表中 }//for }//Distribute int succ(int i) { //求后继函数 return ++i; } void Collect (SLCell *r,int i,ArrType &amp;f,ArrType &amp;e) { //本算法按keys[i]自小至大地将f[0..RADIX-1]所指各子表依次链接成一个链表 //e[0..RADIX-1]为各子表的尾指针 int j,t; for(j=0;!f[j];j=succ(j)); //找第一个非空子表，succ为求后继函数 r[0].next=f[j];t=e[j]; //r[0].next指向第一个非空子表中第一个结点 while(j&lt;RADIX-1) { for(j=succ(j);j&lt;RADIX-1&amp;&amp;!f[j];j=succ(j)) ; //找下一个非空子表 if(f[j]) {r[t].next=f[j];t=e[j];} //链接两个非空子表 }//while r[t].next=0; //t指向最后一个非空子表中的最后一个结点 }//Collect void RadixSort(SLList &amp;L) { //L是采用静态链表表示的顺序表 //对L做基数排序，使得L成为按关键字自小到大的有序静态链表，L.r[0]为头结点 int i; ArrType f,e; for(i=0;i&lt;L.recnum;++i) L.r[i].next=i+1; //next指向i+1，即下一个记录 L.r[L.recnum].next = 0; //将L改造为静态链表 最尾部的next为0 for(i=0;i&lt;L.keynum;++i) { //按最低位优先依次对各关键字进行分配和收集 Distribute(L.r,i,f,e); //第i趟分配 Collect(L.r,i,f,e); //第i趟收集 }//for } // RadixSort void print(SLList L) { //按数组序号输出静态链表 int i,j; for(i=1;i&lt;=L.recnum;i++) { for(j=L.keynum-1;j&gt;=0;j--) cout&lt;&lt;L.r[i].keys[j]; cout&lt;&lt;endl; } } void Sort(SLList L,int adr[]) { //求得adr[1..L.length]，adr[i]为静态链表L的第i个最小记录的序号 int i=1,p=L.r[0].next; while(p) { adr[i++]=p; p=L.r[p].next; } } void Rearrange(SLList *L,int adr[]) { //adr给出静态链表L的有序次序，即L.r[adr[i]]是第i小的记录。 //本算法按adr重排L.r，使其有序。算法10.18(L的类型有变) int i,j,k; for(i=1;i&lt;=(*L).recnum;i++){ if(adr[i]!=i) { j=i; (*L).r[0]=(*L).r[i]; //r[0]用于暂存记录(*L).r[i] while(adr[j]!=i) { //调整(*L).r[adr[j]]的记录到位直到adr[j]=i为止 k=adr[j]; (*L).r[j]=(*L).r[k]; adr[j]=j; j=k; //记录按序到位 } (*L).r[j]=(*L).r[0]; //将原来最初始的记录置于链表到达的最后一个点 adr[j]=j; } } } int main() { SLList l; int *adr; InitList(&amp;l); RadixSort(l); adr=new int[l.recnum]; Sort(l,adr); Rearrange(&amp;l,adr); cout&lt;&lt;&quot;排序后(重排记录):\\n&quot;; print(l); } 1.稳定排序 2.适用于顺序表和链表,一般采用静态链式 3.时间复杂度为O(d(n+rd))/O(n) 空间复杂度为O(n+rd) 4.但是它的使用有严格要求，必须知道各级关键字的主次关系和各级关键字的取值范围","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"归并排序","slug":"归并排序","date":"2020-05-17T11:52:57.097Z","updated":"2020-05-17T12:32:39.626Z","comments":true,"path":"2020/05/17/gui-bing-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/gui-bing-pai-xu/","excerpt":"","text":"归并排序将相邻的两个记录（序列）排序，并成一个有序序列，并继续上述操作 //算法8.11 归并排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }RedType; typedef struct { RedType *r; int length; }SqList; void Create_Sq(SqList &L) { int i,n; cout","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"简单选择排序","slug":"简单选择排序","date":"2020-05-17T11:35:13.462Z","updated":"2020-05-17T11:52:49.562Z","comments":true,"path":"2020/05/17/jian-dan-xuan-ze-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/jian-dan-xuan-ze-pai-xu/","excerpt":"","text":"简单选择排序选择关键字储存最小的记录：和表中的记录进行一一对比，选出最小记录放在开头，接着从第二个记录继续开始 //算法8.6 简单选择排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void SelectSort(SqList &amp;L) { //对顺序表L做简单选择排序 int i,j,k; ElemType t; for(i=1;i&lt;L.length;++i) { //在L.r[i..L.length] 中选择关键字最小的记录 k=i; for(j=i+1;j&lt;=L.length;++j) if(L.r[j].key&lt;L.r[k].key) k=j; //k指向此趟排序中关键字最小的记录 if(k!=i) {t=L.r[i];L.r[i]=L.r[k];L.r[k]=t;} //交换r[i]与r[k] } //for } // SelectSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); SelectSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序，但如果是采用“交换记录”，则会导致不稳定现象 2.顺序，链式皆可以使用 3.时间复杂度O( n^2 ),比直接插入快。 空间复杂度为O(l1).","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"快速排序","slug":"快速排序","date":"2020-05-17T10:28:42.342Z","updated":"2020-05-17T11:35:10.593Z","comments":true,"path":"2020/05/17/kuai-su-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/kuai-su-pai-xu/","excerpt":"","text":"快速排序设置个关键字，将大的放在它后面，小的放在前面，分成两个子表，并且重复上述过程，直到每一个子表只有一个记录为止 //算法8.5 快速排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 int Partition(SqList &amp;L,int low,int high) { //对顺序表L中的子表r[low..high]进行一趟排序，返回枢轴位置 int pivotkey; L.r[0]=L.r[low]; //用子表的第一个记录做枢轴记录 pivotkey=L.r[low].key; //枢轴记录关键字保存在pivotkey中 while(low&lt;high) { //从表的两端交替地向中间扫描 while(low&lt;high&amp;&amp;L.r[high].key&gt;=pivotkey) --high; L.r[low]=L.r[high]; //将比枢轴记录小的记录移到低端 while(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey) ++low; L.r[high]=L.r[low]; //将比枢轴记录大的记录移到高端 }//while L.r[low]=L.r[0]; //枢轴记录到位 return low; //返回枢轴位置 }//Partition void QSort(SqList &amp;L,int low,int high) { //调用前置初值：low=1; high=L.length; //对顺序表L中的子序列L.r[low..high]做快速排序 int pivotloc; if(low&lt;high) { //长度大于1 pivotloc=Partition(L,low,high); //将L.r[low..high]一分为二，pivotloc是枢轴位置 QSort(L,low,pivotloc-1); //对左子表递归排序 QSort(L,pivotloc+1,high); //对右子表递归排序 } } //QSort void QuickSort(SqList &amp;L) { //对顺序表L做快速排序 QSort(L,1,L.length); } //QuickSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); QuickSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.不稳定排序 2.多用于顺序结构 3.时间复杂度O(log2 n)。 空间复杂度为O(log2 n), 最坏O(n). 最坏情况是逆序，或基本有序（顺序）","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-05-17T10:25:30.973Z","updated":"2020-05-17T10:28:31.636Z","comments":true,"path":"2020/05/17/mou-pao-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/mou-pao-pai-xu/","excerpt":"","text":"冒泡排序将关键字大的记录“下沉”,与小的记录进行交换 //算法8.4 冒泡排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void BubbleSort(SqList &amp;L) { //对顺序表L做冒泡排序 int m,j,flag; ElemType t; m=L.length-1; flag=1; //flag用来标记某一趟排序是否发生交换 while((m&gt;0)&amp;&amp;(flag==1)) { flag=0; //flag置为0，如果本趟排序没有发生交换，则不会执行下一趟排序 for(j=1;j&lt;=m;j++) if(L.r[j].key&gt;L.r[j+1].key) { flag=1; //flag置为1，表示本趟排序发生了交换 t=L.r[j];L.r[j]=L.r[j+1];L.r[j+1]=t; //交换前后两个记录 } //if --m; } //while } //BubbleSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); BubbleSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.顺序链式都适用 3.时间复杂度O(n^2)。 空间复杂度为O(1).","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"希尔排序","slug":"希尔排序","date":"2020-05-17T09:07:40.698Z","updated":"2020-05-17T10:07:52.937Z","comments":true,"path":"2020/05/17/xi-er-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/xi-er-pai-xu/","excerpt":"","text":"希尔排序通过分组进行大浮动跳跃性排序，并且分组的形式是以设定的增量为基准 //算法8.3 希尔排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void ShellInsert(SqList &amp;L,int dk) { //对顺序表L做一趟增量是dk的希尔插入排序 int i,j; for(i=dk+1;i&lt;=L.length;++i) if(L.r[i].key&lt;L.r[i-dk].key) { //需将L.r[i]插入有序增量子表 L.r[0]=L.r[i]; //暂存在L.r[0] for(j=i-dk;j&gt;0&amp;&amp; L.r[0].key&lt;L.r[j].key;j-=dk) L.r[j+dk]=L.r[j]; //记录后移，直到找到插入位置 L.r[j+dk]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //for } //ShellInsert void ShellSort(SqList &amp;L,int dt[ ],int t){ //按增量序列dt[0..t-1]对顺序表L作t趟希尔排序 int k; for(k=0;k&lt;t;++k) ShellInsert(L,dt[k]); //一趟增量为dt[t]的希尔插入排序 } //ShellSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); int i,t;//增量数组的长度 int *dt=new int[MAXSIZE];//增量数组 cout&lt;&lt;&quot;请输入增量个数：\\n&quot;; cin&gt;&gt;t; for(i=0;i&lt;t;i++) { cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;个增量:\\n&quot;; cin&gt;&gt;dt[i]; } ShellSort(L,dt,t); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.不稳定排序 2.仅适用于顺序表 3.时间复杂度取决于增量的决定，最少可以减少到n(log2 n)^2, n^3/2等。 空间复杂度为O(1),只需要一个r[0] 对于增量的选取很重要，希尔自带的增量设定为 {N/2, (N / 2)/2, …, 1} ，叫做希尔增量，常用但是效果并不拔群，其余的有 Hibbard：{1, 3, …, 2^k-1}，Sedgewick：{1, 5, 19, 41, 109…} 等","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"折半插入排序","slug":"折半插入排序","date":"2020-05-17T08:36:10.446Z","updated":"2020-05-17T10:07:34.883Z","comments":true,"path":"2020/05/17/zhe-ban-cha-ru-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/zhe-ban-cha-ru-pai-xu/","excerpt":"","text":"折半插入排序其实就是直接插入排序引入了折半的思想 //算法8.2 折半插入排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表 void BInsertSort(SqList &amp;L){ //对顺序表L做折半插入排序 int i,j,low,high,m; for(i=2;i&lt;=L.length;++i) { L.r[0]=L.r[i]; //将待插入的记录暂存到监视哨中 low=1; high=i-1; //置查找区间初值 while(low&lt;=high) { //在r[low..high]中折半查找插入的位置 m=(low+high)/2; //折半 if(L.r[0].key&lt;L.r[m].key) high=m-1; //插入点在前一子表 else low=m+1; //插入点在后一子表 }//while for(j=i-1;j&gt;=high+1;--j) L.r[j+1]=L.r[j]; //记录后移 L.r[high+1]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //for } //BInsertSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); BInsertSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.仅适用于顺序表 3.时间复杂度为O(n^2)，但是平均性能&gt;直接插入。 空间复杂度为O(1),只需要一个r[0]","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"直接插入排序","slug":"直接插入排序","date":"2020-05-17T08:26:32.728Z","updated":"2020-05-18T12:29:18.950Z","comments":true,"path":"2020/05/17/zhi-jie-cha-ru-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/zhi-jie-cha-ru-pai-xu/","excerpt":"","text":"直接插入排序这里采用的是从后向前的比较方式，（从前向后其实也可以） 有点像打牌，抽牌，然后选择地方放好 //算法8.1 直接插入排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void InsertSort(SqList &amp;L) { //对顺序表L做直接插入排序 int i,j; for(i=2;i&lt;=L.length;++i) if(L.r[i].key&lt;L.r[i-1].key) { //&quot;&lt;&quot;，需将r[i]插入有序子表 L.r[0]=L.r[i]; //将待插入的记录暂存到监视哨中 L.r[i]=L.r[i-1]; //r[i-1]后移 for(j=i-2; L.r[0].key&lt;L.r[j].key;--j) //从后向前寻找插入位置 L.r[j+1]=L.r[j]; //记录逐个后移，直到找到插入位置 L.r[j+1]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //if } //InsertSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); InsertSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.适用于顺序表和链表 3.时间复杂度为O(n^2) 空间复杂度为O(1),只需要一个r[0]","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"CSS浮动+常见的网页布局","slug":"CSS浮动+常见的网页布局","date":"2020-05-16T16:00:00.000Z","updated":"2020-05-19T16:36:56.686Z","comments":true,"path":"2020/05/17/css-fu-dong-chang-jian-de-wang-ye-bu-ju/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/css-fu-dong-chang-jian-de-wang-ye-bu-ju/","excerpt":"","text":"浮动CSS三种传统布局：普通流 浮动 定位 标准流：标签按照默认排序 多个块级元素纵向排列用标准流，横向排列用浮动 选择器{ float: 属性值; //none不浮动 left向左浮动 right向右浮动 }//创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘 浮动特性：1.浮动元素会脱离标准流原来标准流的标签会顶上你原来的位置 2.浮动元素会一行内显示并且元素顶部对齐紧贴在一起，不会有缝隙，装不开会另起一行 3.浮动元素具有行内块元素的特性添加浮动后自动附带行内块元素的特性 浮动的使用：一般采取先用标准流父元素排列上下位置，之后在子元素采取浮动，使得浮动在网页中间而不是左右侧","categories":[],"tags":[],"author":"Hello"},{"title":"字典排序","slug":"字典排序","date":"2020-05-14T11:30:26.797Z","updated":"2020-05-17T12:34:15.125Z","comments":true,"path":"2020/05/14/zi-dian-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/zi-dian-pai-xu/","excerpt":"","text":"字典排序实现“ 1 2 3 ， 1 3 2 ， 2 1 3 ， 2 3 1 ， 3 1 2 ， 3 2 1 ”的序列排序方法 代码实现如下 #include #define swap(a,b) {int temp=a;a=b;b=temp;} //交换a，b值 void sort(int arr[],int start,int end)//冒泡排序，从start到end的排序，使用时注意是数组的下标，如数组下标0-3排序，sort（arr,0,3） { int i,j; for(i=0;iarr[a]) //这是字典排序第二步，获取arr[b]的值 { b=j1; break; } } swap(arr[a],arr[b]); //这是第三步 sort(arr,a+1,n-1); //这是第四步 } } int main() { int arr[]={1,2,4,3}; permutation(arr,4); return 0; } 总结得出字典排序算法四步法： 字典排序：第一步：从右至左找第一个左邻小于右邻的数，记下位置i，值list[a]第二部：从右边往左找第一个右边大于list[a]的第一个值，记下位置j，值list[b]第三步：交换list[a]和list[b]的值第四步：将i以后的元素重新按从小到大的顺序排列 举例：125643的下一个字典序列第一步：右边值大于左边的3&lt;4,4&lt;6,6&gt;5,则i=2，list[a]=5第二步：从右往左找出第一个右边大于list[a]=5的值，找到6&gt;5,j=3;list[b]=6;第三步：交换list[a]和list[b]的值，序列125643-&gt;126543第四步：将位置2以后的元素重新排序,126543-&gt;126345;结束： 126345即125643的下一个序列————————————————版权声明：本文为CSDN博主「Hi,Mr.Wang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_34672688/article/details/79557380","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"牛客算法课personnel note","slug":"牛客算法课personnel note","date":"2020-05-14T11:30:26.797Z","updated":"2020-05-21T13:49:02.538Z","comments":true,"path":"2020/05/14/niu-ke-suan-fa-ke-personnel-note/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/niu-ke-suan-fa-ke-personnel-note/","excerpt":"","text":"小基础floor(x) 小于等于x的最大值整数（向下取整） ceil(x) 大于等于x的最小整数（向上取整）( #include&lt;math.h&gt; ) int 32位二进制 第一个是符号位正数为0，负数为1，后面是数值位 -2^31——2^31-1 long long 64位二进制 double 64位二进制 （float别用了，太垃圾了） ~ 取反 &gt;&gt;右移 &lt;&lt;左移 pow(a,b) a的b次方 一维前缀和拥有数组x和数组y，满足： y0=x0; y1=x0+x1; y2=x0+x1+x2; 即想要求某区间和，可用y数组来相减得到结果 枚举一一举例，不重复 先列举出（求第x数到第y数的和，先求数组所有和，直接减），（求四个点的位置，并且四个点组成正方形，先求四个点中的两个点，），（求一排树数量，部份树被整段移走（可能重叠），直接标记1，移走的树部分-1） 取尺法分L，R两个指针，求数组区域&lt;=s的连续数组的个数，&lt;s R右移， &gt;=s L右移 使用前提： 1.能够维护一个区间，保证这个区间能够获得答案。 2.维护的具体操作可以左边移动一位、右边移动一位。 3.区间的变化是连续的而不是跳跃的。问题1就是比较跳跃的，双指针比较好，问题2不能跳跃。 贪心算法局部最优解，然后发现局部最优=整体最优解 桶排序列出数组， 将数组分到有限数量的桶里，将数据对比，有则让数组对应的数据+1，每个桶再个别排序 ，然后依次输出 桶越多，时间效率就越高，而桶越多，空间就越大 这里有位大佬我觉得写得很好，外加动漫配图，可以看一下（简单桶排序） https://www.cnblogs.com/bqwzx/p/11029264.html 计数排序基数排序和计数排序都可以看做桶排序，计数排序的思路是开一个长度为 maxValue-minValue+1 的数组，进行分配+收集: 分配。扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1。 收集。扫描一遍计数器数组，按顺序把值收集起来。 计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序 ， 计数排序非常浪费空间 VECTORvector是一个不限制数组长度的数组 top()返回第一个元素 back()返回最后一个元素 erase（int index,int size）删除 vector a; 迭代器Iterator用于访问问一个容器内的数据的指针 vector:: iterator it; C++ STL的二分查找binary search 返回bool，是否存在 low_bound 返回可插入的最小位置的迭代器，即返回第一个符合条件的元素位置，low_bound(a,a+11,55), a[0]到a[10]找55，返回迭代器，可将结果 -a 得到它的下标 第一个&lt;=x的位置 upper_bound 返回可插入的最大位置的迭代器，即返回最后一个符合条件的元素位置 第一个&gt;x的位置","categories":[{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"}],"tags":[],"author":"Hello"},{"title":"C++string转换int，double","slug":"C++string转换int，double","date":"2020-05-13T09:10:17.923Z","updated":"2020-05-17T12:34:56.111Z","comments":true,"path":"2020/05/13/c-string-zhuan-huan-int-double/","link":"","permalink":"https://taylor12138.github.io/2020/05/13/c-string-zhuan-huan-int-double/","excerpt":"","text":"头文件#include &quot;iostream&quot; #include &quot;stdlib.h&quot; #include &quot;cstdlib&quot; #include &quot;string&quot;使用cstdlib中c_str()使其转换成char，再转int和float/double C 库函数 int atoi(const char *str) 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。 C 库函数 double atof(const char *str) 把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 double price=atof(new_str[2].c_str()); int count=atoi(new_str[3].c_str());;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"CSS样式","slug":"CSS样式","date":"2020-05-09T16:00:00.000Z","updated":"2020-05-19T16:36:48.502Z","comments":true,"path":"2020/05/10/css-yang-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/css-yang-shi/","excerpt":"","text":"声明：可以使用chrome的F12浏览学习别人的样式并且调试你的代码引入CSS&lt;link rel=\"stylesheet\" href=\"css文件路径\"> 1.主要定义//是类型选择,标签选择器 元素（标签） { } //选择所有元素 * { } //类的选择 选择多个类可以 &lt;div class=\"类1 类2\">&lt;/div> .class(类名) { } //id的选择,有点类似class，只能调用一次，别人切勿使用 #(id名) { } //复合，后代选择器 元素1（可以是类名） 元素2（可以是类名） { } //只选择亲儿子，孙子不选 元素1（可以是类名）>元素2（可以是类名） { } //并集选择器，多个统一 元素1, 元素2{ } 文字font-size: 12px //12像素大小文字 谷歌默认16px font-size: 12px/1.5 //12像素大小文字 行高为12*1.5=18 font-weight: xxx //字体加粗 text-align: center //文字水平居中对齐 text-indent: 10px //文本首行缩进,最好使用em，如text-indent: 2em,em是相对单位，当前1个文字元素的大小 text-decoration: none//取消下划线 line-height: 26px //行间距，用QQ截图可以偷偷测量，等于盒子高度时垂直居中 背景background-color //背景颜色 background: rgba(red（数值）,green(数值),blue（数值），透明度（0-1）) //背景颜色 透明化 background-image: url(地址)//背景图片，常见于标志，logo或者超大背景图片，有点是便于控制位置 baackground-repeat: no-repeat//背景平铺，默认为平铺，可以改成取消平铺 background-position: x y//背景图片的位置 ，可以使用方位名词，前后顺序可可以不一样top，center ，botton，left等（只写一个另外一个默认居中）。也可以使用精确单位x轴长度，y轴长度，（只写一个另外一个默认居中） background-attachment: scroll||fixed//背景图像随对象内容滚动||背景图像固定 复合：background: 颜色 图片地址 平铺 图像滚动 图片位置 列表list-style: none//去掉无序列表里 li 列表前面的小圆点 2.伪类选择器//a超链接类 或者写成 a的类名:XXX{} a:link 选择所有未访问的链接 a:visited 选择所有已被访问的链接 a:hover 常用，选择鼠标指向的链接 a:ative 鼠标按下未弹起的链接 //如果全部都写，请按照LVHA的顺序写 //input类，把获得光标的inut选取出来改写CSS input:focus 3.行块转换（块元素和行元素相互转换）display:block //转块元素 display:inline //转行内元素 display: inline-block //转行内块 //使文字垂直居中 让文字行高=盒子的行高 行高&gt;盒子高度偏下，&lt;偏上 line-height: 盒子高度4.CSS的三大特性1.层叠性样式冲突选择就近原则，把前面的覆盖掉，不冲突的不覆盖 2.继承性子标签会继承父标签的属性 3.优先级1.选择器相同，执行层叠性 2.选择器不同，继承/*(0,0,0,0)&lt;元素(0,0,0,1)&lt;类(0,0,1,0)&lt;id(0,1,0,0)&lt;行内样式style(1,0,0,0)&lt;！important无限大 （！important加在某属性后面，如color: green!important） 继承的你加了！important，权值还是（0，0，0，0），毕竟是继承过来的 3.复合选择器有权重叠加的问题 ul li{}权重为(0,0,0,1)+(0,0,0,1) li为(0,0,0,1) .nav li为（0，0，1，1） 权重会叠加，但是永不进位，不是二进制 （a:hover为(0,0,1,1)） 5.CSS盒子border（会影响盒子大小）border-style: solid(实线边框，最常用) dashed(虚线) dotted（点线边框） border-width: XXpx border-color: XX 复写： border: 1px solid red 边框分开写法： border-top: 1px solid red border-collapse:collapse //相邻边框合并padding，内边距（会影响盒子大小，要设置了盒子宽高才会撑开）适用于文字大小不一的盒子，不设置宽高，直接设置padding，字少空间小。字多空间大 子容器盒子没设置宽高，父容器盒子padding不会被撑开 padding: 5px; padding-top: 5px; //仅写上方内边距margin，外边距，盒子和盒子之间的距离（不会撑开）使用方法和padding是一致的 margin可以让块级盒子水平居中：1盒子必须有宽度，盒子左右外边距设置为auto margin: 0 auto; 行内元素或者行内块元素居中只需在其父元素CSS样式中添加：text-align: center;","categories":[],"tags":[],"author":"Hello"},{"title":"emmet语法","slug":"emmet语法","date":"2020-05-09T16:00:00.000Z","updated":"2020-05-10T10:19:56.809Z","comments":true,"path":"2020/05/10/emmet-yu-fa/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/emmet-yu-fa/","excerpt":"","text":"Emmet语法插件于市面上大多前端编译软件，如VScode所带有的，便于快速写html和CSSh5想要生成多个标签：div*10，再回车（或者tab），即可生成10个div标签。 生成父子关系标签：div&gt;span,再回车（或者tab），即可生成包含span标签的div标签。 生成兄弟关系标签：div+span,再回车（或者tab）。 输入：.nav 直接生成一个class=“nav”的div标签。(默认div) 输入：#nav 直接生成一个id=“nav”的div标签。 输入：p.nav 直接生成一个class=“nav”的p标签。 输入：.nav$*5 直接生成5个class=“nav1”,class=“nav2”…..的div标签。($是自增符号) 输入：div{前端真好玩}*5 直接生成5个&lt;div&gt; 前端真好玩 &lt;/div&gt; CSS样式内输入：tac 直接生成text-align: center; 其他语法缩写同样类似，诸如w100—&gt;width: 100 格式化直接鼠标右键，格式化文档，即可直接让文档变整齐。 （或者想要每次保存后自动格式化，需要在首页—首选项—设置—搜索emmet.include,在setting.json下的用户，添加 “editor.formatOnType”: true, “editor.formatOnSave”: true 即可）","categories":[],"tags":[],"author":"Hello"},{"title":"循环队列","slug":"循环队列","date":"2020-05-09T11:51:20.811Z","updated":"2020-05-17T12:35:49.227Z","comments":true,"path":"2020/05/09/xun-huan-dui-lie/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/xun-huan-dui-lie/","excerpt":"","text":"循环队列顺序定义typedef struct { QElemType *base;//初始化时动态分配存储空间 int front;//头指针 int rear;//尾指针 } SqQueue; 初始化//算法3.11 循环队列的初始化 Status InitQueue(SqQueue &Q) {//构造一个空队列Q Q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间 if (!Q.base) exit(OVERFLOW); //存储分配失败 Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空 return OK; } 求队列长度//算法3.12 求循环队列的长度 int QueueLength(SqQueue Q) {//返回Q的元素个数，即队列的长度 return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE; } 入队和出队（防止假溢出）（出头front，入尾rear）（rear无元素，front有元素）//算法3.13 循环队列的入队 Status EnQueue(SqQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满 return ERROR; Q.base[Q.rear] = e; //新元素插入队尾 Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1 return OK; } //算法3.14 循环队列的出队 Status DeQueue(SqQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 if (Q.front == Q.rear) return ERROR; //队空 e = Q.base[Q.front]; //保存队头元素 Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1 return OK; } 链队定义（还是像极了单链表，可知X链的形式一般都是单链表拓展）typedef struct QNode { QElemType data; struct QNode *next; } QNode, *QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 } LinkQueue; 链队的初始化Status InitQueue(LinkQueue &Q) {//构造一个空队列Q Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点 Q.front->next = NULL; //头结点的指针域置空 return OK; } 入队和出队（队头front无元素）//算法3.17 链队的入队 Status EnQueue(LinkQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 QueuePtr p; p = new QNode; //为入队元素分配结点空间，用指针p指向 p->data = e; //将新结点数据域置为e p->next = NULL; Q.rear->next = p; //将新结点插入到队尾 Q.rear = p; //修改队尾指针 return OK; } //算法3.18 链队的出队 Status DeQueue(LinkQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 QueuePtr p; if (Q.front == Q.rear) return ERROR; //若队列空，则返回ERROR p = Q.front->next; //p指向队头元素 e = p->data; //e保存队头元素的值 Q.front->next = p->next; //修改头指针 if (Q.rear == p) Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点 delete p; //释放原队头元素的空间 return OK; } 取队头元素//算法3.19 取链队的队头元素 SElemType GetHead(LinkQueue Q) {//返回Q的队头元素，不修改队头指针 if (Q.front != Q.rear) //队列非空 return Q.front->next->data; //返回队头元素的值，队头指针不变 }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"栈","slug":"栈","date":"2020-05-09T11:14:09.081Z","updated":"2020-05-17T12:35:55.947Z","comments":true,"path":"2020/05/09/zhan/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/zhan/","excerpt":"","text":"顺序栈定义typedef struct { SElemType *base;//栈底指针 SElemType *top;//栈顶指针 int stacksize;//栈可用的最大容量 } SqStack; 初始化Status InitStack(SqStack &S) { //构造一个空栈S S.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间 if (!S.base) exit(OVERFLOW); //存储分配失败 S.top = S.base; //top初始为base，空栈 S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE return OK; } 入栈和出栈（top无元素）//算法3.2 顺序栈的入栈 Status Push(SqStack &S, SElemType e) { // 插入元素e为新的栈顶元素 if (S.top - S.base == S.stacksize) return ERROR; //栈满 *(S.top++) = e; //元素e压入栈顶，栈顶指针加1 return OK; } //算法3.3 顺序栈的出栈 Status Pop(SqStack &S, SElemType &e) { //删除S的栈顶元素，用e返回其值 if (S.base == S.top) return ERROR;//栈空 e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e return OK; } 链栈定义，有点像链表typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack;初始化，无需链表的”头结点“Status InitStack(LinkStack &amp;S) { // 构造一个空栈 S，栈顶指针置空 S = NULL; return OK; }入栈和出栈//算法3.6 链栈的入栈 Status Push(LinkStack &S, SElemType e) {//在栈顶插入元素e LinkStack p; p = new StackNode; //生成新结点 p->data = e; //将新结点数据域置为e p->next = S; //将新结点插入栈顶 S = p; //修改栈顶指针为p return OK; } //算法3.7 链栈的出栈 Status Pop(LinkStack &S, SElemType &e) {//删除S的栈顶元素，用e返回其值 LinkStack p; if (S == NULL) return ERROR; //栈空 e = S->data; //将栈顶元素赋给e p = S; //用p临时保存栈顶元素空间，以备释放 S = S->next; //修改栈顶指针 delete p; //释放原栈顶元素的空间 return OK; }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"双向链表","slug":"双向链表","date":"2020-05-07T11:15:31.827Z","updated":"2020-05-17T12:35:32.455Z","comments":true,"path":"2020/05/07/shuang-xiang-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shuang-xiang-lian-biao/","excerpt":"","text":"双向链表的定义typedef struct DuLNode{ ElemType data; struct DuLNode *prior; struct DuLNode *next; //前驱和后继 }DuLNode，*DuLinkList 插入顺序 s=data; s->prior=p->prior; p->prior->next=s; s->next=p; p->prior=s;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"单链表","slug":"单链表","date":"2020-05-07T10:10:22.778Z","updated":"2020-05-17T12:35:13.050Z","comments":true,"path":"2020/05/07/dan-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/dan-lian-biao/","excerpt":"","text":"如定义单链表结构体，注意引用单链表元素用” -&gt; “,因为是*LinkList，使用单链表用的是LinkListtypedef struct LNode { ElemType data; //结点的数据域 struct LNode *next; //结点的指针域 }LNode,*LinkList; //LinkList为指向结构体LNode的指针类型 前插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头 } }后插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p,r; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 r=L; //尾指针r指向头结点 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=NULL; r-&gt;next=p; r=p; } }单链表的初始化，它的头节点（为了处理方便，在第一个节点之前增加的结点）没有赋值Status InitList_L(LinkList &L){ //功能1---算法2.5 单链表的初始化 //构造一个空的单链表L L=new LNode; //生成新结点作为头结点，用头指针L指向头结点 L->next=NULL; //头结点的指针域置空 return OK; } 它不能像顺序表一样随机取值，所以需要一一查找ElemType FindList(LinkList &amp;L,int i,ElemType &amp;x){ LinkList p=L; for(int j=0;j&lt;i;j++){ if(!(p-&gt;next))return ERROR; p=p-&gt;next; } x=p-&gt;data; return OK; }查找，按值查找int GetElem(LinkList &L,int &i,ElemType e) { LinkList p=L; int j=1; while(p->next) { p=p->next; if(p->data==e){ //查找成功 i=j; return OK; } j++; } return ERROR; //循环至查找失败 } 单链表的插入Status ListInsert_L(LinkList &amp;L,int i,ElemType &amp;e){ //功能3---算法2.8 单链表的插入 //在带头结点的单链表L中第i个位置之前插入元素e int j; LinkList p,s; p=L;j=0; while(p &amp;&amp; j&lt;i-1){p=p-&gt;next;++j;} //寻找第i-1个结点 if(!p||j&gt;i-1) return ERROR; //i大于表长+1或者小于1 s=new LNode; //生成新结点s s-&gt;data=e; //将结点s的数据域置为e s-&gt;next=p-&gt;next; //将结点s插入L中 p-&gt;next=s; return OK; }删除指定序号数据元素Status ListDelete(LinkList &L,int i){ LinkList p=L; int j=1; while(p->next&&jnext; j++; } if(!(p->next)||j>i)return ERROR; LinkList q=p->next; p->next=q->next; delete q; return OK; }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"顺序表","slug":"顺序表","date":"2020-05-07T09:31:08.736Z","updated":"2020-05-17T12:37:04.901Z","comments":true,"path":"2020/05/07/shun-xu-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shun-xu-biao/","excerpt":"","text":"如定义s顺序表结构体，注意引用顺序表元素用” . “,因为是SqList不是*S’q’Listtypedef struct{ ElemType *elem; //存储空间的基地址 int length; //当前长度 }SqList; 顺序表的初始化Status InitList_Sq(SqList &L){ //功能1--算法2.1 顺序表的初始化 //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) return OVERFLOW; //存储分配失败，overflow为-2 L.length=0; //空表长度为0 return OK; } 查找Status LocateElem(SqList *L, ElemType e) //按元素值查找 { int i=0; while (ilength && L->elem[i]!=e) i++; //查找元素e if (i>=L->length) //未找到时返回0 return 0; else return i+1; //找到后返回其逻辑序号 顺序表的插入Status ListInsert_Sq(SqList &amp;L,int i,ElemType e){ //功能3--算法2.3 顺序表的插入 //在顺序表L中第i个位置之前插入新的元素e //i值的合法范围是1&lt;=i&lt;=L.length+1 if(i&lt;1 || i&gt;L.length+1) return ERROR; //i值不合法,error为0 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length; //表长增1 return OK; }删除数据元素bool ListDelete(SqList &L,int i) //删除数据元素 { int j; if (iL.length) //参数错误时返回false return false; for (j=i-1;j","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"C++结构体初始化","slug":"C++结构体初始化","date":"2020-05-07T09:16:02.980Z","updated":"2020-05-17T12:35:02.720Z","comments":true,"path":"2020/05/07/c-jie-gou-ti-chu-shi-hua/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/c-jie-gou-ti-chu-shi-hua/","excerpt":"","text":"如定义药品结构体 typedef struct node{ //定义结构体 string name; float price; int count; float sale; int next; }Medicine; typedef struct{ //定义顺序表 Medicine r[MAX_Size+1]; int length; }SqList; 使用new的初始化 SqList *list_med=new SqList;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"C++求string数组元素个数","slug":"C++求String数组的元素个数","date":"2020-05-06T11:04:31.177Z","updated":"2020-05-17T12:34:40.508Z","comments":true,"path":"2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","link":"","permalink":"https://taylor12138.github.io/2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","excerpt":"","text":"不能使用str.length,这个求的是单个字符串的大小，可以使用以下求得到长度 sizeof(str)/sizeof(str[0])","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"搞定了gitee了！！","slug":"搞定了gitee了！！","date":"2020-05-04T17:01:10.659Z","updated":"2020-05-05T17:02:45.166Z","comments":true,"path":"2020/05/05/gao-ding-liao-gitee-liao/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/gao-ding-liao-gitee-liao/","excerpt":"","text":"原来是个人邮箱的设置必须得是公开的，我一直是设置为private，搞得一直错，终于搞出来了，单独发一条blog来庆祝一下！！！！ 但是发现了gitee的一个缺点，每次部署完后都要去码云更新一次。。。","categories":[],"tags":[],"author":"Hello"},{"title":"HTML5的基本属性","slug":"HTML5的基本属性","date":"2020-05-04T16:25:58.368Z","updated":"2020-05-17T12:38:33.268Z","comments":true,"path":"2020/05/05/html5-de-ji-ben-shu-xing/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/html5-de-ji-ben-shu-xing/","excerpt":"","text":"1.基本标签介绍&lt;html&gt;&lt;/html&gt;``根标签 &lt;head&gt; &lt;/head&gt; 文档头部 &lt; title&gt; &lt;/title&gt; 文档标题 &lt;body&gt;&lt;/body&gt; 文档主体 2.在vscode里使用英文“！”可以直接生成基本结构ctrl+“+”可以放大（写代码）页面 &lt;!DOCTYPE html&gt; （） &lt;html lang=&quot;zh-CN&quot;&gt; (中文) &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;h1&gt;&lt;/h1&gt;---&lt;h6&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; &lt;br /&gt;&lt;strong&gt;&lt;/strong&gt;(字体加粗)&lt;del&gt;&lt;/del&gt;（字体删除线） 3.盒子：类似于view，用于布局&lt;div&gt;&lt;/div&gt; //大盒子，独占一整行 &lt;span&gt;&lt;/span&gt; //小盒子 4.img&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; height=&quot;&quot; width=&quot;&quot;&gt; //微信小程序是image alt为图片无法加载时显示的文字，title为鼠标移到图片上显示的文字提示, 但是对于height和width,一般只修改其中一个，另外一个就会跟着改变 src种绝对路径 \\ 相对路径 / 5.超链接&lt; a&gt;&lt;a href=&quot;&quot; target=&quot;&quot; &gt;文本或者图像&lt;/a&gt; 类似于微信小程序中的navigator, href用于指定目标的url，可打开内部，外部链接 target用于来链接打开方式，默认_self _blank为在新窗口打开 锚点链接：设置href=#名字，如&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;可以快速跳转到第二集的页面位置 ​ 在于目标位置标签里添加id=”two” 6.特殊字符空格：&amp;nbsp (因无法识别大于号和小于号) 小于号：&amp;lt 大于号：&amp;gt 7.表格（用于数据）&lt;table&gt; ​ &lt;tr&gt; ​ &lt;td&gt;单元格文字&lt;/td&gt;或者&lt;th&gt;&lt;/th&gt; ​ &lt;/tr&gt; &lt;/table&gt; table是表格，tr是行，td是单元格（th可充当表头单元格）。还可以加入&lt;thead&gt;和 &lt;tbody&gt;来帮助CSS区分表格结构 单元格合并使用colspan=”（列）想要合并的单元个数”或者rowspan=”（行）想要合并的单元个数”，再删除多余的td（或th） 8.列表（用于布局）无序列表（ul里只能放li标签，所以其他容器放li里面就可以）&lt;ul&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ul&gt; 有序列表(规则同无序)&lt;ol&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ol&gt; 自定义列表(同上)&lt;dl&gt; ​ &lt;dt&gt;名词1&lt;/dt&gt; ​ &lt;dd&gt;名词1解释1&lt;/dd ​ &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 9.表单（用于填写信息，用户注册）&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot; maxlength=&quot;&quot;&gt;&lt;/form&gt;表单域 url地址为处理表单数据的地址，method有get，post 表单元素&lt;input&gt;&lt;input type=&quot;属性值&quot; name=&quot;&quot; value=&quot;&quot; check=&quot;&quot;&gt;输入 type可以为text，password，button，reset（重置）submit（用于提交），radio（单选框，必须添加name才能使用），checkbox（复选框）等 科普：submit是button的一个特例，用于处理大量表单数据 value为输入框内的提示语||充当提交给后台的数据||显示的文字 check用于单选和复选的默认值 check=”checked” maxlength=“最大值” &lt;label for=&quot;sex&quot;&gt;男 &lt;/label&gt; label用于增加用户体验，点击范围内即可选中某input &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; label中的for对应input里的id 或者把input标签放在label里面也能达到同样的效果，此时不需要for和id 表单元素&lt;select&gt; 下拉列表&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;选项3&lt;/option&gt; //默认选中选项3 ... &lt;select&gt;表单元素&lt;textarea&gt; 文本域，可以写大量文字（个人介绍，评论）&lt;textarea&gt; 文字 &lt;/textarea&gt;10 元素分类块元素，独占一行，是一个容器或者盒子如 &lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt;等 但&lt;p&gt; &lt;h&gt; 不能内置块级元素，只能放文字行元素，不能设置宽高，只能容纳文本或者其他行内元素 &lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;span&gt;等 但是&lt;a&gt;不能再放&lt;a&gt; 特殊情况&lt;a&gt;可以转块级行内块元素，能在同一行，也能设置宽高 &lt;input/&gt; &lt;img/&gt; &lt;td&gt;行块的转换详情请看CSS里的《行块转换》h5标签推荐网址： http://www.w3school.com.cn/ http://developer.mozilla.org/zh-CN/","categories":[],"tags":[],"author":"Hello"},{"title":"主题与2d人物","slug":"主题与2d人物","date":"2020-05-03T16:50:47.307Z","updated":"2020-05-05T17:03:19.452Z","comments":true,"path":"2020/05/04/zhu-ti-yu-2d-ren-wu/","link":"","permalink":"https://taylor12138.github.io/2020/05/04/zhu-ti-yu-2d-ren-wu/","excerpt":"","text":"Start人物使用命令安装npm：npm uninstall hexo-helper-live2d npm install –save hexo-helper-live2d此时在blog/node_modeles下多出了一个“live2d-widget”下载动画model：这里是套用别人（大佬）的仓库https://github.com/xiazeyu/live2d-widget-models.git下载好后将packages里的所有文件拷贝到blog/node_modeles最后在win使用padnote _config.yml，把以下：live2d: enable: true pluginModelPath: assets/ model: use: live2d-widget-model-epsilon2_1 #模板目录，在node_modules里 display: position: right width: 150 height: 300 mobile: show: false #是否在手机进行显示 复制进去 再使用hexo clean g d进行部署 主题下载好了之后放入blog/themes里面（整个文件）再在win使用padnote _config.yml把theme: xx改成theme: (你要的主题名)最后部署","categories":[],"tags":[],"author":"Hello"},{"title":"困难的一天","slug":"困难的一天","date":"2020-05-03T15:00:48.806Z","updated":"2020-05-05T17:03:02.641Z","comments":true,"path":"2020/05/03/kun-nan-de-yi-tian/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/kun-nan-de-yi-tian/","excerpt":"","text":"difficult daynothing搞了一天，荒废了一天的宝贵五一假期时间，竟然还搞不好gitee的部署，我太菜了 但是至少弄好了ssh和主题，安慰一下把","categories":[],"tags":[],"author":"Hello"},{"title":"My First Blog","slug":"My First Blog","date":"2020-05-02T17:33:53.947Z","updated":"2020-05-05T17:02:29.455Z","comments":true,"path":"2020/05/03/my-first-blog/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/my-first-blog/","excerpt":"","text":"Quick Start打开win+R进入cmd，然后在正确目录下进入：cd source_post(指定blog下) 基本操作用typora修改完毕后，1.使用“hexo clean”进行清理（1.5.若是发生主题等修改后，要接上hexo g 来建立）2.接上“hexo s”即可进入网站查看（退出键位：control+C，y）（本地浏览）3.再次部署到远端：hexo d 关于主题1.可以使用git clone 网址.git themes\\新建目录名（或者使用码云gitee进行下载，然后复制到themes目录下）2.cd.. (回到blog目录下)notepad _config.yml把记事本里面的theme：xx修改成theme：主题目录名3.重新执行”基本操作” 参考文献 https://hexo.io/docs/one-command-deployment.html)","categories":[],"tags":[],"author":"Hello"}],"categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"},{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"},{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[]}