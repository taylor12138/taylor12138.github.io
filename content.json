{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://taylor12138.github.io","root":"/"},"pages":[{"title":"contact","date":"2020-05-03T17:21:52.000Z","updated":"2020-05-04T06:33:52.664Z","comments":true,"path":"contact/index.html","permalink":"https://taylor12138.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-05-03T17:22:42.000Z","updated":"2020-05-04T06:34:25.403Z","comments":true,"path":"friends/index.html","permalink":"https://taylor12138.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-03T17:20:07.000Z","updated":"2020-05-04T06:33:11.259Z","comments":true,"path":"categories/index.html","permalink":"https://taylor12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-05-04T06:35:25.450Z","comments":true,"path":"about/index.html","permalink":"https://taylor12138.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-03T17:17:32.000Z","updated":"2020-05-04T06:33:28.454Z","comments":true,"path":"tags/index.html","permalink":"https://taylor12138.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript进阶ES6","slug":"JavaScript进阶ES6","date":"2020-12-27T02:02:23.693Z","updated":"2020-12-28T09:18:56.809Z","comments":true,"path":"2020/12/27/javascript-jin-jie-es6/","link":"","permalink":"https://taylor12138.github.io/2020/12/27/javascript-jin-jie-es6/","excerpt":"","text":"1.ESMAScript6ES6其实是一个泛指，泛指ES2015后续的版本 2.新增语法声明变量let 声明的变量 1.只在所处块级有效（大括号中有效），可以防止循环变量变成全局变量 2.不存在变量提升，只能先声明再使用 3.暂时性死区（即在块级作用域中使用某变量，则会先在该块级中查找次变量） var num = 10; if(true) { console.log(num); //报错，变量声明在后面 let num = 20; } const声明常量，常量就是值（内存地址）不能变化的量（值可以改，内存地址不能变） 1.具有块级作用域 2.const声明常量时必须赋值 3.基本数据类型：常量赋值后，不可修改；复杂数据类型：对象赋值后（数组之类的）不可更改，但是可以更改数据结构内部的值 4.不存在变量提升，只能先声明再使用 const ary = [100, 200]; ary[0] = 'a'; //可以 //ary = ['a', 200]; //不可以 解构赋值ES6允许从数组或者对象（分别使用[]、{}）中一一提取值，按照对应的位置，对变量赋值 //数组 let ary = [1, 2, 3]; let [a, b, c, d, e] = ary; //1, 2, 3, undefined, undefined //也可以 let [a, b, c] = [1, 2, 3]; //对象 let person = {name: 'zhangsan', age: 20}; let{name, age} = person; 对象的另一解构写法 let {name: myName, age: myAge} = person; 如果name和age分别和person中的属性值匹配成功，则将右侧该属性值赋值给左边myName，myAge变量 箭头函数(形参) =&gt; {函数体} 箭头函数用来简化定义函数语法 const fn = () => { console.log('xx'); } 如果函数体只有一句话，且代码执行结果就是返回值，则可以省略大括号 //传统 function sum(num1, num2) { return num1+num2; } //new const sum1 = (num1, num2) => num1+num2; 如果形参只有一个，小括号可以省略 //传统 function sum(a) { return a; } //new const sum1 = a => a; 箭头函数和传统函数不一样，箭头函数的this指向函数定义位置的上下文this function() { console.log(this); return () => { console.log(this); } } const obj = {name: 'zhangsan'}; const resFn = fn.call(obj); //这时this指向obj，所以箭头函数跟着指向obj resFn(); //返回obj obj 对象不能产生作用域，所以箭头函数实际被定义在全局作用域下，所以此处的this指向window，所以箭头函数处的this.age未定义 var obj = { age: 20, say: () => { alert(this.age); //undefined }, con: function () { console.log(this); //obj } } 注意：箭头函数是用不了arguments 剩余参数剩余参数语法允许我们将一个不定数量的参数表示为一个数组 ...args function sum(first, ...args) { console.log(first); //10 console.log(args); //20, 30 } sum(10, 20, 30); //剩余参数配合解构 let students = ['allen', 'berry', 'david']; let [s1, ...s2] = students; //s1为allen，s2为[berry. david] 3.ES6内置对象的扩展array的扩展扩展运算符是和剩余参数相反的原理，它可以将数组或者对象转为用逗号分隔的参数序列 ...ary let ary = [1, 2, 3]; console.log(...ary); // 1, 2, 3 //相当于 console.log(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);扩展运算符应用：数组合并 //方法一： let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; //方法二 ary1.push(...ary2); ...ary扩展运算符还能把伪数组转换成真正的数组，然后可以使用数组的方法 同样的，构造函数方法Array.from() 也可以将类数组或可遍历对象转换成真正的数组 let arraylike = { 0: 'a', 1; 'b', length: 2 }; let arr2 = Array.from(arraylike); //[a, b]","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Node+Gulp+MongoDB+Express+ajax","slug":"Node+Gulp+MongoDB+Express+ajax","date":"2020-12-26T13:25:21.026Z","updated":"2020-12-26T17:27:15.040Z","comments":true,"path":"2020/12/26/node-gulp-mongodb-express-ajax/","link":"","permalink":"https://taylor12138.github.io/2020/12/26/node-gulp-mongodb-express-ajax/","excerpt":"","text":"Node开发为什么选择node： 1.node使用JavaScript语法开发后端应用 2.一些公司要求前端人员掌握Node开发 3.生态系统活跃，有大量开源库 4.现有前端开发工具大多居于node开发 node是基于chrome V8引擎的JavaScript代码运行环境（浏览器也是JavaScript代码运行环境） 在命令行工具中输入 node -v 即可查看nodejs是否安装成功 node.js的组成：JavaScript由3部分组成，ECMAScript，DOM，BOM Node.js由ECMAScript及Node环境提供的一些附加API组成的，包括文件、网络、路径等一些更强大的API 使用在cmd命令符窗口中使用 node xx.js 即可完成（在执行文件的目录下按住shift+鼠标右键可快速进入当前目录的命令符窗口，然后配合tab键位快速打开） Node.js模块化开发JavaScript弊端：文件依赖（a.js-&gt;b.js-&gt;c.js，相互依赖，但是很难直接看出来，分析完后才知道要一个一个引入）和命名冲突（在相互依赖的js中声明同样的变量名导致的错误） 模块化开发：一个功能一个模块，多模块组合完整应用，抽离一个模块不会影响其他功能的运行 node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到模块内部使用exports 对象进行成员导出，使用require方法导入其他模块（注意ES6使用require而是使用import） //a.js let version = 1.0; const sayHi = name => `你好, ${name}`; //向模块外导出数据 exports.version = version; exports.sayHi = sayHi; //b.js let a = require('./a.js'); //b.js导入a.js, ./b.js是b.js的目录 console.log(a.version); console.log(a.sayHi('xx'));","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript进阶ES5+面向对象","slug":"JavaScript进阶ES5+面向对象","date":"2020-12-08T09:52:15.778Z","updated":"2020-12-28T06:24:28.105Z","comments":true,"path":"2020/12/08/javascript-jin-jie-es5-mian-xiang-dui-xiang/","link":"","permalink":"https://taylor12138.github.io/2020/12/08/javascript-jin-jie-es5-mian-xiang-dui-xiang/","excerpt":"","text":"1.编程思想介绍面向过程（POP）：分析解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一步一步调用就行了 面向对象（OOP）：把事物分解成一个个对象，然后由对象之间分工合作（找出对象出来，然后写出这些对象的功能） 面向过程的性能比较高，适合和硬件联系很紧密的东西，如单片机，缺点是难维护、难拓展、难复用 面向对象的代码灵活，代码可复用性高，容易维护和开发，更适合多人合作的大型软件项目 面向对象：封装性（直接使用，不需要了解内部）、继承性、多态性（多功能） 2.面向对象1.抽取对象公共属性和行为组织封装成一个类（class） class name { class body } 2.对象实例化，获取类的对象（对象是特指某一个，实例化的具体对象） var xx = new name() 利用类创建对象 对象由属性和方法构成 tip： （1）class关键字创建类，类名习惯定义首字母大写 （2）constructor()是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有明显定义，类内部会自动给我们创建一个constructor()（最好自己写上constructor） class Star { constructor(uname, age) { this.name = uname; this.age = age; } } var xxx = new Star('xxx', 20); 类里添加方法1.在类里面构造函数，不需要加function 2.多个方法、函数之间不需要添加逗号进行分割 class Star { constructor(uname) { this.name = uname; } init() { //xxxx } } 类的继承使用extends进行继承 super关键字用于访问和调用对象父类上的函数，可以调用父类的构造函数，也可以调用父类的普通函数（super必须在字类this的之前进行调用，即必须先调用父类的构造函数，再使用子类的构造函数） 不过要注意的是：（错误❌） class Father { constructor(x, y){ this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } class Son extends Father { constructor(x, y) { this.x = x; this.y = y; } } var son = new Son(1, 2); son.sum(); //会报错 因为此时参数传递给子类的constructor的x和y，而父类的sum函数用的是父类的constructor的x和y，所以应该改为以下函数： class Father { constructor(x, y){ this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } class Son extends Father { constructor(x, y) { //调用父类的构造函数 super(x, y); } } var son = new Son(1, 2); son.sum(); //success 继承中属性或者方法的查找原则：就近原则 在继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就执行字类的 如果没有，就去查找父类有没有此方法，如果有就执行父类的 如果子类想要直接调用父类的方法，则： class Father { say() { //xxx } } class Son extends Father { say() { //调用父类的普通函数 super.say(); } } var son = new Son(); son.say(); 需要注意的三点1.ES6中类没有变量提升，所以必须先定义类，才能通过实例化对象 2.类里的共有属性和方法一定要加this进行使用 （this指向我们创立的·实例化对象） var that; class Father { constructor(uname, age) { //that = this; this.uname = uname; this.age = age; //this.sing(); 加小括号会立即调用 this.btn = document.querySelector('button'); this.btn.onclick = this.sing; this.init(); } init() {} sing() { //这里的this指向的是调用者，所以btn点击事件发生时，this.uname指向的是btn的uname console.log(this.uname); //所以可以外面定义变量，然后让btn固定打印的是该对象的uname //console.log(that.uname) } } 3.构造函数和原型在ES6（ECMAScript6.0）之前，JavaScript没有类的概念，在ES6之前，对象不是基于类创建的，而是用一种称为构造函数的特殊函数来定义对象和他们的特征的。 创建对象：(JavaScript基础也有做过笔记) 1.对象字面量 var obj = {} 2.new Object() var obj = new Object() 3. 自定义构造函数function 构造函数名(){ this.属性=值; this.方法=function (){} } 1.使用构造函数，构造函数名字首字母最好大写如 function Star()2.构造函数不需要return3.使用函数new 构造函数名();即构造一个对象，如new Array()，创建一个数组对象4.属性方法前必须加this如this.name=传参name this.song = function（传参）{} 构造函数中属性和方法我们称之为成员，成员可以添加 实例成员：实例成员就是构造函数内部通过 this 添加的成员 ，实例成员只能通过实例化的对象来访问，不可以通过构造函数访问实例成员，如 function Star(uname){ this.uname = uname; } let star = new Star('xxx'); console.log(star.uname); 静态成员：在构造函数本身上添加的成员，静态成员只能通过构造函数来访问，不能通过对象来访问，如 function Star() {}; Star.sex = 'male'; console.log(Star.sex); 构造函数虽然好用，但是存在浪费内存的问题 构造函数原型对象prototype构造函数通过原型分配的函数是所有对象所共享的 JavaScript规定，每个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype（原型）就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有 因此，我们把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这个方法 使用方法： function Star(uname){ this.uname = uname; } //第一种写法： Star.prototype.sing = function() {} // Star.prototype.sex = 'male'; //第二种写法： Star.prototype = { constructor: Star, //不可省略，因为这种写法覆盖掉原来的constructor方法 sing: function() {}, movie: function() {} } 所以一般情况，我们的公共属性定义到构造函数里面，公共的方法我们放到原型对象的身上 原型对象的this指向谁调用，指向谁 1.在构造函数中，this指向的是对象实例 2.原型对象里面的this指向的也是调用它的实例对象 对象原型: __proto__对象都会有一个属性 __proto__ 指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为 __proto__ 的存在 实例化的对象.__proto__ === 构造函数名.prototype 返回true constructor构造函数对象原型（__proto__）和构造函数原型对象（prototype）里面都有一个constructor属性，constructor我们称为构造函数，因为它指回构造函数本身 主要目的：用于记录该对象引用于哪个构造函数（很多情况下我们需要用它来指回原来的构造函数） 原型链任何构造函数原型对象prototype，它作为一个对象，也有它自己的对象原型 __proto__ ，而此时原型对象的 __proto__ 指向的是Object.prototype， 即某构造函数名.prototype.__proto__ === Object.prototype 而我们Object也有prototype原型对象，而它作为一个对象，也有它自己的对象原型 __proto__ ，而此时指向null（到达了终点） 即Object.prototype.__proto__ === null JavaScript成员查找机制： 所以在成员查找时，先查找最底层，没有则根据它 的__proto__查找至他的原型对象，看看有没有该成员，没有的话继续一层一层往上查找，如果找不到该成员 ，最后返回undefined (undefined是由null派生而来的) 而根据查找规则，使用就近原则来处理重复成员定义问题（即先找到，先使用） 拓展内置对象可以通过原型对象，对原来的内置对象进行拓展自定义的方法，比如给数组增加自定义求偶数和的功能 //在Array原型对象上追加函数，不能采取Array.prototype = {}形式 Array.prototype.sum = function() { let sum = 0; for(let i = 0; i &lt; this.length; i++){ sum+=this[i]; } return sum; } 4.继承在ES6之前没有给我们提供extends，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承 call()fun.call(thisArg, arg1, arg2....) （arg n那些指的是传递的其他参数） 功能：调用这个函数，并且修改函数运行时this的指向 thisArg: 当前调用函数的this的指向对象（一般在JavaScript中直接调用函数时，函数的this指向window） ES5继承的两大步借用构造函数继承父类型的属性 核心原理：通过call() 把父类型的this指向子类型的this，这样就实现了子类型继承父类型的属性 利用原型对象继承父类型的方法 实现如下： // 借用父构造函数继承属性 function Father(uname, age) { this.uname = uname; this.age = age; } //接用父构造函数继承方法 Father.prototype.teach = function () { console('father') } function Son(uname, age) { Father.call(this, uname, age); } // 这样直接赋值会出问题，因为是赋值父原型对象的地址，如果修改了子原型对象，父原型对象也会随之改变 // Son.prototype = Father.prototype; × // 正确方法： Son.prototype = new Father(); // 如果利用了对象形式修改了原型对象，别忘了利用constructor指回原来的构造函数 Son.prototype.constructor = Son; Son.prototype.exam = function () { console('son') } let son = new Son('xxx', 18); console.log(son); 类的本质class本质还是function（用typeof查看），所以我们可以认为类就是构造函数的另一种写法 但是新的class写法只是让对象原型的写法更加清晰，更像面向对象编程的语法 和构造函数相同点： 1.类也有原型对象prototype，而prototype里的constructor也是指回类的本身 2.类也可以利用原型对象添加方法 3.类创建的实例对象中的 __proto__ 原型指向类的原型对象 5.ES5新增的方法数组方法1.forEach() ： arr.forEach(function(vlaue, index, [array])) 分别对应数组的value（值）、index（索引号）、数组本身 （遍历数组的全部元素，即使return true也不会终止迭代） （因为forEach本质是一个函数，参数是一个回调函数，回调函数的return只是终止了回调函数而已，不是终止forEach，而forEach内部应该是多次调用了那个函数） 2.filter(): filter() 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组 （注意它直接返回一个新数组） array.filter(function(currentValue, index, [arr])) 分别对应currentValue（数组当前项的值），index（索引号），arr（数组本身） var newArr = arr.filter(function(value, index) { return value >= 20; }) 3.some() ：some()方法用于检测数组中的元素是否 存在 满足指定条件，通俗点就是查找数组中是否有满足条件的元素，找到第一个满足条件的元素则停止 （注意它返回的是布尔值）在some里设置return true 以终止遍历 array.some(function(currentValue, index, [arr])) 分别对应currentValue（数组当前项的值），index（索引号），arr（数组本身） 4.map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。和forEach相似，不同在于： ​ 如果更改数组内的值，forEach 不能确保数组的不变性。这个方法只有在你不接触里面的任何值时，才能保证不变性。 ​ 由于它们之间的主要区别在于是否有返回值，所以你会希望使用 map 来制作一个新的数组，而使用 forEach 只是为了映射到数组上 5.every() 方法用于检测数组所有元素是否都符合指定条件 字符串方法trim()方法会从一个字符串的两端删除空白字符，它并不影响本身的字符串，它返回的是一个新的字符串 str.trim() 对象方法Object.defineProperty() 定义对象中新属性或修改原有的属性（应用于vue响应式，还是es5实现const的原理） Object.defineProperty(obj, prop,desciptor) obj:：必须，目标对象 prop： 必需，需定义或修改的属性名 descriptor： 必须，目标属性所拥有的特性，一对象的形式{ }进行书写，value设置属性的值，默认undefined；writable值能否重写（修改），默认为false；enumerable：目标属性是否可以被枚举(是否可以被遍历，显示出来)，默认false；configurable目标属性是否可以被删除，或者再次修改特性（是否可以再次更改这个descriptor），默认false var obj = { id: 1, pname: '小米', price: 1999 } //以前的对象添加修改方式 //obj.num = 1000; //obj.price = 99; Object.defineProperty(obj, 'num', { value = 999, enumerable = true }) Object.keys(obj) 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。 6.函数定义和调用函数定义： 1.自定义函数：function fn() {}; 2.匿名函数： var fun = function() {}; 3.new Function(&#39;参数1&#39;, &#39;参数2&#39;, &#39;函数体&#39;)形式调用 像构造函数, Function里面的参数都必须是字符串格式 var f = new Function('a', 'b', 'console.log(a + b)'); 实际上所有的函数都是Function的实例 函数也属于对象 函数调用： 1.普通函数调用 function fn() { //something } fn(); 2.对象方法 var o = { say: function() { //something } } o.say(); 3.构造函数 function Star() {}; new Star(); 4.绑定事件函数btn.onclick = function() {} 5.定时器函数 setInterval(function() {}, 1000); 6.立即执行函数（自动调用） (function() {} )(); 7.this的指向函数内this的指向是当我们调用函数时确定的，调用方式不同导致this指向不同 1.普通函数调用：window 2.构造函数调用：实例对象，原型对象也是指向实例对象 3.对象方法：该方法所属对象 4.事件绑定：绑定事件对象 5.定时器函数：window 6.立即执行函数：window 改变this指向JavaScript为我们专门提供了一些函数方法来帮助我们处理函数内部this指向问题，常用的有bind()、call()、apply()三种方法 1.call()前面讲过，call的主要作用可以实现继承 2.apply()方法调用一个函数，简单理解为调用函数的方式，但是它可以改变this的指向 fun.apply(thisArg, [argsArray]) thisArg：在函数执行时指定的this对象 argsArray: 传递的值，必须包含在数组（伪数组）里面 返回值为函数的返回值，因为它就是调用函数 应用方面：apply传递数组参数，所以可以借助数学内置对象求最大值 Math.max.apply(Math,arr) （es6拓展运算符…Math.max(...arr)也可以，但是不能 MAth.max(arr)，因为max不接受数组，只接受一个一个的参数） 3.bind()方法不会调用函数，但是能改变函数内部this指向 fun.bind(thisArg, arg1, arg2....) 返回指定this值和初始化参数改造的原函数拷贝（即创造新的函数 var f = fn.bind(xx)） 应用方面：定时器等不想立即调用的函数（或者处理其他只能用that来暂时储存对象的情况） btn.onclick = function() { this.disabled = true; //var that = this; //old way: /*setTimeout(function() { //that.disabled = false; }, 3000)*/ //new way: setTimeout(function() { this.disabled = false; }.bind(this), 3000) //这个this指向btn } 巧妙运用： 传参的时候可以传递其他对象过来 class Tab { constructor(id) { this.main = document.querySelector(id); //tabsbox this.lis = this.main.querySelectorAll('li'); } // 初始化 init() { for (let i = 0; i &lt; this.lis.length; i++) { this.lis[i].onclick = this.toggleTab.bind(this.lis[i], this); } } // 切换功能 toggleTab(that) { that.clearTab(); this.className = 'liactive' that.sections[this.index].className = 'conactive'; } } 8.严格模式ie10以上版本才支持 它是让JavaScript以严格的条件下运行代码 1.消除了JavaScript一些语法不严谨的地方，减少怪异行为 2.消除代码一些不安全之处，保证代码运行的安全 3.提高编译器效率，增加运行速度 4.禁用了ECMAscript在未来版本中可能会定义的一些语法，为未来JavaScript做好铺垫，比如class、enum、super等 开启严格模式应用到整个到整个脚本或个别函数中，因此，我们可以讲严格模式分为脚本开启严格模式和为函数开启严格模式两种情况 为脚本开启严格模式： &lt;script> \"use strict\"; //xxxx &lt;/script> 方法二：（写在立即执行函数里的都要按照严格模式） &lt;script> (function() { \"use strict\"; /xxxx })(); &lt;/script> 为函数开启严格模式：(只在此函数内部有严格模式) &lt;script> function fn(){ \"use strict\"; /xxxx } &lt;/script> 变化1.严格模式禁止变量为声明就赋值 2.严禁删除已声明的变量，比如delete x; 是错误的 3.在严格模式下，全局作用域中函数中的this不再是window，而是undefined（但是定时器之类的还是指向window） 4.严格模式下，如果构造函数不配合new来使用，this就会报错 5.函数不能有重名参数 6.函数必须声明在顶层，因为新版本的JavaScript引入了块级作用域，所以不允许在非函数代码块内声明函数 9.高阶函数高阶函数是对其它函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出，最典型的就是作为回调函数 10.闭包闭包指有权访问另外一个函数作用域中变量的函数，简单理解就是一个作用域可以访问另外一个函数内部的局部变量 （被访问作用域的函数就是闭包函数） //在此处fun函数作用域访问了另外一个函数fn里面的局部变量num，形成了闭包，此时fn就是一个闭包函数 function fn() { var num = 10; function fun() { console.log(num); } fun(); } fn(); 在fn外部作用域访问fn内部局部变量（它返回了当时的作用域）： //所以闭包就是典型的高阶函数 function fn() { var num = 10; return function() { console.log(num) } } var f = fn(); f(); 闭包的主要作用：延伸了变量的作用范围 利用闭包解决异步问题： //立即执行函数也成为了小闭包，因为立即执行函数里面任何一个函数都可以使用它的i变量 for(var i = 0;i &lt; lis.length; i++) { function(i) { lis[i].onlcick = function(){ console.log(i) } }(i); } 11.递归如果一个函数在内部可以调用其本身，则这个函数是递归（俄罗斯套娃） 但是容易发生“栈溢出”错误，所以必须加退出条件“return” 浅拷贝和深拷贝（jQuery篇目有提及到（$.extend([deep], target, object1, [objectN])）） 1.浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用 2.深拷贝拷贝多层，每一级别的数据都会拷贝 ES6中浅拷贝的语法糖：Object.assign(target, ...source)（把source拷贝给target） 利用循环写浅拷贝 var obj = { id: 1, name: 'andy', msg: { age: 18 } }; var o = {}; for (var k in obj) { // k是属性名， obj[k]是属性值 o[k] = obj[k]; } 利用递归写深拷贝 var obj = { id: 1, name: 'andy', msg: { age: 18 } }; var o = {}; function deepcopy(newobj, oldobj) { for(var k in oldobj) { // 获取属性值 var item = oldobj[k]; // 判断该值是否属于数组(数组也属于object，所以要先写) if(item instanceof Array) { newobj[k] = []; deepcopy(newobj[k], item); } else if(item instanceof Object) { // 判断该值是否为对象 newobj[k] = {}; deepcopy(newobj[k], item); } else { // 所以剩下的属于简单数据类型 newobj[k] = item; } } } deepcopy(o, obj); console.log(o); 12.正则表达式概述正则表达式（regular expression）是用于匹配字符串中字符组合的模式，再JavaScript，正则表达式也是对象 正则表达式通常用来做检索，替换那些符合某个模式（规则）的文本，例如昵称输入框里的对中文的匹配；此外，正则表达式还常用于过滤掉页面一些敏感（替换），或者从字符串获取我们想要的特定部分（提取）等 特点：1.灵活性、逻辑性、功能性非常强 2.可以迅速用极简的形式达到对字符串复杂的控制 3.对刚接触的人来说，比较晦涩难懂 4.一般实际开发，都是直接复制写好的正则表达式，但是要求会使用正则表达式且根据实际情况修改正则表达式 应用1.通过调用RegExp对象的构造函数创建 var 变量名 = new RegExp(/表达式/) 2.通过字面量创建 var 变量名 = /表达式/（正则表达式不需要加引号，不管是数字型还是字符串型） 测试正则表达式是否符合语法规范：test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数是测试字符串 regexObj.test(str) （只要包含有str这个字符串，返回的都是true） var rg = /123/; console.log(rg.test(123)); //true console.log(rg.test(12123)); //true 特殊字符一个正则表达式可以由简单的字符构成，比如/abc/， 也可以是简单和特殊字符串的组合，比如/ab*c/。其中特殊字符也被称为元字符，在正则表达式中具有特殊意义的专用符号，如^ 、$ 、+ 等 正则表达式速查表：https://www.runoob.com/regexp/regexp-metachar.html 边界符：^ 表示匹配行首的文本（以谁开始） $ 表示匹配行尾的文本（以谁结束） var rg = /^abc/; console.log(rg.test('abcd')); //true console.log(rg.test('babc')); //false //必须是abc,类似全等 var rg2 = /^abc$/; console.log(rg.test('abcd')); //false console.log(rg.test('abcabc')); //false 字符类：[]表示有一系列字符可供选择，只要匹配到其中一个就可以了 var rg = /[abc]/; //只要包含有a或者b或者c就返回true console.log(rg.test('andy')); //返回true //var rg = /^[abc]$/ 是三选一，只有是单个a或者b或者c才返回true []使用范围符号 - var rg = /^[a-z]$/; //26个英文小写字母任何一个字母都返回true var rg1 = /^[a-zA-Z]$/; //26个英文字母任何一个字母都返回true var rg2 = /^[a-z0-9_-]$/; //任何单个26小写字母，0-9数字，_, -,都返回true []里使用^：如果中括号里有^表示取反的意思，千万别和边界符^混淆，要区分开来 var rg = /^[^a-z]$/; //26个英文小写字母任何一个字母都返回false 量词符：用来设定某个模式出现的次数，有*、 +、 ？、 {}，{}的量词间不要有空格，可以用test来检测下方正则表达式 var rg = /^a*$/; //a可以出现0-n次，n>=0 var rg1 = /^a+$/; //a可以出现1-n次，n>=1 var rg2 = /^a?$/; //a可以出现1或0次 var rg3 = /^a{3}$/; //a只能可以出现3次 var rg4 = /^a{3,}$/; //a只可以出现3-n次 n>=3 var rg5 = /^a{3,16}$/; //a只可以出现3-16次 //普遍的用户名规定： var name = /^[a-zA-Z0-9_-]{6, 16}$/ 括号总结 []中括号：字符集合，匹配方括号中的任意字符 {} 大括号：量词符，里面表示重复次数，但只让大括号前面一个字符重复 （注意：/^abc{3}$/，只让c重复三次，即abccc） () 小括号：表示优先级 可以用来：/^(abc){3}$/，表示让abc重复三次，即abcabc 预定义类\\d 匹配到0-9任意一数字，相当于[0-9] (var rg = /\\d/;) \\D 匹配到0-9以外的数字，相当于[^0-9] \\w 匹配任意字母、数字、下划线，相当于[A-Za-z0-9_] \\W匹配除字母数字下划线以外的字符，相当于[^A-Za-z0-9_] \\s 匹配空格（包括换行符、制表符、空格符等），相当于[\\t\\r\\n\\v\\f] \\S匹配非空格字符，相当于[^\\t\\r\\n\\v\\f] 正则里的或者符号：| (var rg = /^\\d{3}-\\d{8}|\\d{4}-\\d{7}$/;) 正则替换replace()方法可以实现替换字符串的操作，用来替换的参数可以是一个字符串或者是一个字符表达式 stringObject.replace(regexp/substr, replacement) var str = 'red and blue and red'; var newstr = str.replace('red', 'yellow'); //结果为yellow and blue and red //var newstr = str.replace(/red/, 'yellow'); 同理 但是replace只能替换掉第一个匹配的字符/正则表达式，无法满足替换掉多个敏感词 可以使用: /表达式/[switch] swtich也成为修饰符，即按照什么样的模式来匹配 g: 全局匹配 i: 忽略大小写 gi: 全局匹配+忽略大小写 var str = 'red and blue and red'; var newstr = str.replace(/red/g, 'yellow'); //结果为yellow and blue and yellow","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JQuery","slug":"JQuery","date":"2020-11-29T16:15:30.028Z","updated":"2020-12-23T16:36:12.611Z","comments":true,"path":"2020/11/30/jquery/","link":"","permalink":"https://taylor12138.github.io/2020/11/30/jquery/","excerpt":"","text":"1.JQuery概述JavaScript库：即library，是一个封装好的特定集合（方法和函数），使得我们可以快速高效的使用这些封装好的功能，而jQuery 就是一个 JavaScript函数库 其他常见地js库还有Prototype、YUI、Dojo、ExtJS和移动端的zepto 优点： 1.轻量级，文件够小 2.跨浏览器兼容，基本兼容主流浏览器 3.链式编程、隐式迭代 4.对事件、样式、动画支持，极大地简化了dom的操作，支持插件扩展开发，有丰富的第三方插件 4.免费、开源 官网下载：https://jquery.com/ 最新版本早已不兼容ie6、7、8 等页面dom加载完毕再去执行代码（类似于DOMContentLoaded） //入口函数 $(function() { xxxx }) 要在页面引入官网下载的jQuery的js文件才能使用 2.jQuery的基本使用$是jquery的简称，一般在代码中用$替代jQuery $(function() { $(&#39;div&#39;).hide() }) 相当于 jQuery(function( jQuery(&#39;div&#39;).hide() ) {}) $是jQuery的顶级对象，相当于JavaScript的window，把元素$包装成jQuery对象，就可以调用jQuery方法 jQuery和dom用原生js获取的对象就是dom对象 用jQuery方式获取的对象就是jQuery对象 这两个对象是不一样的 jQuery对象的本质就是利用$对DOM对象包装后产生的对象（伪数组的形式储存） jQuery对象只能用jQuery方法，DOM对象则只能使用原生的JavaScript属性和方法 但是DOM对象和jQuery对象可以相互转换，因为原生js比jQuery更大，原生的一些属性和方法jQuery没有为我们进行封装，想要使用这些属性和方法需要把jQuery转换成DOM对象才能使用 //DOM转jQuery let myvideo = document.querySelector('video'); $(myvideo); //jQuery转DOM $('video')[index]或者$('video').get(index) $('video'); //获取元素 $('video')[0].play(); //将只有一个元素的视频过来并且使用DOM功能 3.jQuery的APIjQuery选择器$(&quot;选择器&quot;) 语法和CSS选择器一样即可 子代选择器 $(&quot;ul&gt;li&quot;) 后代选择器$(&quot;ul li&quot;) jQuery修改样式：$(&quot;div&quot;).css(&quot;属性&quot;, &quot;值&quot;) jQuery有隐式迭代，它会给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再循环，简化我们的操作 //一次性将所有选中的div元素背景颜色改为pink，不再需要for循环一个一个遍历更改 $(\"div\").css(\"background\", \"pink\"); jQuery筛选选择器 $(&quot;li:first&quot;) 选中第一个 $(&quot;li:last&quot;) 选中最后一个 $(&quot;li:eq(x)&quot;) 选中索引号为x的元素 $(&quot;li:odd&quot;) 选中索引号为奇数的元素 $(&quot;li:even&quot;) 选中索引号为偶数的元素 $(&quot;div&quot;).parent(); 返回的是最近一级的父元素 $(&quot;div&quot;).parents(); 返回的是所有祖先元素的数组，可以制定”()”里的类名单独指定是哪个祖先 $(&quot;div&quot;).children(&quot;ul&quot;); 返回指定的亲儿子，类似于子代选择器div&gt;ul $(&quot;div&quot;).find(&quot;li&quot;); 可以选定指定的所有孩子，类似于后代选择器 div li $(&quot;.item&quot;).sibling(&quot;li&quot;); 可以选定除本身外所有亲兄弟元素 $(&quot;li&quot;).eq(x); 选中索引号为x的元素, 类似$(&quot;li:eq(x)&quot;) ，但是此方法更推荐 $(&quot;li&quot;).hasCLass(&quot;类名&quot;); 查看是否有该类名，返回true或false jquery中的快速实现排他思想： $(function() { $(\"button\").click(function() { $(this).css(\"background\",\"pink\"); $(this).siblings(\"button\").css(\"background\", \"\") }) }) jQuery可以快速得到当前元素索引号，不再需要自己添加自定义属性index $(this).index() $(&quot;xxx:checked&quot;) 选择复选框中被选择的元素（$(&quot;xxx:checked&quot;).length为被选中复选框个数） jquery样式操作使用css方法： 1.参数只写属性名，返回属性值 $(this).css(&quot;color&quot;) 2.设置样式，属性名必须加引号，如果属性值值如果是数字可以不用跟单位和引号 $(this).css(&quot;color&quot;, &quot;red&quot;) 3.参数可以用对象的形式(里面的属性名不用加引号，如果如果属性值值如果是数字可以不用跟单位和引号) 如果是复合属性必须采取驼峰命名法（和DOM一样） $(this).css({ width: 400, height: 400, backgroundColor: \"green\" }) 直接设置类方式： 再写一个类，里面包含了所有你想要改变的样式，然后利用jQuery添加类功能，将其添加进去（注意直接添加类名，不需要 “.类名”） (原生js的className进行更改会覆盖原先的类名) // 1. 添加类 addClass() $(\"div\").click(function() { $(this).addClass(\"current\"); }); // 2. 删除类 removeClass() $(\"div\").click(function() { $(this).removeClass(\"current\"); }); // 3. 切换类 toggleClass() $(\"div\").click(function() { $(this).toggleClass(\"current\"); }); jQuery效果显示和隐藏效果 show([speed, [easing], [fn]]) 显示功能，参数可以省略， speed：三种预定字符串（”speed”,”normal”,”fast”）、或者使用毫秒数表示 easing：swing（在开头/结尾移动慢，在中间移动快）、linear（匀速） fn：回调函数 hide([speed, [easing], [fn]]) 隐藏功能，同上 toggle([speed, [easing], [fn]]) 切换（原本显示则隐藏，原本隐藏则显示） 滑动 slideDown([speed, [easing], [fn]]) 下拉显示，类似于手机官网那些下拉菜单，参数功能同上 slideUp([speed, [easing], [fn]]) 上拉隐藏，参数同上 slideToggle([speed, [easing], [fn]]) 拉动切换，参数同上 事件切换 hover([over],out) over: 鼠标移到元素上触发的函数（相当于mouseenter） out：鼠标移出元素触发的函数（类似于mouseleave） 简洁下拉菜单 $(\".nav>li\").hover(function() { $(this).children(\"ul\").slideDown(200); }, function() { $(this).children(\"ul\").slideUp(200); }); 或者 $(\".nav>li\").hover(function() { $(this).children(\"ul\").slideToggle(); }); 动画队列和其停止方法 上述下拉菜单代码有一个问题 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果的排队执行（即鼠标一次性经过多个选项，导致鼠标在一边停下来了之后，动画还在执行（因为还没执行完毕）） 停止排队： stop() stop()用于停止动画或者效果，将其写在动画或者效果的前面，相当于停止结束上一次的动画 //上述示例改进： $(\".nav>li\").hover(function() { $(this).children(\"ul\").stop().slideToggle(); }); 淡入淡出 fadeIn([speed, [easing], [fn]]) 淡入功能，参数可以省略， speed：三种预定字符串（”speed”,”normal”,”fast”）、或者使用毫秒数表示 easing：swing（在开头/结尾移动慢，在中间移动快）、linear（匀速） fn：回调函数 fadeOut([speed, [easing], [fn]]) 淡出 fadeToggle([speed, [easing], [fn]]) 淡入淡出切换 fadeTo([speed, opacity, [easing], [fn]]) 以渐进的方法修改透明度，opacity为透明度，必须写，取值范围0~1，speed也必须写 自定义动画animate animate(params, [speed], [easing], [fn]) params：想要更改的样式属性，以对象的形式传递，必须写，属性名可以不带引号，如果是复合属性需要采取驼峰命名法 其他的speed、easing、fn和之前相同 $(&quot;div&quot;).animate({ left: 500, top: 300, opacity: .4, width: 500 }, 500);4.jQuery属性操作element.prop(&quot;属性名&quot;) 获取属性值（固有的属性值） element.prop(&quot;属性名&quot;, &quot;属性值&quot;) 设置属性值 element.attr(&quot;属性名&quot;) 获取属性值（自定义属性），类似原生的getArribute element.attr(&quot;属性名&quot;, &quot;属性值&quot;) 设置属性值（自定义属性），类似原生的setArribute element.data(&quot;属性名&quot;, &quot;属性值&quot;) 设置数据缓存，data里的数据是存放在元素的内存中，而不是作为属性（这个方法可以获取data-index 即h5自带的自定义属性，不用写data-，写成$(“div”).data(“index”)） 5.jQuery内容文本值element.html() 获取元素内容（包含标签） 相当于原生的innerHTML element.html(&quot;内容&quot;) 设置元素内容 element.text() 获取元素内容（不包含标签） 相当于原生的innerText element.text(&quot;内容&quot;) 设置元素内容 element.val() 获取表单值 element.val(&quot;表单值&quot;) 设置表单值 6.jQuery的元素操作虽然jquery有隐式迭代，但是只是对同类元素做相同操作，如果想要给不同元素进行不同的操作，就需要使用到遍历 jQuery的遍历$(&quot;div&quot;).each(function (index, domEle) { xxxx; }) index（第一个参数）是每个元素的索引号，domELe（第二个参数）是遍历后的每个DOM元素对象，不是jQuery对象，如果想使用jQuery方法，需要给这个dom元素转换为jQuery对象（$(domEle)） $.each(object, function(index, element) { xxx; }) $.each() 方法可以用于遍历任何对象，主要用于数据处理，如数组、对象，index（第一个参数）为索引号（如果是对象，则为属性名），element（第二个参数）为遍历内容（如果是对象，则为属性值） 创建元素 $(&quot;&lt;li&gt;&lt;/li&gt;&quot;) 动态创建一个li标签 添加元素（创建完之后需要添加元素） 内部添加：（生成后它们是父子关系） element.append(&quot;内容&quot;) 放到匹配元素的最后面，类似于原生的appendChild element.prepend(&quot;内容&quot;) 放到匹配元素的最前，类似于原生的ul.insertBefore(xx, ul.children[0])(指定元素的前面) 外部添加：（生成后它们是兄弟关系） 外部添加：element.after(&quot;内容&quot;) 把内容放入目标元素的后面 element.before(&quot;内容&quot;) 把内容放入目标元素前面 删除元素element.remove() 删除匹配元素 element.empty() 删除匹配元素的所有子节点 element.html(&quot;&quot;) 清空匹配元素的内容（孩子） 7.jQuery事件事件注册element.事件(function() {}) 单个事件注册 如 $(&quot;div&quot;).click(function() {事件处理}) 其他事件和原生基本一致 事件处理on(可以绑定多个事件)on() 方法在匹配元素上绑定一个或多个事件的事件处理函数 element.on(events, [selector], fn) 1.events: 一个或多个用空格的事件类型，如”click” 2.selector: 元素的子元素选择器 3.fn：回调函数，即绑定在元素身上得到侦听函数 如 $(\"div\").on({ mouseenter: function() { //xxxxx }, click: function() { //xxxxx }, mouseleave: function() { //xxxx } }) 不同事件类型触发同一处理函数： $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() {}) on的优势2：可以进行事件委托如 //传统，但是给每个li都添加了一个事件，比较麻烦 $(\"ul li\").click(); //事件是绑定在ul身上，但是触发对象时li，li事件冒泡，冒泡到父级的点击事件然后执行程序 $(\"ul\").on(\"click\", \"li\", function() { }) 此前有blind()、live()等方法处理事件绑定或事件委托，但是我们最新版本用on就行了 on的优势3：动态创建元素，on可以给未来动态创建的元素绑定事件//传统，前面绑定事件，后面创建的标签没有绑定该事件 $(\"ol li\").click(function() {}) let li = $(\"&lt;li>xxx&lt;/li>\"); $(\"ol\").append(li); //使用on,之后创建的也能被给予绑定效果 $(\"ol\").on(\"click\", \"li\", function() {}) let li = $(\"&lt;li>xxx&lt;/li>\"); $(\"ol\").append(li); 事件off解绑off()方法可以移除通过on()方法添加的事件处理程序 element.off() 解绑该元素上所有事件 element.off(&quot;click&quot;) 解绑该元素上点击事件 $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() {}) $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;) 解除事件委托 只使用一次: 用one()来绑定有的事件只想触发一次，可以使用one来绑定 element.one(event, fn) 自动触发事件trigger比如click事件： 1.element.click() 2.element.trigger(&quot;click&quot;) 和上面的差不多 3.element.triggerHandler(&quot;click&quot;) triggerHandler不会触发元素默认行为（包括该元素绑定的其他行为），只触发”click” 事件对象element.on(events, [selector], function(event) {}) 中的event为事件对象 event.preventDefault() 或者return false 用于阻止默认行为 event.stopPropagation() 将其写于事件函数中，可以用于阻止冒泡 8.jQuery的其他方法jQuery拷贝对象$.extend([deep], target, object1, [objectN])（如果有冲突的，会覆盖掉targetObj 里面原来的数据） 1.deep: 如果为true为深拷贝，默认false为浅拷贝 （注意是复杂数据类型）浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝的对象，如果该复杂数据类型对象有冲突，直接覆盖掉 深拷贝，完全克隆，对于复杂数据类型拷贝的是对象，不是地址，修改目标对象不会影响被拷贝的对象（如果该复杂数据类型对象有冲突，但是里面的属性不冲突，则属性会合并在一起） //深拷贝时targetObject的msg会与obj的msg合并 //此时都有id，obj的id会覆盖掉targetObject的id var targetObject = { id: 0, msg: { sex: '男' //对象复杂数据类型 } }; var obj = { id: 1, name: 'andy', msg: { age: 18 } } $.extend(targetObject,obj); 2.target：要拷贝的目标对象 3.object1：待被拷贝到第一个对象的对象 （object拷贝给target） jQuery·多库共存随着jquery的流行，其他js库也会使用$作为标识符，这样一起使用会起冲突 需要一个解决方案，让jQuery和其他js库不存在冲突，可以同时存在，这就叫做多库共存 jquery解决方案： 1.把里面的$符号统一改为jQuery ，比如jQuery(“div”) 2.自定义，释放对$对控制权 var suibian = $.noConflict(); //var suibian = jQuery.noConflict(); suibian(\"span\") //原本是$(\"span\") jQuery插件jQuery功能比较有限，想要更加复杂的效果，可以借助jQuery插件（注：这些插件是依赖于jQuery，所以必须先引入jQuery文件，因此也成为jQuery插件） jquery常用网站： 1.jQuery插件库：http://www.jq22.com/ 2.jQuery之家：http://www.htmleaf.com/ (推荐) jQuery插件使用步骤：1.引入相关文件（jQuery、插件文件） 2.赋值相关html、css、js 图片懒加载: 在jQuery·插件可以找到，图片只加载到可视区域，减缓服务器压力 全屏滚动：jQuery的fullPage.js也十分好用 bootstrap也是依赖于jQuery开发的，因此里面的js插件使用，也必须引入jQuery文件 jQuery的位置位置主要有三个：offset()可设置、 position()只读、 scrollTop()/scollLeft()可设置 element.offset() 返回一个对象，里面包含left和top，用于设置或获取相对于文档document的偏移坐标 但是和原生不同的是，它可以设置偏移：element.offset({top: 10, left: 30})，且原生js的offset返回的是相对于父元素的偏移量 element.position() 获取带有相对于父级的偏移距离，如果没有定义父级，则以文档为准，但是此方法只能获取不能设置 element.scrollTop()/element.scrollLeft()设置或获取被卷去的头部和左侧，类似于原生js自带的元素滚动scroll","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"前端关于本地存储","slug":"前端关于本地存储","date":"2020-11-27T16:00:00.000Z","updated":"2020-11-28T09:59:17.045Z","comments":true,"path":"2020/11/28/qian-duan-guan-yu-ben-di-cun-chu/","link":"","permalink":"https://taylor12138.github.io/2020/11/28/qian-duan-guan-yu-ben-di-cun-chu/","excerpt":"","text":"本地存储1.数据存储于自己的浏览器当中 2.设置、读取十分方便，页面刷新数据不丢失 3.容量较大，sessionStorage约5M，localStorage约20M 4.只能存储字符串，可以将对象JSON.stringify() 编码后存储 window.sessionStorage1.生命周期为关闭浏览器窗口 2.同一个窗口下数据可以共享 3.以键值对的形式存储使用 window.sessionStorage.setItem(key, value) 分别对应键和值，设置（添加或更改） window.sessionStorage.getItem(&#39;key&#39;) 获取 window.sessionStorage.removeItem(&#39;key&#39;) 删除 window.sessionStorage.clear() 删除所有数据(慎用) window.localStorage1.生命周期永久生效，除非手动删除，不然关闭页面仍然存在 2.多窗口共享（同一浏览器才能共享） 3.以键值对的形式存储使用 window.localStorage.setItem(key, value) 分别对应键和值，设置（添加或更改） window.localStorage.getItem(&#39;key&#39;) 获取 window.localStorage.removeItem(&#39;key&#39;) 删除 window.localStorage.clear() 删除所有数据(慎用)","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"PC&移动端网页特效(JS)","slug":"PC&移动端网页特效(JS)","date":"2020-11-17T16:00:00.000Z","updated":"2020-12-18T16:52:23.114Z","comments":true,"path":"2020/11/18/pc-yi-dong-duan-wang-ye-te-xiao-js/","link":"","permalink":"https://taylor12138.github.io/2020/11/18/pc-yi-dong-duan-wang-ye-te-xiao-js/","excerpt":"","text":"PC端1.offset元素偏移量我们使用offset系列相关属性可以动态获取元素的位置（大小）（父亲要定位此功能才有用 element.offsetTop 返回元素相对带有定位父元素上方的偏移，不带单位，如果没有定位或者没有父元素则以body为准 element.offsetLeft 返回元素相对带有定位父元素左方的偏移，情况同上 element.offsetWidth 返回自身宽度大小，自身宽度+padding+border element.offsetHeight 返回自身高度大小，同上 element.offsetParent 返回带有定位的父亲，否则返回body（element.parentNode 直接返回最近一级的父节点，不管父节点是否有定位） offset和style的区别：offset可以得到任意样式表的样式值 style只能得到行内样式表的样式值 offset系列获得的数值没有带单位 style.width获得的是带单位的字符串 offsetWidth等是包含padding+border style.width获得不包含padding和border的值 offsetWidth等属性是只读属性，只能获取不能赋值 style.width是可读写属性，可以赋值 所以offset适合读值，style适合赋值改值 2.元素可视区client通过client系列的相关属性可以动态得到该元素的边框大小、元素大小等（与offset不同点是边框是否囊括其中） element.clientTop 返回元素上边框的大小 element.clientLeft 返回元素左边框的大小 element.clientWidth 返回自身包括padding、内容区的宽度，不包含边框，返回数值不带单位 element.clientHeight 同上，返回高度 （番外）立即执行函数立即执行函数，不需要调用，直接执行 传统： function fn() {} fn(); 立执： (function(a, b) {}(1, 2)) //第一种 (function(a, b) {})(参数1, 参数2) //第二种 立即执行函数最大的优点就是独立创建了一个作用域 3.元素滚动scroll获取或设置一个元素的内容垂直滚动的像素数 有点像client，但是client是盒子的大小宽高，即使内容溢出后保持不变，但是scroll面对溢出状态的盒子，它提供的宽高与内容溢出的宽高相互关联。 element.scrollHeigh 返回自身高度，不含边框，不带单位 element.scrollWidth 返回自身宽度，不含边框，不带单位 element.scrollTop 返回被滚动条卷上去的上方距离，返回数值不带单位（要有滚动条，且内容大于盒子，往下拉的时候才会有） element.scrollLeft 返回被滚动条卷左的左侧距离，同上 滚动条在滚动时发生的事件：onscroll事件 检测整个页面的滚动属性： window.pageYOffset window.pageXOffset等 (ie9以上才支持) 让窗口滚动事件：window.scroll(x, y) 三大系列总结：offset常用于获取元素位置 element.offsetTop element.offsetLeft 只读的 client常用于获取元素大小 element.clientWidth element.clientHeight 只读的 scroll常用于获取滚动距离 element.scrollTop element.scrollLeft 可设置 4.动画函数封装原理：获取盒子当前位置（position），通过定时器setinterval()不断移动盒子位置，利用定时器不断让盒子当前位置加上一个移动距离，最后加一个结束定时器条件（其实也可以用CSS animation 定义动画） &lt;div>&lt;/div> &lt;script> //简单动画函数封装obj目标函数，target目标位置 //给不同的元素制定了不同的定时器 //不过再js中尽量避免这一种“先创建再补充”的动态属性赋值 function animate(obj, target) { obj.timer = setInterval(function () { if (obj.offsetLeft >= target) { clearInterval(obj.timer); } else { obj.style.left = obj.offsetLeft + 5 + 'px'; } }, 30); } // 调用函数 let div = document.querySelector('div'); animate(div, 300); &lt;/script> 缓动动画：让元素运动速度有所变化 ，即让它每次移动的距离有所变化（如慢慢变小）就可以达到效果 比如可以：（目标值-现在位置）/10 作为每次移动的步长 停止条件：让盒子位置等于目标位置 动画函数添加回调函数：回调函数原理为函数作为一个参数，即将这个函数作为参数传到另一个函数里，当那个函数执行完毕之后，再执行传进去的这个函数，这个过程叫做回调 添加了一点细节和回调函数后的改进代码 //简单动画函数封装obj目标函数，target目标位置 //给不同的元素制定了不同的定时器 //不过再js中尽量避免这一种“先创建再补充”的动态属性赋值 function animate(obj, target, callback) { // 当我们不断点击按钮，元素速度会越来越快，因为开启了太多定时器 // 解决方案就是让我恩的元素只有一个定时器执行,清楚之前的定时器 clearInterval(obj.timer); obj.timer = setInterval(function () { // 把步长值改为整数，不要出现小数的问题 let step = (target - obj.offsetLeft) / 10; // 正值往小的取整，负值往大的取证, 保证数值刚好等于target（） step = step > 0 ? Math.ceil(step) : Math.floor(step); // 可以让800回到500，所以用== 而不是>= if (obj.offsetLeft == target) { clearInterval(obj.timer); // 如果有回调函数，在定时器结束时调用 /*if (callback) { callback(); }*/ //更棒写法 callback &amp;&amp; callback(); } else { obj.style.left = obj.offsetLeft + step + 'px'; } }, 30); } // 调用函数 let div = document.querySelector('div'); let btn500 = document.querySelector('.btn500'); let btn800 = document.querySelector('.btn800'); btn500.addEventListener('click', function () { animate(div, 500, function () { alert('hello') }); }) btn800.addEventListener('click', function () { animate(div, 800); }) 5.节流阀控制速度，用于类似于防止轮播图按钮连续点击，导致播放过快的后果 即当上一个函数动画内容执行完毕再去执行下一个函数动画，让事件无法连续触发 核心思路是：利用回调函数，添加变量进行控制。锁住函数和解锁函数 // 设置节流阀 let flag = true; arrow_r.addEventListener('click', function () { if (flag) { flag = false; fun(x, y, function () { flag = true; }); } }) 移动端移动端兼容性较好，我们不需要考虑以前js的兼容问题，可以放心使用原生的JS书写，但是移动端也有自己独特的地方，如touch事件等 1.touch事件响应用户手指对屏幕的操作 touchstart 手指触摸到一个dom元素 （像mousedown） touchmove 手指在一个dom元素上滑动 （像mousemove） touchend 手指从一个dom元素上移开 （像mouseup） div.addEventListener('touchstart', function() {}) 移动端拖动原理：盒子原来的位置+手指移动的距离 拖动三部曲：（手指移动会触发滚动屏幕，所以要在这里阻止的屏幕滚动e.preventDefault()） 触摸 touchstart 获取初始坐标 移动手指 touchmove 计算手指滑动距离，并且移动盒子 离开手指 touchend //div加了绝对定位 &lt;div>&lt;/div> &lt;script> let startX = 0; let startY = 0; let x = 0; let y = 0; let div = document.querySelector('div'); div.addEventListener('touchstart', function (e) { // 获取第一个触碰的坐标 startX = e.targetTouches[0].pageX; startY = e.targetTouches[0].pageY; // 获取盒子的位置 x = this.offsetLeft; y = this.offsetTop; }) div.addEventListener('touchmove', function (e) { // 计算手指移动的距离，手指移动后坐标-手指初始坐标 let moveX = e.targetTouches[0].pageX - startX; let moveY = e.targetTouches[0].pageY - startY; // 移动盒子 this.style.left = x + moveX + 'px'; this.style.top = y + moveY + 'px'; // 阻止屏幕滚动 e.preventDefault(); }) &lt;/script> 2.移动端常见特效transitionend 事件移动端兼容性较强，在js制作时可以穿插 transform:translate(x, y) 、transition 等， 对于transition ，此时需要用到 transitionend 事件 ，等待过渡完成之后，再去判断是否到达最后一张，监听过渡完成事件 classList 属性它是h5新增的属性，返回元素的类名（返回形式为数组，因为一个元素可能包含多个类），但是ie10以上才支持（移动端也支持） let div = document.querySelector('div'); //返回第一个类的类名 console.log(div.classList[0]); 添加类名, 是追加，不会覆盖以前的类名，注意xx前面不用加 ‘.’ element.classList.add(&#39;xx&#39;) 移除类名 element.classList.remove(&#39;xx&#39;) 切换类名（原来有，就给你删除掉，原来没有，就给你加上） element.classList.toggle(&#39;xx&#39;) 移动端click问题移动端click事件会有300ms的延迟，原因是移动端双击会缩放页面 解决方案1：禁用缩放功能 &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt; 在最顶端的视口标签处写下user-scalable=no 解决方案2：利用touch事件自己封装： 手指触屏记录触摸时间 手指离开屏幕，用离开时间减去触摸的时间，若时间小于150ms则没有滑动屏幕，定义为点击事件 解决方案3：使用fastclick插件 3.插件js插件就是js文件，它遵循一定规范进行编写，方便程序展示效果，拥有特定功能且方便调用，功能单一且文件小 插件的使用： 1.引入js文件 2.按照语法规范进行使用 比较常见的还有swiper插件（轮播图）、supersilide插件（无缝滚动等）、iscroll插件、视频插件等等 4.框架比如bootstrap，同样 来自于twitter，目前最受欢迎的前端框架(拿来主义) 中文官网：https://www.bootcss.com/ 官网：https://getbootstrap.com/ 2.x.x 已经停止维护，功能不够完善 3.x.x 目前使用最多，但已经放弃了ie6，ie7，对ie8支持但是界面效果不好，偏向于开发响应式布局，移动设备优先的web项目 4.x.x 最新版，但是目前不流行 根据官网的介绍引入js和结构即可使用","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"BOM","slug":"BOM","date":"2020-11-13T16:17:20.669Z","updated":"2020-12-19T05:47:52.774Z","comments":true,"path":"2020/11/14/bom/","link":"","permalink":"https://taylor12138.github.io/2020/11/14/bom/","excerpt":"","text":"1.BOM概述BOM是浏览器对象模型，他提供独立于内容而与浏览器窗口进行交互的对象，其核心对象是window BOM缺乏标准，Javascript语法的标准化组织是ECMA，DOM标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分，所以它的兼容性比较的差 BOM比DOM更大，它包含着DOM window对象是浏览器的顶级对象，它是JS浏览器的一个接口，是一个全局对象，定义在全局作用域的变量（var）、函数都会变成window对象的属性和方法（alert()、prompt() ），在调用的时候可以省略window 2.window对象常见事件（1）onload本来我们的内嵌式&lt;script&gt;&lt;/script&gt;只能放在所有标签标签下方 而window.onload可以解决，它是窗口加载事件，当文档内容完全加载以后才会触发该事件（包括图像、脚本、CSS），就调用该函数 &lt;script&gt; window.onload = function() { var btn = document.querySelector(&#39;button&#39;); btn.onclick = function() { } } &lt;/script&gt; &lt;button&gt;&lt;/button&gt;但是window.onlaod传统注册方式只能写一次，如果写多个，只以最后一个onload为准，所以推荐 window.addEventListener('load', function() {}) 所以一般情况下引入js文件，则该js文件都要添加 ↑ pageshow事件下面三种情况会触发load事件： 1.a标签的超链接 2.F5刷新（或者强制刷新） 3.前进或后退 但是在火狐中有个“往返缓存”，它不仅保留着页面数据，还保存着DOM和Javascript的状态，实际上将整个页面保存在内存里，导致后退按钮不能刷新页面（无法触发load事件） 所以此时可以用pageshow事件来触发，它有点像load，但是事件在页面显示时就会触发，无论页面是否来自缓存（注意这个事件是给window添加的） window.addEventListener(&#39;pageshow&#39;, fucntion(e){ //e.persisted返回的是true，就是说如果这个页面是从缓存取过来的页面，也需要重新计算一下rem if(e.persisted) { setRemUnit(); //这个函数是设置rem的 } })new : DOMContentLoaded当DOM加载完毕时触发，不包括样式表，图片，flash等，ie9以上支持，如果页面图片很多，onload的出发会比较久，用户体验不佳 ，此时DOMContentLoaded比较合适，执行顺序DOMContentLoaded &gt; onload document.addEventListener('DOMContentLoaded',function(){ }); （2）调整窗口大小只要窗口发生变化，就会触发这个事件 window.onresize = function() {} window.addEventListener(&#39;resize&#39;, function() {}) 响应式布局原理 &lt;div>&lt;/div> &lt;script> var div = document.querySelector('div'); window.addEventListener('resize', function() { if (window.innerWidth &lt;= 800) { div.stye.display = 'none'; } else { div.style.display = 'block'; } }) &lt;/script> （3）定时器window.setTimeout(调用函数, 延时时间) 这个window在调用时可以省略，延时时间单位是毫秒，默认省略为0 延时xx毫秒后，执行该函数，写函数名不加括号、不带参数 var a = setTimeout(function() {}, 1000); var b = setTimeout(callback, 1000); //callback为一个函数 页面中时常有很多定时器，我们经常给定时器加标识符（名字） setTimeout() 这个调用函数我们也称之为回调函数（需要等待时间，时间到了才去调用该函数） callback ，以前onclick之类的函数也是回调函数 停止定时器window.clearTimeout (timeoutID) timeID为定时器的名字（所以我们上方说明了经常要给定时器加名字），这里的window也可以省略，调用该停止定时器方法后，定时器的调用函数不执行，时间被停止了 setInterval() 定时器window.setInterval(回调函数, [间隔毫秒数]) 重复调用一个函数，每隔这个时间就去调用一次，写函数名函数不加括号、不带参数；window也可以省略，默认省略的话为0，同样我们也经常给该定时器加标识符（名字） 停止setInterval定时器window.clearInterval(intervalID) 同停止定时器 利用定时器自动调用事件例如调用在js中的某点击事件 // 自动播放轮播图 let timer = setInterval(function () { arrow_r.click(); }, 2000); }) （4）thisthis的指向在函数定义的时候是确定不了的，只有函数执行的时候才能知道this的指向，一般this最终指向调用它的对象 全局作用域或者普通函数中this指向window, 如 function Fn() { console(this); } Fn(); 方法调用中，谁调用this指向谁（xx = function() {}, 此时function中的this指向xx） 构造函数中this指向的是构造函数的实例对象，如 function Fun() { console.log(this); } var fun = new Fun(); （5）dpr 物理像素比pc端一般都是1，移动端比如iPhone6/7/8都是2，移动端不尽相同 var dpr = window.devicePixelRatio || 1 3.JS执行队列JS原先是单线程，也就是说同一时间只能做一件事，但是单线程就意味着，所有任务需要排队，钱一个任务结束后，才能执行下一个任务，如果JS执行时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞 为了解决这个问题，H5提出Web Worker标准，允许JS创建多个线程，于是JS出现了同步（单线程）和异步（现在的JS可以同时多个任务） 他们本质的区别是，这条流水线上各个流程执行的顺序不同 （1）同步和异步同步任务都放在一个主线程上执行，形成一个执行栈，按顺序执行 异步任务：JS的异步是通过回调函数实现的，一般而言，异步任务有以下三种类型 1.普通事件，如click、resize等 2.资源加载，如load、error等 3.定时器，如setTimeout、setInterval等 （2）执行机制1.先执行执行栈中的同步任务 2.异步任务（回调函数）放入任务队列中 3.一旦执行栈所有同步任务执行完毕，系统就会按次序读取任务队列的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 有异步任务交给异步进程处理，异步任务执行完毕后推入任务队列 当主线程执行完毕就来查询任务队列，取排在第一位的事件推入主线程处理，执行完再来取，不断循环，这个过程叫作事件循环 （实际上细分异步事件的优先级有宏任务和微任务，优先级：微任务&gt;宏任务） 4.location对象location是window对象提供给我们的一个属性，用于获取或设置窗体的URL，并且可以用于解析URL，返回的是一个对象 URL：统一资源定位符是互联网上标准资源的地址，互联网上每个文件都有唯一的URL，它包含的信息支持文件的位置以及浏览器该如何使用它（URL也就是我们的网址） 组成： protocol://host[:port]/path/[?query]#fragment protocol：通信协议，即http、ftp等 host：主机（域名） port：端口号，可选 path：路径，用 / 分隔 query：参数，以键对的形式，通过 &amp; 分隔 fragment：片段， # 后面内容，常见于链接锚点 location对象属性： location.href 获取或设置（实现页面跳转） 整个URL location.search 返回参数（即query部分 ） location.assign() 跟href一样，可以跳转页面，但是可以后退 location.replace() 同上，但是不能记录历史，不能实现后退功能 location.reload() 类似于F5刷新 （location.reload(true)为强制刷新，缓存一起没了） 还有host、port、pathname、hash（链接锚点）等 5.navigator对象navigator对象包含浏览器的信息，它可以知道你是用的是pc端浏览器还是移动端浏览器，有很多属性，最常用的是userAgent，该属性值返回又客户机发送服务器user-agent头部的值 &lt;script> if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href = \"../H5/index.html\"; //手机 } &lt;/script> 引入以上代码可以自动判断是进入了pc端浏览器还是移动端浏览器 6.history对象用于与浏览器历史记录进行交互（实际上和浏览器自带的页面后退，前进功能一样） 实际开发用的少，但是一些OA办公系统会用到 history.back() 后退功能 history.forward() 前进功能 history.go(参数) 前进后退功能，参数是1前进一个页面，-1后退一个页面","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"DOM","slug":"DOM","date":"2020-11-08T08:47:54.905Z","updated":"2020-12-13T09:35:09.517Z","comments":true,"path":"2020/11/08/dom/","link":"","permalink":"https://taylor12138.github.io/2020/11/08/dom/","excerpt":"","text":"DOM基础W3C已经定义了一系列的dom接口，可以改变网页内容、结构、样式 文档：一个页面就是一个文档，用document表示 元素：页面内的所有标签都是元素，用element表示 节点：网页中所有内容都是一个节点（注释，文本，属性等），用node表示 顶级对象是document 注意：因为文档是从上往下加载，所以script要写到文档标签的下面 （1）获取页面元素id获取（id是大小写敏感的字符串组成） &lt;div id=\"time\">2019&lt;/div> &lt;script> var timer = document.getElementById('time'); /*返回的是一个元素对象*/ console.dir(timer); /*dir是打印返回的元素对象，更好的查看里面的属性方法*/ &lt;/script> &lt;/body> 根据标签名获取 &lt;script> // 返回的是获取过来的元素对象的集合，（无论多少个）以伪数组的形式储存 var lis = document.getElementsByTagName('li'); console.log(lis); console.log(lis[0]); // 可以使用element.getElementsByTagName('标签名')获取，但是父元素必须是单个对象，不能是伪数组之类的 var oll = document.getElementsByTagName('ol'); console.log(oll[0].getElementsByTagName('li')); &lt;/script> H5新增获取元素方法，根据类名获取 document.getElementsByClassName(&#39;类名&#39;); H5新增的万能选择器，querySelector返回选择器的第一个元素对象，切记里面选择器需要加符号 querySelectorAll 返回指定选择器的所有对象集合 // 选择类名 var firstbox = document.querySelector('.box'); // 选择id var secondbox = document.querySelector('#nav'); // 选择标签名 var thirdbox = document.querySelector('li'); //选择全部 var fourth = document.querySelectorAll('li'); 多重嵌套进行选择 var firstbox = document.querySelector('.box').document.quertSelector(li); 获取body标签和html标签比较简单特殊 //获取html var htmlEle = document.documentElement; // 获取body元素 var bodyEle = document.body; （2）事件基础事件是可以被js侦测到的行为，触发–响应机制 事件由三部分组成：事件源（被触发对象） 事件类型（触发类型） 事件处理程序 一个简单的事件例子： &lt;button id=\"btn\">哈哈哈&lt;/button> &lt;script> var btn = document.getElementById('btn'); btn.onclick = function() { alert('哈哈哈'); } &lt;/script> （3）操作元素我们可以利用dom操作元素来改变元素里面的内容 element.innnerText 从起始位置到终止位置的内容，但它除去html标签，空格换行也会去掉（非标准） element.innerHTML 从起始位置到终止位置的内容，保留（识别）html标签和空格，换行（W3C标准） 同时，这两个标签是可读写的，可以获取元素里面的内容 btn.onclick = function() { div.innerText = '2020'; /*点击后修改它的文字*/ img.src = 'xxxx'; /*改变图片的src*/ img.title = 'xxxx'; /*改变图片的文字提示*/ input.value = 'xxx' /*改变表单的值*/ this.disabled = true; /*点击后此按钮后，此按钮被禁用，this指向的是事件函数的调用者*/ } p.innerText = 'pp'; /*刷新页面直接修改它的文字*/ console.log(p.innerText); 修改样式（通过JS修改后，变成行内样式，权重比较高） div.onclick = function() { //1.样式比较少的话使用此方法 //采用驼峰命名，原来的 background-color -> backgroundColor this.style.backgroundColor = 'purple'; //2.另一个方法就是再写一个类，里面包含了所有你想要改变的样式，但是注意，它会覆盖原先的类名 this.className = '样式名'; //3.保留原先得类 this.className = '原先样式名 新样式名' } 表单的获取焦点 var text = document.querySelector('input'); text.onfocus = function () { //获得焦点 if (this.value) { this.value = ''; } this.style.color = '#333' } text.onblur = function () { //失去焦点 if (this.value === '') { this.value = '手机'; } this.style.color = '#999' } 表单经过事件（类似于“ :hover ”） // 1.获取元素 获取的是 tbody 里面所有的行 var trs = document.querySelector('tbody').querySelectorAll('tr'); // 2. 利用循环绑定注册事件 for (var i = 0; i &lt; trs.length; i++) { // 3. 鼠标经过事件 onmouseover trs[i].onmouseover = function() { this.className = 'bg'; } // 4. 鼠标离开事件 onmouseout trs[i].onmouseout = function() { this.className = ''; } } 全选框小案例： // 获取元素 var Btn_All = document.getElementById('Btn_All'); // 全选按钮 var Btns = document.getElementById('Btns').getElementsByTagName('input'); // 下面所有的复选框 //1.让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可 Btn_All.onclick = function () { for (var i = 0; i &lt; Btns.length; i++) { Btns[i].checked = this.checked; } } // 2. 每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。 for (var i = 0; i &lt; Btns.length; i++) { Btns[i].onclick = function () { var flag = true; for (var i = 0; i &lt; Btns.length; i++) { if (!Btns[i].checked) { flag = false; break; } } Btn_All.checked = flag; } } （4）自定义属性js的两种元素属性获取方法： element.属性获取属性 element.getArribute(&#39;属性&#39;)也是获取属性，不过这个可以获取自定义属性 自定义属性：&lt;div id=&quot;demo&quot; index=&quot;1&quot;&gt;&lt;/div&gt; 中的index 设定属性值： element.属性 = 值 设置内置属性 element.setArribute(&#39;属性&#39;,&#39;值&#39;) 同上，主要设置自定义属性，它的class比较特殊，不使用className，使用class，如 div.setAttribute(‘class’, ‘footer’); 移除属性：element.removeAttribute(&#39;属性名&#39;) Hs规范：H5规定自定义属性以“data-”作为开头，并且赋值，比如 &lt;div data-index=&quot;1&quot;&gt;&lt;/div&gt; H5新增获取自定义属性的方法：div.dataset.index（属性名为data-index）， div.dataset.listName(属性名为data-list-name) ，dataset是一个集合里面存放了所有以data开头的自定义属性 （5）节点操作dom提供的获取元素方法比较繁琐，利用节点父子兄弟关系获取元素比较方便，但是兼容性差 一般的，节点至少拥有节点类型（nodeType）、节点名称（nodeName）、节点值（nodeValue） 元素节点 nodeType = 1 节点操作一般都是操作元素节点 属性节点 nodeType = 2 文本节点 nodeType = 3 父亲节点： node.parentNode (得到的是离元素最近的父节点，找不到父节点返回空值) 孩子节点： parentNode.childNodes 返回包含节点的子节点的集合，包含元素节点，文本节点等等，该集合为及时更新的集合，若只想获取元素节点：(因为繁琐，所以实际开发不提倡使用childNodes) var ul = document.querySelect(&#39;ul&#39;); for (var i = 0; i &lt; ul.childNodes.length; i++) { if(ul.childNodes[i].nodeType == 1) { console.log(lu.childNodes[i]); } }(new) 孩子节点： parentNode.children 返回所有子元素节点 （常用） parentNode.firsElementtChild 返回第一个元素子节点，找不到返回null parentNode.lastChild 返回最后一个元素子节点，找不到返回null 这两个方法有兼容问题ie9以上才能使用 所以推荐写法： parentNode.children[0] parentNode.children[parentNode.children.lenth-1] 下一个兄弟元素节点：node.nextElementSibling 找不到返回null 上一个兄弟元素节点：node.previousElementSibling 找不到返回null 这两个方法有兼容问题ie9以上才能使用 创建节点 document.createElement(&#39;targetName&#39;) 动态创建节点 添加节点 node.appendChild(child) 创建完后需要添加节点，此方法是将一个节点添加到指定父节点的子节点列表末尾，类似于CSS中的after伪元素 ,child写名称不用加 ‘ ’（不支持追加字符串子元素） or： node.insertBefore(child, 指定元素（子节点）) 将一个节点添加到父节点指定的子节点前面 var li = document.createElement('li'); var ul = document.querySelector('ul'); ul.appendChild(li); var li_2 = document.createElement('li'); ul.insertBefore(li_2, ul.children[0]); /*添加至开头*/ 发表评论案例： &lt;textarea name=\"\" id=\"\">&lt;/textarea> &lt;button>发布&lt;/button> &lt;ul>&lt;/ul> &lt;script> var btn = document.querySelector('button'); var text = document.querySelector('textarea'); var ul = document.querySelector('ul'); btn.onclick = function() { if (text.value == '') { alert('您没有输入内容'); return false; } else { var li = document.createElement('li'); //并且添加删除功能 li.innerHTML = text.value + \"&lt;a href='javascript:;'>删除&lt;/a>\"; //javascript:;意思是页面不发生跳转 ul.insertBefore(li, ul.children[0]); //删除元素 var as = document.querySelectorAll('a'); for(var i = 0; i &lt; as.length; i++) { as[i].onclick = funciton() { ul.removeChild(this.parentNode) } } } } &lt;/script> 删除节点：node.removeChild(child) 返回删除的节点 node.remove() 返回删除的节点（）删除本身 复制节点： node.cloneNode() 克隆完节点之后，和创建节点一样也必须要添加节点才能显示出来 1.如果括号参数为空，是浅拷贝，只克隆该节点本身，不克隆其子节点，即没有任何内容 node.cloneNode(true) 深拷贝 复制标签并且复制里面的内容 （6）创建标签的四种方法：1.element.write() 写入内容（标签），但是页面文档流加载完毕，再调用会导致页面重绘，不好用 2.element.innerHTML 从起始位置到终止位置的内容，保留（识别）html标签和空格，换行（W3C标准） 同时，这两个标签是可读写的，可以获取元素里面的内容 3.document.createElement(&#39;targetName&#39;) 动态创建节点 document.createElement(&#39;targetName&#39;)对比使用element.innerHTML 写多个标签会更省时，省空间，因为他创建多个标签时不用开辟新的空间，而innerHTML使用拼接的原理，所以每次都要要开辟新的空间 但是，如果element.innerHTML 不用拼接字符串的方法来实现创建多个标签，而是采用数组的形式拼接，结构写麻烦一点： var arr[]; for(var i = 0; i &lt; 100; i++) { arr.push('&lt;a href=\"#\">百度&lt;/a>'); } //以''进行拼接，并且转化为字符串 xx.innerHTML = arr.join(''); 执行起来会比 document.createElement(&#39;targetName&#39;) 更快，但是结构不太清晰 element.insertAdjacentHTML(插入的位置, 插入的字符串)可以直接把字符串格式元素添加到父元素中 (如：&quot;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&quot;) 插入位置：beforebegin 元素自身前面 afterbegin 插入元素内部第一个子节点之前 ​ beforeend 插入元素内部的最后一个子节点之后 afterend 元素自身的后面 （注意：appendChild不支持追加字符串子元素，insertAdjacentHTML支持追加字符串子元素） 事件部分1.注册事件传统方式： btn.onclick = function() {} 注册事件唯一性，最后注册处理的函数会覆盖掉前面注册处理的函数，即一个元素只能设置一个处理函数 w3c标准的推荐方式：（ie9以前不支持此方法） eventTarget.addEventListener(type, listerner[, useCapture]) （ie9以前使用的是eventTarget.attachEvent(type, listener[, useCapture]);） type：事件类型，如click，mouseover，不带on listener：事件处理，事件发生时会调用其监听函数 useCapture：可选参数，默认false btn.addEventListener('click', function() { //必须要字符串 alert(xxx); }) btn.addEventListener('click', function() { //必须要字符串 alert(yyy); }) 同一个元素同一个事件可以添加多个监听器，不会覆盖掉 2.解绑事件传统方式： eventTarget.onclick = null 如 div.onclick = function() {alert(); div.onclick = null;} 在点击一次之后删除该事件 方法监听方式：eventTarget.removeEventListener(type, listener[, useCapture]); （ie9以前使用的是eventTarget.detach(type, listener[, useCapture]);） 方法监听方式来解绑事件不能用匿名函数的方法，即 var fun=function(){} 所以使用以下策略 div.addEventListener('click', fn); function fn() { alert(xx); div.removeEventListener('click', fn); } 使得目标div在点击一次之后解绑事件 3.dom事件流事件发生时会在元素节点之间按照特定的顺序传播（document-&gt;Element gtml-&gt;Element body-&gt;Element div），这个传播过程即DOM事件流 DOM事件流分为三个阶段 ： 1.捕获阶段（从大往小传播，从最顶层开始，然后逐级向下传播到具体元素接收的过程） 2.当前目标阶段 3.冒泡阶段（从小到大，从里到外的传播，由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程） 注意：JS代码只能执行捕获或者冒泡其中一个阶段； 传统注册时间方式（onclick、attachEvent）只能得到冒泡阶段，而eventTarget.addEventListener(type, listerner[, useCapture])第三个参数如果是true，则在事件捕获阶段调用程序，如果是false（默认），则在冒泡阶段调用事件 如下代码，son包含于father内，使用捕获阶段（true），则点击son后先执行father再执行son，冒泡阶段则相反 &lt;div class=\"father\"> &lt;div class=\"son\">son盒子&lt;/div> &lt;/div> &lt;script> var son = document.querySelector('.son'); son.addEventListener('click', function() { alert('son'); }, true); var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, true); &lt;/script> 但是实际开发中我们更关注的是冒泡，且有些事件是没有冒泡的，如onblur，onfocus，onmouseenter，onmouseleave 4.事件对象div.addEventListener(&#39;click&#39;, funciton(event){} ) 中的event为事件对象，写到我们监听函数的小括号里，当形参看 事件对象只有有了事件才会存在，它是系统自动为我们创建的，不需要我们传递参数 事件对象是我们事件一些列相关数据的集合 事件对象也有兼容性问题，比如ie6、7、8，通过window.event获取 常见事件对象属性（对低版本浏览器有兼容性问题）： div.addEventListener('click', function(e) { console.log(e.target); console.log(this); /*两者有些许相似，但是e.target返回的是触发事件得元素，this返回的是绑定事件的对象（元素）*/ console.log(e.type); //返回事件类型 e.preventDefault(); //阻止默认事件，让它成为一个普通盒子，比如让链接不跳转，让input不提交等 e.stopPropagation(); //阻止事件冒泡，使得触发子事件后，不会相应触发父事件，不会向外传播 }) ie6\\7\\8 div.onclick = function() { console.log(e.srcElement); //返回的是触发事件得元素 e.returnValue; // 阻止默认事件 /*我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式*/ return false; window.e.cancelBubble = true; //阻止冒泡 } 5.事件委托事件委托也称为事件代理，再JQuery称为事件委派，它提高了程序性能 若多个子节点同时有事件，不需要将每个子结点单独设置事件监听器，而是将事件监听器设置在父节点上，然后利用冒泡原理影响每个子节点，使得每个子节点反馈到父节点，触发父节点的事件 6.常用的鼠标事件鼠标右键菜单： contextmenu 鼠标选中：selectstart dblclick 鼠标双击事件 mousedown 鼠标按下 mousemove 鼠标移动 ，mousemove是鼠标指针在元素内部移动式重复触发的事件，可用于鼠标指针定位实时变化的案例 mouseup 鼠标松开 mouseover 鼠标经过， 类似于“ :hover ” 它不仅经过自身盒子会触发，经过子盒子还会再触发一次 mouseenter 鼠标移动到元素上，只会经过自身盒子才触发一次，之所以会这样，是因为mouseenter不会冒泡 mouseleave 鼠标离开元素，和mouseenter相互搭配，同样不会冒泡 //禁用鼠标右键 document.addEventListener('contextmenu', function(e) { e.preventDefault(); }) //禁止选中文字 document.addEventListener('selectstart', function(e) { e.preventDefault(); }) （e代表事件对象） e.clientX 返回鼠标对于浏览器窗口可视区域的X坐标 e.clientY 返回鼠标对于浏览器窗口可视区域的Y坐标 e.pageX 返回鼠标相对于文档页面的X坐标，ie9+支持 e.pageY 返回鼠标相对于文档页面的Y坐标，ie9+支持 e.screenX 返回鼠标相对于电脑屏幕的X轴坐标 e.screenY 返回鼠标相对于电脑屏幕的Y轴坐标 pink老师天使跟随鼠标案例 &lt;style> img { position: absolute; } &lt;/style> &lt;body> &lt;img src=\"images/angel.gif\" alt=\"\"> &lt;script> var pic = document.querySelector('img'); document.addEventListener('mousemove', function(e) { /*核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的top和left 值就可以移动图片*/ var x = e.pageX; var y = e.pageY; //千万不要忘记给left 和top 添加px 单位 pic.style.left = x - 50 + 'px'; pic.style.top = y - 40 + 'px'; }); &lt;/script> &lt;/body> 7.常用键盘事件onkeyup 某个按键松开时被触发 （松开瞬间） onkeydown 某个按键被按下时被触发 （按下瞬间） onkeypress 同onkeydown 但是它不识别功能键如ctrl shift等 执行顺序down&gt;press&gt;up 使用addEventListener不需要加on keyon和keydown不能区分大小写 keyon和keydown不能区分大小写 （a和A得到的ASCII码值得到的都是65） 键盘事件 （e代表事件对象） e.keyCode 返回该键ASCII码值 注意（）：keydown 和 keypress 在文本框（input）比较特殊，当它们两个事件触发的时候，文字还没落入文本框中 而keyup事件触发的时候，文字已经落入文本框， 8.input事件onchange 事件会在域的内容改变时发生。 onchange 事件也可用于单选框与复选框改变后触发的事件。 比如复选框发生改变（单击鼠标切换“打勾”/“不打勾”状态） onfocus 获得焦点事件 onblur 失去焦点事件 input.select() 让文本框里的文字处于选定状态 remember.addEventListener('change', function () { // 勾选上 if (this.checked) { localStorage.setItem('username', username.value); } else { localStorage.removeItem('username') } })","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"移动Web开发及其常见布局(CSS)","slug":"移动Web开发及其常见布局(CSS)","date":"2020-10-01T16:00:00.000Z","updated":"2020-10-30T16:27:31.275Z","comments":true,"path":"2020/10/02/yi-dong-web-kai-fa-ji-qi-chang-jian-bu-ju-css/","link":"","permalink":"https://taylor12138.github.io/2020/10/02/yi-dong-web-kai-fa-ji-qi-chang-jian-bu-ju-css/","excerpt":"","text":"兼容移动端主流浏览器，处理Webkit内核浏览器即可 1.视口视口分类视口可以分为布局视口，视觉视口和理想视口 布局视口：一般移动设备浏览器都默认设置一个布局视口（980px），用于早期PC端页面在手机上显示的问题 缺点：使得元素看上去很小，字体小 视觉视口：用户正在看的网站区域，我们可以通过缩放操作视觉视口，但是不影响布局视口 理想视口：设定最理想的浏览和阅读宽度，与要手动添加meta视口标签通知浏览器（乔布斯发明） &lt;meta name=\"viewport\" content=\"width-device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"> content=”width-device-width 适应窗口大小 user-scalable=no 不允许用户缩放 maximum-scale=1.0 初始的最小缩放比 minimum-scale=1.0 初始的最大缩放比 2.二倍图在移动端，1px=一个物理像素，但是移动端不尽相同 移动端有物理像素比，可从px转化移动端时，（开发尺寸）px × 物理像素比 = 移动端显示的像素 此做法可以使得在移动端上显示更加高清 背景缩放background-sizebackground-size用于规定背景尺寸 /*现有background: 才能设置*/ background-size: 图片宽度,图片高度; /*可以px，可以百分比（相对于父盒子）*/ background-size: cover; /*完全盖住盒子，可能图片显示不全*/ background-size: contain; /*宽高完全适应父盒子，父盒子可能有空白区域*/ 切图时可以用ps里的cutterman多倍切图 精灵图缩放1.使用工具（如firework）把精灵图缩放为原来的一半 2.根据大小测量坐标 3.注意代码里面的background-size也要写：精灵图原来的一半 （原图进行修改查看， 但是不要保存） （或者直接上，用chrome调试就行了） background-size: 宽度（原来的大小/倍数） 高度auto 3.移动端开发的选择1.单独移动端页面（主流）：京东、淘宝 pc和手机打开后显示的网页布局不同 2.响应式页面兼容移动端：三星官网 响应屏幕宽度，制作麻烦，需要大量调整兼容性 CSS的初始化推荐使用 normalize.css CSS3盒子模型传统盒子计算方式：CSS设置的width+border+padding CSS3盒子模型：盒子宽度=CSS设置的宽度width包含了border+padding 设置方式：(CSS高级部分讲过，但是使用此方法后文字使用line-heigh居中会有所影响,原因是我们要对其的是盒子内部中间的位置，即去除掉边框的高度的中间位置，但是line-heigh会把所有方框所有高度算进去) box-sizing:border-box; 移动端链接清除高亮移动端点击完链接 &lt;a&gt; 会出现高亮 ，清除高亮可用 -webkit-tap-highlight-color:transparent; 移动端链接清除外观效果在移动端浏览器默认的外观上在ios上加上这个属性才能给按钮和输入框自定义样式（清除原来的样式） -webkit-appearance: none; 禁用长安页面弹出菜单img, a {-webkit-touch-callout: none; } 4.移动端常见布局不需要像pc端一样排列版心 单独移动端页面（主流）：流式布局（百分比布局）（京东）、flex弹性布局（新闻网，强烈推荐）、less+rem+媒体查询布局（苏宁）、混合布局 流式布局也就是百分比布局，非固定像素布局，可自由伸缩 为了保护屏幕不被拉过宽（缩过窄），导致里面的元素显示出现问题，设置最大最小宽度 max-width: xxpx; min-width: xxpx; flex布局传统布局：兼容性好，布局繁琐，有一定局限 flex布局：操作方便，pc端浏览器支持差，IE11或者更低版本不支持或仅部分支持 flex可以让原本span（无法设置宽高）成功使用宽高属性，即不需要浮动，更不用清除浮动 （1）flex原理flex是flexible box的缩写，意为弹性布局，任何一个容器都可以指定为flex布局（谁都可以用，除了IE） 父盒子设置为flex后，子元素的float、clear、vertical属性都失效 采用flex布局的元素称为flex容器，他的所有子元素自动成为容器成员，称为flex项目，即它是通过给父盒子添加flex属性，来控制子盒子的位置和排列 （2）flex常见父项属性默认主轴方向是x轴，水平向右 侧轴方向是y轴 水平向下，我们的元素是跟着主轴排列地 flex-direction 设置主轴方向，剩下那个就自动变成侧轴 1.默认值row从左到右 2.row-reverse从右到左 3.column从上到下 4.column-reverse从下到上 justify-content 设置主轴上子元素的排列方式 1.flex-start默认 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.space-around平分剩余空间 5.space-between先两边贴边，再平分剩余空间 flex-wrap 设置子元素是否换行 默认不换行，装不开会缩小子元素的宽度，自动适应 wrap：换行 align-content 设置侧轴上的子元素的排列方式（多行）（即有换行情况）（单行情况下没用） 1.flex-start 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.stretch拉伸，默认 5.space-around平分剩余空间 6.space-between先两边贴边，再平分剩余空间 align-items 设置侧轴上的子元素的排列方式（单行） 1.flex-start 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.stretch拉伸，默认，但是子盒子不要带高度 flex-flow 复合属性，相当于同时设置flex-direction和flex-wrap flex-flow: column wrap; （3）flex常见子项属性flex属性，定义子项目分配剩余空间，用flex表示占有份数 flex: number;/*默认为0*/ 如果是flex：1的话，则将改行剩余空间全部划分给该子元素，不用设置宽高，且类似于百分比流式布局，可以根据窗口大小调节剩余空间大小 如果该行没有设置任何子元素在该行（假设当前主轴为x轴），然后将三个子元素设置flex：1，则每个盒子占33.33%的宽度（即设置该盒子的主轴长度） A设置flex:2 ， B设置flex:1 则A占比2/3，B占比1/3 (其实可以写百分比 即flex: 20%, 相对父级来说) align-self，控制子项自己在侧轴上的排列方式。 它允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items属性，默认值为auto，表示继承align-items的属性 span:nth-child(3) { align-self: flex-end; /*只让第三个盒子在侧轴上从尾部开始排列*/ } oder定义项目的排列顺序，数值越小，排名越靠前，注意，和z-index不一样（定位属性） span:nth-child(2) { order:-1; /*让2号盒子跑到1号盒子前面，因为默认是0，0&lt;1*/ } Rem适配布局（1）rem基础rem是一个单位（root em），是一个相对单位，类似于em，em是父元素的字体大小，如父元素的font-size为12px，子元素设置宽高为10em，则大小实际为10*12=120px；而不同的地方在于rem是相对于html元素的字体大小，rem的优点是可以通过修改html的文字大小来改变页面中的元素大小 （2）媒体查询媒体查询是CSS3的新语法，使用@media可以针对不同屏幕尺寸设置不同的屏幕样式 /*用@media开头，mediatype是媒体类型，关键字and、not、only，media feature是媒体特性，要用小括号包含*/ @media mediatype and|not|only (media feature) { CSS-Code; } mediatype查询类型： all 用于所有设备 print 用于打印机和打印预览 screen用于电脑屏幕，智能手机 媒体特性：暂且先了解三个 1.width 定义输出设备页面可见区域的宽度 2.min-width 定义输出设备页面最小可见区域宽度 3.max-width 定义输出设备页面最大可见区域宽度 @media screen and (max-width: 800px) and (min-width: 540px) { /*在屏幕上且最大宽度为800px且最小宽度为540px则设置该样式*/ body { background-color: pink; } } 当样式改变比较多的时候（如三星官网首页根据页面不同大小的变化样式的改变），可以针对不同的媒体使用不同的stylesheets（样式表）原理，直接在link中判断设备的尺寸，引用不同的CSS文件 &lt;link rel=\"stylesheet\" href=\"style320.css\" media=\"screen and (min-width: 320px)\"> 媒体查询最好的方法是从小到大 less基础CSS的冗余度比较高，需要书写大量看似没有逻辑的代码，不方便维护，且无计算能力 而Less是CSS的拓展语言，也成为CSS预处理器（常见的CSS预处理器：Less、Sass、Stylus），可以计算（运算符的左右两侧必须加一个空格， 两个数参与运算，如果只有一个数有单位，最后结果以这个单位为准 两个数参与运算，如果两个数都有单位，以前面那个数字单位为准） Less的文件后缀名：.less （1）less变量@color: pink; /*@变量名:值;*/ @font: 14px; 使用： background-color: @color ; （2）less的编译需要把less编译成CSS才能放入H5使用 在VScode中安装easy-less插件，less文件保存后一键生成CSS文件 （3）less镶套在less不需要再 .header a {} 去选择后代选择器(再见) 可以直接： .header { width: 100px; a { color: red; } } 伪类选择器： .nav { &amp;:hover { color: blue; } &amp;::before { content: \"\"; } } 在一个less中可以引入另外一个less（套娃） @import \"common\"; /*导入conmon.less*/ rem的实际适配1.按照设计稿与设备宽度比例，动态计算并设置html根标签font-size大小（屏幕宽度/划分的份数=font-size的大小）（划分份数有15、20、10都有可能，苏宁移动端网页是15） 2.CSS中，设计稿元素宽、高、相对位置等取值，按照同等比例换算为rem rem适配方案一：less 媒体查询 rem 适配方案二：flexible.js rem (推荐) 适配方案二：rem适配之flexible.js再也不用太过繁琐的写下多个媒体查询，使用js做了处理 它的原理是把当前设备自动划分为10等份 会根据屏幕自动修改文字大小 github下载地址：https://github.com/amfe/lib-flexible 但是需要加一个限定弥补不足： /* 如果屏幕超过了750px, 那么我们按照750的设计稿走，不让我们的页面超过750px*/ @media screen and (min-width: 750px) { html { font-size: 75px!important; /*提权重*/ } }适配方案（add）：Vscode px转换rem插件cssrem（堪称外挂），及其好用 可以使得px直接转换rem 该插件默认的html字体大小为16px（根据当前页面大小（正常大小状态）/划分份数=得到我们应该设置的字体大小）,需要在设置里更改setting.json里的&quot;cssrem.rootFontSize&quot;: 16才可以 响应式布局其原理就是根据媒体查询对不同宽度设备进行布局和样式设置，从而适配不同设备的目的 小屏幕（手机）&lt;768px 小屏设备（平板） &gt;=768px~&lt;992px 中等屏幕（桌面显示器）&gt;=992px~&lt;1200px 宽屏设备（大桌面显示器）&gt;=1200px @media screen and (max-width: 767px) { .container { width: 100%; } } @media screen and (min-width: 768px) { .container { width: 750px; } } @media screen and (min-width: 992x) { .container { width: 970px; } } @media screen and (min-width: 1200px) { .container { width: 1170px; } } (1)Bootstrap前端开发框架来自于twitter，目前最受欢迎的前端框架(拿来主义) 中文官网：https://www.bootcss.com/ 官网：https://getbootstrap.com/ 2.x.x 已经停止维护，功能不够完善 3.x.x 目前使用最多，但已经放弃了ie6，ie7，对ie8支持但是界面效果不好，偏向于开发响应式布局，移动设备优先的web项目 4.x.x 最新版，但是目前不流行 样式库的使用：1.创建文件夹结构（复制bootstrap的文件夹）-&gt; 2.创建html骨架结构（在bootstrap中文文档官网中找到bootstrap入门-基础模板）-&gt; 3. 引入相关样式文件 -&gt; 使用 (2)Bootstrap的布局容器bootstrap需要为页面内容和栅格系统包裹一个.container容器，Bootstrap预先定义好了这个类 .container已经定义好了响应式布局，如@media screen and (max-width: 767px)之类的 而.container-fluid类定义了流式布局（百分比布局） (3）Bootstrap的栅格系统亦称为网络系统，它指页面布局划分为等宽的列，通过样式定义来模块化页面布局（rem是把整个屏幕划分多个等份，这个是页面内容），bootstrap自动拓展到最多12等份 bootstrap里面的CSS已经包含了normalize.css即关于网页初始化的内容，所以不用再引入normalize.css进行初始化 栅格系统用于通过一系列的行row和列coloum的组合来创建页面布局 （行缩小到一定程度，模块进入下一个列）,实现列的平均划分，需要给列添加类前缀（添加类名），分别对应着响应式布局上面定义的四种媒体查询代码 超小屏幕列前缀.col-xs-小屏设备列前缀.col-sm-中等屏幕列前缀.col-md-宽屏幕列前缀.col-lg-有12份，让其占4分之一，即3份,所有盒子总和没达到12，则占不满，超过12，则另起一行（像浮动）.col-lg-3 大屏幕占4分之一，即3份，中等屏幕占3分之一，即4份，小屏幕占2分之一，即6份 .col-lg-3 col-md-4 col-sm-6 每一列的盒子里有默认左右15px的padding Bootstrap的列嵌套：父盒子会产生一个padding值，使得子盒子划分的时候没有按照父盒子的宽高划分，而是按照父盒子的宽高-padding值划分，所以在嵌套的时候最好加多一个盒子进行包装，并且此时子盒子和父级一样高： &lt;div class=\"col-md-4\"> &lt;div> &lt;div class=\"col-md-6\">&lt;/div> &lt;div class=\"col-md-6\">&lt;/div> &lt;/div> &lt;/div> &lt;div class=\"col-md-4\">&lt;/div> &lt;div class=\"col-md-4\">&lt;/div> &lt;div class=&quot;col-mid-4 col-md-offset-4&quot;&gt;&lt;/div&gt;的offset功能，在中间增加了4份的空格（1/3），实现每个盒子不必紧密相连的模型格式，其实可以把offset当成空盒子来看待 &lt;div class=&quot;col-md-4 colmd-push-8&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;col-md-4 colmd-pull-4&quot;&gt;右侧&lt;/div&gt;可以实现左右盒子颠倒的状态（做盒子推，右盒子拉） (4）响应式工具利用媒体查询功能，使用工具类可以方便针对不同设备展示或者隐藏页面内容（类似淘宝首页某类商品的隐藏） hidden-xs 超小屏：隐藏 小屏：可见 中屏：可见 大屏：可见 hidden-sm 超小屏：可见 小屏：隐藏 中屏：可见 大屏：可见 hidden-md 超小屏：可见 小屏：可见 中屏：隐藏 大屏：可见 hidden-lg 超小屏：可见 小屏：可见 中屏：可见 大屏：隐藏 &lt;div class=\"col-md-3 hidden-xs\">&lt;/div> 与之相反的是visible-xs，visible-sm等，可以实现广东财经大学首页的搜索栏隐藏模块功能 bootstrap官网里还有字体图标供给使用 bootstrap已经帮你写好清除浮动，只需添加类名clearfix 5.线性渐变颜色（针对于移动端）pc端需要很多私有前缀，特别麻烦，但是移动端只需要添加webkit就可以了 background: linear-gradient(起始方向,颜色1,颜色2); /*起始方向默认top*/ background: -webkit-linear-gradient(left,red,blue); /*一般都要添加-webkit-私有前缀*/ background: -webkit-linear-gradient(left top,red,blue);","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"matlab期末知识点汇总","slug":"matlab期末知识点汇总","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-06T09:30:41.436Z","comments":true,"path":"2020/08/06/matlab-qi-mo-zhi-shi-dian-hui-zong/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/matlab-qi-mo-zhi-shi-dian-hui-zong/","excerpt":"","text":"regress命令 用于一元及多元线性回归 B = regress(Y,X)[B,BINT] = regress(Y,X)[B,BINT,R] = regress(Y,X)[B,BINT,R,RINT] = regress(Y,X)B,BINT,R,RINT,STATS] = regress(Y,X)[…] = regress(Y,X,ALPHA) B：回归系数，类似于斜率，是个向量（“the vector B of regression coefficients in the linear model Y = X*B”）。BINT：回归系数的区间估计（“a matrix BINT of 95% confidence intervals for B”）。R：残差（ “a vector R of residuals”）。RINT：置信区间（“a matrix RINT of intervals that can be used to diagnose outliers”）。STATS：用于检验回归模型的统计量。有4个数值：判定系数R^2，接近1，回归方程越显著，F统计量观测值，F越大，回归方程越显著，检验的p的值，误差方差的估计。ALPHA：显著性水平（缺少时为默认值0.05）。 %导入数据 y=[7613.51 7850.91 8381.86 9142.81 10813.6 8631.43 8124.94 9429.79 10230.81 ... 10163.61 9737.56 8561.06 7781.82 7110.97]&#39;; x1=[7666 7704 8148 8571 8679 7704 6471 5870 5289 3815 3335 2927 2758 2591]&#39;; x2=[16.22 16.85 17.93 17.28 17.23 17 19 18.22 16.3 13.37 11.62 10.36 9.83 9.25]&#39;; X=[ones(size(y)) x1.^2 x2.^2 x1 x2 x1.*x2]; % size（）：获取矩阵的行数和列数 % s=size(A), 当只有一个输出参数时，返回一个行向量，该行向量的第一个元素时矩阵的行数，第二个元素是矩阵的列数。 % ones(M,N)产生一个M*N的矩阵 %开始分析 [b,bint,r,rint,stats] = regress(y,X);创建残差的置信区间图用regress返回的值r，rint：rcoplot（r，rint） 线性回归模型类线性回归模型类 wlb=LinearModel; %创建线性回归类对象，对象名wlb wlb=LinearModel.fit(x,y); %创建线性回归类对象，并对观测 数据做多元线性回归 wlb.plot %绘制wlb的效果图 wlb.anova %给出方差分析表 [y,ly]=wlb.predict(x) %给出x预测和置信区间 wlb.plotResiduals %绘制残差图 wlb. plotDiagnoisetics(method) %绘制不同统计量的残差图分 析 properties(wlb) %显示所有统计量属性t值和显著性水平有什么样的对应关系t-检验：可以用于比较两组数据是否来自同一分布。（可以用于比较两组数据的区分度） 在统计检验中，统计量t值和显著性水平具有什么样的对应关系？一般来说，大样本和正态分布情况下的数据，当1.65&lt;|t|&lt;1.96时,p&lt;0.10;当1.96&lt;|t|&lt;2.58时，p&lt;0.05；|t|大于2.58时，p&lt;0.01。 但是要注意的是，当样本量很小（小于30），数据分布形态不明或明显不服从正态分布（一座山一样的分布）时，t值和显著性水平不一定完全对应，例如t值绝对值大于2时，p值有可能大于0.05，也就是不显著。这种情况一般要采用非参数检验的方法，而不是t检验。 1、t值，指的是T检验，主要用于样本含量较小（例如n&lt;30），总体标准差σ未知的正态分布资料。T检验是用t分布理论来推论差异发生的概率，从而比较两个平均数的差异是否显著。 2、P值，就是当原假设为真时，所得到的样本观察结果或更极端结果出现的概率。如果P值很小，说明原假设情况的发生的概率很小，而如果出现了，根据小概率原理，我们就有理由拒绝原假设，P值越小，我们拒绝原假设的理由越充分。 p值代表的是不接受原假设的最小的显著性水平，可以与选定的显著性水平直接比较。例如取5%的显著性水平，如果P值大于5%，就接受原假设，否则不接受原假设。这样不用计算t值，不用查表。 3、P值能直接跟显著性水平比较；而t值想要跟显著性水平比较，就得换算成P值，或者将显著性水平换算成t值。在相同自由度下，查t表所得t统计量值越大，其尾端概率P越小，两者是此消彼长的关系，但不是直线型负相关 怎么得到检验回归系数显著性的T值对于X、Y两个正态总体的样本，其t检验应使用ttest2()函数来检验假设。[H,P,CI]=ttest2(X,Y) ttest2（）函数是用来检验具有相同方差的两个正态总体均值差的假设检验（即两正态总体的检验法）。 基本调用格式： h=ttest2（x，y）判断来自不同正态总体的样本数据x与y是否有相同的均值。当h=0表示接受原假设，当h=1表示拒绝原假设。 h=ttest2（x，y，alpha）调用格式表示执行显著性水平为（100*alpha）%的假设检验。没有给出alpha值，默认alpha=0.05。 h=ttest2（x，y，alpha，tail）调用格式表示执行以tail指定的备择假设作假设检验，原假设为均值等于m，当tail=‘both’时表明备择假设为“x与y均值不相等”，当tail=‘right’时表明备择假设为“x的均值大于y的均值”，当tail=‘left’时表明备择假设为“x的均值小于y的均值”。regstats函数（回归系数显著性检测？）MATLAB统计工具箱中提供了regstats函数，也可用来作多重线性或广义线性回归分析，它的调用方式如下：regstats(y,X,model)stats = regstats(…)stats = regstats(y,X,model,whichstats) 非线性用nlinfit函数或者开启cftool工具箱 eye函数该函数返回单位矩阵。 Y = eye(n)：返回n*n单位矩阵； Y = eye(m,n)：返回m*n单位矩阵；","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"数学建模国赛matlab知识点","slug":"数学建模国赛matlab知识点","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-22T07:55:04.587Z","comments":true,"path":"2020/08/06/shu-xue-jian-mo-guo-sai-matlab-zhi-shi-dian/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/shu-xue-jian-mo-guo-sai-matlab-zhi-shi-dian/","excerpt":"","text":"1.基础命令行太长，可加上三个小数点：“…” 进行分割（续行符），如 s=1-1/2+1/3-1/4... +1/5-1/6+1/7数值数据默认双精度double clear命令，清除工作区的所有变量 class(变量)得到变量类型 复型数据，虚数部分用i或j表示，如6+5i ，real函数求复数实部，imag函数求复数的虚部 以角度为单位的函数，在函数名后加“d”，如sin(pi/2)=sind(90) abs(xx)可求实数绝对值，复数的模，字符串的ascii码 rem(m,10)求m/10的余数 isprime(n)求n是否为素数，是返回1，否返回0 exp(pi/2)为e的2/Π次方 整形转换x=int8(129) //转有符号的int，最大127，即这里x=127 x=uint(129) //转无符号uint，即x=129 取整函数round()函数按照四舍五入 ceil()向上取整 floor()向下取整 fix()取靠近0的整数矩阵的建立//no.1 A=[1,2,3;4,5,6;7,8,9] //第一行1，2，3，第二行4，5，6冒号表达式e1:e2:e3 //分别为初始值，步长（两两之间间隔的大小，如果省略步长，则步长为1），终止值 inspace(a,b,n)//分别对应第一个元素，最后一个元素，元素总数（省略时为100）结构矩阵&amp;单位矩阵//结构矩阵 结构矩阵元素.成员名=表达式 a(1).x1=10; a(1).x2=&#39;liu&#39;; a(1).x3=[11,21;34,78]; //单元矩阵，用大括号 b={10,&#39;liu&#39;,[11,21;34,78]}2.矩阵引用矩阵元素A(3,2)表示A矩阵第三行，第二列元素 可用序号引用，如在A=[1,2,3;4,5,6;7,8,9]中，A(3)=7 (矩阵元素按列储存) D=sub2ind(S,I,J),分别为行数和列数组成的向量，转换矩阵元素的行下标，转换矩阵元素的列下标，D为序号（下标转序号） size(A)求矩阵A的行列数 [I,J]=ind2sub(S,D),分别为行数和列数组成的向量，序号（序号转下标） k=find(ch&gt;=&#39;a&#39;&amp;ch&lt;&#39;z&#39;) 找到符合条件的元素的序号 利用冒号获得子矩阵A(i,:) 第i行的所有元素 A(:,j) 第j列的所有元素 A(i:i+m,k:k+m) 第i~i+m行且在第k~k+m行的所有元素end运算符：表示某一维末尾下标 如：A(end,:)，是指A矩阵最后一行所有元素 利用空矩阵删除矩阵的元素将想要的元素范围赋值空矩阵[]即可，如A(:,[2,4])=[]，删除第二列，第四列元素 改变矩阵形状reshape(A,m,n)：在矩阵综援素不变的情况下，将A重新排列成m×n的二维矩阵 注意：并不改变元素个数及其储存顺序 A(:)：将矩阵A每一列元素堆叠起来成为一个列向量 3.算术运算&amp;字符串须知：加减运算两矩阵必须同型，乘法运算要求A行数和B的列数相同 点运算：两矩阵进行点运算是指它们对应元素进行运算，要求两矩阵同型 逻辑运算符：&amp;，|，~ 字符串和数值之间的转换：数值（ASCII码）=abs(字符串) 字符串=char(ASCII码) strncmp(s1,s2)：用于比较字符串s1，s2是否相等 strncmp(s1,s2,n)：用于比较字符串s1，s2前n个字符是否相等 strcmpi(s1,s2)：忽略大小写 4.特殊矩阵zeros函数：产生全零矩阵 ones函数：产生全1矩阵 eye函数：产生对角线为1的函数 rand函数：产生（0,1）区间均匀分布的随机矩阵 randn函数：产生均值为0，方差为1的标准正态分布随机矩阵 inv(矩阵)：求其逆矩阵 zeros(m):产生m×m零矩阵 zeros(m,n):产生m×n零矩阵特殊矩阵介绍： 魔方矩阵M=magic(8) (8行8列) 范德蒙矩阵vander(1:5) 希尔伯特矩阵：H=hilb(4) 伴随矩阵：A=compan(P) 帕斯卡矩阵：P=pascal(5) 对角阵对角矩阵：对角线上元素非零 数量矩阵：对角线上元素相等 对角矩阵：对角线上元素为1 diag(A)：提取矩阵A对角线元素，产生一个列向量 diag(A,k)：提取矩阵A第k条对角线元素，产生一个列向量 构造对角矩阵：diag(V)：以向量V为主对角线元素，产生对角矩阵 三角阵triu(A)：提取矩阵A的主对角线及以上的元素 tril(A)：提取矩阵A的主对角线及以下的元素 triu(A,k)：提取矩阵A的第k条主对角线及以上的元素 矩阵的转置A=[1,3;3+4i,1-2i] 转置：A.’ 共轭转置：A’ 若矩阵为实数，转置和共轭转置是一样的 矩阵旋转：rot90(A,k)，将矩阵A逆时针旋转90°的k倍，k为1可省略 矩阵左右翻转：fliplr(A) 矩阵上下翻转：flipud(A) 矩阵其他功能把一个方阵看作一行列式，并对其按行列式的规则求值：det(A) 求矩阵的秩：rank(A) 求矩阵的迹，即对角线元素之和：trace(A) 求矩阵A全部特征值，构成向量E：E=eig(A) 或者 [X,D]=eig(A) A的全部特征值构成对角阵D，X的各列是对应的特征向量 5.subplot画图subplot（m,n,p）或者subplot（mnp）此函数最常用：subplot是将多个图画到一个平面上的工具。其中，m表示是图排成m行，n表示图排成n列，也就是整个figure中有n个图是排成一行的，一共m行，如果第一个数字是2就是表示2行图。p是指你现在要把曲线画到figure中哪个图上，最后一个如果是1表示是从左到右第一个位置。 ） 6.MatLab中关于程序的操作建立函数，新建脚本，开头为： function C = 函数名( 参数A,参数B)，并且通过C返回（当有多个形参时，可用逗号分隔，而C为输出形参表，多个输出形参需要用方括号[] 括起来） 数据的输入：A=input(‘请输入A的值：’); 数据的输出：disp(输出项) 程序暂停：pause(延迟数秒),如果省略参数，则一直暂停，除非用户按任意键就可以继续执行 x^(1/3)=power(x,1/3) matlab中的switch case相对于C，java不需要break，且最后一个的default改成otherwise 匿名函数：简化了函数的过程：如f=@(x,y)x^2+y^2，f(3,4)进行调用，但是不适用于复杂函数 7.Plot函数plot(x,y)，x，y分别存储x，y坐标的数据 最简单的plot调用格式：plot(x)，下标为横坐标，值为纵坐标 x,y为同型矩阵，则分别对应x，y坐标绘画出曲线图 多条曲线可以plot(x1,y1,x2,y2,x3,y3……) x=linspace(0,2*pi,100) ,位置0到2pi的100个元素存于x plot（x,y,选项）选项有线性，颜色，数据点标记 线型：“ - ” 实线, “ : ”虚线, “ -. ”点画线, “ – ” 双画线 颜色：“ r ”红，“ g ”绿，“ b ”蓝。。。。。。 数据点标记：“ * ”星号，“ o ”圆圈，” s “方块。。。。 8.fplot函数fplot（f,lim,选项），f是函数，lim是x的取值范围，用二元向量[xmin,xmax]表示，默认[-5,5]，选项和plot相同 自变量无法间隔采样时使用fplot（函数变化趋势未知，或者在不同区间函数变化频率过大，如sin（x/1）） 9.曲线拟合polyfit（）进行拟合，找一个函数去逼近数据，再根据找到的函数预测下一个点的值（如 人口预测问题）（它实际上是求得最小二乘法拟合的多项式系数） p=ployfit（x,y,3）生成三次多项式函数，调用ployval（p,2020）进行计算（求2020年的人口）","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"模拟退火算法","slug":"模拟退火算法","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-07T03:16:44.061Z","comments":true,"path":"2020/08/06/mo-ni-tui-huo-suan-fa/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/mo-ni-tui-huo-suan-fa/","excerpt":"","text":"1.模拟退火算法可能的情况很多，数据量太大，用模拟退火搜索出需要的解（求最值）（最大值问题可以添加负号转换成求最小值问题） 启发式搜索：利用搜索过程中获取的信息改进搜索策略。启发式搜索有利于找到问题最优解，且有助于加速求解过程。 模拟退火可以说是最简单（应用）的启发式搜索之一 相比起爬山法（找到局部最优解），模拟退火算法有一定概率能接受比当前还要差的解，概率p位于[0,1]，旧解和新解的函数值越接近，p值就越大（概率为0对应爬山法，概率为1对应蒙特卡洛算法）；时间越长，p值越小；搜索前期p大，后期p小 2.搜索过程1.随机生成一个解A，计算F(A) 2.在A附近随机生成一个解B，计算F(B) 3.对比F(A)和F(B)，进行对比，若F(B)&gt;F(A)（求最大值）,B赋值A，F(B)&lt;F(A)，计算接受B的概率，接受则B赋值A，且重复以上操作，否则返回第2步，在原来A附近再生成一个B继续下去 如果优化问题有约束条件： 1.生成B是查看是否符合要求 2.使用罚函数 与时间相关的系数Ct如何设置：Ct是温度t的倒数（模拟退火） 如何再A附近随机生成一个解B：没有统一规定，需要具体问题具体分析 停止搜索1.达到迭代次数 2.达到指定温度 3.找到连续最优解，M（如30次）次迭代还未改变 3.实现产生新解： 1.matlab内置工具 根据温度不同，新解距离旧解的步长改变，温度高步长高，温度低步长短，由全局缩短为 x_new=x_i+T×z_i 然后检查x_new是否位于上下界 2.旅行商问题 交换法，位移法，倒置法","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"JavaScript基础","slug":"JavaScript基础","date":"2020-07-21T14:14:19.766Z","updated":"2020-12-28T04:56:37.699Z","comments":true,"path":"2020/07/21/javascript-ji-chu/","link":"","permalink":"https://taylor12138.github.io/2020/07/21/javascript-ji-chu/","excerpt":"","text":"1.JS的介绍JS是脚本语言，不需要编译，直接由js解释器逐行进行解释并执行，现在也可以基于node.js技术（后台）进行服务器编程 实现业务逻辑和页面控制功能，浏览器的JS引擎，也就是JS解释器，用来读取JS代码 JS的组成JavaScript语法：ECMAScript 页面文档对象模型：DOM 浏览器对象模型：BOM ECMAScript它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和拓展 DOM它是标准编程接口，通过DOM提供的接口可以对页面上各种元素进行操作（大小位置颜色） BOM它提供了独立于内容，可以与浏览器窗口进行互动的对象，操作浏览器窗口比如弹出窗，控制浏览器跳转，获取分辨率等 JS的三种书写 类似于CSS，有行内式，内嵌式&lt;script&gt;xxxx&lt;/script&gt; 还有从外部引入：(script标签中间别写代码) &lt;script src=\"xx.js\">&lt;/script> 2.JS基本功能介绍输入输出alert(msg); //弹出警示框 console.log(msg) //打印输出信息，是控制台输出，给程序猿测试用的 prompt(info) //弹出输入框，提供用户输入 但是都是以字符的形式输入console.log()会在浏览器控制台打印出信息 console.dir()可以显示一个对象的所有属性和方法 定义使用var，自动确定类型（JS拥有动态类型） 功能isNaN() 判断是否非数字 typeof 变量名 查看数据类型 转换转字符串： 变量名.toString() 强制转换：String(变量名) 隐式转换：变量名+”xxxx”(拼接字符串) String转数字类型：（1）String-&gt;int： parseInt(String)； （2） String-&gt;float: parseFloat(String)； ​ （3）Number强制转换（String转数值）：Number(String) （4）利用加减乘除：String-String或String-int之类的 运算符18==‘18’ 成立true，默认转换数据类型 ===为全等需要完全一致， 18===‘18’为false 逻辑与短路运算：123&amp;&amp;456，返回456，左式为真返回右式子，为假返回左式 逻辑或短路运算：123||456，返回123，左式为真返回左式子，为假返回右式 三元表达式：条件表达式？表达式1：表达式2，条件为真返回表达式1，为假返回表达式2 数组数组名.length为数组的长度 数组增加元素 （1）直接设定数组长度arr.length=xx,多出来的变成空 （2）arr数组有三个元素，直接arr[3]=xx，进行新增元素 3.函数//1.利用函数关键字自定义函数 function 函数名(参数) { 函数体 } //如下： function sort(arr){ } //2.匿名函数 var fun=function(){ } //调用 fun(); 函数没有return，则返回的是undefined 注意在函数内部没有声明直接赋值的变量，也属于全局变量 arguments的使用当我们不确定函数用多少个参数来传递的时候，arguments实际上是当前函数的一个内置对象（函数才拥有），arguments储存了传递的所有实参,它展示的方式是伪数组，因此可以进行遍历（使用for等） 注意：箭头函数是用不了arguments function fn(){ console.log(agruments); console.log(agruments.length); } fn(1,2,3); //则输出1，2，3 伪数组：1.具有length属性 2.按索引凡是储存数据 3.不具有push，pop功能 预解析js引擎运行js，分为两步：1.预解析 2.代码执行 预解析：js会把里面所有var还有function提升到当前作用域的最前面（分别为变量提升和函数提升） 变量提升：把所有变量声明提升至当前作用于最前，但是不提升赋值操作 4.对象对象一定是一个具体的对象，而不是泛指的东西 属性：事物的特征，用对象的属性表示 方法：事物的行为，在对象中方法来表示 以下方法是利用对象字面量创建对象 var obj ={ uname:'xx', age:18, sex:'man', say:function(){ console.log('good'); } } //调用对象属性(2种) obj.uname obj['uname'] (1)键 属性名: 值 属性值 (2)用逗号隔开 (3)方法冒号后面跟的一个匿名函数 利用new Object创建对象，再赋值的时候创建属性，因此此方法效率不高 var obj = new Object obj.uname='xx'; obj.age=18; obj.say=funciton(){} （1）利用等号赋值添加对象的属性和方法 （2）每个属性和方法用分号 利用构造函数创建对象，其过程也称为对象的实例化,构造函数是泛指的某一大类，对象是具体的事物 function 构造函数名(){ this.属性=值; this.方法=function（）{} } 1.使用构造函数，构造函数名字首字母最好大写如 function Star()2.构造函数不需要return3.使用函数new 构造函数名();即构造一个对象，如new Array()，创建一个数组对象4.属性方法前必须加this如this.name=传参name this.song = function（传参）{} 遍历对象for (var k in obj){ //obj为对象 console.log(k); //k输出的是属性名 console.log(obj[k]);//得到的是属性值 } //我们使用for in 喜欢var k或者key 5.内置对象JavaScript中对象分为自定义对象，内置对象，浏览器对象，前两种属于ECMAScript；第三个浏览器对象是js特有的 Javascript提供了多个和内置对象：Math、Date、Array、String 可以通过MDN/W3C来查询内置对象的使用 MDN的网址：https://developer.mozilla.org/zh-CN/ （1）Math对象//绝对值方法： Math.abs(-1) //1 Math.abs('-1') //1,隐式转换 Math.abs('pink') //NAN Math.PI //圆周率 Math.floor(x) //向下取整 Math.ceil(x) //向上取整 Math.round(x) //四舍五入 Math.max(x) //最大值 Math.min(x) //最小值 Math.random() //随机 0&lt;=x&lt;1 Math.floor(Math.random()*(x_max-x_min+1))+x_min//得到两个数之间的随机整数 （2）Date对象是一个构造函数，必须使用new调用 var date = new Date(); //无参数，返回当前系统的时间 //常用的两种时间写法 var date = new Date(2020, 10, 1); //指定固定日期 var date = new Date('2020-10-1 8:8:8'); //返回年份，月份，日期 date.getFullYear(); date.getMonth()+1; //0-11 + 1 = 1-12 date.getDate(); //距离1970年 1.1经历的毫秒数，用来：d=parsent（总秒数/60/60/24）得到天数等单位 date.valueOf() date.getTime() var date1= +new Date(); //最常用 Date.now() //H5新增 （3）数组对象数组的每个槽位可以储存任意类型数据 var arr1 = new Array(2,3); //相当于[2,3]的数组 arr1 instanceof Array //检验是否为数组，是返回true，否则false Array.isArray(arr1); //同上,H5新增,但这个效果好，防止多个不同版本的Array构造函数 arr1.push(xx); // 在数组末尾增加数组元素，push完毕之后，返回结果是新数组的长度,push实际上可以接收多个参数一次增加 arr1.unshift(xx); // 在数组开头增加数组元素，unshift完毕之后，返回结果是新数组的长度 arr1.pop(); // 删除数组的最后一个元素 返回值为被删除的元素值 arr1.shift(); // 删除数组的第一个元素 返回值为被删除的元素值 arr1.reverse(); //翻转数组 arr1.sort(function(a,b) { return a-b; }); //冒泡排序，自动排序 ,升序 如果不加function则为按照字符串排序 arr1.indexOf(xx); //返回该数组元素的索引号（只返回第一个满足条件的索引号），找不到返回-1 arr1.lastindexOf(xx); //同上，只返回倒数第一个满足条件的索引号 arr1.toString(); //转换成字符串，逗号分隔 arr1.join('你想要的分隔符'); //用指定分隔符分割不同的数组元素，并转换成字符串 array.splice(开始的指针下标,删除的个数[, item1[, item2[, ...]]]); //用于删除多组元素并且天地添加新元素 //案例，数组去重 //利用indexoOf，返回-1则添加入新数组 function unique(arr) { var newArr = []; //另一种创建数组方式 for(int i = 0; i &lt; arr.length; i++){ if(newArr.indexOf(arr[i]) == -1) { newArr.push(arr[i]); } } } 6.基本包装类型基本数据类型是没有属性和方法的，而对象才有属性和方法 //String var str = 'andy'; //但是str可以使用str.length,因为jshui把基本数据类型包装成复杂数据类型，操作如下 var temp = new String('andy'); str = temp; temp = null; //因为字符串不可变，所以每次str += i ，拼接字符串会开辟另外一个内存空间，字符串赋值同理 //String 同样有很多很多数组对象的属性功能 str.indexOf('xx'); str.indexOf('查找的字符',[起始的位置]); //这个也可以 str.charAt(位置); //根据位置返回字符 str.charCodeAt(位置); //根据位置返回字符的ASCII码 str[index]; //同str.charAt，H5新增 str.replace(被替换的字符,替换的字符); //只替换掉里面第一个字符 判断一个对象是否有该属性 可使用对象[‘属性名’], 返回true则有，反则返回false 遍历对象可使用 for (var k in o) { //k得到属性名 //o[k]得到的是属性值 }截取字符串substr(start,length); //start位置开始，length取的个数，省略length则默认取到最后 slice(start,end); //start开始，截取到end，但是end截取不到 数组对象转字符用join()，字符转数组用split var str = 'red, pink, blue'; console.log(str.spilt(',')); //用逗号分隔 toUpperCase() 转换大写， toLowerCase() 转换小写 7.简单类型和复杂类型如果有个数据类型打算作为存储对象，暂时没想好放什么，可以先放null 简单数据类型（值类型）：string（但是string数值不可变）、number、boolean、undefined、null 简单数据类型放入栈里面（操作系统），栈里开辟的空间存放的是值 （用函数传参是不会影响变量的值） 复杂数据类型（引用类型）：Object、 Array、 Date 复杂数据类型放入堆里面（操作系统），于栈里存放地址，十六进制表示，然后这个地址指向堆里的数值；一般由程序员分配释放，若程序员不释放，由垃圾回收机制释放 （用函数传参是会影响对象的值） 但是JS里没有堆栈的概念，只是通过堆栈的方式理解代码的执行方式 8.APIs介绍Web APIs我们主要学习的是DOM和BOM，进行页面交互 API是预先定义的函数，提供给开发人员直接调用，无需访问源码工作细节 Web API 是浏览器提供的一套操作浏览器功能和页面元素的api（DOM和BOM） 9.swiper插件的使用官网地址：https://www.swiper.com.cn （1）下载并解压包后，把其中的swiper.min.js和swiper.min.css放入网页文件夹的js和css中 （2）官网找到类似的案例，复制html，css和js（进入官网swiper演示中，然后新窗口打开，查看网页源代码） （3）根据需求修改模块","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"CSS高级","slug":"CSS高级","date":"2020-05-30T16:00:00.000Z","updated":"2020-11-13T14:45:52.296Z","comments":true,"path":"2020/05/31/css-gao-ji/","link":"","permalink":"https://taylor12138.github.io/2020/05/31/css-gao-ji/","excerpt":"","text":"1.精灵图为了有效减少服务器接收和发射请求次数，提高速度出现的CSS技术。即将网页小背景图合成一张大图。 主要针对于背景图片（非产品类等更新换代图片） 主要使用background-position+x和y轴配合使用，x轴向右，y轴向下 background: url()no-repeat -182px 0; //分别对应x轴，y轴,基本都是负值缺点：文件大，放大缩小会失真，更换复杂 2.字体图标iconfont常用于一些小图标（样式简单），展示状态时图标，实际上是字体 优点1.轻量级，够小 2.灵活性，可改多种效果 3.几乎支持所有浏览器 下载：相应网站（如https://icomoon.io/）下载后得到压缩包，解压后，把下载包里的fonts放入页面根目录下 使用：在CSS中根据说明引用全局声明，然后再在个体css中再次引用你想要的声明，同时可以自己调色和字体大小（font-size） 这里以阿里的图标为例子，把项目添加好之后，根据操作https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.16&amp;helptype=code一步一步来（这里是unicode引用），注意：**复制代码的时候，一定要在url的值中补充 “http:”** （使用bootstrap框架，可以直接使用其官网给的图标） 3.三角形若盒子设置宽高为0；此时又设置边框，则会形成组成一个正方形的4个三角形，实际上我们写三角形可以利用这个原理，把其他三个三角形隐藏起来则就只有一个三角形了 width: 0; height: 0; /*line-height: 0; font-size: 0; 有时需要添加，看浏览器*/ /*先设置一个边框，尽量大，以边框概括盒子大小*/ border: 50px solid #ccc; border-color: transparent red transparent transparent //上右下左的颜色 4.用户界面鼠标样式 cursorcursor: defalut 默认无样式 cursor: pointer 小手 cursor: move 移动 cursor: text 文本 cursor: not-allowed 禁止 轮廓线给表单（input）添加 outline: 0;，点击表单时，会去掉默认的l蓝色光标 防止拖拽文本域textarea{ resize: none }可以使文本框没有拖拽选项 5.Vertical-align(图片)css常用vertical-align让图片和文字对齐（但是只能针对行内元素或者行内块元素） vertical-align: middle; 中线对齐（一般使用这个来对齐） 图片底侧放置于盒子内时，时常有一个空白缝隙，可以使用vertical-align: middle||top||bottom;将其解决 （其实还可以直接转成块元素，但是此方法不提倡） 6.文字溢出变省略号（推荐让后端写）单行文本：white-space: nowrap //强制一行内显示 ​ overflow: hidden; //溢出隐藏 ​ text-overflow: ellipsis ///变成省略号 多行文本：（有较大兼容性问题，适用于移动端或者webkit浏览器） ​ overflow: hidden; + text-overflow: ellipsis display: -webkit-box; //单行伸缩盒子 -webkit-line-clamp: 2; //限制其文本行数 -webkit-box-orient: vertical; //设置盒子的子元素排列方式，（垂直居中） 7.常见布局技巧可以使用margin的负值来消除浮动边框的重合（消除产生的巨大影子）如： margin-left: -Xpx; 想要移动到某个边框内自动变色可以使用hover，但是当排列方式为每个盒子的右边框被另外一个盒子的左边框压住时，变色效果会出bug，正确做法是：xx:hover{ position: relative; }添加相对定位使其马上覆盖当前所有单位 如果失败，有可能是因为当前已经添加了绝对定位了，此时只需要提高层级：z-index: 1; 8.CSS初始化为了照顾浏览器兼容，必须首先进行CSS初始化，即重新设定CSS个标签的初始默认值 9.CSS3新特性ie9+才支持 属性选择器可以不借助类选择器 input[att] {} 带有att属性值的被选中input[att=&quot;value&quot;] {} 带有att属性并且属性值等于value被选中 input[class^=icon]{} 选择类属性以icon开头的所有标签 input[class$=icon]{} 选择类属性以icon结尾的所有标签 input[class*=icon]{} 选择类属性含有icon的所有标签 如 .local-nav li [class^=\"local-nav-icon\"] { } 类选择器，伪类选择器，属性选择器（这个一般是11，因为包含标签名+属性名=1+10=11）它们权重都为10 结构伪类选择器first和last等可以来了解一下，实际开发不太建议使用，也比较少使用。 值得注意的是 nth-child(n)比较重要 n可以是数字，可以是关键字（even偶数，odd奇数），甚至公式 ul li:nth-child(even){ } //选择所有的偶数孩子 ul li:nth-child(n){ } //选择所有孩子,因为n是公式类似n++，依次施加CSS效果 ul li:nth-child(2n){ } //选择所有的偶数孩子 ul li:nth-child(-n+5){ } //选择前5个孩子 nth-of-type和nth-child的不同： section div:nth-child(1){ } //先排序，再看是否符合div，如果是div就渲染 section div:nth-type(1){ } //先看是否符合div，如果是就在div里排序，选择第一个就渲染 伪元素选择器通过CSS创建新的子标签（比较简单的），从而简化html结构，（还与之前清除浮动使用的伪元素方法有关） element::before{ content：'XX'; /*必须要有content属性，为内容*/ 样式 } /*在元素内部前面（左）插入内容*/ element::after{ content: 'XX'; 样式 } /*在元素内部后面（右）插入内容*/ 它和标签选择器一样，权重=1，且为行内元素，想要设置大小必须转行内块 （还可以有element:hover::before{}的操作） CSS3盒子模型只需增加如下代码 box-sizing: border-box; /*只看盒子大小，不考虑border和padding因素*/ 即可不用考虑border和padding因素是否会将盒子本身撑大。 CSS3滤镜filter用于模糊图形效果，filter: 函数(); 如：filter:blur(5px); //模糊处理，数值越大越模糊 …… CSS3calc函数(计算函数)width: calc(100% - 80px); //宽度永远比父盒子宽度小30px CSS过渡（重点）一些变化的动画效果（时间缓滞），经常和 :hover 一起搭配 transition: 要过渡的属性 花费的时间（单位为s） 运动曲线（默认ease，可以省略） 何时开始（默认0s，可省略）; transition: width 0.5s,heigh 0.5s; /*多个属性\",\"分割，想要更多属性，直接属性值写all*/ xx:hover{width:100px;heigh:100px;} transition: all 0.xs; 使用的比较多 10.CSS的morecss的2D转换transform可以理解为变形 移动：translate 旋转：rotate 缩放：scale 2d为二维坐标，x轴向右，y轴向下 translate类似于定位transform:translate(x,y); transform:translateX(n); transform:translateY(n); /*单位是px，如果是百分号，则它的距离是盒子自身高宽对比出来的*/ translate最大的优点：不会影响其他元素的位置，绝对定位会脱标，margin会影响，（有点像相对定位，但是更方便，可以加过渡效果） 可用于定位父盒子的中间位置 使用： position: absolute; top: 50%; left: 50%; transform:translate(-50%,-50%);但是它对行内标签没有效果 rotate旋转transform:rotate(度数deg); transform-origin:x y; /*设置元素旋转依靠的中心点*/ x，y默认为50%，50%，设置x，y可以可是bottom，left等，如transform-origin:left bottom;为设置左下角为中心点 scale之缩放transform:scale(x,y);/*里面的数字不跟单位，是倍数，x，y分别是宽，高*/ transform-origin:x y; /*设置元素旋转依靠的中心点*/ 若只有一个参数，则同比放大 使用scale的优点：变大时不会影响其他盒子的位置，且放大是以中心向外扩张的放大，直接修改width和heigh放大是直接往下放大 动画用keyframes定义动画 @keyframes 动画名称 { 0%{ width:100px.... } 100%{ width:200px.... } }//可以设置25%，75%等多个状态，习惯上把0%也写了 //以下也可以 @keyframes 动画名称 { form{ width:100px.... } to{ width:200px.... } } 0%动画的开始 100%动画的结束 1.可以做多个状态变化 keyframe关键帧 2.里面的数字为整数 3.百分比为时间的划分 使用动画： div { animation-name:动画名称; animation-duration:持续时间; animation-iteration-count:播放次数，可以为infinite; animation-direction:xx; //默认normal，alternate为设置逆向播放 animation-fill-mode:xx; //默认backwards，动画结束后返回原来位置，forwards可取消该功能 animation-play-state:xx; //running/paused 是动画运行或者暂停 animation-timing-fuction: ease; //默认ease加速度，linear匀速，step分步。。。 }使用多个动画用“，”分隔，如animation: bear 0.7s steps(8) infinite, move 0.7s …… 3D转换x轴向右，y轴向下，z轴向外，最常用的是3d位移和3d旋转,以下许多功能与2d十分相似 3d移动transform: translate3d(x,y,z); transform:translateZ(n); /*translateZ一般采用px，3d的z轴显现出来需要透视功能*/ 透视透视我们也成为视距，即眼睛到屏幕的距离，透视的单位是像素，透视越小，盒子越大 透视写在被观察元素的父盒子上 perspective: xxpx;3d旋转一般加上透视效果会比较明显，3d旋转方向遵循左手定则： 左手大拇指指向x轴正方向，手指弯曲的方向则为旋转的方向 transform: rotateX(度数); /*沿着X轴旋转*/ transform: rotateY(度数); transform: rotateZ(度数); /*z轴旋转和2d普通rotate有点像*/ transform: rotate3d(x,y,z,度数); /*自定义轴旋转*/ 自定义旋转只对x轴选取为transform: rotate3d(1,0,0,度数); 对角线旋转为transform: rotate3d(1,1,0,度数) transform要看情况选择：先写旋转rotate再写移动translate或者相反情况 3d呈现transform-style控制子元素是否开启三维立体环境，代码要写给父级（一定是父级，不能爷爷级别，亲测过），此属性很重要 transform-style: preserve-3d /*此为开启立体空间，但是默认值为flat，不开启立体空间*/","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"CSS定位&显示","slug":"CSS定位&显示","date":"2020-05-27T16:00:00.000Z","updated":"2020-11-19T14:44:03.147Z","comments":true,"path":"2020/05/28/css-ding-wei-xian-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/28/css-ding-wei-xian-shi/","excerpt":"","text":"CSS定位1.某个元素可以在盒子内移动位置，并且压住其他盒子。 2.滚动窗口时，盒子固定于屏幕某个位置。 定位=定位模式+边偏移量 定位选择器{ position: static; position: relative; position: absolute; position: fixed; position: sticky; top: 100px; //必备的指定位置，可以为left，right，bottom } position: static; //默认，无定位,标准流特性 position: relative; //相对定位，参照点是自己，移动位置后，原来的位置继续占有 position: absolute; //绝对定位，是相对于他的祖先元素。 1.没有祖先元素或者，祖先元素没有使用定位，则以浏览器为准直接偏移 2.如果祖先元素有定位（相对，绝对，固定），则以最近一级定位的祖先元素为参考点 3.绝对定位不再占有原来的位置（脱标） 4.加了绝对定位的盒子不能通过 margin: 0 auto; 来居中，让它居中的原理和fixed设置版心的原理差不多，都是left：50%+margin组合 position: fixed; //固定于浏览器可视区位置，不占有原先位置 1.还可以设置于版心附近，方法：让那个固定定位的盒子 left: 50%,然后让固定定位的盒子margin-left：版心的一半距离 position: sticky; //粘性定位，被认为相对定位和固定定位的混合体 1.以浏览器可视窗口为参照移动的元素（固定特点） 2.粘性定位占有原先的位置 3.必须添加top，left等，不然相当于相对定位 缺点：ie不支持 (子绝父相—–出自pink老师) -&gt;&gt;&gt;&gt;&gt;&gt;&gt; —–&gt; 子级使用绝对定位，父亲则需要使用相对定位 位置如果一个定位既设置了left，也设置了right，它默认会执行left。若及设置了top，也设置了bottom，会默认执行top（无关权重的事情） 定位叠放次序通过控制z-index来控制盒子的前后次序（叠放次序） z-index： 1; 1.数值越大盒子越靠上，2.如果值相同，按照书写顺序，后来居上 3.数字不能加单位 4.只有定位盒子才有z-index属性 定位的特殊性质1.行内元素添加绝对或固定定位，可以直接设置高度和宽度 2.块级元素添加绝对或固定定位，未设置宽高，会脱标，默认内容大小（类似浮动）（不会发生外边距合并） 3.和浮动不同，绝对或固定定位会压住你标准流文字等内容 元素的显示和隐藏1.displaydisplay: none; 隐藏对象（不再占有原来的位置，可以用于js的下拉菜单等功能） display: block; 显示对象（也可以是转换块元素） 2.visiblevisibility: visible; 元素可视 visibility: hidden; 元素隐藏（仍然占有原来位置） 3.overflowoverflow: visible; 超出你的标签部分（固定大小）可见 overflow: hidden; 超出你的标签部分（固定大小）隐藏，如果有定位的盒子慎用，他会切掉你溢出布局标签的部分 overflow: scroll; 可添加滚动条 overflow: auto; 需要的时候添加滚动条","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"基数排序","slug":"基数排序","date":"2020-05-17T12:55:49.418Z","updated":"2020-10-26T09:00:35.835Z","comments":true,"path":"2020/05/17/ji-shu-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/ji-shu-pai-xu/","excerpt":"","text":"基数排序使用的大致思路是：根据关键字进行分类，再次排序，在分类，在排序，以此类推直至完成结果 如扑克牌中根据分13类，排序，再根据花色分类，再排序； 对百位数排序，先根据个位分类，排，再根据十位分类，排，再根据百位分类，排 //算法8.12 基数排序 #include &lt;iostream&gt; using namespace std; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #define MAXNUM_KEY 8 //关键字项数的最大值 #define RADIX 10 //关键字基数，此时是十进制整数的基数 #define MAX_SPACE 10000 typedef char KeysType; //定义关键字类型为字符型 typedef int InfoType; //定义其它数据项的类型 typedef struct { KeysType keys[MAXNUM_KEY]; //关键字 InfoType otheritems; //其他数据项 int next; }SLCell; //静态链表的结点类型 typedef struct { SLCell r[MAX_SPACE]; //静态链表的可利用空间，r[0]为头结点 int keynum; //记录的当前关键字个数 int recnum; //静态链表的当前长度 }SLList; //静态链表类型 typedef int ArrType[RADIX]; //指针数组类型 void InitList(SLList *L) { //初始化静态链表L（把数组D中的数据存于L中） char c[MAXNUM_KEY],c1[MAXNUM_KEY]; int i,j,n,max; //max为关键字的最大值 max=-10000; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAX_SPACE&lt;&lt;&quot;个。\\n&quot;; cin&gt;&gt;n; while(n&gt;MAX_SPACE) { cout&lt;&lt;&quot;您输入的个数超过上限，请重新输入，不超过&quot;&lt;&lt;MAX_SPACE&lt;&lt;&quot;个。\\n&quot;; cin&gt;&gt;n; } int *D=new int[n]; cout&lt;&lt;&quot;请输入&quot;&lt;&lt;n&lt;&lt;&quot;个排排序的数据：\\n&quot;; for(i=0;i&lt;n;i++) { cin&gt;&gt;D[i]; if(max&lt;D[i]) max=D[i]; } (*L).keynum=(int)(ceil(log10(max))); //存放十进制的位数 (*L).recnum=n; for(i=1;i&lt;=n;i++) { itoa(D[i-1],c,10); //将10进制整型转化为字符型,存入c for(j=strlen(c);j&lt;(*L).keynum;j++) //若c的长度&lt;max的位数,在c前补&#39;0&#39; { strcpy(c1,&quot;0&quot;); strcat(c1,c); strcpy(c,c1); } for(j=0;j&lt;(*L).keynum;j++) (*L).r[i].keys[j]=c[(*L).keynum-1-j]; } } int ord(char c) { //返回k的映射(个位整数) return c-&#39;0&#39;; } void Distribute(SLCell *r,int i,ArrType &amp;f,ArrType &amp;e) { //静态链表L的r域中记录已按（keys[0], …, keys[i-1]）有序 //本算法按第i个关键字keys[i]建立RADIX个子表，使同一子表中记录的keys[i]相同。 //f[0..RADIX-1]和e[0..RADIX-1]分别指向各子表中第一个和最后一个记录（很重要！！！！） int j,p; for(j=0;j&lt;RADIX;++j) f[j]=0; //各子表初始化为空表 for(p=r[0].next;p;p=r[p].next) { j=ord(r[p].keys[i]); //ord将记录中第i个关键字映射到[0..RADIX-1] if(!f[j]) f[j]=p; //f[j]为空，则直接赋值 else r[e[j]].next=p; //若不为空，则将其排在之前已有被赋值相同映射关键字的r的next的next里 e[j]=p; //将p所指的结点插入第j个子表中 }//for }//Distribute int succ(int i) { //求后继函数 return ++i; } void Collect (SLCell *r,int i,ArrType &amp;f,ArrType &amp;e) { //本算法按keys[i]自小至大地将f[0..RADIX-1]所指各子表依次链接成一个链表 //e[0..RADIX-1]为各子表的尾指针 int j,t; for(j=0;!f[j];j=succ(j)); //找第一个非空子表，succ为求后继函数 r[0].next=f[j];t=e[j]; //r[0].next指向第一个非空子表中第一个结点 while(j&lt;RADIX-1) { for(j=succ(j);j&lt;RADIX-1&amp;&amp;!f[j];j=succ(j)) ; //找下一个非空子表 if(f[j]) {r[t].next=f[j];t=e[j];} //链接两个非空子表 }//while r[t].next=0; //t指向最后一个非空子表中的最后一个结点 }//Collect void RadixSort(SLList &amp;L) { //L是采用静态链表表示的顺序表 //对L做基数排序，使得L成为按关键字自小到大的有序静态链表，L.r[0]为头结点 int i; ArrType f,e; for(i=0;i&lt;L.recnum;++i) L.r[i].next=i+1; //next指向i+1，即下一个记录 L.r[L.recnum].next = 0; //将L改造为静态链表 最尾部的next为0 for(i=0;i&lt;L.keynum;++i) { //按最低位优先依次对各关键字进行分配和收集 Distribute(L.r,i,f,e); //第i趟分配 Collect(L.r,i,f,e); //第i趟收集 }//for } // RadixSort void print(SLList L) { //按数组序号输出静态链表 int i,j; for(i=1;i&lt;=L.recnum;i++) { for(j=L.keynum-1;j&gt;=0;j--) cout&lt;&lt;L.r[i].keys[j]; cout&lt;&lt;endl; } } void Sort(SLList L,int adr[]) { //求得adr[1..L.length]，adr[i]为静态链表L的第i个最小记录的序号 int i=1,p=L.r[0].next; while(p) { adr[i++]=p; p=L.r[p].next; } } void Rearrange(SLList *L,int adr[]) { //adr给出静态链表L的有序次序，即L.r[adr[i]]是第i小的记录。 //本算法按adr重排L.r，使其有序。算法10.18(L的类型有变) int i,j,k; for(i=1;i&lt;=(*L).recnum;i++){ if(adr[i]!=i) { j=i; (*L).r[0]=(*L).r[i]; //r[0]用于暂存记录(*L).r[i] while(adr[j]!=i) { //调整(*L).r[adr[j]]的记录到位直到adr[j]=i为止 k=adr[j]; (*L).r[j]=(*L).r[k]; adr[j]=j; j=k; //记录按序到位 } (*L).r[j]=(*L).r[0]; //将原来最初始的记录置于链表到达的最后一个点 adr[j]=j; } } } int main() { SLList l; int *adr; InitList(&amp;l); RadixSort(l); adr=new int[l.recnum]; Sort(l,adr); Rearrange(&amp;l,adr); cout&lt;&lt;&quot;排序后(重排记录):\\n&quot;; print(l); } 1.稳定排序 2.适用于顺序表和链表,一般采用静态链式 3.时间复杂度为O(d(n+rd))/O(n) 空间复杂度为O(n+rd) 4.但是它的使用有严格要求，必须知道各级关键字的主次关系和各级关键字的取值范围","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"归并排序","slug":"归并排序","date":"2020-05-17T11:52:57.097Z","updated":"2020-05-17T12:32:39.626Z","comments":true,"path":"2020/05/17/gui-bing-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/gui-bing-pai-xu/","excerpt":"","text":"归并排序将相邻的两个记录（序列）排序，并成一个有序序列，并继续上述操作 //算法8.11 归并排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }RedType; typedef struct { RedType *r; int length; }SqList; void Create_Sq(SqList &L) { int i,n; cout","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"简单选择排序","slug":"简单选择排序","date":"2020-05-17T11:35:13.462Z","updated":"2020-10-26T09:00:27.784Z","comments":true,"path":"2020/05/17/jian-dan-xuan-ze-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/jian-dan-xuan-ze-pai-xu/","excerpt":"","text":"简单选择排序选择关键字储存最小的记录：和表中的记录进行一一对比，选出最小记录放在开头，接着从第二个记录继续开始 //算法8.6 简单选择排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void SelectSort(SqList &amp;L) { //对顺序表L做简单选择排序 int i,j,k; ElemType t; for(i=1;i&lt;L.length;++i) { //在L.r[i..L.length] 中选择关键字最小的记录 k=i; for(j=i+1;j&lt;=L.length;++j) if(L.r[j].key&lt;L.r[k].key) k=j; //k指向此趟排序中关键字最小的记录 if(k!=i) {t=L.r[i];L.r[i]=L.r[k];L.r[k]=t;} //交换r[i]与r[k] } //for } // SelectSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); SelectSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序，但如果是采用“交换记录”，则会导致不稳定现象 2.顺序，链式皆可以使用 3.时间复杂度O( n^2 ),比直接插入快。 空间复杂度为O(l1).","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"快速排序","slug":"快速排序","date":"2020-05-17T10:28:42.342Z","updated":"2020-10-26T09:00:22.389Z","comments":true,"path":"2020/05/17/kuai-su-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/kuai-su-pai-xu/","excerpt":"","text":"快速排序设置个关键字，将大的放在它后面，小的放在前面，分成两个子表，并且重复上述过程，直到每一个子表只有一个记录为止 //算法8.5 快速排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 int Partition(SqList &amp;L,int low,int high) { //对顺序表L中的子表r[low..high]进行一趟排序，返回枢轴位置 int pivotkey; L.r[0]=L.r[low]; //用子表的第一个记录做枢轴记录 pivotkey=L.r[low].key; //枢轴记录关键字保存在pivotkey中 while(low&lt;high) { //从表的两端交替地向中间扫描 while(low&lt;high&amp;&amp;L.r[high].key&gt;=pivotkey) --high; L.r[low]=L.r[high]; //将比枢轴记录小的记录移到低端 while(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey) ++low; L.r[high]=L.r[low]; //将比枢轴记录大的记录移到高端 }//while L.r[low]=L.r[0]; //枢轴记录到位 return low; //返回枢轴位置 }//Partition void QSort(SqList &amp;L,int low,int high) { //调用前置初值：low=1; high=L.length; //对顺序表L中的子序列L.r[low..high]做快速排序 int pivotloc; if(low&lt;high) { //长度大于1 pivotloc=Partition(L,low,high); //将L.r[low..high]一分为二，pivotloc是枢轴位置 QSort(L,low,pivotloc-1); //对左子表递归排序 QSort(L,pivotloc+1,high); //对右子表递归排序 } } //QSort void QuickSort(SqList &amp;L) { //对顺序表L做快速排序 QSort(L,1,L.length); } //QuickSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); QuickSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.不稳定排序 2.多用于顺序结构 3.时间复杂度O(log2 n)。 空间复杂度为O(log2 n), 最坏O(n). 最坏情况是逆序，或基本有序（顺序）","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-05-17T10:25:30.973Z","updated":"2020-12-18T15:59:54.939Z","comments":true,"path":"2020/05/17/mou-pao-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/mou-pao-pai-xu/","excerpt":"","text":"冒泡排序将关键字大的记录“下沉”,与小的记录进行交换 //算法8.4 冒泡排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void BubbleSort(SqList &L) { //对顺序表L做冒泡排序 int m,j,flag; ElemType t; m=L.length-1; flag=1; //flag用来标记某一趟排序是否发生交换 while((m>0)&&(flag==1)) { flag=0; //flag置为0，如果本趟排序没有发生交换，则不会执行下一趟排序 for(j=1;jL.r[j+1].key) { flag=1; //flag置为1，表示本趟排序发生了交换 t=L.r[j];L.r[j]=L.r[j+1];L.r[j+1]=t; //交换前后两个记录 } //if --m; } //while } //BubbleSort void Create_Sq(SqList &L) { int i,n; cout","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"希尔排序","slug":"希尔排序","date":"2020-05-17T09:07:40.698Z","updated":"2020-10-26T08:58:54.711Z","comments":true,"path":"2020/05/17/xi-er-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/xi-er-pai-xu/","excerpt":"","text":"希尔排序通过分组进行大浮动跳跃性排序，并且分组的形式是以设定的增量为基准 //算法8.3 希尔排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void ShellInsert(SqList &amp;L,int dk) { //对顺序表L做一趟增量是dk的希尔插入排序 int i,j; for(i=dk+1;i&lt;=L.length;++i) if(L.r[i].key&lt;L.r[i-dk].key) { //需将L.r[i]插入有序增量子表 L.r[0]=L.r[i]; //暂存在L.r[0] for(j=i-dk;j&gt;0&amp;&amp; L.r[0].key&lt;L.r[j].key;j-=dk) L.r[j+dk]=L.r[j]; //记录后移，直到找到插入位置 L.r[j+dk]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //for } //ShellInsert void ShellSort(SqList &amp;L,int dt[ ],int t){ //按增量序列dt[0..t-1]对顺序表L作t趟希尔排序 int k; for(k=0;k&lt;t;++k) ShellInsert(L,dt[k]); //一趟增量为dt[t]的希尔插入排序 } //ShellSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); int i,t;//增量数组的长度 int *dt=new int[MAXSIZE];//增量数组 cout&lt;&lt;&quot;请输入增量个数：\\n&quot;; cin&gt;&gt;t; for(i=0;i&lt;t;i++) { cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;个增量:\\n&quot;; cin&gt;&gt;dt[i]; } ShellSort(L,dt,t); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.不稳定排序 2.仅适用于顺序表 3.时间复杂度取决于增量的决定，最少可以减少到n(log2 n)^2, n^3/2等。 空间复杂度为O(1),只需要一个r[0] 对于增量的选取很重要，希尔自带的增量设定为 {N/2, (N / 2)/2, …, 1} ，叫做希尔增量，常用但是效果并不拔群，其余的有 Hibbard：{1, 3, …, 2^k-1}，Sedgewick：{1, 5, 19, 41, 109…} 等","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"折半插入排序","slug":"折半插入排序","date":"2020-05-17T08:36:10.446Z","updated":"2020-10-26T09:01:35.198Z","comments":true,"path":"2020/05/17/zhe-ban-cha-ru-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/zhe-ban-cha-ru-pai-xu/","excerpt":"","text":"折半插入排序其实就是直接插入排序引入了折半的思想 //算法8.2 折半插入排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表 void BInsertSort(SqList &amp;L){ //对顺序表L做折半插入排序 int i,j,low,high,m; for(i=2;i&lt;=L.length;++i) { L.r[0]=L.r[i]; //将待插入的记录暂存到监视哨中 low=1; high=i-1; //置查找区间初值 while(low&lt;=high) { //在r[low..high]中折半查找插入的位置 m=(low+high)/2; //折半 if(L.r[0].key&lt;L.r[m].key) high=m-1; //插入点在前一子表 else low=m+1; //插入点在后一子表 }//while for(j=i-1;j&gt;=high+1;--j) L.r[j+1]=L.r[j]; //记录后移 L.r[high+1]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //for } //BInsertSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); BInsertSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.仅适用于顺序表 3.时间复杂度为O(n^2)，但是平均性能&gt;直接插入。 空间复杂度为O(1),只需要一个r[0]","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"直接插入排序","slug":"直接插入排序","date":"2020-05-17T08:26:32.728Z","updated":"2020-10-26T08:58:13.811Z","comments":true,"path":"2020/05/17/zhi-jie-cha-ru-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/zhi-jie-cha-ru-pai-xu/","excerpt":"","text":"直接插入排序这里采用的是从后向前的比较方式，（从前向后其实也可以） 有点像打牌，抽牌，然后选择地方放好 //算法8.1 直接插入排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void InsertSort(SqList &amp;L) { //对顺序表L做直接插入排序 int i,j; for(i=2;i&lt;=L.length;++i) if(L.r[i].key&lt;L.r[i-1].key) { //&quot;&lt;&quot;，需将r[i]插入有序子表 L.r[0]=L.r[i]; //将待插入的记录暂存到监视哨中 L.r[i]=L.r[i-1]; //r[i-1]后移 for(j=i-2; L.r[0].key&lt;L.r[j].key;--j) //从后向前寻找插入位置 L.r[j+1]=L.r[j]; //记录逐个后移，直到找到插入位置 L.r[j+1]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //if } //InsertSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); InsertSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.适用于顺序表和链表 3.时间复杂度为O(n^2) 空间复杂度为O(1),只需要一个r[0]","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"CSS浮动+常见的网页布局","slug":"CSS浮动+常见的网页布局","date":"2020-05-16T16:00:00.000Z","updated":"2020-11-08T09:47:40.139Z","comments":true,"path":"2020/05/17/css-fu-dong-chang-jian-de-wang-ye-bu-ju/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/css-fu-dong-chang-jian-de-wang-ye-bu-ju/","excerpt":"","text":"浮动CSS三种传统布局：普通流 浮动 定位 标准流：标签按照默认排序 多个块级元素纵向排列用标准流，横向排列用浮动 选择器{ float: 属性值; //none不浮动 left向左浮动 right向右浮动 }//创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘 浮动特性：1.浮动元素会脱离标准流原来（排在浮动后面的）标准流的标签会顶上你原来的位置（但标准流之后的浮动挤不上去） （但是！！不会覆盖掉你的文字！，因为本身浮动是为环绕图片而设计的） 2.浮动元素会一行内显示并且元素顶部对齐紧贴在一起，不会有缝隙，装不开会另起一行 3.浮动元素具有行内块元素的特性添加浮动后自动附带行内块元素的特性 4.浮动自带文字环绕效果浮动的使用：一般采取先用标准流父元素排列上下位置，之后在子元素采取浮动，使得浮动在网页中间而不是左右侧 一般一个元素浮动了，他的兄弟标签最好也使用浮动 清除浮动布局1.父盒子不给高度，子盒子会自动撑开 2.父盒子不给高度的话，子盒子如果是浮动，父盒子会发生高度塌陷，导致高度变成0 所以总结：需要清除浮动！！！ clear: 属性值 一般属性值取both（常用）清楚两侧浮动，也有left，right 1.额外标签法，隔墙法，W3C推荐做法在浮动标签最后加多个一子标签（必须是块级元素），如： .clear{ clear: both; } &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;优点：通俗易懂，书写方便 缺点：结构化差 2.父级添加overflow//父级盒子 .box{ overflow: hidden; //或者auto } 优点：代码简洁 缺点：无法显示出溢出部分 3.：after伪元素法额外标签的升级版，给父元素添加 .clearfix:after { content: \"\"; display: block; //伪元素默认是行内元素，所以得转 height: 0; clear: both; visibility: hidden; } .clearfix { *zoom: 1; //兼容ie6，ie7 } /*一般类名定义为clearfix*/ 优点：结构简单 缺点：需要照顾低版本浏览器 代表网站：百度，淘宝，网易 4.双伪元素清除浮动.clearfix:before, .clearfix:after { content: &quot;&quot;; display: table; //转化为块级，并且一行显示 } .clear:after { clear: both; } .clearfix { *zoom: 1; //兼容ie6，ie7 }优缺点同上，代表网站：小米，腾讯 学成在线案例实际开发中导航栏不会直接用a标签，而是用li（列表）包含a标签的做法，1.语义更加清晰 2.故意对其关键字有被搜索引擎降权的风险 导航栏不给宽度是不想定死，让其自动适应","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"字典排序","slug":"字典排序","date":"2020-05-14T11:30:26.797Z","updated":"2020-05-17T12:34:15.125Z","comments":true,"path":"2020/05/14/zi-dian-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/zi-dian-pai-xu/","excerpt":"","text":"字典排序实现“ 1 2 3 ， 1 3 2 ， 2 1 3 ， 2 3 1 ， 3 1 2 ， 3 2 1 ”的序列排序方法 代码实现如下 #include #define swap(a,b) {int temp=a;a=b;b=temp;} //交换a，b值 void sort(int arr[],int start,int end)//冒泡排序，从start到end的排序，使用时注意是数组的下标，如数组下标0-3排序，sort（arr,0,3） { int i,j; for(i=0;iarr[a]) //这是字典排序第二步，获取arr[b]的值 { b=j1; break; } } swap(arr[a],arr[b]); //这是第三步 sort(arr,a+1,n-1); //这是第四步 } } int main() { int arr[]={1,2,4,3}; permutation(arr,4); return 0; } 总结得出字典排序算法四步法： 字典排序：第一步：从右至左找第一个左邻小于右邻的数，记下位置i，值list[a]第二部：从右边往左找第一个右边大于list[a]的第一个值，记下位置j，值list[b]第三步：交换list[a]和list[b]的值第四步：将i以后的元素重新按从小到大的顺序排列 举例：125643的下一个字典序列第一步：右边值大于左边的3&lt;4,4&lt;6,6&gt;5,则i=2，list[a]=5第二步：从右往左找出第一个右边大于list[a]=5的值，找到6&gt;5,j=3;list[b]=6;第三步：交换list[a]和list[b]的值，序列125643-&gt;126543第四步：将位置2以后的元素重新排序,126543-&gt;126345;结束： 126345即125643的下一个序列————————————————版权声明：本文为CSDN博主「Hi,Mr.Wang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_34672688/article/details/79557380","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"牛客算法课personnel note","slug":"牛客算法课personnel note","date":"2020-05-14T11:30:26.797Z","updated":"2020-10-26T08:59:32.432Z","comments":true,"path":"2020/05/14/niu-ke-suan-fa-ke-personnel-note/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/niu-ke-suan-fa-ke-personnel-note/","excerpt":"","text":"小基础floor(x) 小于等于x的最大值整数（向下取整） ceil(x) 大于等于x的最小整数（向上取整）( #include&lt;math.h&gt; ) int 32位二进制 第一个是符号位正数为0，负数为1，后面是数值位 -2^31——2^31-1 long long 64位二进制 double 64位二进制 （float别用了，太垃圾了） ~ 取反 &gt;&gt;右移 &lt;&lt;左移 pow(a,b) a的b次方 一维前缀和拥有数组x和数组y，满足： y0=x0; y1=x0+x1; y2=x0+x1+x2; 即想要求某区间和，可用y数组来相减得到结果 枚举一一举例，不重复 先列举出（求第x数到第y数的和，先求数组所有和，直接减），（求四个点的位置，并且四个点组成正方形，先求四个点中的两个点，），（求一排树数量，部份树被整段移走（可能重叠），直接标记1，移走的树部分-1） 取尺法分L，R两个指针，求数组区域&lt;=s的连续数组的个数，&lt;s R右移， &gt;=s L右移 使用前提： 1.能够维护一个区间，保证这个区间能够获得答案。 2.维护的具体操作可以左边移动一位、右边移动一位。 3.区间的变化是连续的而不是跳跃的。问题1就是比较跳跃的，双指针比较好，问题2不能跳跃。 贪心算法局部最优解，然后发现局部最优=整体最优解 桶排序列出数组， 将数组分到有限数量的桶里，将数据对比，有则让数组对应的数据+1，每个桶再个别排序 ，然后依次输出 桶越多，时间效率就越高，而桶越多，空间就越大 这里有位大佬我觉得写得很好，外加动漫配图，可以看一下（简单桶排序） https://www.cnblogs.com/bqwzx/p/11029264.html 计数排序基数排序和计数排序都可以看做桶排序，计数排序的思路是开一个长度为 maxValue-minValue+1 的数组，进行分配+收集: 分配。扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1。 收集。扫描一遍计数器数组，按顺序把值收集起来。 计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序 ， 计数排序非常浪费空间 VECTORvector是一个不限制数组长度的数组 top()返回第一个元素 back()返回最后一个元素 erase（int index,int size）删除 vector a; 迭代器Iterator用于访问问一个容器内的数据的指针 vector:: iterator it; C++ STL的二分查找binary search 返回bool，是否存在 low_bound 返回可插入的最小位置的迭代器，即返回第一个符合条件的元素位置，low_bound(a,a+11,55), a[0]到a[10]找55，返回迭代器，可将结果 -a 得到它的下标 第一个&lt;=x的位置 upper_bound 返回可插入的最大位置的迭代器，即返回最后一个符合条件的元素位置 第一个&gt;x的位置","categories":[{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"}],"tags":[],"author":"Hello"},{"title":"C++类型转换&java的一些对象","slug":"C++类型转换&java的一些对象","date":"2020-05-13T09:10:17.923Z","updated":"2020-11-15T05:40:12.960Z","comments":true,"path":"2020/05/13/c-lei-xing-zhuan-huan-java-de-yi-xie-dui-xiang/","link":"","permalink":"https://taylor12138.github.io/2020/05/13/c-lei-xing-zhuan-huan-java-de-yi-xie-dui-xiang/","excerpt":"","text":"头文件#include &quot;iostream&quot; #include &quot;stdlib.h&quot; #include &quot;cstdlib&quot; #include &quot;string&quot;使用cstdlib中c_str()使其转换成char，再转int和float/double C 库函数 int atoi(const char *str) 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。 C 库函数 double atof(const char *str) 把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 double price=atof(new_str[2].c_str()); int count=atoi(new_str[3].c_str());; javaStringBuilder：动态StringStringBuilder str = new StringBuilder(“Hello World!”, 25)//最大长度，可有可无str.append//增加 str.insert(6,”Beautiful”);//在第6个位置插入str.toString转String 自带栈：import java.until.Stack1 boolean empty()测试堆栈是否为空。2 Object peek( )查看堆栈顶部的对象，但不从堆栈中移除它。3 Object pop( )移除堆栈顶部的对象，并作为此函数的值返回该对象。4 Object push(Object element)把项压入堆栈顶部。5 int search(Object element)返回对象在堆栈中的位置，以 1 为基数。 用栈Stack 创建对象（类型不同） Stack&lt;Integer> stack = new Stack&lt;>(); Stack&lt;Character> stack = new Stack&lt;>(); //Stack stack=new Stack()也可 Hashmap的特点： hashmap和hashset的区别：一个是使用键值对存放（快一点），一个是对象存放底层实现是 链表数组，JDK 8 后又加了 红黑树实现了 Map 全部的方法key 用 Set 存放，所以想做到 key 不允许重复，key 对应的类需要重写 hashCode 和 equals 方法map.put(“zhang”, “31”)//存放键值对map.containsKey(“zhang”);//键中是否包含这个数据map.get(“zhang”);//通过键拿值map.isEmpty();//判空map.remove(“zhang”);//从键值中删除 利用set帮List去重复：List list = new ArrayList(); 。。。。。。。List newList = new ArrayList(new HashSet(list)); 或者 Set set = new HashSet(); List newList = new ArrayList(); set.addAll(list); newList.addAll(set); String[] s = {“aa”,”bb”,”cc”}; List ebsCodes = new ArrayList();List strlist = Arrays.asList(s); 等同于 ebsCodes.add(“USERNAME”); 等同于 (Arrays.asList(“USERNAME”,”REAP”,”NLS”)但不支持add，remove ebsCodes.add(“REAP”); ebsCodes.add(“NLS”);","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"CSS样式","slug":"CSS样式","date":"2020-05-09T16:00:00.000Z","updated":"2020-10-24T10:48:59.141Z","comments":true,"path":"2020/05/10/css-yang-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/css-yang-shi/","excerpt":"","text":"声明：可以使用chrome的F12浏览学习别人的样式并且调试你的代码引入CSS&lt;link rel=\"stylesheet\" href=\"css文件路径\"> 1.主要定义/*是类型选择,标签选择器*/ 元素（标签） { } /*选择所有元素*/ * { } /*的选择 选择多个类可以 &lt;div class=\"类1 类2\">&lt;/div>*/ .class(类名) { } /*id的选择,有点类似class，只能调用一次，别人切勿使用*/ #(id名) { } /*复合，后代选择器*/ 元素1（可以是类名） 元素2（可以是类名） { } /*只选择亲儿子，孙子不选*/ 元素1（可以是类名）>元素2（可以是类名） { } /*并集选择器，多个统一*/ 元素1, 元素2{ } 文字font-size: 12px //12像素大小文字 谷歌默认16px font-size: 12px/1.5 //12像素大小文字 行高为12*1.5=18 font-weight: xxx //字体加粗 text-align: center //文字水平居中对齐 text-indent: 10px //文本首行缩进,最好使用em，如text-indent: 2em,em是相对单位，当前1个文字元素的大小 text-decoration: none//取消下划线 line-height: 26px //行间距，用QQ截图可以偷偷测量，等于盒子高度时垂直居中 背景background-color //背景颜色 background: rgba(red（数值）,green(数值),blue（数值），透明度（0-1）) //背景颜色 透明化 background-image: url(地址)//背景图片，常见于标志，logo或者超大背景图片，有点是便于控制位置 baackground-repeat: no-repeat//背景平铺，默认为平铺，可以改成取消平铺 background-position: x y//背景图片的位置 ，可以使用方位名词，前后顺序可可以不一样top，center ，botton，left等（只写一个另外一个默认居中）。也可以使用精确单位x轴长度，y轴长度，（只写一个另外一个默认居中） background-attachment: scroll||fixed//背景图像随对象内容滚动||背景图像固定 复合：background: 颜色 图片地址 平铺 图像滚动 图片位置 列表list-style: none//去掉无序列表里 li 列表前面的小圆点 阴影box-shadow: 10px 10px 5px #888888; 分别对应阴影的水平，垂直和阴影，颜色 text-shadow: 1px 1px rgba(0,0,0,.2); 文字阴影效果 inputoutline: none; 消除输入边框 border: 0; 消除输入框的自带边框 透明opacity: 0.5 半透明 opacity: 1 不透明 2.伪类选择器/*a超链接类 或者写成 a的类名:XXX{}*/ a:link 选择所有未访问的链接 a:visited 选择所有已被访问的链接 a:hover 常用，选择鼠标指向的链接 a:ative 鼠标按下未弹起的链接 /*如果全部都写，请按照LVHA的顺序写*/ /*input类，把获得光标的inut选取出来改写CSS*/ input:focus 3.行块转换（块元素和行元素相互转换）display:block /*转块元素*/ display:inline /*转行内元素*/ display: inline-block /*转行内块*/ /*使文字垂直居中 让文字行高=盒子的行高 行高>盒子高度偏下，&lt;偏上*/ line-height: 盒子高度 4.CSS的三大特性1.层叠性样式冲突选择就近原则，把前面的覆盖掉，不冲突的不覆盖 2.继承性子标签会继承父标签的属性 3.优先级1.选择器相同，执行层叠性 2.选择器不同，继承/*(0,0,0,0)&lt;元素(0,0,0,1)&lt;类(0,0,1,0)&lt;id(0,1,0,0)&lt;行内样式style(1,0,0,0)&lt;！important无限大 （属性选择器input[class^=icon]{} 是（0,0,1,0）） （！important加在某属性后面，如color: green!important） 继承的你加了！important，权值还是（0，0，0，0），毕竟是继承过来的 3.复合选择器有权重叠加的问题 ul li{}权重为(0,0,0,1)+(0,0,0,1) li为(0,0,0,1) .nav li为（0，0，1，1） 权重会叠加，但是永不进位，不是二进制 （a:hover为(0,0,1,1)） 5.CSS盒子border（会影响盒子大小）border-style: solid(实线边框，最常用) dashed(虚线) dotted（点线边框） border-width: XXpx border-color: XX 复写： border: 1px solid red 边框分开写法： border-top: 1px solid red border-collapse:collapse /*相邻边框合并*/ border-top-right-radius: 15px; /*右上方改圆角，无top，right则全部都改*/ padding，内边距（会影响盒子大小，要设置了盒子宽高才会撑开）适用于文字大小不一的盒子，不设置宽高，直接设置padding，字少空间小。字多空间大 子容器盒子没设置宽高，父容器盒子padding不会被撑开 padding: 5px; padding: 0 10px; /*分别对应上下和左右*/ padding-top: 5px; /*仅写上方内边距*/ margin，外边距，盒子和盒子之间的距离（不会撑开）使用方法和padding是一致的 margin可以让块级盒子水平居中：1盒子必须有宽度，盒子左右外边距设置为auto margin: 0 auto;(不适用于定位) 行内元素或者行内块元素居中只需在其父元素CSS样式中添加：text-align: center; 外边距合并问题1.外边距合并指的是，当两个垂直外边距（2个margin）相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。而左右外边距不合并。2.在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。3.注释：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 关于text-indent：-999px这个是为了隐藏对象内的内容，然后在使用overflow: hidden进行隐藏 6.PSjpg： JPEG对色彩保留好，高清颜色多 gif：常用于小图片动画，可保留透明背景 png：结合jpg和gif，储存形式丰富，支持透明背景 PSD：保存PS设计稿 图层切图： 选定图层，右键，快速导出为png 切片切图： 切片工具—》选中—》左上角文件—》导出—》存储为Web所用格式—》JPEG（png可用于保存透明图）（保存的时候选”选中的切片“） ps插件切图：需要下载Cutterman插件 7.部署网站免费的远程服务器：http://free.3v.do/","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"emmet语法","slug":"emmet语法","date":"2020-05-09T16:00:00.000Z","updated":"2020-08-06T09:24:08.564Z","comments":true,"path":"2020/05/10/emmet-yu-fa/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/emmet-yu-fa/","excerpt":"","text":"Emmet语法插件于市面上大多前端编译软件，如VScode所带有的，便于快速写html和CSSh5想要生成多个标签：div*10，再回车（或者tab），即可生成10个div标签。 生成父子关系标签：div&gt;span,再回车（或者tab），即可生成包含span标签的div标签。 生成兄弟关系标签：div+span,再回车（或者tab）。 输入：.nav 直接生成一个class=“nav”的div标签。(默认div) 输入：#nav 直接生成一个id=“nav”的div标签。 输入：p.nav 直接生成一个class=“nav”的p标签。 输入：.nav$*5 直接生成5个class=“nav1”,class=“nav2”…..的div标签。($是自增符号) 输入：div{前端真好玩}*5 直接生成5个&lt;div&gt; 前端真好玩 &lt;/div&gt; CSS样式内输入：tac 直接生成text-align: center; 其他语法缩写同样类似，诸如w100—&gt;width: 100 格式化直接鼠标右键，格式化文档，即可直接让文档变整齐。 （或者想要每次保存后自动格式化，需要在首页—首选项—设置—搜索emmet.include,在setting.json下的用户，添加 “editor.formatOnType”: true, “editor.formatOnSave”: true 即可）","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"循环队列","slug":"循环队列","date":"2020-05-09T11:51:20.811Z","updated":"2020-10-26T08:58:48.437Z","comments":true,"path":"2020/05/09/xun-huan-dui-lie/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/xun-huan-dui-lie/","excerpt":"","text":"循环队列顺序定义typedef struct { QElemType *base;//初始化时动态分配存储空间 int front;//头指针 int rear;//尾指针 } SqQueue; 初始化//算法3.11 循环队列的初始化 Status InitQueue(SqQueue &Q) {//构造一个空队列Q Q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间 if (!Q.base) exit(OVERFLOW); //存储分配失败 Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空 return OK; } 求队列长度//算法3.12 求循环队列的长度 int QueueLength(SqQueue Q) {//返回Q的元素个数，即队列的长度 return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE; } 入队和出队（防止假溢出）（出头front，入尾rear）（rear无元素，front有元素）//算法3.13 循环队列的入队 Status EnQueue(SqQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满 return ERROR; Q.base[Q.rear] = e; //新元素插入队尾 Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1 return OK; } //算法3.14 循环队列的出队 Status DeQueue(SqQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 if (Q.front == Q.rear) return ERROR; //队空 e = Q.base[Q.front]; //保存队头元素 Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1 return OK; } 链队定义（还是像极了单链表，可知X链的形式一般都是单链表拓展）typedef struct QNode { QElemType data; struct QNode *next; } QNode, *QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 } LinkQueue; 链队的初始化Status InitQueue(LinkQueue &Q) {//构造一个空队列Q Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点 Q.front->next = NULL; //头结点的指针域置空 return OK; } 入队和出队（队头front无元素）//算法3.17 链队的入队 Status EnQueue(LinkQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 QueuePtr p; p = new QNode; //为入队元素分配结点空间，用指针p指向 p->data = e; //将新结点数据域置为e p->next = NULL; Q.rear->next = p; //将新结点插入到队尾 Q.rear = p; //修改队尾指针 return OK; } //算法3.18 链队的出队 Status DeQueue(LinkQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 QueuePtr p; if (Q.front == Q.rear) return ERROR; //若队列空，则返回ERROR p = Q.front->next; //p指向队头元素 e = p->data; //e保存队头元素的值 Q.front->next = p->next; //修改头指针 if (Q.rear == p) Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点 delete p; //释放原队头元素的空间 return OK; } 取队头元素//算法3.19 取链队的队头元素 SElemType GetHead(LinkQueue Q) {//返回Q的队头元素，不修改队头指针 if (Q.front != Q.rear) //队列非空 return Q.front->next->data; //返回队头元素的值，队头指针不变 }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"栈","slug":"栈","date":"2020-05-09T11:14:09.081Z","updated":"2020-05-17T12:35:55.947Z","comments":true,"path":"2020/05/09/zhan/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/zhan/","excerpt":"","text":"顺序栈定义typedef struct { SElemType *base;//栈底指针 SElemType *top;//栈顶指针 int stacksize;//栈可用的最大容量 } SqStack; 初始化Status InitStack(SqStack &S) { //构造一个空栈S S.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间 if (!S.base) exit(OVERFLOW); //存储分配失败 S.top = S.base; //top初始为base，空栈 S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE return OK; } 入栈和出栈（top无元素）//算法3.2 顺序栈的入栈 Status Push(SqStack &S, SElemType e) { // 插入元素e为新的栈顶元素 if (S.top - S.base == S.stacksize) return ERROR; //栈满 *(S.top++) = e; //元素e压入栈顶，栈顶指针加1 return OK; } //算法3.3 顺序栈的出栈 Status Pop(SqStack &S, SElemType &e) { //删除S的栈顶元素，用e返回其值 if (S.base == S.top) return ERROR;//栈空 e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e return OK; } 链栈定义，有点像链表typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack;初始化，无需链表的”头结点“Status InitStack(LinkStack &amp;S) { // 构造一个空栈 S，栈顶指针置空 S = NULL; return OK; }入栈和出栈//算法3.6 链栈的入栈 Status Push(LinkStack &S, SElemType e) {//在栈顶插入元素e LinkStack p; p = new StackNode; //生成新结点 p->data = e; //将新结点数据域置为e p->next = S; //将新结点插入栈顶 S = p; //修改栈顶指针为p return OK; } //算法3.7 链栈的出栈 Status Pop(LinkStack &S, SElemType &e) {//删除S的栈顶元素，用e返回其值 LinkStack p; if (S == NULL) return ERROR; //栈空 e = S->data; //将栈顶元素赋给e p = S; //用p临时保存栈顶元素空间，以备释放 S = S->next; //修改栈顶指针 delete p; //释放原栈顶元素的空间 return OK; }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"双向链表","slug":"双向链表","date":"2020-05-07T11:15:31.827Z","updated":"2020-05-17T12:35:32.455Z","comments":true,"path":"2020/05/07/shuang-xiang-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shuang-xiang-lian-biao/","excerpt":"","text":"双向链表的定义typedef struct DuLNode{ ElemType data; struct DuLNode *prior; struct DuLNode *next; //前驱和后继 }DuLNode，*DuLinkList 插入顺序 s=data; s->prior=p->prior; p->prior->next=s; s->next=p; p->prior=s;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"单链表","slug":"单链表","date":"2020-05-07T10:10:22.778Z","updated":"2020-05-17T12:35:13.050Z","comments":true,"path":"2020/05/07/dan-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/dan-lian-biao/","excerpt":"","text":"如定义单链表结构体，注意引用单链表元素用” -&gt; “,因为是*LinkList，使用单链表用的是LinkListtypedef struct LNode { ElemType data; //结点的数据域 struct LNode *next; //结点的指针域 }LNode,*LinkList; //LinkList为指向结构体LNode的指针类型 前插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头 } }后插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p,r; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 r=L; //尾指针r指向头结点 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=NULL; r-&gt;next=p; r=p; } }单链表的初始化，它的头节点（为了处理方便，在第一个节点之前增加的结点）没有赋值Status InitList_L(LinkList &L){ //功能1---算法2.5 单链表的初始化 //构造一个空的单链表L L=new LNode; //生成新结点作为头结点，用头指针L指向头结点 L->next=NULL; //头结点的指针域置空 return OK; } 它不能像顺序表一样随机取值，所以需要一一查找ElemType FindList(LinkList &amp;L,int i,ElemType &amp;x){ LinkList p=L; for(int j=0;j&lt;i;j++){ if(!(p-&gt;next))return ERROR; p=p-&gt;next; } x=p-&gt;data; return OK; }查找，按值查找int GetElem(LinkList &L,int &i,ElemType e) { LinkList p=L; int j=1; while(p->next) { p=p->next; if(p->data==e){ //查找成功 i=j; return OK; } j++; } return ERROR; //循环至查找失败 } 单链表的插入Status ListInsert_L(LinkList &amp;L,int i,ElemType &amp;e){ //功能3---算法2.8 单链表的插入 //在带头结点的单链表L中第i个位置之前插入元素e int j; LinkList p,s; p=L;j=0; while(p &amp;&amp; j&lt;i-1){p=p-&gt;next;++j;} //寻找第i-1个结点 if(!p||j&gt;i-1) return ERROR; //i大于表长+1或者小于1 s=new LNode; //生成新结点s s-&gt;data=e; //将结点s的数据域置为e s-&gt;next=p-&gt;next; //将结点s插入L中 p-&gt;next=s; return OK; }删除指定序号数据元素Status ListDelete(LinkList &L,int i){ LinkList p=L; int j=1; while(p->next&&jnext; j++; } if(!(p->next)||j>i)return ERROR; LinkList q=p->next; p->next=q->next; delete q; return OK; }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"顺序表","slug":"顺序表","date":"2020-05-07T09:31:08.736Z","updated":"2020-10-26T08:59:00.549Z","comments":true,"path":"2020/05/07/shun-xu-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shun-xu-biao/","excerpt":"","text":"如定义s顺序表结构体，注意引用顺序表元素用” . “,因为是SqList不是*S’q’Listtypedef struct{ ElemType *elem; //存储空间的基地址 int length; //当前长度 }SqList; 顺序表的初始化Status InitList_Sq(SqList &L){ //功能1--算法2.1 顺序表的初始化 //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) return OVERFLOW; //存储分配失败，overflow为-2 L.length=0; //空表长度为0 return OK; } 查找Status LocateElem(SqList *L, ElemType e) //按元素值查找 { int i=0; while (ilength && L->elem[i]!=e) i++; //查找元素e if (i>=L->length) //未找到时返回0 return 0; else return i+1; //找到后返回其逻辑序号 顺序表的插入Status ListInsert_Sq(SqList &amp;L,int i,ElemType e){ //功能3--算法2.3 顺序表的插入 //在顺序表L中第i个位置之前插入新的元素e //i值的合法范围是1&lt;=i&lt;=L.length+1 if(i&lt;1 || i&gt;L.length+1) return ERROR; //i值不合法,error为0 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length; //表长增1 return OK; }删除数据元素bool ListDelete(SqList &L,int i) //删除数据元素 { int j; if (iL.length) //参数错误时返回false return false; for (j=i-1;j","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"C++结构体初始化","slug":"C++结构体初始化","date":"2020-05-07T09:16:02.980Z","updated":"2020-05-17T12:35:02.720Z","comments":true,"path":"2020/05/07/c-jie-gou-ti-chu-shi-hua/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/c-jie-gou-ti-chu-shi-hua/","excerpt":"","text":"如定义药品结构体 typedef struct node{ //定义结构体 string name; float price; int count; float sale; int next; }Medicine; typedef struct{ //定义顺序表 Medicine r[MAX_Size+1]; int length; }SqList; 使用new的初始化 SqList *list_med=new SqList;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"C++求string数组元素个数","slug":"C++求String数组的元素个数","date":"2020-05-06T11:04:31.177Z","updated":"2020-07-27T13:28:02.604Z","comments":true,"path":"2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","link":"","permalink":"https://taylor12138.github.io/2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","excerpt":"","text":"不能使用str.length(),这个求的是单个字符串的大小，可以使用以下求得到长度 sizeof(str)/sizeof(str[0]) int[] a={1,2,3,4,5}; 数组长度为 a.length","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"finished gitee","slug":"finished gitee","date":"2020-05-04T17:01:10.659Z","updated":"2020-07-06T16:11:42.941Z","comments":true,"path":"2020/05/05/finished-gitee/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/finished-gitee/","excerpt":"","text":"原来是个人邮箱的设置必须得是公开的，我一直是设置为private，搞得一直错，终于搞出来了。 但是发现了gitee的一个缺点，每次部署完后都要去码云更新一次。。。","categories":[],"tags":[],"author":"Hello"},{"title":"HTML5的基本属性","slug":"HTML5的基本属性","date":"2020-05-04T16:25:58.368Z","updated":"2020-11-30T07:54:48.302Z","comments":true,"path":"2020/05/05/html5-de-ji-ben-shu-xing/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/html5-de-ji-ben-shu-xing/","excerpt":"","text":"1.基本标签介绍&lt;html&gt;&lt;/html&gt;``根标签 &lt;head&gt; &lt;/head&gt; 文档头部 &lt; title&gt; &lt;/title&gt; 文档标题 &lt;body&gt;&lt;/body&gt; 文档主体 2.在vscode里使用英文“！”可以直接生成基本结构ctrl+“+”可以放大（写代码）页面 &lt;!DOCTYPE html&gt; （） &lt;html lang=&quot;zh-CN&quot;&gt; (中文) &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;h1&gt;&lt;/h1&gt;---&lt;h6&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; &lt;br /&gt;&lt;strong&gt;&lt;/strong&gt;(字体加粗)&lt;del&gt;&lt;/del&gt;（字体删除线） &lt;em&gt;&lt;/em&gt; 标签告诉浏览器把其中的文本表示为强调的内容 3.盒子：类似于view，用于布局&lt;div&gt;&lt;/div&gt; //大盒子，独占一整行 &lt;span&gt;&lt;/span&gt; //小盒子 无法设置高度和宽度 4.img&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; height=&quot;&quot; width=&quot;&quot;&gt; //微信小程序是image alt为图片无法加载时显示的文字，title为鼠标移到图片上显示的文字提示, 但是对于height和width,一般只修改其中一个，另外一个就会跟着改变 src种绝对路径 \\ 相对路径 / （图片设置宽高一般设置为width：100%，heigh：100%，可以自动适应盒子） 5.超链接&lt; a&gt;&lt;a href=&quot;&quot; target=&quot;&quot; &gt;文本或者图像&lt;/a&gt; 类似于微信小程序中的navigator, href用于指定目标的url，可打开内部，外部链接 target用于来链接打开方式，默认_self _blank为在新窗口打开 锚点链接：设置href=#名字，如&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;可以快速跳转到第二集的页面位置 ​ 在于目标位置标签里添加id=”two” &lt;a href=&quot;&quot; title=&quot;&quot;&gt;移动到链接时会出现提示框 一般情况下，a如果包含有宽度的盒子，a需要转换为块级元素 &lt;a href=&#39;javascript:;&#39;&gt;xx&lt;/a&gt; 直接添加javascript:; 可以阻止链接跳转 6.特殊字符空格：&amp;nbsp (因无法识别大于号和小于号) 小于号：&amp;lt 大于号：&amp;gt 7.表格（用于数据）&lt;table&gt; ​ &lt;tr&gt; ​ &lt;td&gt;单元格文字&lt;/td&gt;或者&lt;th&gt;&lt;/th&gt; ​ &lt;/tr&gt; &lt;/table&gt; table是表格，tr是行，td是单元格（th可充当表头单元格）。还可以加入&lt;thead&gt;和 &lt;tbody&gt;来帮助CSS区分表格结构 单元格合并使用colspan=”（列）想要合并的单元个数”或者rowspan=”（行）想要合并的单元个数”，再删除多余的td（或th） 8.列表（用于布局）无序列表（ul里只能放li标签，所以其他容器放li里面就可以）&lt;ul&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ul&gt; 有序列表(规则同无序)&lt;ol&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ol&gt; 自定义列表(同上)&lt;dl&gt; ​ &lt;dt&gt;名词1&lt;/dt&gt; ​ &lt;dd&gt;名词1解释1&lt;/dd ​ &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 9.表单（用于填写信息，用户注册）&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot; maxlength=&quot;&quot;&gt;&lt;/form&gt;表单域 url地址为处理表单数据的地址，method有get，post 表单元素&lt;input&gt;&lt;input type=&quot;属性值&quot; name=&quot;&quot; value=&quot;&quot; check=&quot;&quot;&gt;输入 type可以为text，password，button，reset（重置）submit（用于提交），radio（单选框，必须添加name才能使用），checkbox（复选框）等 科普：submit是button的一个特例，用于处理大量表单数据，而此时input里的name是表单的名称，需要填写name才能提交表单数据 value为输入框内的提示语||充当提交给后台的数据||显示的文字 placeholder=&quot;Search...&quot; 显示提示的文字 check用于单选和复选的默认值 check=”checked” maxlength=“最大值” &lt;label for=&quot;sex&quot;&gt;男 &lt;/label&gt; label用于增加用户体验，点击范围内即可选中某input &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; label中的for对应input里的id 或者把input标签放在label里面也能达到同样的效果，此时不需要for和id 表单元素&lt;select&gt; 下拉列表&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;选项3&lt;/option&gt; //默认选中选项3 ... &lt;select&gt;表单元素&lt;textarea&gt; 文本域，可以写大量文字（个人介绍，评论）输入的评论作为element.value &lt;textarea> 文字 &lt;/textarea> //如果没文字textarea必须写到同一行 10 元素分类块元素，独占一行，是一个容器或者盒子如 &lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt;等 但&lt;p&gt; &lt;h&gt; 不能内置块级元素，只能放文字行元素，不能设置宽高，只能容纳文本或者其他行内元素 &lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;span&gt;等 但是&lt;a&gt;不能再放&lt;a&gt; 特殊情况&lt;a&gt;可以转块级行内块元素，能在同一行，也能设置宽高，但是行内块之间有缝隙 &lt;input/&gt; &lt;img/&gt; &lt;td&gt;行块的转换详情请看CSS里的《行块转换》h5标签推荐网址： http://www.w3school.com.cn/ http://developer.mozilla.org/zh-CN/ 11.HTML5新特性i9以上版本浏览器才支持 &lt;header&gt;: 头部标签 &lt;nav&gt;: 导航标签 &lt;article&gt;: 内容标签 &lt;section&gt;: 定义文档某个区域 &lt;aside&gt;: 侧边栏标签 &lt;footer&gt;: 尾部标签 /*实质上都和div差不多，只是语义化了而已，主要针对搜索引擎*/ /*但是在i9中，需要把这些元素转换成块级元素，所以移动端更喜欢使用这些标签*/ 新增：&lt;audio&gt;音频，&lt;video&gt;视频，抛弃flash等插件功能video尽量使用mp4格式，谷歌把音频，视频自动播放禁止了 &lt;video src=&quot;文件地址&quot; autoplay=&quot;autoplay&quot;自动播放 谷歌需要添加muted=&quot;muted&quot;（静音播放）,才能实现自动播放 controls=&quot;controls&quot;添加播放组件 loop=&quot;loop&quot;循环播放 poster=&quot;图片地址&quot; 视频封面显示图片 &gt;&lt;/video&gt; 遇到不兼容的情况可以写成 &lt;video width=&quot;320&quot; height=&quot;240&quot;&gt; &lt;source src=&quot;&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;&quot; type=&quot;video/ogg&quot;&gt; &lt;/video&gt;兼容问题同上 &lt;audio src=&quot;文件地址&quot;&gt;&lt;/audio&gt; 其功能性同video，如autoplay，loop，controls新增input的类型type=&quot;email&quot; type=&quot;url&quot; type=&quot;date&quot; type=&quot;number&quot; type=&quot;search&quot; type=&quot;tel&quot;(手机号码) 限制用户只能使用&quot;X&quot;类型 /*表单属性*/ &lt;input type=&quot;search&quot; required=&quot;required&quot; 填写字段不能为空 placeholder=&quot;XX&quot; 表单的提示信息 autofocus=&quot;autofocus&quot; 页面完成时自动聚焦到指定表单 autocomplete=&quot;on&quot; 打开历史记录功能，需要加上name属性，放在表单内，成功提交过，可以可选择&quot;off&quot; mutiple=&quot;multiple&quot; 选择多个文件上传 &gt;12.网站的缩略图标一般使用favicon.ico作为图标，主要的浏览器都支持。 通过第三方网站将png图片转化成ico图标，如http://www.bitbug.net/ 转化成功后，在&lt;head&gt; &lt;/head&gt;之间引入代码： &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico type=&quot;XX&quot;&gt;(网页那里有代码直接copy) 在某网页的页面，在它的网址后输入”/favicon.ico” 可以直接获取它的ico 13.网站TDK三大标签优化SEOSEO是搜索引擎优化，目的为对网站深度优化，使得网站排名位于搜索引擎使用后较前的位置。 1.title网站名-网站介绍（不超过30字） 2.description简要概述网站内容 3.keywords页面关键字，搜索引擎的关注点 logo的SEO优化logo里首先放一个h1标签来提权，h1里再放一个链接，用于返回至首页，为了让搜索引擎收录我们，我们要在链接里放文字（网站名称），但是文字不要显示出来（文字大小设置为0，font-size: 0），最后给链接一个title属性","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"主题与2d人物","slug":"主题与2d人物","date":"2020-05-03T16:50:47.307Z","updated":"2020-05-05T17:03:19.452Z","comments":true,"path":"2020/05/04/zhu-ti-yu-2d-ren-wu/","link":"","permalink":"https://taylor12138.github.io/2020/05/04/zhu-ti-yu-2d-ren-wu/","excerpt":"","text":"Start人物使用命令安装npm：npm uninstall hexo-helper-live2d npm install –save hexo-helper-live2d此时在blog/node_modeles下多出了一个“live2d-widget”下载动画model：这里是套用别人（大佬）的仓库https://github.com/xiazeyu/live2d-widget-models.git下载好后将packages里的所有文件拷贝到blog/node_modeles最后在win使用padnote _config.yml，把以下：live2d: enable: true pluginModelPath: assets/ model: use: live2d-widget-model-epsilon2_1 #模板目录，在node_modules里 display: position: right width: 150 height: 300 mobile: show: false #是否在手机进行显示 复制进去 再使用hexo clean g d进行部署 主题下载好了之后放入blog/themes里面（整个文件）再在win使用padnote _config.yml把theme: xx改成theme: (你要的主题名)最后部署","categories":[],"tags":[],"author":"Hello"},{"title":"My First Blog","slug":"My First Blog","date":"2020-05-02T17:33:53.947Z","updated":"2020-05-05T17:02:29.455Z","comments":true,"path":"2020/05/03/my-first-blog/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/my-first-blog/","excerpt":"","text":"Quick Start打开win+R进入cmd，然后在正确目录下进入：cd source_post(指定blog下) 基本操作用typora修改完毕后，1.使用“hexo clean”进行清理（1.5.若是发生主题等修改后，要接上hexo g 来建立）2.接上“hexo s”即可进入网站查看（退出键位：control+C，y）（本地浏览）3.再次部署到远端：hexo d 关于主题1.可以使用git clone 网址.git themes\\新建目录名（或者使用码云gitee进行下载，然后复制到themes目录下）2.cd.. (回到blog目录下)notepad _config.yml把记事本里面的theme：xx修改成theme：主题目录名3.重新执行”基本操作” 参考文献 https://hexo.io/docs/one-command-deployment.html)","categories":[],"tags":[],"author":"Hello"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"},{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"},{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"},{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[]}