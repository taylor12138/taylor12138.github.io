{"meta":{"title":"Hexo","subtitle":"Books are the ladder of human progress","description":"","author":"Hello","url":"https://taylor12138.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-05-03T17:20:07.000Z","updated":"2020-05-04T06:33:11.259Z","comments":true,"path":"categories/index.html","permalink":"https://taylor12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-05-04T06:35:25.450Z","comments":true,"path":"about/index.html","permalink":"https://taylor12138.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-05-03T17:21:52.000Z","updated":"2020-05-04T06:33:52.664Z","comments":true,"path":"contact/index.html","permalink":"https://taylor12138.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-05-03T17:22:42.000Z","updated":"2020-05-04T06:34:25.403Z","comments":true,"path":"friends/index.html","permalink":"https://taylor12138.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-03T17:17:32.000Z","updated":"2020-05-04T06:33:28.454Z","comments":true,"path":"tags/index.html","permalink":"https://taylor12138.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Chrome的探索","slug":"Chrome的探索","date":"2021-08-21T16:00:00.000Z","updated":"2021-08-22T08:17:22.251Z","comments":true,"path":"2021/08/22/chrome-de-tan-suo/","link":"","permalink":"https://taylor12138.github.io/2021/08/22/chrome-de-tan-suo/","excerpt":"","text":"浏览器结构 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 呈现引擎：用于CSS格式化HTML内容和图片 Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。 多进程一般一个应用对应 -&gt; 一个进程 开发一个浏览器，它可以是单进程多线程的应用，也可以是使用 IPC 通信的多进程应用。 Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程 chrome多进程的优点 某一渲染进程出问题不会影响其他进程 更为安全，在系统层面上限定了不同进程的权限 缺点：由于不同进程间的内存不共享，不同进程的内存常常需要包含相同的内容。（意思就是内存占用大呗） 如果 Chrome 运行在强大的硬件上，它会分割不同的服务到不同的进程，这样 Chrome 整体的运行会更加稳定，但是如果 Chrome 运行在资源贫瘠的设备上，这些服务又会合并到同一个进程中运行，这样可以节省内存 参考链接 https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React-native","slug":"React-native","date":"2021-06-24T16:00:00.000Z","updated":"2021-08-22T11:52:10.594Z","comments":true,"path":"2021/06/25/react-native/","link":"","permalink":"https://taylor12138.github.io/2021/06/25/react-native/","excerpt":"","text":"1.React Native概述引入关于React Native一些人的评价 优点： 1.完全采用JavaScript 2.跨平台，Write Once, Run anywhere变得可能，尤其是Android和IOS两端 3.社区给力，React Native有着强大的社区，众多开发者提供了各种类型的组件（对比国内阿里系，看起来就是某个人的绩效） 缺点： 1.复杂的状态管理（让我想起里被redux支配的恐惧），即使你会使用React，但也觉得它的页面切换有点绕 2.创建新的原生组件复杂。如果要创建一个之前从未出现过的原生组件，不仅需要懂得Android开发，还得懂得IOS开发 安装依赖Node、JDK 和 Android Studio。 虽然你可以使用任何编辑器来开发应用（编写 js 代码），但你仍然必须安装 Android Studio 来获得编译 Android 应用所需的工具和环境。(记得JDK一定要装1.8版本的（2021年）！！！) 苹果公司目前只允许在 Mac 电脑上开发 iOS 应用。如果你没有 Mac 电脑，那么只能考虑使用沙盒环境，或者先开发 Android 应用了。 跟着官网搭建环境 https://reactnative.cn/docs/environment-setup 然后可以在vscode上运行命令创建react-native项目 npx react-native init AwesomeProject （使用 React Native 内建的命令行工具来创建一个名为”AwesomeProject”的新项目。这个命令行工具不需要安装，可以直接用 node 自带的npx命令来使用：） 而且也推荐装Yarn，它是Facebook提供的替代npm的工具，可以加速node模块的下载 npm install yarn -g // 使用npm全局安装yarn 检查是否安装成功 yarn -v 安卓模拟器不过听说Android studio本身自带的模拟器又卡又慢，附上模拟器推荐的网址 https://blog.csdn.net/huanhuan59/article/details/80281509 比如下载夜神模拟器，然后在目录的bin文件夹下（连接Android studio（夜神的端口号是62001）） nox_adb.exe connect 127.0.0.1:62001 之后连接就可以输入adb connect 127.0.0.1:62001命令连接上模拟器 adb connect 127.0.0.1:62001 踩坑之路：连接后运行 npx react-native run-android，给我报了No connected devices的错误，，而且我在连接adb的时候出现这种情况 这种情况下说明你的模拟器的adb版本太低，被杀死了(无语，研究了好久这个问题) 处理方式：先把你夜神模拟器中的nox_adb.exe删除，然后在你的SDK里面的platform-tools中找到adb.exe,把你的SDK里面的adb复制到夜神模拟器的bin中，记得要改名字（注意要把adb.exe改为nox_adb.exe） 真机 准备一台 Android 手机, 通过数据线 连接 到电脑，设置启用 USB调试 一般的手机在 设置 中可以直接找到 开发者选项 进行开启, 如果 找不到 , 就自行百度查一下 手机连接电脑成功后运行检测命令 adb devices , 如果有输出设备列表与 ID 相关的字符串就证明手机和电脑是连接成功了，如果没有显示设备号，则说明连接有问题，一定要保证手机和电脑是正常连接状态 下载投影工具scrcpy 解压之后，打开scrpy.exe即可 踩坑之路：使用小米手机安装RN的项目会报错：Task :app:installDebug FAILED 解决方法：先检查了一下开发者选项，USB调试、未知源 都是开启的； 然后发现 “启用MIUI优化”这一项是开启的，把它关掉（设置—-更多设置—-开发者选项—-启用MIUI优化 关闭） 确保你先运行了模拟器或者连接了真机，然后在你的项目目录中运行yarn android或者yarn react-native run-android： cd AwesomeProject yarn android # 或者 npm run android # 或者 yarn react-native run-android # 或者 npx react-native run-android 踩坑之路：Could not receive a message from the daemon 解决方法：关闭电脑的移动热点，问题即解决。 运行成功 项目目录介绍App.js：项目根组件 index.js：项目入口文件 _tests_：测试文件 app.json：配置文件 metro.config.js：facebook的工程构建工具 .prettierrc.js：控制代码格式化的风格 顺便推荐两个VScode常用的RN插件 Prettier - Code formatter（负责格式化）、React-Native snippets（快捷输入） jsx模板生成的快捷键（类式组件）： rnc jsx模板生成的快捷键（函数式组件）： rnf 2.React Native基本语法三个对象这里介绍三个对象 StyleSheet，我们建议使用StyleSheet.create来集中定义组件的样式，通过 create 另外定义style样式并且导入，里面的属性名要使用驼峰命名法 View，视图组件,相当于div标签，不能放文本，不能绑定点击事件 （点击事件必须由 TouchableOpacity替代 ） Text，文本组件，相当于p标签，文字一定要放在其中，支持绑定点击事件 numberOfLines属性，用于限制文本行数 ellipsizeMode属性，一行写不完，以 … 的形式省略 import React from 'react' import { StyleSheet, View, Text } from 'react-native' const App = () => { //空标签，它也可以实现fragment的效果 return ( &lt;> &lt;View style={styles.view}> &lt;Text>helloWorld&lt;/Text> &lt;/View> &lt;/> ) } // 定义对象样式 const styles = StyleSheet.create({ view: { height: 200, width: 200, backgroundColor: \"rgba(200, 255, 0, 0.5)\", color: 'red' //hello world不会变成红色 } }); export default App; React Native的样式RN的默认样式： flex布局 方向 flex-direction: column 在react-native中没有样式继承，每一个组件都要单独设置样式 单位不能加 &#39;px&#39;、&#39;vw&#39;、&#39;vh&#39;，不能使用fontSize: &#39;100px&#39;的形式，必须使用 fontSize: 100；但是可以加百分比 &#39;%&#39;，width:&quot;100%&quot; 既然不能加&#39;vw&#39;、&#39;vh&#39;，如何实现依据屏幕的宽度 / 高度？ import { Dimensions } from 'react-native'; const windowWidth = Dimensions.get('window').width; const windowHeight = Dimensions.get('window').height; transfrom的使用 &lt;Text style={{transfrom:[{translateY:300}, {scale:2}]}}>&lt;/Text> 安卓内部单位不是px，是dp。所以需要把px转变为安卓内部的dp。此时可以在src文件下新建一个utils文件夹，然后新建styleKits.js文件 //设计稿宽度 / 元素宽度 = 手机屏幕 / 手机中元素的宽度 //手机中元素的宽度 = 元素宽度 * 手机屏幕 / 设计稿宽度 //设计稿的宽度由美工决定，这里暂定为375 import { Dimensions } from \"react-native\" export const screenHeight = Dimensions.get('window').height; export const screenWidth = Dimensions.get('window').width; export const pxToDp = (elePx) => screenWidth * elePx / 375; 按照以上公式，当使用到样式（px）时，直接套用该方法即可 相对之前学习的React改动对于属性state、props的使用，和在React里面如出一辙（函数组件的state、ref还是使用Hook） 移动端的点击事件：onPress import React from \"react\"; import { View, Text } from \"react-native\"; //类式组件的state export default class MyComponent extends React.Component { state = { isHot: true } change = () => { const { isHot } = this.state; this.setState({ isHot: !isHot }) } render() { const { isHot } = this.state return ( &lt;View> &lt;Text onPress={this.change}>today is {isHot ? 'hot' : 'cold'}&lt;/Text> &lt;/View> ) } } 类式组件的props，直接 this.props.属性名使用 函数式组件的props const MyComponent = (props) => { const { name, sex, age } = props; return ( &lt;ul> &lt;li>性名：{name}&lt;/li> &lt;li>性别：{sex}&lt;/li> &lt;li>年龄：{age}&lt;/li> &lt;/ul> ) } 所以结论：其实没有什么改动，只是多了很多React Native带的移动端组件罢了 3.React Native组件TouchableOpacity(点击)TouchableOpacity，点击触摸时会反馈给用户一个透明度的变化，它是一个绑定点击事件的块级标签 有 activeOpacity属性，用于调节点击时的透明度 import {TouchableOpacity } from \"react-native\"; Text-Input(输入框)Text-Input组件时React native的内置组件，不需要额外安装 引入组件 import {TextInput } from \"react-native\"; 通过 onChangeText事件来获取输入框的值 Text-Input属性 属性名 值 描述 autoCapitalize “none”, “sentence”, “words”, “characters” 字母大写模式 autoCorrent bool 设置拼写自动修正功能，默认为开启(true) autoFocus bool 设置是否默认获取到焦点，默认为关闭(false) keyboardType “default”, “number-pad”, “decimal-pad”, “phone-pad” 等 键盘类型 returnKeyType “done”, “go”, “next”, “search”, “send” 键盘上返回键类型 placeholder string 占位符 underlineColorAndroid string 下划线颜色 secureTextEntry bool 设置是否为密码安全输入框 onChange function 监听方法,文本框内容发生改变回调方法 onChangeText function 监听方法，文本框内容发生改变回调方法，该方法会进行传递文本内容（也就是默认传入文本内容作为默认参数） onSubmitEditing function 监听方法，当编辑提交的时候回调方法（提交）。不过如果multiline={true}的时候，该属性就不生效 更多 Text-Input 属性可以查看这个页面https://blog.csdn.net/u014484863/article/details/51732074 案例： import React from \"react\"; import { View, Text, TextInput, TouchableOpacity } from \"react-native\"; export default () => { const [email, setEmail] = React.useState('') const [password, setPassword] = React.useState('') const [intro, setIntro] = React.useState('') // onChangeText默认传入文本内容作为默认参数 function handleEmail(text) { setEmail(text); } function handlePassword(text) { setPassword(text); } function handleIntro(text) { setIntro(text); } function register() { alert('email' + email + '\\npassword' + password + '\\nintro' + intro); } return ( &lt;> &lt;View> &lt;TextInput underlineColorAndroid=\"transparent\" placeholder=\"请输入邮箱\" placeholderTextColor=\"#ccc\" autoCapitalize=\"none\" keyboardType=\"email-address\" returnKeyType=\"next\" onChangeText={handleEmail} >&lt;/TextInput> &lt;TextInput onChangeText={handlePassword} placeholder=\"请输入密码\" secureTextEntry={true}>&lt;/TextInput> &lt;TextInput onChangeText={handleIntro} placeholder=\"请输入信息\">&lt;/TextInput> {/* 提交按钮 */} &lt;TouchableOpacity onPress={register}> &lt;Text>注册&lt;/Text> &lt;/TouchableOpacity> &lt;/View> &lt;/> ) } Image(图片)Image组件时React native的内置组件，不需要额外安装 引入组件 import {Image } from \"react-native\"; 其实还有2个组件推荐， ScrollView，用于滑动的操作 import {ScrollView } from \"react-native\"; 它实际上所做的就是将一系列不确定高度的子组件装进一个确定高度的容器（通过滚动操作） ImageBackground,相当于以前的 div + 背景图片，因为在RN当中，是不存在背景图片这个属性的 标签一定要配套商 style属性，不然会报错 （至少配套上）style={{}} import {ImageBackground } from \"react-native\"; &lt;ImageBackground source={...} style={{width:100%, height:100%}}> &lt;/ImageBackground> Image 常用属性 source 资源定位 使用网络图片要用 uri，且一定要设置宽高 图片显示模式resizeMode contain（整体缩放）,按照正常的比例缩放到可以刚好放进来 cover不会变形(截屏)，放大图片至刚好覆盖住整个内容 stretch会变形（局部压缩），直接拉伸至设置的大小 blurRadius(模糊半径)：为图片添加一个指定半径的模糊滤镜。 案例 import React from \"react\"; import { Image, ScrollView } from \"react-native\"; export default () => { return ( &lt;> &lt;ScrollView> {/* 普通图片设置 */} &lt;Image source={require('./assets/1.png')}>&lt;/Image> {/* 网络图片设置,一定要设置宽高，不然不显示 */} &lt;Image style={{ margin: 10, width: 200, height: 200 }} source={{ uri: 'https://img2.baidu.com/it/u=3963436481,1344394108&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg' }}>&lt;/Image> &lt;Image style={{ margin: 10, width: 200, height: 200, resizeMode: 'contain' }} source={require('./assets/1.png')} >&lt;/Image> &lt;Image style={{ margin: 10, width: 200, height: 200, resizeMode: 'cover' }} source={require('./assets/1.png')} >&lt;/Image> &lt;Image style={{ margin: 10, width: 200, height: 200, resizeMode: 'stretch' }} source={require('./assets/1.png')} >&lt;/Image> &lt;/ScrollView> &lt;/> ) } 在 Android 上支持 GIF 和 WebP 格式图片 默认情况下 Android 是不支持 GIF 和 WebP 格式的。你需要在android/app/build.gradle文件中根据需要手动添加以下模块： dependencies { // 如果你需要支持Android4.0(API level 14)之前的版本 implementation 'com.facebook.fresco:animated-base-support:1.3.0' // 如果你需要支持GIF动图 implementation 'com.facebook.fresco:animated-gif:2.0.0' // 如果你需要支持WebP格式，包括WebP动图 implementation 'com.facebook.fresco:animated-webp:2.1.0' implementation 'com.facebook.fresco:webpsupport:2.0.0' // 如果只需要支持WebP格式而不需要动图 implementation 'com.facebook.fresco:webpsupport:2.0.0' } ActivityIndicator(加载)活动指示器组件，也可以叫它Loading，有一些比较耗时的操作，可能需要用户等待，那么可以使用活动指示器组件 ActivityIndicator告诉用户你需要等待（类似于一个圈圈在不停旋转） ActivityIndicator组件时React native的内置组件，不需要额外安装 常用属性 animating，是否显示转圈加载 color，滚轮的前景颜色 案例 import React, { Component } from \"react\"; import { TouchableOpacity, ActivityIndicator, Button } from \"react-native\"; export default class App extends Component { state = { animating: true } closeActivityIndicator = () => { this.setState({ animating: !this.state.animating }) } componentDidMount = () => this.closeActivityIndicator(); render() { const { animating } = this.state return ( &lt;> &lt;ActivityIndicator animating={animating} color=\"blue\" /> &lt;TouchableOpacity> &lt;Button onPress={this.closeActivityIndicator} title=\"切换显示loading\">&lt;/Button> &lt;/TouchableOpacity> &lt;/> ) } } Alert(提示框) React的弹窗组件，启动一个提示对话框，包含对应的标题和信息。你还可以指定一系列的按钮，点击对应的按钮会调用对应的 onPress 回调并且关闭提示框。默认情况下，对话框会仅有一个’确定’按钮。 iOS# 在 iOS 上你可以指定任意数量的按钮。每个按钮还都可以指定自己的样式，此外还可以指定提示的类别。参阅AlertButtonStyle来了解更多细节。 Android# 在 Android 上最多能指定三个按钮，这三个按钮分别具有“中间态”、“消极态”和“积极态”的概念： 如果你只指定一个按钮，则它具有“积极态”的属性（比如“确定”）；两个按钮，则分别是“消极态”和“积极态”（比如“取消”和“确定”）；三个按钮则意味着“中间态”、“消极态”和“积极态”（比如“稍候再说”，“取消”，“确定”）。 在 Android 上可以通过点击提示框的外面来取消提示框，但这一行为默认没有启用。你可以在Options额外参数来启用这一行为：{ cancelable: true }。 方法 alert() ：static alert(title, message?, buttons?, options?) 名称 类型 说明 title string Required The dialog’s title. Passing null or empty string will hide the title. message string An optional message that appears below the dialog’s title. buttons Buttons An optional array containg buttons configuration. options Options Android An optional Alert configuration for the Android. 案例 import React from \"react\"; import { Alert, TouchableOpacity, View, Text } from \"react-native\"; export default () => { const showAlert1 = () => Alert.alert(\"发送数据成功\") const showTip = () => Alert.alert(\"删除数据成功\") const showAlert2 = () => { // 传入内容，传入的数组对应不同的按钮，引发不同的事件 Alert.alert(\"警告\", '确认删除?', [ { text: '确认', onPress: () => showTip() }, { text: '取消', style: 'cancel' } ], //不能点击提示框的外面来取消提示框 { cancelable: false } ) } return ( &lt;> &lt;View style={{ alignItems: 'center' }}> &lt;TouchableOpacity onPress={showAlert1}> &lt;Text>发送&lt;/Text> &lt;/TouchableOpacity> &lt;TouchableOpacity onPress={showAlert2}> &lt;Text>删除&lt;/Text> &lt;/TouchableOpacity> &lt;/View> &lt;/> ) } Animating(动画)Animated是一个动画组件，旨在使动画变得流畅，强大并易于构建和维护。Animated侧重于输入和输出之间的声明性关系，以及两者之间的可配置变换，此外还提供了简单的 start/stop方法来控制基于时间的动画执行。 创建动画最基本的工作流程是先创建一个 Animated.Value ，将它连接到动画组件的一个或多个样式属性，然后使用Animated.timing()通过动画效果展示数据的变化： 常用属性： Value 驱动动画运行的一维标量值。一般使用new Animated.Value(0);来初始化。 常用方法： timing() 推动一个值按照一个缓动曲线而随时间变化。Easing模块定义了一大堆曲线，你也可以使用你自己的函数。 Config 参数有以下这些属性： duration: 动画的持续时间（毫秒）。默认值为 500. easing: 缓动函数。 默认为Easing.inOut(Easing.ease)。 delay: 开始动画前的延迟时间（毫秒）。默认为 0. isInteraction: 指定本动画是否在InteractionManager的队列中注册以影响其任务调度。默认值为 true。 useNativeDriver: 启用原生动画驱动。默认不启用(false)。 .start()方法用于开始一个动画 案例 import React from 'react' import { Animated, TouchableOpacity, StyleSheet } from 'react-native' export default () => { // 默认宽高 const animatedWidth = new Animated.Value(50) const animatedHeight = new Animated.Value(100) function animatedBox() { // 点击后，设置动画变化 Animated.timing(animatedWidth, { toValue: 200, //值到200 duration: 1000,//持续时间 useNativeDriver: false //不设置这个会有黄色的warn }).start() Animated.timing(animatedHeight, { toValue: 300, duration: 500, useNativeDriver: false }).start() } const animatedStyle = { width: animatedWidth, height: animatedHeight } return ( &lt;> &lt;TouchableOpacity onPress={animatedBox} style={styles.container}> &lt;Animated.View style={[styles.box, animatedStyle]}>&lt;/Animated.View> &lt;/TouchableOpacity> &lt;/> ) } const styles = StyleSheet.create({ container: { justifyContent: 'center', alignItems: 'center' }, box: { backgroundColor: 'blue', width: 50, height: 100 } }) Switch(开关)Switch是一个开关组件，一个“受控组件”（controlled component）。必须使用onValueChange回调来更新value属性以响应用户的操作。如果不更新value属性，组件只会按一开始给定的value值来渲染且保持不变，看上去就像完全点不动。 主要属性： onValueChange，切换开关回调的事件 value，开关指定的值 案例： import React, { useState } from 'react' import { View, Text, Switch } from 'react-native' export default () => { const label = { false: '关', true: '开' }; const [switchValue, setSwitchValue] = useState(true); const toggleSwitch = () => setSwitchValue(preState => !preState); return ( &lt;> &lt;View> &lt;Switch trackColor={{ false: \"#767577\", true: \"#81b0ff\" }} thumbColor={switchValue ? \"#f5dd4b\" : \"#f4f3f4\"} ios_backgroundColor=\"#3e3e3e\" onValueChange={toggleSwitch} value={switchValue}> &lt;/Switch> &lt;View>&lt;Text>当前状态是: {label[switchValue]}&lt;/Text>&lt;/View> &lt;/View> &lt;/> ) } StatusBar(状态栏)StatusBar组件是手机屏幕最上方的区域，包含运营商名称、网络情况、手机电池 可以通过它定制白天/夜晚 主题模式 由于StatusBar可以在任意视图中加载，可以放置多个且后加载的会覆盖先加载的。因此在配合导航器使用时，请务必考虑清楚StatusBar的放置顺序。 常用属性 barStyle，主题颜色，enum(‘default’, ‘light-content’, ‘dark-content’) hidden，隐藏显示 backgroundColor，状态栏的背景色，可以为transparent（透明）。 translucent，设置为true，配合backgroundColor: transparent可以把背景图片提上状态栏 animated，指定状态栏的变化是否应以动画形式呈现。目前支持这几种样式：backgroundColor, barStyle 和 hidden。 案例 import React, { useState } from 'react' import { Text, StatusBar, TouchableOpacity } from 'react-native' export default () => { const [hidden, sethidden] = useState(false) const [barStyle, setbarStyle] = useState('default'); const changeHidden = () => { sethidden(preState => !preState); } const changeBarStyle = () => { const temp = barStyle === 'light-content' ? 'dark-content' : 'light-content'; setbarStyle(temp); } return ( &lt;> &lt;StatusBar barStyle={barStyle} hidden={hidden}>&lt;/StatusBar> &lt;TouchableOpacity onPress={changeHidden}> &lt;Text>显示/隐藏&lt;/Text> &lt;/TouchableOpacity> &lt;TouchableOpacity onPress={changeBarStyle}> &lt;Text>改变主题颜色&lt;/Text> &lt;/TouchableOpacity> &lt;/> ) } 4.移动端服务器部署&amp;注意事项安卓访问本地服务器地址为 10.0.2.2:端口号，我们平时浏览器访问服务器都是 localhost:端口号 关于React Native的调试1.使用谷歌浏览器来调试 使用谷歌浏览器即可 不能查看标签结构 不能查看网络请求 2.使用rn推荐的工具 react-native-debugger来调试 (老师推荐使用这种方式) 可以查看标签结构 不能查看网络请求 3.想要查看网络请求 找到项目的入口文件 index.js 加入以下代码即可 GLOBAL.XMLHttpRequest = GLOBAL.originalXMLHttpRequest || GLOBAL.XMLHttpRequest 移动端路由导航、导航栏可以用以下的react-navigation框架 react-native从开源至今，一直存在几个无法解决的毛病，偶尔就会复发让人隐隐作痛，提醒你用的不是原生，其中包括列表的复用问题，导航跳转不流畅的问题等等。 终于facebook坐不住了，在前一段时间开始推荐使用react-navigation，并且在0.44发布的时将之前一直存在的Navigator废弃了。 react-navigation是致力于解决导航卡顿，数据传递，Tabbar和navigator布局，支持redux。虽然现在功能还不完善，但基本是可以在项目中推荐使用的。 import { createAppContainer } from 'react-navigation'; import { createStackNavigator } from 'react-navigation-stack' React navigation的部分使用规范 页面跳转和转场动画 安装（在项目中使用） yarn add react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view @react-navigation/stack @react-navigation/native 或者 npm i react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view @react-navigation/stack @react-navigation/native 代码 import * as React from 'react'; import { Button, View, Text } from 'react-native'; import { NavigationContainer } from '@react-navigation/native'; import { createStackNavigator } from '@react-navigation/stack'; function HomeScreen({ navigation }) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}> &lt;Text>Home Screen&lt;/Text> &lt;Button title=\"Go to Details\" onPress={() => navigation.navigate('Details')} /> &lt;/View> ); } function DetailsScreen() { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}> &lt;Text>Details Screen&lt;/Text> &lt;/View> ); } const Stack = createStackNavigator(); function App() { return ( &lt;NavigationContainer> &lt;Stack.Navigator initialRouteName=\"Home\" headerMode=\"none\"> &lt;Stack.Screen name=\"Home\" component={HomeScreen} /> &lt;Stack.Screen name=\"Details\" component={DetailsScreen} /> &lt;/Stack.Navigator> &lt;/NavigationContainer> ); } export default App; 路由要在 Stack.Navigator 中以Stack.Screen组件的格式进行存放 Screen的属性component属性直接放入路由组件 Navigator的属性headerMode=&quot;none&quot;隐藏页面路由的标题 当然，可以和Vue脚手架一样，在src下新建一个 nav.js文件，专门用于存放路由，此时我们将上图代码放入这个nav.js文件（App改问Nav） 然后再App.js文件写入Nav组件即可 import React from 'react' import { View, Text } from 'react-native' import Nav from './src/nav' export default function App() { return ( &lt;View style={{ flex: 1 }}> &lt;Nav>&lt;/Nav> &lt;/View> ) } 可以在 createStackNavigator里一一放置组件，有点类似路由的作用； 官方解释：一次渲染一个屏幕并提供屏幕之间的转换。当一个新屏幕打开时，它被放置在堆栈的顶部 格式为 传入的第一个参数为组件 （以对象的形式） 路由名: {screen: 组件名, navigationOptions: 配置选择（也可以自定义title、tabBarLabel等）} 主页面使用了createStackNavigator，子组件就会默认传入this.props.navigation。 navigation用于跳转页面和获取导航信息 然后，我们就可以在组件内进行路由跳转 this.props.navigation.navigate(&#39;路由名&#39;)可进行跳转 (跳转到 Brief 页面 + 传入名为 ‘book’ 的参数 )，接收的 Brief页面可以通过 this.props.navigation.state.params.book进行获取 this.props.navigation.goBack() 返回 const {navigation} = this.props reutrn( &lt;TouchableOpacity onPress={() => { navigation.navigate('Brief', { book: item }) }}> &lt;/TouchableOpacity> &lt;TouchableOpacity onPress={() => { navigation.goBack()}> &lt;/TouchableOpacity> ) //app.js import { createAppContainer } from 'react-navigation'; import { createStackNavigator } from 'react-navigation-stack' //这里分别引入了4个页面组件 import BottomNavigator from './page/root/rootPage' import BriefPage from './page/brief/briefPage' import ImgPage from './page/brief/ImgPage' import ListPage from './page/cate/ListPage' const AppStack = createStackNavigator( { // 首页组件设置：从rootPage引入的并且命名为BottomNavigator BottomNavigator: { screen: BottomNavigator, navigationOptions: { headerShown: false, } }, Login: { screen: Login }, Register: { screen: Register }, Brief: { screen: BriefPage }, ImgPage: { screen: ImgPage }, ListPage: { screen: ListPage } }, { mode: 'modal', headerMode: 'none', } ); export default createAppContainer(AppStack); UI框架框架推荐 react-native-elements 下载 需要使用到图标 因此也需要安装 react-native-vector-icons yarn add react-native-elements react-native-vector-icons 或者 npm i react-native-elements react-native-vector-icons 引入和使用 import { Icon } from 'react-native-elements' &lt;Icon name='rowing' /> react-native-vector-icons 的其他使用（使用UI库的icon时需要进行配置） 编辑 android/app/build.gradle 添加以下配置 project.ext.vectoricons = [ iconFontNames: [ 'MaterialIcons.ttf', 'EvilIcons.ttf' ] // Name of the font files you want to copy ] //这个时自定义添加字体时才配置 apply from: \"../../node_modules./React-native-vector-icons/fonts.gradle\" //这个是一定要配置的 重启项目 添加代码 如 import FontAwesome5 from 'react-native-vector-icons/FontAwesome5'; const icon = &lt;FontAwesome5 name={'comments'} />; 关闭黄色警告粘贴到index.js文件下 console.ignoredYellowBox = ['Warning: BackAndroid is deprecated. Please use BackHandler instead.','source.uri should not be an empty string','Invalid props.style key']; console.disableYellowBox = true // 关闭全部黄色警告 渐变色容器react-native-linear-gradient 下载 yarn add react-native-linear-gradient npm i react-native-linear-gradient 简单使用 import LinearGradient from 'react-native-linear-gradient'; &lt;LinearGradient colors={['#4c669f', '#3b5998', '#192f6a']} style={styles.linearGradient}> &lt;Text style={styles.buttonText}> Sign in with Facebook &lt;/Text> &lt;/LinearGradient> var styles = StyleSheet.create({ linearGradient: { flex: 1, paddingLeft: 15, paddingRight: 15, borderRadius: 5 }, buttonText: { fontSize: 18, fontFamily: 'Gill Sans', textAlign: 'center', margin: 10, color: '#ffffff', backgroundColor: 'transparent', }, }); 验证码输入框react-native-confirmation-code-field 下载 yarn add react-native-confirmation-code-field npm i react-native-confirmation-code-field 代码 import React, {useState} from 'react'; import {SafeAreaView, Text, StyleSheet} from 'react-native'; import { CodeField, Cursor, useBlurOnFulfill, useClearByFocusCell, } from 'react-native-confirmation-code-field'; const styles = StyleSheet.create({ root: {flex: 1, padding: 20}, title: {textAlign: 'center', fontSize: 30}, codeFiledRoot: {marginTop: 20}, cell: { width: 40, height: 40, lineHeight: 38, fontSize: 24, borderWidth: 2, borderColor: '#00000030', textAlign: 'center', }, focusCell: { borderColor: '#000', }, }); //验证码格子个数 const CELL_COUNT = 6; const App = () => { const [value, setValue] = useState(''); const ref = useBlurOnFulfill({value, cellCount: CELL_COUNT}); const [props, getCellOnLayoutHandler] = useClearByFocusCell({ value, setValue, }); return ( &lt;SafeAreaView style={styles.root}> &lt;Text style={styles.title}>Verification&lt;/Text> &lt;CodeField ref={ref} {...props} value={value} onChangeText={setValue} cellCount={CELL_COUNT} rootStyle={styles.codeFiledRoot} keyboardType=\"number-pad\"//弹窗显示数组键盘 textContentType=\"oneTimeCode\" renderCell={({index, symbol, isFocused}) => ( &lt;Text key={index} style={[styles.cell, isFocused &amp;&amp; styles.focusCell]} onLayout={getCellOnLayoutHandler(index)}> {symbol || (isFocused ? &lt;Cursor /> : null)} &lt;/Text> )} /> &lt;/SafeAreaView> ); }; export default App; react-native SVG推荐(就是我们常用的阿里巴巴矢量图标) yarn add react-native-svg react-native-svg-uri 日期组件推荐react-native-datepiker 用于日期填写 yarn add react-native-datepicker 基本使用（放出基本使用的代码居然使得hexo本身命令startprocessing卡死。。。） 定位组件推荐使用 react-native-amap-geolocation 使用高德地图进行定位 高德地图组件 分别使用了两个功能，一个是AndroidSDK和一个web服务 申请 高度地图的key（可以在b站https://www.bilibili.com/video/BV1e5411L7VV?p=49 ） （这里我个人设置密钥库口令为taylor） 踩坑之路： 其中关于PackageName, 如果配置了 build.gradle 文件，PackageName 应该以 applicaionId 为准，防止 build.gradle 中的 applicationId 与 AndroidMainfest.xml 中的 PackageName 不同，导致 key 鉴权不过。 调试版本使用 debug.keystore，命令为：keytool -list -v -keystore debug.keystore 发布版本使用 apk 对应的 keystore，命令为：keytool -list -v -keystore 项目下的debug.keystore 手机端打开GPS，不然会没有权限 手动配置： 下载依赖 yarn add react-native-amap-geolocation 配置文件 编辑 android/settings.gradle，设置项目路径： （+ 号表示要新增） + include ':react-native-amap-geolocation' + project(':react-native-amap-geolocation').projectDir = new File(rootProject.projectDir, '../node_modules./React-native-amap-geolocation/lib/android') 编辑 android/app/build.gradle，新增依赖： dependencies { + implementation project(':react-native-amap-geolocation') } 编辑 MainApplication.java：（注意rn0.61之后的版本里面，我们不再需要配置这个，也就是0.61版本以上的不用配置） + import cn.qiuxiang.react.geolocation.AMapGeolocationPackage; public class MainApplication extends Application implements ReactApplication { @Override protected List&lt;ReactPackage> getPackages() { @SuppressWarnings(\"UnnecessaryLocalVariable\") List&lt;ReactPackage> packages = new PackageList(this).getPackages(); // Packages that cannot be autolinked yet can be added manually here, for example: + packages.add(new AMapGeolocationPackage()); return packages; } } 自动配置（舒服，懂的都懂，一般情况下 react-native link 即可完成配置，如果因特殊原因无法使用 react-native link 或 link 失败，则可参照以下步骤检查并进行手动配置。） react-native link react-native-amap-geolocation 基本使用 import { PermissionsAndroid, Platform } from \"react-native\"; import { init, Geolocation } from \"react-native-amap-geolocation\"; import axios from \"axios\"; class Geo { //初始化 async initGeo() { if (Platform.OS === \"android\") { await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION); } //这里要放置在高德地图上，放置的服务平台位android的key，初始化 await init({ ios: \"891d0cf9dfba7fd2e99b509640f46644\", android: \"891d0cf9dfba7fd2e99b509640f46644\" }); return Promise.resolve(); } //获取经纬度 async getCurrentPosition() { return new Promise((resolve, reject) => { console.log(\"开始定位\"); Geolocation.getCurrentPosition(({ coords }) => { resolve(coords); }, reject); }) } //获取地区信息 async getCityByLocation() { const { longitude, latitude } = await this.getCurrentPosition(); const res = await axios.get(\"https://restapi.amap.com/v3/geocode/regeo\", { // 这里的key对应的是高德地图上web端的key params: { location: `${longitude},${latitude}`, key: \"b63b60478b9fe5e0498c9a6913097056\", } }); return Promise.resolve(res.data); } } export default new Geo(); 此外，我们还可以配合react-native-picker方便在项目中使用 (给Input标签添加点击事件的效果，点击后可以弹出选择地点具体方位的事件，不过这里我还在项目中添加了citys.json文件才能进行选择) react-native-picker 自定义picker 安装 yarn add react-native-picker 或者 npm i react-native-picker --save 代码 import Picker from 'react-native-picker'; import CityJson from '../../../res/citys.json'//添加了citys.json文件 Picker.init({ pickerData: CityJson, //显示哪些城市的数据 selectedValue: [\"北京\", \"北京\"],//默认选择的数据 wheelFlex: [1, 1, 0], // 显示省和市 pickerConfirmBtnText: \"确定\", pickerCancelBtnText: \"取消\", pickerTitleText: \"选择城市\", onPickerConfirm: data => { // data = [广东，广州，天河] this.setState( { city: data[1] } ); } }); Picker.show(); 效果图： 5.Mobxmobx是react中的全局数据管理库，可以简单实现数据的跨组件共享，有点类似于vue中的vuex或者是react的redux 使用步骤 安装依赖 mobx 核心库 mobx-react 方便在react中使用mobx技术的库 @babel/plugin-proposal-decorators 让 rn 项目支持 es7 的装饰器语法的库 yarn add mobx mobx-react @babel/plugin-proposal-decorators 在 babel.config.js添加以下配置 plugins: [ ['@babel/plugin-proposal-decorators', { 'legacy': true }] ] 新建文件 mobx\\index.js 用来存放 全局数据 @observable是es7装饰器的语法（使用到了Object.defineproperty） import { observable, action } from \"mobx\"; class RootStore { // observable 表示数据可监控 表示是全局数据 @observable name = \"hello\"; // action行为 表示 changeName是个可以修改全局共享数据的方法 @action changeName(name) { this.name = name; } } export default new RootStore(); 在根组件中挂载 通过 Provider 来挂载和传递，包裹在其中的组件可以拿到全局数据 import React, { Component } from 'react'; import { View} from 'react-native'; import rootStore from \"./mobx\"; import { Provider} from \"mobx-react\"; class Index extends Component { // 正常 render() { return ( &lt;View > &lt;Provider rootStore={rootStore} > &lt;Sub1>&lt;/Sub1> &lt;/Provider> &lt;/View> ); } } 组件中使用 import React, { Component } from 'react'; import { View, Text } from 'react-native'; import {inject,observer } from \"mobx-react\"; @inject(\"rootStore\") // 注入传入的属性用来获取 全局数据的 @observer // 当全局发生改变了 组件的重新渲染 从而显示最新的数据，有点类似setState class Sub1 extends Component { changeName = () => { // 修改全局数据 this.props.rootStore.changeName(Date.now()); } render() { console.log(this); return ( &lt;View>&lt;Text onPress={this.changeName}>{this.props.rootStore.name}&lt;/Text>&lt;/View> ); } } export default Index; 6.RN &amp; FlutterRN 优点： RN的效率由于是将View编译成了原生View,所以效率上要比基于Cordova的HTML5高很多。 程序组件看起来就像原生组件（例如，iOS设备上的按钮看起来就像原生 iOS 按钮，Android 上也是如此） 以JS为编程语言 稳定性（上市 5 年以上） 缺点： 但是如果我们碰上了复杂的组件渲染结构比如我们渲染一个复杂的ListView,每一个小的控件,都是一个native的view,然后相互组合叠加.想想此时如果我们的list再需要滑动刷新,会有多少个对象需要渲染.所以也就有了前面所说的RN的列表方案不友好 React Native 使用桥接和原生元素，因此可能需要针对每个平台单独优化，它可能会使使用 React Native的应用程序开发时间更长。 Flutter 优点： 吸收了前两者的教训之后,在渲染技术上,选择了自己实现(GDI),由于有更好的可控性，所以在性能方面比RN更高一筹 共享域更广，我们可以使用相同的代码库将本机应用程序传送到五个操作系统：iOS、Android、Windows、macOS 和 Linux；以及针对 Firefox、Chrome、Safari 或 Edge 等浏览器的网络体验。Flutter 甚至可以嵌入到汽车、电视和智能家电中（谷歌官方说的） 缺点： 但是Dart是AOT编译的，Dart语言受众小，且Flutter的第三方库相对较少","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Vue-aplayer","slug":"Vue-aplayer","date":"2021-06-14T16:00:00.000Z","updated":"2021-06-15T04:02:37.804Z","comments":true,"path":"2021/06/15/vue-aplayer/","link":"","permalink":"https://taylor12138.github.io/2021/06/15/vue-aplayer/","excerpt":"","text":"vue-aplayer简单介绍为 Easy-to-use music player for Vue 2.x，一款基于Vue2.0的音乐播放器，传入相关的prop参数可进行自定义修改 因为在项目中使用到了，在这里记录相关的用法 安装npm install vue-aplayer --save 使用&lt;aplayer autoplay :music=\"{ title: 'secret base~君がくれたもの~', artist: 'Silent Siren', src: 'https://moeplayer.b0.upaiyun.com/aplayer/secretbase.mp3', pic: 'https://moeplayer.b0.upaiyun.com/aplayer/secretbase.jpg' }\" /> 实践&lt;aplayer :music=\"audio[0]\" :list=\"audio\" :showlrc=\"true\">&lt;/aplayer> Props（参数） 名称 类型 默认值 说明 music Object 必需 当前播放的音乐。 具体请看音乐信息 list Array [] 播放列表。如果 list 不是空数组，播放列表就会显示出来，即使 list 中只有一首歌并且它和 music 一样 mini Boolean false 迷你模式 float Boolean false 浮动模式。你可以在页面上随意拖放你的播放器 showLrc Boolean false 是否显示歌词 mutex Boolean true 是否在该播放器播放时暂停其他播放器 theme String &#39;#41b883&#39; 主题色。如果当前歌曲也设置了 theme 则以歌曲的为准 shuffle Boolean false 随机播放 repeat String &#39;no-repeat&#39; 轮播模式。值可以是 &#39;repeat-one&#39;（单曲循环）&#39;repeat-all&#39;（列表循环）或者 &#39;no-repeat&#39;（不循环）。为了好记，还可以使用对应的 &#39;music&#39; &#39;list&#39; &#39;none&#39; listMaxHeight String none 播放列表面板最大高度 listFolded Boolean false 默认收起播放列表 narrow DEPRECATED, 请使用 mini listmaxheight DEPRECATED, 请使用 listMaxHeight showlrc DEPRECATED, 请使用 showLrc 如果你是用的是 Vue@2.3.0+, 你可以在 music shuffle 和 repeat 上使用 .sync修饰符 将 Audio 属性作为 props从 v1.4.0 开始，我们选取了一些 &lt;audio&gt; 属性并将它们运用为 props（其实也就是上方props参数的拓展） 名称 类型 默认值 是否可变 说明 autoplay Boolean false false 自动播放。如果多个 mutex 播放器设置了 autoplay，只有第一个会自动播放 controls Boolean false true 显示原生 audio 元素（在播放器面板和播放列表面板之间） muted Boolean false true 静音 preload String none true The way to load music, can be ‘none’ ‘metadata’ or ‘auto’ volume Number 0.8 true 播放音量 muted 和 volume 也可以使用 .sync 修饰符，你可以利用这一点做一些自定义的控制 音乐信息对应props里面的music，当前播放音乐，music props 包含了当前播放歌曲的如下信息。 属性 默认值 说明 src 必需 音频文件的 URL title &#39;Untitled&#39; 歌曲名称 artist &#39;Unknown&#39; 演唱者 pic none 封面图片 URL lrc none LRC 歌词或者歌词文件的 URL theme none 歌曲的主题色，会覆盖播放器的主题色 url DEPRECATED, 请使用 src author DEPRECATED, 请使用 artist 实践： music: { // 当前播放的音乐 title: \"晴天\", artist: \"周杰伦\", src: require(\"@/assets/music/周杰伦 - 晴天.mp3\"), pic: require(\"...\"), // 封面图片 }, 事件从 v1.4.0 开始, Vue-APlayer 会抛出它内部的 &lt;audio&gt; 元素上触发的所有媒体事件. 你可以查阅 MDN 上的这张完整列表. 在 v1.4.0 以前, 我们有一些自定义事件，如 play pause canplay playing ended error, 它们现在已全部被废弃。 自适应主题色从 v1.3.0 开始, 如果你将一首歌的 theme 值设为 &#39;pic&#39;, Vue-APlayer 会从它的封面图片中提取颜色作为主题色. 你也可以直接将 Vue-APlayer 的 theme prop 设为 &#39;pic&#39;, 这样所有的歌曲都会使用自适应主题色 你只需将 color-thief 库加入页面中. 注意 color-thief 无法正常使用 npm 安装 也就是说我们只能导入，不能用npm装 &lt;!-- 或者你选择的其他 CDN --> &lt;script src=\"https://cdn.jsdelivr.net/npm/colorthief@2.0.2/src/color-thief.js\">&lt;/script> 查询更多可以看 https://github.com/SevenOutman/vue-aplayer/blob/develop/docs/README.zh-CN.md","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"文件上传","slug":"文件上传","date":"2021-06-13T16:00:00.000Z","updated":"2021-06-14T08:46:40.881Z","comments":true,"path":"2021/06/14/wen-jian-shang-chuan/","link":"","permalink":"https://taylor12138.github.io/2021/06/14/wen-jian-shang-chuan/","excerpt":"","text":"图片读取实例以下例子均以Vue框架作为实践应用文件上传功能 在html里使用label + input的方式设置按钮触发文件上传的回调函数 以input的onchange事件触发回调，这里并不需要展示input，所以设置了 style=&quot;display: none&quot; &lt;label for=\"file\"> &lt;!-- 这里可以使用其他icon插入方式代替 --> &lt;img src=\"~@/assets/img/file.png\" alt=\"\" /> &lt;/label> &lt;input type=\"file\" style=\"display: none\" id=\"file\" @change=\"handleFile\" /> 展示文件（图片）部分 这里以上传图片作为实验 &lt;img :src=\"item.file\" alt=\"\" v-if=\"item.file\" preview=\"1\" /> 回调method对应的事件： handleFile(e) { const file = e.target.files[0]; if (file.size > 1024 * 1024) { return this.$message.info(\"发送图片大小不能超过1M!\"); } const reader = new FileReader(); // 创建读取文件对象 reader.readAsDataURL(file); // 发起异步请求，读取文件 reader.onload = (e) => { // 文件读取完成后 // 读取完成后，将结果赋值给img的src this.socket.emit(\"sendMessage\", this.turnFile(e.target.result)); }; }, // 把信息转换成对象(图片) turnFile(file) { const id = nanoid(); return { id, file, username: this.username, avator: this.imgAddress, }; }, 这里我把读取后的文件转换成对象 =&gt; 发送到websocket，文件读取主要是理解通过input的change事件获取文件 + FileReader读取文件部分 FileReader文件读取主要使用到**FileReader** 对象 MDN的解释是： **FileReader** 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File或Blob对象指定要读取的文件或数据。 FileReader() 返回一个新构造的FileReader。 事件处理 FileReader.onabort 取操作被中断时触发。 FileReader.onerror (en-US) 取操作发生错误时触发。 FileReader.onload 读取操作完成时触发。 FileReader.onloadstart 处理loadstart (en-US)事件。该事件在读取操作开始时触发。 FileReader.onloadend 处理loadend (en-US)事件。该事件在读取操作结束时（要么成功，要么失败）触发。 FileReader.onprogress 处理progress (en-US)事件。该事件在读取Blob触发。 方法 FileReader.abort() 中止读取操作。在返回时，readyState属性为DONE。 FileReader.readAsArrayBuffer() 开始读取指定的 Blob的内容,一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer FileReader.readAsBinaryString()e 开始读取指定的Blob的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。 FileReader.readAsDataURL() 开始读取指定的Blob的内容。。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。 FileReader.readAsText() 开始读取指定的Blob的内容一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。","categories":[],"tags":[],"author":"Hello"},{"title":"TypeScript","slug":"TypeScript","date":"2021-05-22T07:21:51.269Z","updated":"2021-08-22T11:52:38.730Z","comments":true,"path":"2021/05/22/typescript/","link":"","permalink":"https://taylor12138.github.io/2021/05/22/typescript/","excerpt":"","text":"1.结识TypeScript传统上，JS旨在用于简短，快速运行的代码片段，作为浏览器脚本语言，主要用途是与用户互动，以及操作DOM，所以JS比较适合单线程。 但是由此导致后期维护性比较差 面向对象撰写麻烦 没有类型规范 TypeScript以JavaScript为基础构建的语言，JavaScript的超集（拓展）引入了类型的概念，它可以在任何支持JS的平台中运行，但是不能被JS解析器直接执行，所以需要我们进行编译 TS -&gt; JS 对比： 1.引入类型，可以理解为TypeScript为JavaScript的静态语言模式， 2.增加了ES不具备的新特性，比如抽象类、工具等 3.丰富的配置选项，可以通过配置转化为兼容性强的es5、es3语法 环境搭配1.下载 and 安装Node.js 2.使用npm安装全局TypeScript npm i -g typescript 3.创建一个ts文件 4.使用tsc对ts文件进行编译 进入ts文件目录 执行tsc xxx.ts (此时就会转换成js文件，感觉有点less转css内味了) 2.TypeScript基础类型声明let a: number; //声明一个变量a，同时指定它的类型为number let b: number | string //声明一个变量b，同时指定它的类型为number或者string 由此，在以后的使用过程中，a只能为number类型 // a = 'hello'; //报错，不能将类型string分配给类型number a = 1; 不过还是TS -&gt; JS 编译成功，因为是为了让JS开发人员慢慢熟悉 最常用的类型声明方式还是： （记住number是小写） let a: number = 2; //如果变量的声明和赋值是同时进行，TS可以自动对变量进行类型检测，最后可以简化为 let a = 2; 虽然在变量声明看不出有多大用处，但是应用于函数上，大有文章 JS中的函数不考虑参数的类型和个数，很容易出现错误 function sum(a, b) { return a + b; } console.log(sum(123, \"456\")); //123456，不是我们想要的结果 // ts语法 function Sum(a: number, b: number): number{ //设置返回值类型为number return a + b; } console.log(Sum(123, \"456\")); //报错 typescript在类中的类型选择 class Dog{ name: string; age: number; constructor(name: string, age: number){ this.name = name; this.age = age; } } 类型选择 类型 例子 描述 number 1, 2, -22 任意数字， string “here we go” 任意字符串 boolean true、false 布尔值true或false 字面量 其本身 限制变量的值就是该字面量的值 any * 任意类型 unknown * 类型安全的any void 空值（undefined） 没有值（或undefined） never 没有值 不能是任何值 object {name:’Allen’} 任意的JS对象 array [1,2,3] 任意JS数组 tuple [4,5] 元素，TS新增类型，固定长度数组 enum enum{A, B} 枚举，TS中新增类型 解说： 字面量：相当于定死一个固定的常量，let a: 10，此时a只能赋值为10。 在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。 any：类似于让TS回归JS原生，可以赋值给任意变量 -.- 声明变量如果不指定类型，则TS解析器会自动判断变量类型为any unknown：表示未知类型的值，有点类似any，不能赋值给任意变量。尽量用unknown，不要用any let a: any; a = true; //a可以表任意类型 let b: unknown; b = \"hello\" //b可以表任意类型 let s: string; s = a //通过 s = b //报错 if(typeof b === \"string\"){ s = b //通过 } 类型断言用来告诉解析器变量实际类型，编译器不知道（所以报错），我们自己是知道的，让它放心使用 在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。 s = b as string //通过 s = &lt;string>b //通过 const断言 const断言告诉编译器为表达式推断出它能推断出的最窄或最特定的类型。如果不使用它，编译器将使用其默认类型推断行为，这可能会导致更广泛或更一般的类型。 当我们使用关键字 const 声明一个字面量时，类型是等号右边的文字，例如： const x = 'x'; // x has the type 'x' const 关键字确保不会发生对变量进行重新分配，并且只保证该字面量的严格类型。 但是如果我们用 let 而不是 const， 那么该变量会被重新分配，并且类型会被扩展为字符串类型，如下所示： let x = 'x'; // x has the type string; 网络上找到一个比较形象具体的例子： const args = [8, 5]; // const args: number[] const angle = Math.atan2(...args); // error! Expected 2 arguments, but got 0 or more. console.log(angle); 也可以解释为，当前类型为number[]，数组数量可以被修改，所以时显示 ”0或更多“ 通过const断言进行改动后 const args = [8, 5] as const; // const args: readonly [8, 5] const angle = Math.atan2(...args); // okay console.log(angle); 现在编译器推断args属于readonly [8, 5]类型。。。一个readonly元组，其值正好是按此顺序排列的数字8和5。具体来说，args.length被编译器精确地称为2。（看不懂 readonly可以拆解为 read only，只读的，它仅允许对数组、元组使用 ） 也可以解释为，当前类型为[8, 5]，数组数量固定死了，为2，参数数量可以接收 + 通过 void：空值，常用于表示表示函数没有返回值 function fn(): void{} never：空值，常用于表示表示函数没有返回结果 function fn(): never{} object： //声明一个变量c，同时指定它是一个对象，且一定有一个string类型的name属性，可选属性age类型为number，不能有其他新的属性 //可选属性要放在后面 let c: {name: string, age?: number}; //声明一个变量d，同时指定它是一个对象，且一定有一个string类型的name属性，可以有其他新的可选属性 let d: {name:string, [propName: string]: any}; array： let e: string[]; //声明一个字符串数组（存储字符串） let arr: number[]; let arr2 = Array&lt;number> //声明数值数组 tuple：元组，也就是固定长度的数组，效率相对数组好一点 。 可以并行多种类型， let h: [string, number]，两个元素的数组，分别是string、number类型 enum：枚举的使用 // 平时我们存储男、女这些字符串，数据库占用空间大，像这种在几个值之间选择的情况，可以用枚举替代字符串 enum Gender { Male = 1, Female = 0 } let i: { name: string, gender: Gender } i = { name: 'Allen', gender: Gender.Male } console.log(i.gender === Gender.Male); //true console.log(Gender['Male']); //1 console.log(Gender[1]); //Male 定时器： 类型为NodeJS.Timeout 自定义类型： type myType = 1 | 2 | 3 | string; let a: myType; a = 4 //报错 编译选项每一次对TS文件进行改动，我们都不得不使用 tsc xxx.ts进行重新编译 tsc xxx.ts -w -w加上后，会自动监视TS文件变化。但是一个文件就得开一个窗口进行监视 如果当前项目有TS的配置文件（tsconfig.json），可以在当前目录下直接执行命令（没有配置文件直接执行命令 tsc --init即可 ） tsc #编译所有ts文件 tsc -w #编译所有TS文件 + 监视所有TS文件的变化 tsconfig.json是ts编译器的配置文件 { \"include\": [ //配置些TS文件需要被编译，这里是根目录/src/任意目录/任意文件 \"./src/**/*\" ], \"exclude\": [], //不包含哪些文件 \"files\": [], //和include很像，只不过include列出路径，files直接一一列出文件 \"compilerOptions\":{ //编译器配置选项 \"target\": \"es5\", //target用来指定ts被编译为ES版本，默认ES3 \"module\": \"commonjs\", //module指定模块化的规范 \"lib\": [], //lib用来指定项目中要使用的库，使用场景一般在非浏览器环境下运行，比如在nodejs下我要使用dom，\"lib\": [\"dom\"] \"outDir\": \"./\", //outDir指定编译后文件所在的目录 \"outDir\": \"./dist\", 存于个目录下dist文件夹 \"outFile\":\"./dist/app.js\", //outFile 将代码合并为一个文件，但其实项目开发更多让打包工具去做这个事 \"allowJs\": false, //是否对js文件进行编译，默认false \"checkJs\": false, //检查js文件符合语法规范，一般和allowJs配套使用 \"removeComments\": false, //是否移除备注 \"noEmitOnError\": false, //当有错误时不生成编译后的文件 \"strict\":false, //所有严格检查总开关 \"alwaysStrict\": true, //设置编译后JS文件是否使用严格模式，默认false \"noImplicitAny\": false, //不允许隐式any类型 \"noImplicitThis\": false, //不允许不明确类型this \"strictNullChecks\": false, //严格检查空值（或者可能成为空值的变量） } } 备注： 路径 **：任意目录 *：任意文件 exclude 有默认值，[“node_modules”, “bower_components”, “jspm_packages”]，如果只想排除以上默认值，其实我们可以不用写这个配置 使用webpack打包TS代码初始化生成pack.json文件 npm init --yes 安装相关loader，webpack等 npm i -D webpack webpack-cli typescript ts-loader 新建webpack.config.js文件，并且进行配置 const path = require('path') module.exports = { entry: \"./src/index.ts\", output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js' }, module: { // 指定加载规则 rules: [ { test: /\\.ts$/,// test指定规则生效的文件,以ts结尾的文件 use: 'ts-loader', exclude: /node_modules/ } ] } } 新建 + 配置 TS编译的配置文件（tsconfig.json） { \"compilerOptions\": { \"module\": \"ES2015\", \"target\": \"ES2015\", \"strict\": true } } 这时在命令窗口直接输入 webpack，即可成功打包 TS文件模块的许可配置（webpack.config.js） // 用来设置模块，只要js、ts结尾都可以作为模块来使用 module.exports = { //... // 用来设置模块，只要js、ts结尾都可以作为模块来使用 resolve:{ extensions:['.ts', '.js'] } } 在React中使用typescriptReact脚手架 + typescript npx create-react-app my-app --template typescript 如果是对当前React脚手架项目添加typescript支持 npm install --save typescript @types/node @types/react @types/react-dom @types/jest 在构建React组件类的时候，还有这一种接口的写法 React.Component&lt;props接口的名称, state接口的名称&gt;，用来说明派生的 Component 使用的 Props 和 State 的类型 React.Component&lt;Props, State> 3.TypeScript对面向对象的延伸以下阐述的抽象类、接口均为TypeScript新增的 抽象类有时候，我们创建一个类，主要是为了作为多个类的父类，让子类通过继承得到共有的属性和方法，比如创建一个Animal类，然后让Cat、Dog类继承Animal类 以abstract开头的为抽象类，抽象类其实和其他类差别不大，只是不能用来创建对象，也就是专门用于继承的类 抽象类中可以添加抽象方法 抽象方法，使用abstract开头，没有方法体 抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写 abstract class Animal { name: string; constructor(name: string) { this.name = name; } abstract say(): void; } class Dog extends Animal { say() { console.log(\"gogogo\"); } } 接口在typescript基础中，我们学习到了自定义类型的写法；而接口就是用来定义一个类的结构即类中应该包含哪些属性和方法（我个人理解为，实际上接口也可能看成一种自定义类型，该类型一定要包含接口的规范） 实际上又不一定仅限于定义类的结构，也可以作为一种类型去使用，比如用 :myInterface规范类型， 所以才导致出现type 和 interface都可以使用的场景，所以接口也可以当成类型声明去使用 自定义类型 type myType = { name: string, age: number } const obj: myType = { name:\"allen\", age:18 } 接口 // 该接口规定了我们定义了一个类，该类一定有两个属性，一个是name，一个是age interface myInterface{ name: string; age:number } （1）接口 VS 自定义类型 VS抽象类1.接口可以同名进行重复声明：比如之前定义了 type myType，后面不能重复定义该类型；而前面个定义了 interface myInterface，后面依旧可以再次定义 interface myInterface（这两个 myInterface会进行合并） interface myInterface{ name: string; age:number } interface myInterface{ gender:string } //两个会发生合并，这种语法在TS里是合理的 2.接口可以在定义类的时候，限制类的结构（这一点有点像在继承抽象类） 接口中所有属性都不能有实际的值（但是抽象类可以定义实际的值） 接口中的方法都是抽象方法（但是抽象类可以有非抽象方法） 定义类时让类去实现（implement）这个接口 interface myInterface{ name: string; saySomething(): void; //抽象方法啊 } // 实现接口，实现接口就是使类满足接口要求 class MyClass implements myInterface{ name: string; constructor(name:string) { this.name = name; } saySomething(): void { throw new Error(\"Method not implemented.\"); } } 3.接口可以实现多个,互相实现,抽象类的子类却只能继承一个抽象类；抽象类只针对类，接口其实也可以应用于函数、属性等 总而言之，接口就相当于一个规范，实现了接口，即满足了规范，就可以在指定场景中进行使用 接口的应用场景（很愿意以接口的方式来实现）： 后台接口 第三方和开发的SDK，比如Vue 前端的库 正常的开发任务来说，interface、type都差不多，type更直接更方便 （2）属性接口使用场景：我们如果向约束传入参数是作为一个 string类型，可以直接 function fn(params: string){} 但如果我们需要传入一个参数，它是一个对象，但是我们要求这个对象里的某个属性（或者多个属性），必须为 string类型，我们可以使用属性接口 //对传入对象里面的属性进行约束 interface FullName{ firstName:string; lastName:string } function printName(name: FullName){} （3）函数类型接口对函数方法进行约束 / 批量约束 interface myInterface{ //参数为两个string类型，返回参数为string类型 (key:string, value:string):string } const fn: myInterface = (a: string, b: string) => a + b; （4）可索引接口也可以看成针对数组、对象索引的接口 //针对数组索引 interface myArr{ [index:number]:string } let arr:myArr = ['allen', 'bruce'] //针对对象索引值的约束 interface myObj{ [index:string]:string } let obj:myObj = {name:'allen'} （5）类类型接口//类类型接口，也就是最上方类对接口的实现，和抽象类类似 interface myClass{ name: string; action(params:String):void } class Me implements myClass{ name = 'Allen'; action() {} } （6）接口继承使用extends，接口可以实现对其他接口的继承，可以对接口进行拓展 interface Animals{ eat(): void; } interface Person extends Animals{ work(): void; } //这里再套一个baby类进行类的继承 class baby{} class People extends baby implements Person{ eat() { } work(){} } 属性封装 如果属性是在对象中设置，则属性可以随意被修改，导致数据不安全 class Person { name: string; age: number; constructor(name: string, age: number) { this.name = name; this.age = age; } } const SpiderMan = new Person(\"SpiderMan\", 18); SpiderMan.age = -30; //被随意修改 TS可以在属性前添加修饰符 public，可以在任意位置访问 / 修改，默认值 private，私有属性，私有属性只能在类内部进行访问 / 修改，子类也不能访问 / 修改 通过在类中添加方法使得私有属性可以被外部访问 （但是却可以通过 (实例as any).私有属性进行访问。。不过有另外一种设置私有的方式，就是 #变量，并且还要在tsconfig.json对 lib 、target 进行配置） protected，受保护属性，仅能在当前类 or 当前类的子类中访问 / 修改 class Person { private _name: string; private _age: number; constructor(name: string, age: number) { this._name = name; this._age = age; } // 现在数据的读写访问权在我们编码人员上了 getAge() { return this._age; } setAge(age: number) { if (age > 0) this._age = age; } // getter和setter被称为属性存取器 } const Bruce = new Person(\"Bruce\", 18); //console.log(Bruce._age); //报错 console.log(Bruce.getAge()) 但是TS内帮我们提供了读写属性的方法（语法糖） 实际上是应用了Object.defineProperty()的get和set （在使用get函数后，get后面的变量将自动保存为该实例的变量，比如 get Name()，然后类似于在类里添加了 this.Name,） TS设置getter、setter的方式以下所示 class Person { private _name: string; private _age: number; constructor(name: string, age: number) { this._name = name; this._age = age; } get name() { console.log(\"我被执行了\"); return this._name //此时在类外面，通过实例对象.name依然可以获取，即使获取格式看似像是和以前相同 // 但是获取方式已经和以往完全不一样了，是通过函数获取的 } get age() { return this._age } set age(age: number) { if (age > 0) this._age = age; } } const Bruce = new Person(\"Bruce\", 18); //可以，此时.name并不是找属性，而是找是否有get name方法 console.log(Bruce.name); //我被执行了 //数值大于0，可以执行 Bruce.age = 20; 关于类定义属性简便写法 旧的： class Person { private _name: string; private _age: number; constructor(name: string, age: number) { this._name = name; this._age = age; } } 新的： class Person { constructor(private _name: string, private _age: number) {} } 泛型当出现类型不明确的情况，可以使用泛型（之前也提到过使用any不太好） 之前还提及过unknown，而泛型针对定义函数或者类时，遇到类型不明确的情况（实质上也可以理解为在使用函数或者类或者接口的时候，不仅仅需要传递形式参数，还要把类型作为参数传递过去） 泛型比any的好处 1.避免跳过了类型检查部分 2.在这里也能体现出返回值类型和传入参数类型相同 函数 + 泛型 的方式 ：函数&lt;自定义泛型&gt;(参数:泛型(这里实质上是在使用泛型)):返回值类型(泛型(这里实质上是在使用泛型)){} 基本使用： // 指定了自定义的泛型：T，有点像一个变量的感觉，即类型的变量 function fn&lt;T>(a: T): T { return a; } console.log(fn(10)); //此时T为number，此时是自动推断 console.log(fn&lt;string>(\"string\")); //此时T为string，此时时指定推断，这种方式应该用的比较多 // 指定多个泛型 function fn2&lt;T, K>(a: T, b: K): T { console.log(`I am ${b}!`); return a; } console.log(fn2(10, \"bruce\")); // 在类中使用泛型 class MyClass&lt;T>{ constructor(public name: T) { }; fn(params:T) { return params; } } let c = new MyClass&lt;number>(123); let c2 = new MyClass&lt;string>('str'); 限制泛型假如我只想传入某种指定规格的数据，但是由于泛型没有对传入的参数进行规范校验，就可能可以乱传参数进去而没有被编译器发现 我们可以使用接口对泛型传入的参数加以规范 泛型 + 接口联动实现：应用场景：限制泛型的范围 interface myInterface { length: number } function fn3&lt;T extends myInterface>(a: T) { return a.length; } fn3(\"123\"); //可以通过 // fn3(123); //报错，因为这个参数没有length属性 应用场景：拓展接口类型 //函数接口 + 泛型 interface myInter&lt;T>{ (value:T):T } const getData: myInter = &lt;T>(value: T) => value; 泛类：把类当作参数的泛型类 class MysqlDB&lt;T>{ add(info: T) { console.log(info); } } class User { name: string | undefined; password: string | undefined; } let u = new User(); u.name = \"Allen\"; u.password = \"123\"; 此时我只想让User作为传入add的参数，但是 let db = new MysqlDB(); db.add(u); db.add(123) //也可以,对传入的参数没能进行限制 所以我们要对此进行约束 let db = new MysqlDB&lt;User>(); db.add(u); db.add(123) //报错 4.TypeScript其他命名空间有时不同模块中接口、类的名称或许会发生冲突（不同类、接口命名一致）。一个模块里可能有多个命名空间 import { MySQL } from './database'; //报错，发生冲突 class MySQL{ //... } 此时我们可以在ts文件最上方使用命名空间 namespace A{ //代码块 } 此时属于A命名空间的私有该代码块定义的接口、类等 如果我们要在外部使用该命名空间的东西，需要使用export对外部进行暴露 namespace A{ interface Animal{ name: string eat(): void; } export class Dog implements Animal{ constructor(public name: string) { } eat(){} } } // 只能使用Dog类，因为其他比如Animal接口没有暴露，所以在外面也不能使用 let temp = new A.Dog('边牧'); 对外部模块到处该命名空间，直接 export namespace A{}即可 装饰器装饰器是一种特殊的类型声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为 通俗来讲装饰器就是一个方法，可以注入到类、方法、属性参数上来拓展类、属性、方法、参数的功能。装饰器是过去几年JS最大成就之一，已经是ES7的标准特性之一 常见的装饰器有类装饰器、属性装饰器、方法装饰器、参数装饰器 装饰器的写法： 普通装饰器（无法传参） 装饰器工厂（可传参） 注意 装饰器是一项实验性特性，在未来的版本中可能会发生改变。 若要启用实验性的装饰器特性，你必须在命令行或tsconfig.json里启用experimentalDecorators编译器选项： tsc --target ES5 --experimentalDecorators { \"compilerOptions\": { \"target\": \"ES5\", \"experimentalDecorators\": true } } 基本使用 （1）类装饰器@装饰器下一行接类 //它在不修改类 MyClass的情况下，对类的功能进行了拓展 function logClass(params: any) { // params就是当前类 console.log(params); // 现在我们可以通过params来操作类了 //拓展一个属性 params.prototype.apiURL = 'xxx'; // 拓展一个方法 params.prototype.fn = () => { console.log(\"I am function!\"); } } @logClass class MyClass { constructor(public name: string) { } } 但我们可以看到，通过 @logClass的方式进行装饰，无法传入参数（params是默认传入，不算） 类装饰器（装饰器工厂）： 实际上说的那么玄乎，不过就是运用了柯里化方式进行传参，类似于React的函数传参方式 function logClass(params: string) { return function (target: any) { //这里的target就是当前类MyClass，也就是上方普通装饰器的params //使用传入参数来拓展属性 target.prototype.apiURL = params; } } @logClass('something') class MyClass { constructor(public name: string) { } } 除此之外，装饰器还能修改当前类的构造函数下面是一个重载构造函数的例子： 类装饰器表达式会在运行时被调用，类的构造函数作为其唯一的参数 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明 function logClass(params: any) { return class extends params { name = 'I am another name'; //getData也要记得一起重载 getData() { console.log(this.name); } //或者getData() { super.getData() } } } @logClass class MyClass { constructor(public name: string) { console.log('我在执行constructor'); console.log(name); } getData() { console.log(this.name); } } let a = new MyClass('Kobe'); a.getData(); //我在执行constructor //Kobe //I am another name （2）属性装饰器属性装饰器表达式会在运行时当作函数被调用，传入下列两个参数： 对于静态成员来说是类的构造函数（constructor），对实例成员来说是类的原型对象（prototype） 成员名字 @装饰器下一行接属性 // 属性装饰器 + 装饰器工厂传参 function logProperty(params: any) { return (target: any, attr: any) => { console.log(target); //MyClass {} console.log(attr); //name //修改target（MyClass）类的attr（name）属性 //中括号的主要优势在于可以通过变量访问属性 target[attr] = params; } } class MyClass { // 当前有一个name的属性 @logProperty('something') name: string; constructor(name: string) { this.name = name } } let a = new MyClass('Kobe'); （3）方法装饰器它会被应用到方法的属性描述符上，可以用来监视、修改、替换方法定义 方法装饰会在运行时传入下列3个参数 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象 成员名字 成员的属性描述符 @装饰器下一行接函数 // 方法装饰器 function logMethod(params: any) { return (target: any, methodName: any, desc: any) => { console.log(target); //MyClass{} console.log(methodName); //fn console.log(desc); //关于该函数的描述（特性），比如writable、enumerable、configurable、value // 修改方法实现： 把参数转为字符串再传入 //1.保存之前方法 let fn = desc.value; desc.value = function(...args: any[]){ //先把参数全部转为字符串 let newArgs = args.map(item => String(item)); console.log(newArgs, params); //复用之前的方法 + 传入参数，保留之前函数定义的内容 fn.apply(this,newArgs); } } } class MyClass { @logMethod('Something') fn(...args: any[]) { } } let a = new MyClass(); a.fn('123', 12345) （4）方法参数装饰器参数装饰器表达式会在运行时被当作函数被调用，可以使用参数装饰器为类的原型增加一些元素数据，传入下列三个参数 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象 传入参数的方法名字 参数在函数参数列表中的索引 // 参数装饰器 + 装饰器工厂传参 function logParams(params: any) { return (target: any, methodName: any, paramsIndex: any) => { console.log(target); //MyClass{} console.log(methodName); //fn console.log(paramsIndex);//0 } } class MyClass { fn(@logParams(123) id: number) { } } let a = new MyClass(); 装饰器执行顺序：在TypeScript中，装饰器的执行顺序为：首先执行属性装饰器，然后执行方法装饰器，其次是方法参数装饰器，最后是类装饰器。如果同一个类型的装饰器有多个，总是先执行后面的装饰器。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React(下)","slug":"React(下)","date":"2021-05-16T09:50:07.114Z","updated":"2021-08-22T11:51:21.524Z","comments":true,"path":"2021/05/16/react-xia/","link":"","permalink":"https://taylor12138.github.io/2021/05/16/react-xia/","excerpt":"","text":"由于React部分太多了，分上下两篇进行浏览 7.React UI库material-ui（国外） 官网：https://material-ui.com/zh/ GitHub：https://github.com/mui-org/material-ui ant-design（国内蚂蚁金服）（推荐） 官网：https://ant.design/index-cn GitHub：https://github.com/ant-design/ant-design 下载antd npm i antd --save 在引入的时候，不要忘记也要引入 antd/dist/antd.css（官网显示代码居然没有提示要引入css），不过最好要按需引入，import &#39;antd/dist/antd.css&#39;加载了全部的 antd 组件的样式 。 此时我们可以进入官网 -&gt; 文档-&gt; 在create-react-app -&gt;高级配置中使用进行查看（看不到就看3.x版本） 假如我只是用了Button组件 //引入Button组件 import { Button } from 'antd' import 'antd/dist/antd.css' Vue的话推荐使用element-UI库，后面反响不错，也出了react的UI 对于React Native的按需导入，还得再babel.config.js进行配置 npm i ant-design/react-native module.exports = { presets: ['module:metro-react-native-babel-preset'], // 按需加载 \"plugins\": [ [\"import\", { libraryName: \"@ant-design/react-native\" }] // 与 Web 平台的区别是不需要设置 style ] }; 8.reduxredux是一个专门做状态管理的JS库（集中式管理） 它可以在React、Angular、Vue等项目中，但基本和React配合使用 作用：集中式管理react应用中多个组件共享状态 当需要大量共享可以使用，但是能不用就不用，毕竟是全局的东西 （实际上有点像Vuex，Vue人家就很少用这个，用自己内部的Vuex） 以上为redux原理图 redux三个核心概念action 有同步action （sync）和异步action （async） 动作对象 包含两个属性： type：标识属性，值为字符串，唯一，必要属性 data：数据属性，任意类型，可选属性 reducer Reducers不仅能加工状态（加工状态那么部分有点像Vue里的mutations），还能初始化状态 加工时，根据旧的state和action，产生新的state纯函数 在初始化时，reducer得到的previousState、action分别为 undefined、type:&#39;@@init&#39; + 随机字符,data: 无 store 将state、action、reducer联系在一起的对象，负责对外暴露 基本使用初始化 npm i redux 新建一个redux文件夹，在里面新建 store.js和处理某组件的 xxx_reducer.js 建立store store.js是专门用于暴露一个store对象，整个一应用只有一个store对象，配合redux的createStore API 可以创建一个store对象 //store.js //createStore专门用于创建store对象 import { createStore } from 'redux' // 引入reducer import countReducer from './count_reducer' // 暴露store export default createStore(countReducer) 建立reducer 这里我模拟一个处理count数据的reducer xxx_reducer.js是用于创建一个为Count组件服务的reducer，reducer的本质就是一个函数，reducer函数会接到两个参数，分别为：之前的对象preState、动作对象action // reducer用于最基本的数据处理，是一个纯函数 const initState = 0; //如果你要存多个数据，可以初始化成一个对象 export default function countReducer(preState = initState, action) { console.log(preState); const { type, data } = action; switch (type) { case 'increment': return preState + data * 1; case 'decrement': return preState - data * 1; default: // 不加也不减，说明是初始化 return preState } } 关于reducer的小bug 在redux底层会做一个判断，如果返回的东西，和之前的preState是一样的，那就不会进行页面更新。 注意redux的reducer必须是一个纯函数（纯函数的概念我在ES5篇章有提及到） export default function personReducer(preState = initState, action) { const { type, data } = action; switch (type) { case ADD_PERSON: // 做了一个浅比较，返回的preState的地址值和之前的是一样的，那就不进行页面更新了 //错×：preState.unshift(data); return preState; return [data, ...preState] default: return preState; } } 所以可以在React、Redux里面，我们很少使用push、unshift这些数组方法，而且这样会导致函数不再是纯函数了。 组件中导入 + 使用 // 引入store，用于获取redux中保存的状态 import store from '../redux/store' 在组件中使用 store.getState()可以直接获取store存储的数据 这里我直接在组件内自定义increment函数模拟action向store发送更改 数据的类型type 和 传入的数据data increment = () => { const { value } = this.selectNumber; // dispatch传入type和data store.dispatch({ type: 'increment', data: value }); } 但是平时我们使用setState会自动帮我们调用一次render更新页面，但是store更新没有调用render 解决方法一：在组件内，在componentDidMount生命周期钩子后使用 redux 带的 subscribe API ，用于订阅状态更改，监听store数据的变化，发生变化则执行传入的回调函数（ this.setState({}) -&gt; render ） // DOM挂在完毕后，监听redux中状态的变化，只要变化就调用render componentDidMount() { store.subscribe(() => { //虚晃一枪，让它帮我们调用一次render（自己调用this.render不管用） //不过我感觉使用forceUpdate()好像也行 this.setState({}); }) } 解决方法二：对于整个组件，直接用redux 带的 subscribe API 进行包裹，（这里老师说有了diff算法，实际上整体性能影响不会特别大） ReactDOM.render(&lt;App />, document.querySelector('#root')); store.subscribe(() => { ReactDOM.render(&lt;App />, document.querySelector('#root')) }) 解决方法三：使用react-redux 补充Action此时可以补充action提交修改：向store发送更改 数据的类型type 和 传入的数据data 在redux文件夹下创建xxx_action.js，导出action方法 export const createIncrementAction = data => ({ type: 'increment', data }); export const createdecrementAction = data => ({ type: 'decrement', data }); 然后可以直接在组件中导入 + 使用，可以像官方redux原理图一样，不需要自己来 向store发送更改 数据的类型type 和 传入的数据data 和Vue一样，开发时定义常量是减少错误的基本方法（实际上也是防止单词写错） 然后再组件中使用Action方法 import { createIncrementAction } from '../redux/count_action' increment = () => { const { value } = this.selectNumber; // dispatch为action传入参数 store.dispatch(createIncrementAction(value)); } sync Action and async Action action可以为对象（type、data属性），也可以为函数 我们把对象类型的Action称为同步Action，函数类型的Action称为异步Action 我们返回一个函数，把异步操作存放在这个函数里，再调用同步action（异步Action中一般都会调用一个同步action），由此形成一个异步操作， 但是！！：因为store只认action作为一个对象来返回，此时我们需要用到一个中间件，让store愿意接收一个函数，并且调用它： npm i redux-thunk 然后再store.js里 //store.js //applyMiddleware为store使用中间件的API import { createStore, applyMiddleware } from 'redux' // 引入reducer，thunk为接收函数式action必须的中间件 import countReducer from './count_reducer' import thunk from 'redux-thunk' // 暴露store， export default createStore(countReducer, applyMiddleware(thunk)) 然后在action.js这个文件里定义异步action（作为一个函数返回，经过中间件的处理，接收一个dispatch方法，可帮助你调用同文件下的同步action方法） export const asyncIncrement = (data, time) => { return (dispatch) => { setTimeout(() => { dispatch(createIncrementAction(data)) }, time); } } 在组件中使用： import store from '../redux/store' import {asyncIncrement } from '../redux/count_action' store.dispatch(asyncIncrement(value, 500)); 异步action：它不是一个必须的东西，实际上我们可以在自己的组件函数里定义异步操作，只是当你不想要把异步操作放在组件里是，可以使用以上异步action方法 react-reduxfacebook为了让开发人员更加舒服使用redux，开发了react-redux（其实我个人觉得可以理解为，react让组件和redux之间的交互多了一个中间人：container） 可以看得出外面要了一层容器，防止UI组件直接对接redux components文件夹存放的是UI组件（不能使用任何的redux API，只负责页面的呈现） 我们要创建一个container的文件夹，然后新建一个容器组件，容器组件作为UI组件 和 react-redux的桥梁，不能直接rcc自定义组件，而是使用react-redux库创建。 npm i react-redux 连接UI组件的方式：新建一个containers文件夹，index.jsx文件 // 引入CountUI组件,CountUI组件为components文件夹下的自定义组件 import CountUI from '../../components/Count' // 引入connect用于连接UI组件和redux import { connect } from 'react-redux' // 使用connect()()创建并且暴露一个Count容器组件 export default connect()(CountUI) 此时把原来引入UI组件替换成容器的自定义组件 连接store的方式：在app组件使用容器组件时，通过定义属性props方式对 Count 容器 传入store（之前是导入 store后 ，通过 store.getState()获取数据的 ） import React, { Component } from 'react' //import Count from './components/Count' //现在不需要在app.jsx文件里直接导入UI组件 import Count from './containers/Count' //而是需要导入container组件 import store from './redux/store' export default class App extends Component { render() { return ( &lt;div> &lt;Count store={store} /> &lt;/div> ) } } 开始container 和 component的数据交互 由于容器组件的创建比较不走寻常路，所以它传递给子组件（UI组件）props的方式也有点不寻常 在连接UI组件时使用到的connect API，要传入两个参数，并且得传两个函数（mapStateToProps函数、mapDispatchToProps函数）作为参数 。（在上方react-redux模型图可以看到第一个参数传状态，第二个参数传方法） mapStateToProps（函数） 1.mapStateToProps函数的返回值是一个对象2.作为状态(key: value 组合的对象)传递给UI组件3.通过props传入store，使得第一个参数的函数默认传入store的state状态作为参数（state = store.getState()） mapDispatchToProps（函数） 1.mapDispatchToProps函数的返回值是一个对象2.作为操作状态的方法（key: func 包含函数的对象）传递给UI组件3.通过props传入store，使得第二个参数的函数默认传入store的dispatch方法，直接使用dispatch告诉action你要执行的事件 //count组件的父容器的index文件 // 引入CountUI组件 import CountUI from '../../components/Count' // 引入connect用于连接UI组件和redux import { connect } from 'react-redux' // 引入redux中的action提交对状态的修改 import { createIncrementAction, asyncIncrement, createdecrementAction } from '../../redux/count_action' function mapStateToProps(state) { return { count: state } //假如state = 900,相当于正常父子组件传值 &lt;CountUI count={900}> } function mapDispatchToProps(dispatch) { return { increment: (number) => { dispatch(createIncrementAction(number)) }, decrement: (number) => { dispatch(createdecrementAction(number)) }, asyncIncrement: (number, time) => { dispatch(asyncIncrement(number, time)) } } } export default connect(mapStateToProps, mapDispatchToProps)(CountUI) 然后我们在子组件（UI组件），就可以直接通过props.xx获得传入的状态/修改状态的方法，对子组件进行操作修改 increment = () => { const value = parseInt(this.selectNumber.value); this.props.increment(value); } const { count } = this.props; 优化部分 1.对于上述传参 的精简写法： mapDispatchToProps（对象） 在写mapDispatchToProps部分的时候，react-redux会帮你做一个自定分发的动作（自动dispatch） 也就是判断当前是否为action，如果是就自动跑分发dispatch的逻辑；如果不是按照以往的代码逻辑执行 export default connect( state => ({count:state}), //原本mapDispatchToProps函数变成一个对象（key: action） { increment: createIncrementAction, decrement: createdecrementAction, asyncIncrement: asyncIncrement, } )(CountUI) 2.使用react-redux不需要使用 subscribe API（用于订阅状态更改，监听store数据的变化），容器组件自带监听数据变化的能力 3.连接store的方式为 在组件中传入store作为props属性&lt;Count store={store}，如果多个容器组件，岂不是要一个一个传？不用，react-redux里有个 Provider组件，用 provider组件 将外壳app组件包裹住，则在整个应用里面，但凡需要store的容器组件，都会传过去 //总的index.js文件 import React from 'react' import ReactDOM from 'react-dom' import App from './App' import { Provider } from 'react-redux' import store from './redux/store' //此处使用Provider，使得APP的所有后代容器组件都能接收store ReactDOM.render( &lt;Provider store={store}> &lt;App /> &lt;/Provider>, document.querySelector('#root')); 4.我们自己对文件的优化： 由于每个UI组件为了对接redux存储的状态，都会多一个容器组件，导致文件量成倍增长。 所以我们可以自己把容器组件和UI组件写在同一个jsx文件里，对外暴露容器组件 在react-redux处理多个组件(如果引入多个reducer（不同reducer对应处理不同组件的状态处理）)，要先使用redux的API：combineReducers，把所有的reducer组合起来，再进行暴露 //store.js //createStore专门用于创建store对象 import { createStore,combineReducers } from 'redux' // 引入reducer import countReducer from './Count/reducer' import personReducer from './Person/reducer' // 汇总所有的reducers变成一个总的reducer const allReducer = combineReducers({ sum: countReducer, people:personReducer }) // 暴露store export default createStore(allReducer) 使用connect()()创建并且暴露组件时，传入的mapStateToProps函数也要发生相应改变（因为传入的state由于要存储多个数据，已经变成一个对象了） 但是由此实现了数据互通！ //Count/index.jsx export default connect( //mapStateToProps state => ({ count: state.sum //在Count组件里，我并不需要使用到state.pepple数据 }) { increment: createIncrementAction, decrement: createdecrementAction, asyncIncrement: asyncIncrement, } )(Count) //Person/index.jsx export default connect( state => ({ count: state.sum, personList: state.people }) { addPersonAction } )(Person) Other这里顺便推荐一下redux的相关开发者工具：Redux DevTools（这个工具很顶阿！）（React的开发者工具React Developer Tools也推荐安装），在谷歌商店添加拓展插件即可 但是使用这个工具还得安装拓展库 npm i redux-devtools-extension 别忘了还要再store.js文件中导入 + 使用 （你会看到一个奇葩的格式。。。这样子的语法：composeWithDevTools(applyMiddleware(thunk))） // 引入redux-devtools-extension import {composeWithDevTools } from 'redux-devtools-extension' // 让store愿意接收action作为一个函数 import thunk from 'redux-thunk' // 暴露store export default createStore(allReducer, composeWithDevTools(applyMiddleware(thunk))) //如果没使用applyMiddleware(thunk)：export default createStore(allReducer, composeWithDevTools()) 9.HooksReact的Hook 是 16.8版本新增的特性/语法，可以让我们在函数式组件中使用state和其他React特性 函数式组件最主要没有上述功能的原因是没有实例对象，没有this（现在函数式组件是主流了） 三个常用的Hook State Hook：React.useState()，让我们是使用state const [xxx, setXxx] = React.useState(initValue) 参数: 第一次初始化指定的值在内部作缓存 返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数 Effect Hook：React.useEffect()，让我们使用生命周期函数 useEffect(fn, [stateValue]) 根据stateValue数组的范围，可划分 componentDidMount()、componentDidUpdate()两种生命周期函数，stateValue为监听的state fn是作为以上两种生命周期函数进入该周期执行的回调函数。 fn可以再返回一个函数fn2，fn是作为componentWillUnmount()这个生命周期函数 综上所述，可以把 useEffect Hook 看做如下三个函数的组合`componentDidMount()` `componentDidUpdate()` `componentWillUnmount()` Ref Hook：React.useRef() const refContainer = useRef() State Hook使用示范 import React from 'react' // 这个demo函数调用次数 = render次数 function Demo() { // 保存状态和更新状态的方法，都自定义名字 //这里react底层做了处理，第一次调用，就把count数据存了下来，所以即使调用了很多次Demo，也不会把新的count把旧的count覆盖掉 const [count, setCount] = React.useState(0); const [NewArr, setArr] = React.useState([0]); function add() { // 第一种写法，适用于改变一次的情况 setCount(count + 1); // 第二种写法，适用于不断改变的情况，比如定时器，此时count总能获取到上次状态设置好的count // setCount(count => count+1) // setCount(preState => preState+1) 更容易理解 } function addArr() { setArr([NewArr.length, ...NewArr]) } return ( &lt;div> &lt;h2>当前的Count为：{count}&lt;/h2> &lt;button onClick={add}>+1&lt;/button> &lt;button onClick={addArr}>为数组添加数据&lt;/button> 当前数组：&lt;ul>{ NewArr.map((item, index) => { return ( &lt;li key={index}>{item}&lt;/li> ) }) } &lt;/ul> &lt;/div> ) } export default Demo; Effect Hook 示范 // 总觉得有点像vue里的watch //第一个参数相当于两个钩子，一个是DidMount、一个是DidUpdate // 第一个参数返回值相当于componentWillUnmount React.useEffect(() => { let timer = setInterval(() => { setCount(count => count + 1); }, 1000); return () => { //组件卸载前执行，相当于componentWillUnmount，可以执行比如清除定时器，取消订阅等操作 clearInterval(timer); } }, []) //这里传入空数组，可以当作componentDidMount来使用 // React.useEffect(() => { // // do something // }, [count]) 只监测count的变化，有点像隶属于count的watcher，如果第二个参数不传入，则全部state都监听 其中第二个参数为依赖数组，每次都会进行“浅比较”，判断是否重新渲染 Ref Hook 示范 function Demo() { // 感觉和类式组件的createRef差不多 const myRef = React.useRef(); function show() { alert(myRef.current.value); } return ( &lt;div> &lt;input type=\"text\" ref={myRef} /> &lt;button onClick={show}>tip&lt;/button> &lt;/div> ) } 对于Hook的理解不能只停留在这种桌面上对于周期函数 -&gt; useEffect，更要心领神会，忘记之前所学的“生命周期”，他们还是有很多不同之处的， 比如 useEffect 直接使用state、props，会捕获到 “初始的 props和state”（当前渲染状态/ 次数下的props和state），而在useEffect中使用useRef可以获取到最新的数据之类的。 下面这篇文章可以帮助大家加深React Hook的印象https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/ React Hook书写习惯（Borrowed by Robin Wieruch，who is famous in GitHub） 在useEffect中调用异步请求时，顺便在useEffect中定义异步请求，如下（使用 try/catch 块进行错误处理） useEffect(() => { const fetchData = async () => { try{ const result = await axios( 'https://hn.algolia.com/api/v1/search?query=redux', ); setData(result.data); } catch { //.... } fetchData(); }, []); 由于挂钩不应返回任何内容或清理函数，而async 函数返回一个AsyncFunction对象，所以以下写法为错误的 × //错误示范 × useEffect(async () => { const result = await axios( 'https://hn.algolia.com/api/v1/search?query=redux', ); setData(result.data); }, []); 一般建议把不依赖props和state的函数提到你的组件外面，并且把那些仅被effect使用的函数放到effect里面。 如果effect要用到外面的函数（不在effect中定义的函数） 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在effects中使用 也可以在定义这些函数的地方用useCallback包一层 出现无限重复请求的问题： 没有设置effect依赖参数（你至少也设置一个空数组呀 [] ，如果没有的话个人感觉有点像进入到类式组件的redner中） 无限循环的发生也可能是因为你设置的依赖总是会改变 不要对依赖项进行撒谎，effect中用到的所有组件内的值都要包含在依赖中。这包括props，state，函数 — 组件内的任何东西。（虽然有时可能导致死循环，但是解决方法不是移除依赖项！——前端大师 Dan说到） function SearchResults() { async function fetchData() { // ... } useEffect(() => { fetchData(); }, []); // Is this okay? Not always -- and there's a better way to write it. // ... } 如果导致死循环，也就是依赖项在Effect中被改动，该如何是好？ 让Effect减少依赖项，仔细思考一下，我们真的需要在Effect中时用到这个依赖项吗？减少“错误依赖”的产生，巧用 setCount(c =&gt; c+1)，也就是这种函数的形式，减少依赖项 处理state中出现相互依赖的关系时，比如 setCount(c =&gt; c + step);（step是一种状态），此时依赖项要添加上step，消除这个依赖项我们可以使用useReducer！ 技术参考：https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/ 自定义hook自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook（实质上自定义hook也我们平时使用函数复用相同逻辑的代码是一样的，只是自定义hook这个函数里面我们可以调用其他的hook，比如State Hook、Effect Hook等） React官方示例 import { useState, useEffect } from 'react'; function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); useEffect(() => { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () => { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; } 它就像一个正常的函数。但是它的名字应该始终以 use 开头，这样可以一眼看出其符合 Hook 的规则。 在React 函数中使用（分别在两个组件中使用相同的逻辑代码） function FriendStatus(props) { const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) { return 'Loading...'; } return isOnline ? 'Online' : 'Offline'; } function FriendListItem(props) { const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style={{ color: isOnline ? 'green' : 'black' }}> {props.friend.name} &lt;/li> ); } 官方的问题回答： 在两个组件中使用相同的 Hook 会共享 state 吗？不会。自定义 Hook 是一种重用状态逻辑的机制，他们的state是相互隔离的 useReduceruseReducer是useState的替代方案 const [state, dispatch] = useReducer(reducer, initialArg, init); 在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。所以当你写类似setSomething(something =&gt; ...)这种代码的时候，也许就是考虑使用reducer的契机 当你想更新一个状态，并且这个状态更新依赖于另一个状态（非自身状态）的值时，你可能需要用useReducer去替换它们。 官网的使用示例 const initialState = {count: 0}; function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1}; case 'decrement': return {count: state.count - 1}; default: throw new Error(); } } function Counter() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;> Count: {state.count} &lt;button onClick={() => dispatch({type: 'decrement'})}>-&lt;/button> &lt;button onClick={() => dispatch({type: 'increment'})}>+&lt;/button> &lt;/> ); } 从此中我们可以看到，是有点类似于redux的模式 为什么用dispatch替换依赖项会更好？React会保证dispatch在组件的声明周期内保持不变。在下面的例子中我们不再重新订阅定时器 （正常情况下使用useEffect订阅定时器，当step依赖项发生改变时，定时器将会被重新订阅；反观使用dispatch，在定时器开启后，如果step发生改变，定时器不会被重新渲染，而是采用之前的step） import React, { useReducer, useEffect } from \"react\"; import ReactDOM from \"react-dom\"; function Counter() { const [state, dispatch] = useReducer(reducer, initialState); const { count, step } = state; useEffect(() => { const id = setInterval(() => { dispatch({ type: 'tick' }); }, 1000); return () => clearInterval(id); }, [dispatch]); return ( &lt;> &lt;h1>{count}&lt;/h1> &lt;input value={step} onChange={e => { dispatch({ type: 'step', step: Number(e.target.value) }); }} /> &lt;/> ); } const initialState = { count: 0, step: 1, }; function reducer(state, action) { const { count, step } = state; if (action.type === 'tick') { return { count: count + step, step }; } else if (action.type === 'step') { return { count, step: action.step }; } else { throw new Error(); } } （你可以从依赖中去除dispatch, setState, 和useRef包裹的值因为React会确保它们是静态的。不过你设置了它们作为依赖也没什么问题。） 10.React拓展setState使用方法方法一：传统的对象式setState setState(stateChange, [callback]) stateChange为状态改变对象（原state的key: 新的值） callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用 （实际上，setState是一个同步的方法，但是异步执行，也就是改动state的数据是异步的，为了提高性能，会将收集到多个state一次性整合更新。这里其实和Vue的异步渲染原因是一致的） something = () => { const {a} = this.state; //1 this.setState({a:a+1}, () => { //2 console.log(this.state.a) //2 }); console.log(this.state.a); //1 } 方法二：函数式的setState setState(updater, [callback]) updater是一个返回stateChange对象（（原state的key: 新的值）的一个对象）的函数。 updater可以接收到state和props。 callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。 something = () => { this.setState((state, props) => { return {a:state.a+1} },() => { console.log(this.state.a) }); } something2 = () => { this.setState(state => {a:state.a-1}); //不再需要 const {a} = this.state; 这个语句，一行解决 } 对象式的setState是函数式setState的语法糖 LazyLoad-React的懒加载如果有多个所有路由组件，所有的路由组件都会在第一次就全部给你加载完毕。我们可以借助react里面的 Lazy 函数 // lazy为路由懒加载函数，Suspence为如果当前路由组件没能即使请求出来，给用户展示的页面信息 import React, { Component, lazy, Suspense } from 'react' 引入路由组件是写的方式有所变化 （在Vue中是直接 const Home = () =&gt; import(&#39;../components/home&#39;);） // import Home from './pages/Home' // import About from './pages/About' const Home = lazy(() => import('./pages/Home')) const About = lazy(() => import('./pages/About')) 但是注册路由部分需要使用 从React 引入的 Suspense 组件进行包裹，为的是当前路由组件没能及时加载出来，给用户展示的页面信息 {/* 注册路由部分都给我用Suspence包裹起来,fallback部分可以放置一个组件 */} {/* 但是这个放置的加载组件，不能使用路由懒加载 */} &lt;Suspense fallback={&lt;h2>Loading...&lt;/h2>}> {/* 注册路由 */} &lt;Route path=\"/about\" component={About}>&lt;/Route> &lt;Route path=\"/home\" component={Home}>&lt;/Route> &lt;Redirect to=\"/about\" /> &lt;/Suspense> Fragment正常情况下，我们使用jsx语法们都需要在外层包裹一层div，但其实有另外一个选择，就是在外层包一层Fragment（隶属于源码干净强迫症患者） &lt;Fragment> .... &lt;/Fragment> 最终Fragment会被React解析，丢弃，撰写Fragment实际上是为了骗过jsx语法（类似Vue的template），由此可以得到没有太多曾div包裹的干净html代码 0.0 实际上我们可以写空标签，它也可以实现fragment的效果 &lt;> ..... &lt;/> 只不过如果使用fragment标签，可以给它添加key属性： &lt;Fragment key={1}&gt;，所以使用fragment标签可以进行遍历，二空标签不行 Context一种组件间通信方式（生产消费者模式），常用于祖组件和后代组件的通信（祖孙），在应用开发中一般不用context, 一般都用它的封装react插件 （回忆：父传子直接props，子传父用回调，兄弟等跨父子可用订阅发布机制或者redux） 1.创建Context容器对象：const XxxContext = React.createContext() 2.渲染子组时，外面包裹xxxContext.Provider标签, 通过value属性给后代组件传递数据 3.哪个子组件要使用，则 如果是类式子组件，需要 static contextType = XxxContext;进行声明接收；然后 this.context.username 就可以使用祖组件传过来的数据了 如果是函数式组件，则需要通过 XxxContext.Consumer标签进行声明接收，并且由回调函数得到祖组件传来的数据 import React, { Component } from 'react' //记住这里赋值变量名首字母大写，因为现在要把MyContext作为组件去使用 const MyContext = React.createContext(); export default class App extends Component { state = { username: 'Allen', age: 18 } render() { const { username, age } = this.state return ( &lt;div> I am grandFather &lt;MyContext.Provider value={{ username, age }}> &lt;Son /> &lt;/MyContext.Provider> &lt;/div> ) } } class Son extends Component { render() { return ( &lt;div> &lt;Grand /> &lt;/div> ) } } // class Grand extends Component { // // 举手示意我要使用(必须要声明才能接收到) // static contextType = MyContext; // render() { // return ( // &lt;div> // {this.context.username} // &lt;/div> // ) // } // } // 函数式组件写法 function Grand() { return ( &lt;div> &lt;MyContext.Consumer> { value => { return `My name is ${value.username}, my age is ${value.age}` } } &lt;/MyContext.Consumer> &lt;/div> ) } React的插槽技术在我们封装自定义的 Link 标签时（React（上）路由篇章部分），我们直接在自定义路由组件标签内写入文字，从而在子组件里面可以使用 children属性进行接收（this.props.children） 插槽技术的实用性在于：预留位置，随时改变整个组件 由此，我们可以看到React在处理组件插槽时的策略 class App extends Component { render() { return ( &lt;div> &lt;A> &lt;B /> &lt;/A> &lt;/div> ); } } class A extends Component { render() { return ( &lt;div> I am A {this.props.children} &lt;/div> ); } } class B extends Component { render() { return ( &lt;div> I am B &lt;/div> ); } } 此时B要算作A的子组件，可是此时B如何获取到A的state呢？以上的 children props只能实现传递结构，无法传递数据 我们要使用render props（实际上也有点像利用正常的子传父闭包特性实现） class App extends Component { render() { return ( &lt;div> {/* render是自定义的属性名，但是我们一般都定义为render */} &lt;A render={(name) => &lt;B name={name} />} /> &lt;/div> ); } } class A extends Component { state = { name: 'Allen' } render() { return ( &lt;div> I am A {this.props.render(this.state.name)} &lt;/div> ); } } class B extends Component { render() { return ( &lt;div> I am B &lt;br /> {this.props.name} &lt;/div> ); } } 由此，我们也可以是实现作为插槽的父子组件数据传递了 在Vue中，以上被称为slot技术。 错误边界由于某些不可控因素，代码错误、后端数据问题、服务器崩溃、返回数据undefined等 而ErrorBoundary，不要让一个子组件的错误，影响到整个组件都无法呈现 我们之前学习过 getDerivedStateFromProps钩子（新钩子），这一次是 我们使用 getDerivedStateFromError处理错误边界 getDerivedStateFromError： 如果该组件的子组件出现任何的报错，都会调用这个钩子，并携带错误信息作为参数 它必须返回一个状态对象，只能捕获后代组件生命周期产生的错误（包括render） getDerivedStateFromError 经常搭配另外一个不太常用的 钩子 componentDidCatch 一起使用 class App extends Component { state = { hasError: '' //用于表示子组件是否产生错误 } // 在出错组件的父组件进行处理 getDerivedStateFromError static getDerivedStateFromError(err) { return { hasError: err } } // 统计子组件错误次数，反馈给服务器，用于通知编码人员bug的解决： componentDidCatch() { console.log(); } render() { return ( &lt;div> I am App {/* 不过在生产环境下其实还是会出现网页整体报错，但是打包后就不会了 0.0 */} {this.hasError ? &lt;h2>当前网络不稳定，请稍后重试&lt;/h2> : &lt;A />} &lt;/div> ); } } useLayoutEffect官方的推荐使用时机： 如果你正在将代码从 class 组件迁移到使用 Hook 的函数组件，则需要注意 useLayoutEffect 与 componentDidMount、componentDidUpdate 的调用阶段是一样的。但是，我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。 所以我们可以看到useEffect 并不等价于 componentDidMout，而useLayoutEffect 才是与 componentDidMount 等价 useEffect 和 useLayoutEffect的差异 useEffect 是异步执行的，而useLayoutEffect是同步执行的。（所以设计到渲染操作放到useLayoutEffect里面去） useEffect 的执行时机是浏览器完成渲染之后，而 useLayoutEffect 的执行时机是浏览器把内容真正渲染到界面之前，和 componentDidMount 等价。 如果使用服务端渲染，使用 useLayoutEffect 可能会导致实际渲染效果和服务端渲染初衷不一致 参考链接 https://zhuanlan.zhihu.com/p/348701319 useContext函数式组件除了可以使用 Consumer 接受Context的数据，还可以使用useContext进行接收（特别是在多个context的时候，更能体现出useContext的优势） function HeaderBar() { return ( &lt;CurrentUser.Consumer> {user => &lt;Notifications.Consumer> {notifications => &lt;header> Welcome back, {user.name}! You have {notifications.length} notifications. &lt;/header> } } &lt;/CurrentUser.Consumer> ); } function HeaderBar() { const user = useContext(CurrentUser); const notifications = useContext(Notifications); return ( &lt;header> Welcome back, {user.name}! You have {notifications.length} notifications. &lt;/header> ); } 11.React优化PureComponent问题一：执行setState的时候，即使state未发生改变，也会重新render（不过redux的更新也由此得益） 问题二：React中使用父子组件嵌套时，父组件使用props传入state的状态，发生 setState 时state改变，setState触发 render()，而传入的props也随之改变，子组件也发生 render()；但是如果没有传入props，父组件发生 render()更新时，因为子组件也放在 render()里面，所以子组件即使没什么要改的地方，也不得不随着父组件一起 render()更新 造成原因： Component中的shouldComponentUpdate()总是返回true（拉闸开门） 在我们研究中，可以判断： shouldComponentUpdate(nextProps, nextState) { console.log(this.props, this.state); //当前组件的props、state console.log(nextProps, nextState); //发生更新后的props、更新后的state return !this.props.属性 === nextProps.属性 &amp;&amp; !this.state.属性 === nextState.属性 } 在开发中解决： 我们可以使用React带的 PureComponent，它能帮我们自动重写阀门这个逻辑 import React, { PureComponent } from 'react' 然后定义类式组件时，原本继承Component -&gt; 继承PureComponent export default class App extends PureComponent { //xxx } 但实际上 PureComponent 有些许小瑕疵（类似于redux小bug）,它在底层也是做一个浅比较，如果只是数据对象内部数据变了，shouldComponentUpdate()返回false changeSomething = () => { let obj = this.state; obj.username = 'Bruce'; this.setState(obj); //地址没有改变，不发生变化 // this.setState({ username: 'Bruce' }) 这个也不顶用了 // 之前不推荐使用push、unshift const { student } = this.state; student.push('Olivia'); this.setState({ student: student }); ////地址没有改变，不发生变化 } 正确写法： this.setState({ username:'Bruce', student: ['Olivia', ...student] }); useCallback官方： 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。 这里引入一个例子 function Foo() { const [count, setCount] = useState(0); const handleClick() { console.log(`Click happened with dependency: ${count}`) } return &lt;Button onClick={handleClick}>Click Me&lt;/Button>; } 这里每次渲染，都会造成handleClick重新创建，给Button是不同的引用，然后Button也跟着渲染。 function Foo() { const [count, setCount] = useState(0); const memoizedHandleClick = useCallback( () => console.log(`Click happened with dependency: ${count}`), [count], ); return &lt;Button onClick={memoizedHandleClick}>Click Me&lt;/Button>; } 此时在依赖项count不变的情况下，他会返回相同的引用，避免Button无意义的重复渲染。 useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。 useMemoconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]); 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。 关于useCallback和useMemo更深一侧的了解（利弊关系）可以查看https://jancat.github.io/post/2019/translation-usememo-and-usecallback/，实质上可以当成对时间、空间的分配置换关系来看就行了 使用场景： 一、应该使用 useMemo 的场景 保持引用相等 对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo。 自定义 Hook 中暴露出来的 object、array、函数等，都应该使用 useMemo 。以确保当值相同时，引用不发生变化。 使用 Context 时，如果 Provider 的 value 中定义的值（第一层）发生了变化，即便用了 Pure Component 或者 React.memo，仍然会导致子组件 re-render。这种情况下，仍然建议使用 useMemo 保持引用的一致性。 成本很高的计算 比如 cloneDeep 一个很大并且层级很深的数据 二、无需使用 useMemo 的场景 如果返回的值是原始值： string, boolean, null, undefined, number, symbol（不包括动态声明的 Symbol），一般不需要使用 useMemo。 仅在组件内部用到的 object、array、函数等（没有作为 props 传递给子组件），且没有用到其他 Hook 的依赖数组中，一般不需要使用 useMemo。 useCallback使用场景 + 死循环https://segmentfault.com/a/1190000020108840 死循环的出现（链接里面的两个例子）： 子组件的渲染依赖父组件传递的函数，而函数被在被调用的时候会触发父组件的渲染，会导致父组件内，该函数的引用发生改变 -&gt; 传入子组件函数发生改变，函数再次调用 -&gt; 死循环 函数依赖自身自家组件的state（加上usecallback，但依赖列表也要添加自身的state），state发生改变，引用再次改变 -&gt; 再调用，再改变，再调用，再改变。 解决方法： 将方法传递给子组件的时候包一层useCallback 自定义hook 12.React 17.0新增特性一览（主要的，也可以说是我所关注的） （1）在React 16和更早的版本中，React将对大多数事件执行document.addEventListener()。 React 17将在后调用rootNode.addEventListener()。（也就是将事件委托从 document 切换为 root） 一张图明示两者的差异 )（2) React 17支持新的JSX转换。我们还将对它支持到React 16.14.0，React 15.7.0和0.14.10。需要注意的是，这是完全选择启用的，您也不必使用它。之前的JSX转换的方式将继续存在，并且没有计划停止对其支持。 更多：https://juejin.cn/post/6885881513741647886","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"React(上)","slug":"React(上)","date":"2021-05-06T05:16:30.444Z","updated":"2021-08-22T11:50:35.039Z","comments":true,"path":"2021/05/06/react-shang/","link":"","permalink":"https://taylor12138.github.io/2021/05/06/react-shang/","excerpt":"","text":"1.React简介react由Facebook开发 &amp; 开源的一个用于构建用户界面、将数据渲染为html视图的开源JavaScript库 react相对于原生js的优点： 采用组件化模式，声明式编码，提高组件复用率 React Native中可以使用React 语法进行移动端开发 使用了虚拟DOM和diff算法，减少和真实DOM的交互 下载react的文件（当前阐述的是16.8版本） babel.js不仅适用于es6 -&gt; es5 语法的转换，还适用于 jsx -&gt; js 的转换 react.development.js 为react的核心库 react-dom-development为react的拓展库，可用于操作dom等 引入顺序 &lt;div id=\"container\">&lt;/div> &lt;script src=\"./js/react.development.js\">&lt;/script> &lt;script src=\"./js/react-dom.development.js\">&lt;/script> &lt;script src=\"./js/babel.min.js\">&lt;/script> &lt;!-- 告诉浏览器你写不是默认的js，而是jsx --> &lt;script type=\"text/babel\"> // 创建虚拟dom const VDOM = &lt;h1>hello react!&lt;/h1> // 渲染到页面 ReactDOM.render(VDOM, document.querySelector('#container')) &lt;/script> JSX的使用直接使用原生js也能创建虚拟dom // document.createElement为创建真实dom，以下是创建虚拟dom // 不使用jsx创建虚拟dom，React.createElement(标签名, 标签属性, 标签内容) const VDOM = React.createElement('h1', { id: 'title', className: 'title' }, 'hello, world'); // 渲染到页面 ReactDOM.render(VDOM, document.querySelector('#container')) 使用jsx的原因是jsx对于多重嵌套的标签比较容易撰写，而原生js比较难顶 const VDOM = React.createElement('h1', { id: 'title' }, React.createElement('h2', {}, 'hahaha')); 然而使用jsx const VDOM = ( &lt;h1 id=\"title\"> &lt;span>hello, react&lt;/span> &lt;/h1> ) 综上，还是乖乖使用jsx比较吃香 JSX语法1.定义虚拟DOM时，不要写引号 2.在大括号中可以填入js的表达式，但不代表所有js语句、js代码 表达式：一个表达式会产生一个值，可以放在任意一个需要值的地方，简单来说，就是能用变量 const x = 表达式接收的，均为表达式 不可以填入if、for等js语句（但是我们可以使用数组的map、三元表达式等语法来填补） 3.样式指定类名时不要用class，而是使用className 4.内联表达式时，style要注意键值的形式去写，这里使用双括号并不是类似于vue的八字胡语法，而是一个大括号填入js表达式，一个大括号表示这是一个对象 const inner = 'hello, react' const VDOM = ( &lt;h1 className=\"title\"> &lt;span style={{ color: 'white', backgroundColor: 'red' }}>{inner}&lt;/span> &lt;/h1> ) // 渲染到页面 ReactDOM.render(VDOM, document.querySelector('#container')) 5.只能有一个根标签，有点类似vue的template模板 6.标签必须闭合，即使遇到像input这种实质上再html中单标签就可以的，也必须进行双标签闭合 const VDOM = ( &lt;div> &lt;input type=\"text\" /> &lt;/div> ) 7.标签首字母若是小写，则转换为html同名标签元素，若html无该标签对应的，则报错同名元素；若大写字母开头，react则取渲染对应的组件，若没定义该组件，则报错（这里和vue不同，vue也是直接小写，遇到驼峰则用 - 连接） 8.jsx写注释的时候，要 {/*&lt;input type=&quot;text&quot; /&gt;*/}这样写 2.React的组件化函数式组件即用函数定义的组件 它适用于简单的组件定义 &lt;div id=\"container\">&lt;/div> &lt;script src=\"./js/react.development.js\">&lt;/script> &lt;script src=\"./js/react-dom.development.js\">&lt;/script> &lt;script src=\"./js/babel.min.js\">&lt;/script> &lt;!-- 告诉浏览器你写不是默认的js，而是jsx --> &lt;script type=\"text/babel\"> function MyComponent() { return &lt;h2>函数定义的组件&lt;/h2> } // 记住jsx里标签必须闭合 ReactDOM.render(&lt;MyComponent />, document.querySelector('#container')); &lt;/script> 而此时在函数内部打印this，得到的结果为undefined function MyComponent() { console.log(this) //undefined return &lt;h2>函数定义的组件&lt;/h2> } 那是因为babel编译后开启了严格模式，使得指向window都改成指向undefined 此时内部： React解析组件标签 -&gt; 找到组件 -&gt; 调用函数 -&gt; 虚拟DOM转为真实DOM，随后呈现在页面中 类式组件用类定义的组件 它适用于复杂的组件定义 class MyComponent extends React.Component { render() { return &lt;h2>hello React&lt;/h2> } } //这里的的render和上方类定义的render没有关系，只是同名罢了 ReactDOM.render(&lt;MyComponent />, document.querySelector('#container')) 创建类式组件必须1.继承react定义的内置类2.必须写render3.render必须有返回值 而此时在render打印this，得到的结果为MyComponent实例对象（React内部帮你new了一个） class MyComponent extends React.Component { render() { console.log(this) return &lt;h2>hello React&lt;/h2> } } 此时内部： React解析组件标签 -&gt; 找到组件 -&gt; new出实例，调用原型上render方法 -&gt; 将render返回的虚拟DOM转为真实DOM，随后呈现在页面中 看到其他文章中的组件对象，其实基本上可以默认他们是用类式组件定义的。 组件三大核心属性之state实际上隶属于类式组件，毕竟有实例对象，才有对应的属性 state（状态） 有点像vue的data / vuex的state，存储数据，在组件化的使用过程中，我们时常把数据存储在组件们共同的父组件的state里（官方称之为状态提升） class MyComponent extends React.Component { constructor(props) { super(props); this.state = { isHot: true } } render() { return &lt;h2>today is {this.state.isHot ? 'hot' : 'cold'}&lt;/h2> } } setState (状态更新) 然而在React中，修改完状态，不能和Vue一样直接做到响应式，需要我们去使用setState！！从而改动页面上呈现的数据效果 这里的setState是一个合并的动作，如果其他state属性没有发生改变，并不会发生丢失 setState要求传入一个对象 class MyComponent extends React.Component { constructor(props) { super(props); this.state = { isHot: true } this.changeWeathter = this.changeWeathter.bind(this); } render() { return &lt;h2 onClick={this.changeWeathter}>today is {this.state.isHot ? 'hot' : 'cold'}&lt;/h2> } changeWeathter() { const isHot = !this.state.isHot; //实际上也是因为setState这个方法，才能让state称为核心属性之一，泪目。。 this.setState({ isHot: isHot }) } } ReactDOM.render(&lt;MyComponent />, document.querySelector('#container')) 从这里我们可以看出，每次setState，render都会调用一次对页面进行渲染（有点控制页面回流重绘的感觉，所以绝对不能再render里进行setState），总共调用 1 + n次，而construtor只会在初始化的时候调用一次 react事件监听（前传）原生js onclick -&gt; React onClick (vue的是 v-on:click=&quot;&quot; 或者@click=&quot;&quot;) 原生js onblur -&gt; React onBlur (vue的是 v-on:blur=&quot;&quot; 或者@blur=&quot;&quot;) 原生js onkeyup -&gt; React onKeyUp (vue的是 v-on:keyup=&quot;&quot; 或者@keyup=&quot;&quot;) 普通函数的调用（注意不要加括号！） class MyComponent extends React.Component { render() { return &lt;h2 onClick={fn}>hello React&lt;/h2> } } ReactDOM.render(&lt;MyComponent />, document.querySelector('#container')) function fn(){ console.log('today is a good day'); } react中this指向 要注意的是： 以下代码中render输出this的是MyComponent组件实例 fn输出的this是undefined constructor的this指向的也是MyComponent组件实例 因为在使用类式组件时，是new出组件对象实例，然后都通过该实例调用render方法，所以在render中this指向的是组件对象实例 而constructor构造函数中的this一定是指向当前对象的实例 而这里的fn方法，是在全局下调用的，没有在render下完成调用，this应该是指向window，但是在类内部自动帮你开启了局部严格模式，所以this指向了undefined （我个人在es5笔记中总结的在类中的this指向的是其实例对象，实质上是因为我们调用函数时，是通过实例对象来调用的，比如p1.render()，此时this当然指向的是实例对象，而这里的 函数方法类似于发生了 const x = p1.fn; x();的操作） class MyComponent extends React.Component { constructor(props){ super(props); } render() { console.log(this); //实例对象 return &lt;h2 onClick={this.fn}>hello React&lt;/h2> } fn(){ console.log(this); //undefined } } ReactDOM.render(&lt;MyComponent />, document.querySelector('#container')) 解决方法一：在constructor使用bind（即创造新的函数 const f = fn.bind(xx)，拷贝，无调用） constructor(props){ super(props); this.fn = this.fn.bind(this); } 解决方法二： 简化方案 在实际开发中，不会使用到如上比较麻烦的写法，而是利用类中直接写赋值语句的操作，往实例自身默认追加一个属性 此时函数成为了实例的自定义方法，且this的指向能毫不动摇指向实例 class MyComponent extends React.Component { state = { isHot: true } render() { return &lt;h2 onClick={this.changeWeathter}>today is {this.state.isHot ? 'hot' : 'cold'}&lt;/h2> } //箭头函数this指向函数定义上下文的this //要写成 changeWeathter = function(){}的形式才能改为箭头函数，没有changeWeathter()=>{}的写法，所以只能： changeWeathter = () =>{} changeWeathter = () => { const isHot = !this.state.isHot; this.setState({ isHot: isHot }) } } 组件三大核心属性之propsprops用于组件间数据传递 父传子，和vue的props类似，都是在组件标签上赋值传递；父组件传入的props如果是state，发生了setState，重新render()一次，传入的props也会随之更新 注意：props属性是只读的，不可以修改 class MyComponent extends React.Component { render() { return ( &lt;ul> &lt;li>性名：{this.props.name}&lt;/li> &lt;li>性别：{this.props.sex}&lt;/li> &lt;li>年龄：{this.props.age}&lt;/li> &lt;/ul> ) } } //age={18}才能传入number类型 ReactDOM.render(&lt;MyComponent name=\"Allen\" age={18} sex=\"男\" />, document.querySelector('#container')); 在js语法中，使用 let person1 = {...person2}展开对象中的属性 但是通过React内置 + babel语法加成，可以直接 ...person2进行展开，但是仅仅适用于标签属性的传递，也就是通过props传递 虽然你可以在这里看到一个大括号，但是这只是表明要在jsx中插入js表达式的含义 const p = {name=\"Allen\",age=\"18\",sex=\"男\"} ReactDOM.render(&lt;MyComponent {...p} />, document.querySelector('#container')); 当需要对传入的props进行数据类型、数据默认值等进行限制时，需要引入另一个包 （像 Flow 和 TypeScript 等这些静态类型检查器，可以在运行前识别某些类型的问题。他们还可以通过增加自动补全等功能来改善开发者的工作流程。出于这个原因，我们建议在大型代码库中使用 Flow 或 TypeScript 来代替 PropTypes。） （对于Vue，可以直接让子组件在props属性里定义props传入的数据格式即可） &lt;!-- 引入prop-types包 --> &lt;script src=\"./js/prop-types.js\">&lt;/script> 如果是搭建脚手架，React默认没有帮你下载这个限制包，需要自己下载 npm i prop-types import PropType from 'prop-types' // 对标签属性进行类型、必要性(required)的限制 // 记住上面的时小写props，下面的是大写Props MyComponent.propTypes = { name: PropTypes.string.isRequired, //限制name顺序性必须传入，且为string age: PropTypes.number, //限制age为number } // 默认标签属性值 MyComponent.defaultProps = { sex: '男', //不传入时，sex默认值为'男' age: 18 //不传入时，age默认值为18 } ReactDOM.render(&lt;MyComponent name=\"Allen\" age={18} sex=\"男\" />, document.querySelector('#container')); 如果传入的是函数 MyComponent.propTypes = { speak: PropTypes.func //限制speak为函数 } ReactDOM.render(&lt;MyComponent name=\"Allen\" age={18} sex=\"男\" speak={fn}/>, document.querySelector('#container')); function fn(){} 不过在最好还是都写在React类的内部，但是要添加到类上，而不是类的实例的话，不能直接写表达式，要添加一个static class MyComponent extends React.Component { static propTypes = { name: PropTypes.string.isRequired, age: PropTypes.number, speak: PropTypes.func } // 默认标签属性值 static defaultProps = { sex: '男', age: 18 } render() { //... } } 函数式组件的props上面说道属性都是隶属于类式组件，毕竟有实例对象才有属性，但是props比较特殊，函数组件也可以有，因为函数组件可以传参，即在传参部分使用props进行接收。 （实际上除非使用最新版本的hooks，不然函数式组件不能使用到state 和 refs） function MyComponent(props) { const { name, sex, age } = props; return ( &lt;ul> &lt;li>性名：{name}&lt;/li> &lt;li>性别：{sex}&lt;/li> &lt;li>年龄：{age}&lt;/li> &lt;/ul> ) MyComponent.propTypes = { name: PropTypes.string.isRequired, age: PropTypes.number, speak: PropTypes.func } // 默认标签属性值 MyComponent.defaultProps = { sex: '男', age: 18 } } ReactDOM.render(&lt;MyComponent name=\"Allen\" />, document.querySelector('#container')); 废物构造器（我们在开发的时候，能省就省，几乎不写构造器的原因） 在使用类式组件时，使用其构造器，则会默认传入props，并且需要你使用super(props) 如果直接不传props，直接 super()，React官网已经明示你了，会： 在 React 组件挂载之前，会调用它的构造函数。在为 React.Component 子类实现构造函数时，应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug！！ 在React类式组件里，构造器的作用： 通过给 this.state 赋值对象来初始化内部 state。（可以直接在类中使用表达式替代） 为事件处理函数绑定实例 （可以直接在类中使用表达式 + 箭头函数替代） 实际上也就是之前我们的繁琐两步走，没什么必要。。。so weak constructor(props) { super(props); this.state = { isHot: true } this.changeWeathter = this.changeWeathter.bind(this); } 组件三大核心属性之refs官网提示：请勿过度使用refs，可以通过事件对象event解决（发生事件元素 = 操作的元素），则用event解决 同样的，refs也类似于vue的refs（只不过vue属性都会加上 $），适用于父组件操作子组件时对子组件的获取，也用于父组件获取子组件数据 class Demo extends React.Component { showData = () => { alert(this.refs.input1.value); } showData2 = () => { alert(this.refs.input2.value); } render() { return ( &lt;div> &lt;input ref=\"input1\" type=\"text\" placeholder=\"点击按钮提示数据\" /> &lt;button onClick={this.showData}>click me&lt;/button> &lt;input onBlur={this.showData2} ref=\"input2\" type=\"text\" placeholder=\"失去焦点提示数据\" /> &lt;/div> ) } } ReactDOM.render(&lt;Demo />, document.querySelector('#container')); 以上我使用的是字符串类型的ref（同Vue），但它目前已经不被官方所推荐使用了，甚至有可能废弃掉，以下是官网解释（可能带效率问题）。 过时 API：String 类型的 Refs 如果你之前使用过 React，你可能了解过之前的 API 中的 string 类型的 ref 属性，例如 &quot;textInput&quot;。你可以通过 this.refs.textInput 来访问 DOM 节点。我们不建议使用它，因为 string 类型的 refs 存在 一些问题。它已过时并可能会在未来的版本被移除。 回调式refs 它的回调函数接受 React 组件实例或 HTML DOM 元素作为参数 以 ref = () =&gt; {}形式进行传递 以下代码是对上方字符串形式ref的改进 class Demo extends React.Component { showData = () => { alert(this.input1.value); } showData2 = () => { alert(this.input2.value); } render() { return ( &lt;div> &lt;input ref={currentNode => { this.input1 = currentNode }} type=\"text\" placeholder=\"点击按钮提示数据\" /> &lt;button onClick={this.showData}>click me&lt;/button> &lt;input onBlur={this.showData2} ref={currentNode => { this.input2 = currentNode }} type=\"text\" placeholder=\"失去焦点提示数据\" /> &lt;/div> ) } } ReactDOM.render(&lt;Demo />, document.querySelector('#container')); 官网还有个提示：关于回调 refs 的说明 如果 ref 回调函数是以内联函数的方式定义（也就是把函数直接定义在标签内）的，在更新过程（render调用第二、三次的时候，每次setState，render也都会被调用一次）中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 避免方式也就是在类组件里写一个回调函数，而不是以内联的形式（但是我觉得为了定义一个id，写一个函数，太麻烦了吧0.0） createRef 目前React最新版本的ref使用方法就是用 React.createRef方式 React.createRef调用后会创建一个容器，该容器可以存储被ref所标识的节点（保存在current属性里） 如果你想获取多个节点，就要创建多个React.createRef()，因为它是专有的 class Demo extends React.Component { //但是注意，该容器是专人专用的！如果再次在这个容器存储的话，会覆盖掉原来用ref标识的节点 //所以一个容器存一个节点 myRef = React.createRef(); clickEvent = () => { //节点保存在容器里的current中 alert(this.myRef.current.value) } render() { return ( &lt;div> &lt;input type=\"text\" ref={this.myRef} /> &lt;button onClick={this.clickEvent}>click me&lt;/button> &lt;/div> ) } } refs的使用 在Hook中使用useEffect时，如果你想得到“最新”的值，你可以使用ref 3.React事件监听原生js onclick -&gt; React onClick 原生js onblur -&gt; React onBlur React除了把大小写换了之外，实质上它内部重新自定义了方法，拥有更好的兼容性 除此之外，React的事件，是通过事件委托的方式处理的（委托给组件最外层元素，即将事件都加给了jsx里在外层的div） 和原生js一样，React对事件监听时，会传入事件对象event，可以通过以下形式得到事件对象，避免使用了refs clickEvent = (e) => { alert(e.target.value) } render() { return ( &lt;div> &lt;input type=\"text\" onBlur={this.clickEvent} /> &lt;/div> ) } 非受控组件 &amp; 受控组件非受控组件 说由输入类的DOM，比如 input，如果是现用现取，则为非受控组件，比如下方就是一个非受控组件 class Login extends React.Component { handle = (e) => { e.preventDefault(); const { userName, password } = this; alert(`用户名：${userName.value}, 密码：${password.value}`) } render() { return ( &lt;div> &lt;form action=\"https://www.baidu.com\" onSubmit={this.handle}> 用户名&lt;input type=\"text\" ref={node => this.userName = node} name=\"username\" /> 密码&lt;input type=\"password\" ref={node => this.password = node} name=\"password\" /> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) } } 受控组件（建议） 也可以说是利用触发本身事件，不需要使用到ref，然后保存于state 这个案例实际上可以理解为Vue的 v-model语法糖，只不过这里需要我们自己写 class Login extends React.Component { state = { userName: null, passWord: null } changeName = (e) => { this.setState({ userName: e.target.value }) } changePsw = (e) => { this.setState({ passWord: e.target.value }) } handle = (e) => { e.preventDefault(); const { userName, passWord } = this.state; alert(`用户名：${userName}, 密码：${passWord}`) } render() { return ( &lt;div> &lt;form action=\"https://www.baidu.com\" onSubmit={this.handle}> {/* onChange事件和DOM的onchange不一样，这里只要表单的value发生改变，就会回调事件*/} 用户名&lt;input type=\"text\" onChange={this.changeName} name=\"username\" /> 密码&lt;input type=\"password\" onChange={this.changePsw} name=\"password\" /> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) } } React函数传参在Vue中，如果该方法不需要传递参数，则方法后面的()可以不用添加， 如果需要传入参数，则使用 函数名(参数)的形式 但是在React中，如果使用 函数名()的形式，比如在标签里 &lt;h2 onClick={this.fn()}&gt;hello React&lt;/h2&gt;，则在触发事件时，并不会回调函数，而是在网页渲染的时候调用一次，此时传入的回调函数是fn里的返回值，若没写入返回值，则传入的是undefined 所以我们需要用一个巧妙的方法，方便我们传入参数，即在事件回调函数里，返回一个回调函数！！（即使用函数柯里化的方式） 方法一：柯里化方式 以下是对上方chang事件的优化，实现用户名 和 密码都可以使用同一个函数 cChange = (dataType) => { return (event) => { this.setState({ // 作为键名时，如果是变量名直接写，就必须加[] [dataType]: event.target.value }) } } 然而，除此之外，还有其他不用柯里化的方式也能实现React函数传参 方法二：内联的箭头函数我个人认为实质上和柯里化的意思差不多，只是在内联部分实现罢了 cChange = (dataType, event) => { this.setState({ // 作为键名时，如果是变量名直接写，就必须加[] [dataType]: event.target.value }) } render() { return ( &lt;div> &lt;form action=\"https://www.baidu.com\" onSubmit={this.handle}> 用户名&lt;input type=\"text\" onChange={event => this.cChange('userName', event)} name=\"username\" /> 密码&lt;input type=\"password\" onChange={event => this.cChange('passWord', event)} name=\"password\" /> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) } React生命周期函数生命周期函数可以不用箭头函数，因为它们和render属于同一性质，在创建页面/销毁页面的时候通过类的实例调用一次 1.挂载组件mount 卸载组件unmount componentDidMount（和Vue的mounted一样，只调用一次，即挂载组件的时候调用一次，类似于render的兄弟，只不过setState不能在 render里进行调用，然而setState可以在 mountd里面调用 ） 使用方式： componentWillMount(){}调用：组件即将挂载时 componentDidMount(){}调用：组件挂载完毕（常用） componentWillUnmount() {}调用：组件被卸载前执行，有点像vue里的beforeDestory（常用，一般用于解决一些内存泄漏的问题） 卸载节点(组件)的方式 ReactDOM.unmountComponentAtNode(节点) 2.render：初始化渲染或者状态更新之后（常用） 有点类似Vue的updated，因为Vue官方解释对于updated也是避免在里面操作DOM，可能会引起死循环，而在render里调用setState，也会引起死循环！ 以下为生命周期函数小案例 class Life extends React.Component { state = { opacity: 1 } wind = () => { // 卸载节点 ReactDOM.unmountComponentAtNode(document.querySelector('#container')) } componentDidMount() { if (this.timer) this.timer = null; this.timer = setInterval(() => { console.log('gg'); let { opacity } = this.state; opacity -= 0.1; if (opacity &lt;= 0) opacity = 1; this.setState({ opacity }) }, 200) } componentWillUnmount() { //在卸载节点之前，清除定时器，防止报错 + 内存泄露 clearInterval(this.timer); } render() { return ( &lt;div> &lt;h1 style={{ opacity: this.state.opacity }}>刮风之前&lt;/h1> &lt;button onClick={this.wind}>刮风之后&lt;/button> &lt;/div> ) } } ReactDOM.render(&lt;Life />, document.querySelector('#container')) 旧版React生命周期图 我们可以看到（由ReactDOM.render()触发）初始化阶段： constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount 更新阶段，有 setState、 forceUpdate、 父组件重新render 三条时间线 发生了setState -&gt; shouldComponentUpdate（是否应该重新更新页面），如果返回false，阀门关闭，则停住；如果返回true，则进行下一步（这个生命周期钩子默认返回true） -&gt; componentWillUpdate-&gt; render发生更新 -&gt; componentDidUpdate 第二条线，发生了 forceUpdate() -&gt; componentWillUpdate-&gt; render发生更新 -&gt; componentDidUpdate 第三条，是当其父组件发生了render时，跳转到 -&gt; componentWillReceiveProps(组件将要接收参数) -&gt; shouldComponentUpdate -&gt; componentWillUpdate-&gt; render发生更新 -&gt; componentDidUpdate 但实质上 componentWillReceiveProps 有个坑，就是第一次传入时不算，不会调用这个生命周期函数；然后再第二、三次时，让父组件发生render，子组件就会调用这个生命周期函数 由此我们得到一些其他的生命周期函数 3.shouldComponentUpdate(){} 控制组件是否更新的阀门时钩子 4.componentWillUpdate(){} 组件将要发生更新时钩子 5.componentDidUpdate(){}组件更新完毕时钩子，它可以接收两个参数，第一个参数preProps是先前接收的props值，第二个preState是更新前的state值 6.componentWillReceiveProps(){}父组件 render 再次传入新的props调用 补充： forceUpdate()是强制更新的方法、有时并不想使用setState()，只是单纯想让页面发生更新，可以使用这个函数 新生命周期图 改动一： 在新版本（17.0以上）使用旧的生命周期函数 比如使用 componentWillMount 、 componentWillUpdate、 componentWillReceiveProps 就会出现黄色警告（虽然上图没出现他们三个，但是可以使用）（简称 3 Will组合，但是 componentWillUnMount() 没事 ） 它提示你新版本已经开始使用 UNSAFE_componentWillMount、 UNSAFE_componentWillUpdate，并且提示你可能在18.0版本以后就不能使用旧版本的以上的生命周期函数了 然而为什么这三个生命周期要发生改动？React官方解释道： 这些生命周期方法经常被误解和滥用（不常用，可能导致编程人员用错地方）；此外，我们预计，在异步渲染中，它们潜在的误用问题可能更大。我们将在即将发布的版本中为这些生命周期添加 “UNSAFE_” 前缀。（这里的 “unsafe” 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染之后。） 改动二： 出现新的钩子： 1.getDerivedStateFromProps，它横跨初始化 &amp; 更新部分（这部分英文意思可以理解为：从Props得到派生的状态） 它作为一个静态方法（static），应该挂载到类上，而不是挂载到实例上 它必须返回一个状态对象，不然会报错（不然也得返回一个null） 它可以接受两个参数，即接收props、state，此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props（比如state的 某 key : value 取决于 props 传入的 key : value） static getDerivedStateFromProps(props, state){ } 但是：！！！派生状态会导致代码冗余，并使组件难以维护，所以了解即可 2.getSnapshotBeforeUpdate，它钩在React更新DOM 和 refs之前 （这部分英文意思可以理解为：在更新之前，获取快照）（大家回家之前，集体拍个照 * .* ） 它必须返回一个快照值，不然会报错（不然也得返回一个null） 快照值可以是任意类型 之前讲述到componentDidUpdate(){}生命周期函数，实质上它可以接收第三个参数，也就是 snapshotValue，而snapshotValue就是 getSnapshotBeforeUpdate钩子函数返回的值 componentDidUpdate(preProps, preState, snapshotValue){ //xxxx } 虽然这两个新的钩子名字巨长，很恶心，但是官方也阐述了这两个钩子的使用场景极其罕见 总结： 初始化阶段： constructor -&gt; getDerivedStateFromProps -&gt; render -&gt; componentDidMount 更新阶段，同样也有有 setState、 forceUpdate、 父组件重新render 三条时间线，如上图所示 4.React脚手架使用脚手架开发项目的特点：模块化，组件化，工程化 项目整体技术架构为：react + webpack + es6 + eslint 当然创建react脚手架必须在本地主机上安装react的专用脚手架库 npm i -g create-react-app 切换到我们想要的目录下进行初始化 create-react-app 项目名称 启动项目（默认情况下） npm start 打包项目（默认情况下） npm build 启动项目（默认情况下） React脚手架中通用路径写法： %PUBLIC_URL%/favicon.ico ：public目录下的favicon图标 在index.html中可以看到 &lt;!-- 开启理想窗口、做移动端适配 --> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> &lt;!-- 用于配置浏览器页签 + 地址栏的颜色（仅支持安卓手机） --> &lt;meta name=\"theme-color\" content=\"#000000\" /> &lt;!-- 用于适配苹果系统的图标 --> &lt;link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" /> &lt;!-- 在html上套上安卓 / ios的 apk壳 --> &lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" /> 在src文件夹下 于index.js我们可以看到 import React from 'react' import ReactDOM from 'react-dom' import App from './App' ReactDOM.render( &lt;React.StrictMode> &lt;App /> &lt;/React.StrictMode>, document.getElementById('root') ); 其实也就是平时我们渲染的部分，只是 使用了 &lt;React.StrictMode&gt;，它会自动检查插入组件的撰写是否合理，检查代码合理性 而reportWebVitals.js 和 setupTests.js 分别用于页面性能分析 和 组件单元测试 tip： 在脚手架里，引入文件时，如果文件名是index.js、index.jsx，则引到该文件所处文件夹即可 在脚手架里，引入文件时，如果文件是js / jsx，可以不写后缀名 jsx模板生成的快捷键（类式组件）： rcc jsx模板生成的快捷键（函数式组件）： rfc 脚手架中css模块化正常在jsx文件里引入css： import &#39;./index.css&#39; 实现css模块化：方法一 1.index.css -&gt; index.module.css 2.引入样式：import xx from &#39;./index.module.css&#39; 3.使用样式 :&lt;h2 className={xx.title}&gt; Hello, React &lt;/h2&gt; 方法二：使用less进行嵌套 （React中less使用教程 https://www.cnblogs.com/liangziaha/p/13632623.html ） （还是Vue的scope舒服呀） react中设置全局路径npm run eject 暴露出webpack的配置文件webpack.config.js resolve: { ... alias: { ... // 路径引用 @ '@': paths.appSrc, } } 5.React开发中应用组件数据传递（子传父）利用的是回调函数闭包的特性，和Vue的子组件传递给父组件的 $emit() 有异曲同工之妙 父组件：设置函数，并在子组件上使用props传递该函数 export default class App extends Component { addTodo = (name) => { console.log(name); //得到子组件的数据 } render() { return ( &lt;div> &lt;Header addTodo={this.addTodo}>&lt;/Header> &lt;/div> ) } } 子组件，使用props接收传入的回调函数，并且将数据作为参数进行调用 export default class Header extends Component { addTodo = (e) => { if (e.keyCode !== 13) return; this.props.addTodo(e.target.value); //进行回调 } render() { return ( &lt;div className=\"todo-header\"> &lt;input type=\"text\" onKeyUp={this.addTodo} placeholder=\"请输入你的任务名称，按回车确认\" /> &lt;/div> ) } } id生成库在标识数据唯一性我们需要用到id，当使用random、date.now()生成id都有一定弊端，可以借用uuid，一个id库帮助我们生成id npm i uuid 开发小项目，我更加推荐的是nanoid npm i nanoid nanoid是一个函数，每次调用都会帮你生成一个字符串，保证全球唯一 import {nanoid} from 'nanoid' const str = nanoid(); React内部配置代理跨域(正向代理) 新建一个setupProxy.js文件 在此文件中必须使用cjs的方式撰写（CommonJS），因为这个文件是要加到webpack配置里面的，而webpack用的是node语法 React脚手架内部已经下载好 http-proxy-middleware 库了 proxy内部选项介绍： 第一个参数设置前缀名，比如设置了前缀名为/api1，遇到这个前缀的请求就会触发该代理配置， 原本请求地址 ： http://localhost:3000/student -&gt; 此时我们需要改成 http://localhost:3000/api1/student，就会触发代理 第二个参数是配置 target：我们发送的目标跨域url changOrigin：默认值为false，控制服务器收到请求头中Host（请求资源所在服务器，也就是发送源）字段的值；当changOrigin: true 时，能欺骗服务器，让服务器以为是同源请求，而不知道你的真实host发送源。（实际上不加其实也没关系，但是防止服务器的限制，比较好一点） pathRewrite：重写请求路径，一定要加上，不加上虽然有走代理，请求路径加上了 /api1，不存在该资源，一般会报404 const proxy = require('http-proxy-middleware') ///使用proxy中间件 module.exports = function (app) { app.use( proxy('/api1', { target: 'http://localhost:5000', changOrigin: true, pathRewrite: { 'api1': '' } }), proxy('/api2', { target: 'http://localhost:5001', changOrigin: true, pathRewrite: { '/api2': '' } }) ) } 消息订阅与发布机制工具库 ： PubSubJS 可以在github上下载，也可以直接npm npm i pubsub-js --s 引入后（import PubSub from &#39;pubsub-js&#39; / const PubSub = require(&#39;pubsub-js&#39;);） 官网使用的案例 //回调函数 var mySubscriber = function (msg, data) { //在调用时会传入两个参数，第一个msg就是消息名，第二个data就是交互的数据 }; //订阅消息 var token = PubSub.subscribe('MY TOPIC', mySubscriber); //第一个参数消息名 //第二个参数是收到消息后的回调函数，即如果有人发布了该消息名则进行回调 //发布消息 PubSub.publish('MY TOPIC', 'hello world!'); //第一个参数消息名 //第二个参数是传送的数据 //token接收到订阅的返回值，后续可以使用下列方式取消订阅，防止内存泄漏 PubSub.unsubscribe(token); 利用这个订阅发布机制，我们可以实现兄弟组件的通信！（有点像Vue的eventBus） 小栗子： // 订阅消息名为SearchGitHhub的消息 componentDidMount() { this.token = PubSub.subscribe('SearchGitHhub', (msg, stateObj) => { this.setState(stateObj) }); } componentWillUnmount() { // 临走前取消订阅 PubSub.unsubscribe(this.token); } // 发布消息名为SearchGitHhub的数据 PubSub.publish('SearchGitHhub', { isFirst: false, isLoading: true }); 6.React路由React和Vue一样，都是采取单页面富应用的方式配置网页（SPA），即单个页面通过路由的切换，展示不同的数据信息， 而且改变url，依然是页面不发生整体刷新（只做页面的局部刷新） React-router有三种实现方式，分别对应三种平台 1.web 2.native 3.anwhere 针对Web的路由针对Web，我们使用的是react-router-dom react的一个插件库 专门用来实现一个SPA应用 基于react的项目基本会用到这个库 脚手架并没有自动帮你下载 react-router-dom npm i react-router-dom 首先需要包裹路由，让单页面的所有组件使用统一路由，老师推荐的方式是直接在包裹在渲染APP组件那一块 BrowserRouter &amp; HashRouter BrowserRouter使用H5的history API，不兼容IE9以下版本；HashRouter使用URL的哈希值 HashRouter路径带 # 对于BrowserRouter，刷新后state参数能得以保存，但是HashRouter会丢失state参数（我觉得可能history模式使用到了sessionStorage存储数据） HashRouter可以解决一些关于路径问题（可以看路由嵌套小节的路径坑部分） import { BrowserRouter } from 'react-router-dom' //index.js ReactDOM.render( &lt;BrowserRouter> &lt;App /> &lt;/BrowserRouter>, document.querySelector('#root')) 在主页面App.jsx中引入 + 使用 // 引入react-router-dom中需要使用的模块 import { Link, Route } from 'react-router-dom' //引入自定义组件 import Home from './component/Home' import About from './component/About' 在render中（在Vue中是使用 &lt;router-link&gt;），这里Home、About都属于路由组件，也就是通过路由进行展示，推荐把路由组件放在pages文件夹，而不是放在components文件夹 &lt;Link to=\"/about\">About&lt;/Link> &lt;Link to=\"/home\">Home&lt;/Link> {/* 注册路由 */} &lt;Route path=\"/about\" component={About}>&lt;/Route> &lt;Route path=\"/home\" component={Home}>&lt;/Route> NavLink 如果想要使得link标签点击完后有高亮效果，可以引入 + 使用 &lt;NavLink&gt;，实际上内部还是 &lt;link&gt;，只是你点击了哪一个 Link，就会自动给该 Link添加一个 样式，类名为active，当然也可以定义类名（使用activeClassName），自定义link标签点击后的样式 （在Vue中是通过定义Router实例LinkActiveClass属性进行自定义类名的） &lt;NavLink activeClassName=\"自定义类名\" to=\"/home\">Home&lt;/NavLink> Link的其他属性的补充 默认push方式进入路由，可以替换成replace：replace={true}，或者直接 &lt;Link replace to=\"/home\">Home&lt;/Link> 路由匹配 在进行路由注册时，我们不难发现，如果是进入 /home 路由，则Home、Other组件都会展示 这说明路由匹配完成后还会向下匹配，如果有很多路由，则会逐个匹配，导致效率不高 &lt;Route path=\"/about\" component={About}>&lt;/Route> &lt;Route path=\"/home\" component={Home}>&lt;/Route> &lt;Route path=\"/home\" component={Other}>&lt;/Route> 我们可以使用 Switch，用Switch组件包裹所有注册路由，这时匹配到路由后就不会继续向下匹配 import {Switch} from 'react-router-dom'; &lt;Switch> &lt;Route path=\"/about\" component={About}>&lt;/Route> &lt;Route path=\"/home\" component={Home}>&lt;/Route> &lt;Route path=\"/home\" component={Other}>&lt;/Route> &lt;/Switch> 模糊匹配 路由匹配遵从模糊匹配，比如下方link的to在匹配路由时，以 /home/a/b 进行匹配 ，Home组件依然能得到展示。 但是一定要按照顺序，比如link 的 to里为 /a/home/b就不可以 &lt;Link to=\"/about\">About&lt;/Link> &lt;Link to=\"/home/a/b\">Home&lt;/Link> &lt;Route path=\"/about\" component={About}>&lt;/Route> &lt;Route path=\"/home\" component={Home}>&lt;/Route> {/* 可以展示 */} 如果想要精准匹配（严格匹配），不要搞模糊匹配，则需要添加 exact 属性（但是这个属性在开发中少用，可能引发一些问题，比如不能开启二级路由，非要用到时才要用） &lt;Route exact path=\"/home\" component={Home}>&lt;/Route> 路由重定向import { Redirect } from 'react-router-dom' 默认网页对于每个路由都不匹配（没有点击Link进行路匹配时），此时我们可以使用 Redirect组件进行重定向，让默认网页跳转到某个路由（Redirect一般写在路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定路由） &lt;Switch> &lt;Route path=\"/about\" component={About}>&lt;/Route> &lt;Route path=\"/home\" component={Home}>&lt;/Route> &lt;Redirect to=\"/about\" /> {/* 谁都匹配不上了就去about */} &lt;/Switch> 一般组件和路由组件上方阐述的是路由组件的使用，他们有各自的不同之处（不过Vue就没一般组件、路由组件那么多事） 1.一般组件直接使用，路由组件通过路由 link切换，然后依靠路由匹配决定渲染哪一个 2.一般组件存放于components文件夹，路由组件存放于pages文件夹（公司通用） 3.一般组件如果父组件没传props，则收到空对象，路由组件默认会受到props：history、location、match 4.传参方式不一样，一般组件直接属性传值，props接收，路由组件有三种传参方式 插槽使用上述 NavLink、Link 方法来写路由链接时，有许多冗余的地方，比如多个NavLink使用相同类名、active类名时，有很高的重复性 &lt;NavLink activeClassName=\"自定义类名\" to=\"/home\">Home&lt;/NavLink> &lt;NavLink activeClassName=\"自定义类名\" to=\"/about\">About&lt;/NavLink> &lt;NavLink activeClassName=\"自定义类名\" to=\"/other\">Other&lt;/NavLink> 我们可以自己封装MyLink！(外加小插槽) 标签体内容的接收可以使用插槽，在子组件接收的props里，如果插槽有内容，则自动使用children属性进行接收 &lt;MyLink to=\"/about\" >About&lt;/MyLink> &lt;MyLink to=\"/home\" >Home&lt;/MyLink> 定义封装的子组件 export default class MyLink extends Component { render() { return ( &lt;div> &lt;NavLink className=\"list-group-item\" {...this.props}}>{this.props.children}&lt;/NavLink> &lt;/div> ) } } 实际上，不仅link标签可以以这种方式是用插槽，子组件都可以这样使用，这时父子组件插槽的通用方法 路由嵌套路径坑 如果React直接在路径头嵌套，有可能导致引入文件路径也相对发生错误 &lt;Link to=\"/something/about\">About&lt;/Link> &lt;Link to=\"/something/home\">Home&lt;/Link> &lt;Route path=\"/something/about\" component={About}>&lt;/Route> &lt;Route path=\"/something/home\" component={Home}>&lt;/Route> 原本引入css样式的路径为 &lt;link rel=\"stylesheet\" href=\"./css/bootstrap.css\"> 在切换路由 + F5刷新后路径会随之更改 解决方法一： 改变路径，去掉当前路径 ./，直接 /是去到url的public目录下 &lt;link rel=\"stylesheet\" href=\"/css/bootstrap.css\"> 解决方法二：与上方同理 &lt;link rel=\"stylesheet\" href=\"%PUBLIC_URL%/css/bootstrap.css\"> 解决方法三：使用HashRouter 因为它有一个锚点 #，这样子发送请求时会忽略 #后面的相关哈希值（路由） 路由嵌套二级路由 和Vue一样，使用多重路由嵌套只需在路由组件里，再放置路由组件（Link + Route 组合），切记，这里和Vue一样，link里的to必须要写完整路径（带上父级路由），这样子计算子路由组件未显示，路由也能遵从模糊匹配至少展示一级路由的页面效果 比如 {/* 这里需要给完整的路径， 不能直接to=\"/news\" */} &lt;MyLink to=\"/home/news\">News&lt;/MyLink> &lt;MyLink to=\"/home/messages\">Messages&lt;/MyLink> 当然了，我们的路由注册也得写完整的path路径 {/* 路由注册 */} &lt;Route path=\"/home/Messages\" component={Messages} /> &lt;Route path=\"/home/News\" component={News }/> 路由传参传递参数主要有两种类型：params和query（同Vue） params：需要分别在Link 、 Route里进行声明（只有params才需要声明接收参数） return ( &lt;div> &lt;ul> { messageArr.map(item => { return ( &lt;li key={item.id}> {/* 向路由组件传递params参数 */} &lt;Link to={`/home/Messages/Detail/${item.id}/${item.title}`}>{item.title}&lt;/Link> &lt;/li> ) }) } &lt;/ul> &lt;hr /> {/* 声明接收params参数 */} &lt;Route path=\"/home/Messages/Detail/:id/:title\" component={Detail} /> &lt;/div> ) 此时你查看子路由组件 Detail 的 props上接收的参数会有所变化，稍稍查看可得知，在this.props.match.params可找到你传递的参数 search传参 search传参的方式实际上也就是query参数 return ( &lt;div> &lt;ul> { messageArr.map(item => { return ( &lt;li key={item.id}> {/* 向路由组件传递search参数 */} &lt;Link to={`/home/messages/detail/?id=${item.id}&amp;title=${item.title}`}>{item.title}&lt;/Link> &lt;/li> ) }) } &lt;/ul> &lt;hr /> {/* search无需声明接收，正常注册路由即可 */} &lt;Route path=\"/home/messages/detail\" component={Detail} /> &lt;/div> ) 此时你查看子路由组件 Detail 的 props上接收的参数会有所变化，稍稍查看可得知，在this.props.location.search可找到你传递的参数 可是！ 但是参数的形式是 “?id=01&amp;titile=message1” 对于query参数 ：key=value&amp;key=value其实是一种叫urlencoded的编码形式 我们可以使用React脚手架帮我们下载好的库 querystring直接转换 import qs from 'querystring' qs.stringify(obj)//对象转urlencoded qs.parse(str)//urlencoded转对象 然后我们可以进行正式的格式转换了 const { search } = this.props.location; const { id, title } = qs.parse(search.slice(1)); //截取掉开头的\"?\" console.log(this.props, id, search); 会不会感觉有点像json和string的相互转换？： JSON.stringify(对象) JavaScript 值(对象或数组)转换为 JSON 字符串 JSON.parse(data) 字符转对象 state传参 这个是路由组件独有的状态，和一般组件里的state是不一样的 state传参你在url地址栏是看不到的，而params和search传参在地址栏可以看到明显的改变 return ( &lt;div> &lt;ul> { messageArr.map(item => { return ( &lt;li key={item.id}> {/* 向路由组件传递state参数 */} {/* to要写成一个对象的形式 */} &lt;Link to={{ pathname: '/home/messages/detail', state: { id: item.id, title: item.title } }}>{item.title}&lt;/Link> &lt;/li> ) }) } &lt;/ul> &lt;hr /> {/* state无需声明接收，正常注册路由即可 */} &lt;Route path=\"/home/messages/detail\" component={Detail} /> &lt;/div> ) （Maybe你会发现和Vue的query传参有点像？） 此时你查看子路由组件 Detail 的 props上接收的参数会有所变化，稍稍查看可得知，在this.props.location.state可找到你传递的参数 虽然使用state传参方式，刷新页面不会丢失参数（实际上是因为history对象帮你缓存了），但是如果你强行清除缓存，在接收时就会“不见了” 编程式路由在不借助 Link的条件下进行路由切换，自己定义函数进行跳转切换，这种方式叫做编程式路由导航 感觉有点像Vue中对router-link原理的延伸 ：this.$router.push(&quot;/home&quot;); //编程式路由导航 + params传参 replaceCheck = (id, title) => { return () => { this.props.history.replace(`/home/messages/detail/${id}/${title}`); } } //编程式路由导航 + query传参 pushcheck = (id, title) => { return () => { this.props.history.push(`/home/messages/detail?id=${id}&amp;title=${title}`); } } //编程式路由导航 + state传参 pushcheck = (id, title) => { return () => { this.props.history.push(`/home/messages/detail`, {id:id, title:title}); } } 同样的，如果想实现网页前进 + 后退功能；也可以使用 this.props.history.goForward()、this.props.history.goBack() withRouter上方讲述了许多关于路由组件的api，但是这些都仅限于路由组件，如果想要在一般组件使用，可以使用到 withRouter withRouter(一般组件) 就会添加上路由组件身上特有的三个属性：history、location、match！ class Header extends Component{ // } export default withRouter(Header);","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"红宝书啃读note","slug":"红宝书啃读note","date":"2021-04-19T07:35:51.292Z","updated":"2021-08-01T10:37:50.206Z","comments":true,"path":"2021/04/19/hong-bao-shu-ken-du-note/","link":"","permalink":"https://taylor12138.github.io/2021/04/19/hong-bao-shu-ken-du-note/","excerpt":"","text":"第一、二章（JavaScript）Script标签 在Script标签里面不要出现 console.log(\"&lt;/script>\") //会把它当成script结束标签，即使是字符串也不可以，但是除非 console.log(\"&lt;\\/script>\") 可以使用async代替 DOMContentLoaded事件进行 异步操作（并不是所有浏览器都支持async），使得页面保证dom渲染完毕后再执行js文件，只是不能保证执行次序 defer只对外部脚本有效 async不能保证多个script标签事件执行的顺序 noscript标签：当浏览器禁用JavaScript，或者对脚本的支持关闭时可以使用 &lt;script async src=\"xxxx\">&lt;/script> &lt;script defer src=\"xxxx\">&lt;/script> 第三章（语言基础）标识符第一个字符不能为数字 推荐语句以分号结尾，除了是一个好习惯之外，有助于在某些情况提升性能 变量在不初始化(直接 var a; )的情况下，会保存一个特殊值：”undefined” 定义一个将来要保存对象值的变量时，建议使用null初始化 undefined 是由 null 派生出来的，所以 null == undefined // true undefined被设计是希望表示一个变量最原始的状态，我们可以通过undefined来判断改变量是否存在，或者是否被赋值（初始化） 当一个对象被赋值了null 以后，原来的对象在内存中就处于游离状态，GC 会择机回收该对象并释放内存。因此，如果需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。 if语句 会自动执行其他类型知道布尔值的转换，注意以下几个会被转化为false：(其他的一般都是true) false “” 0、NAN null undefined NAN：非数值，不等于包括NAN在内的任何值，但是有一个isNAN() 函数 字符串 字符串一旦创建，不可改变，一般我们修改字符串，都是销毁原先的字符串，然后把新的另一个字符串保存到该变量 let lang = 'Java'; lang += 'Script' //改变，进行销毁 + 赋值 变量提升 由于变量提升需要查看是否有var或者function，所以需要注意 console.log(a); //undefined var a = 100 //会变量提升 console.log(a); //报错 a is not defined a = 100 //不会变量提升,但是即使在函数内部声明也会创建一个全局变量，会导致内存泄漏 对象方法 Object.getOwnPropertyNames(obj1)返回对象实例的常规属性数组，比如 [name, value] Object.getOwnPropertySymbols(obj1)返回对象实例的符号属性数组，比如 [Symbol(foo), Symbol(bar)] 这两种方法互斥，但： Object.getOwnPropertyDescriptors(obj1)返回对象实例的符号 + 常规属性的对象 递增递减操作符 &amp; 一元加和减 对于布尔值，如果是false，则转为0再做相应改变；如果为true，则转为1再做相应改变 let s1 = '2', s2 = false; s1++ //值变成了数值3 s2++ //值变成了数值1 而一元加和减，也会执行与Number()相似的类型转换 let s1 = false, s2 = \"1.1\"; s1 = +s1; //得到数值0 s2 = -s2; //得到数值-1.1 左右移和无符号左右移 正常左移操作和右移操作都是直接让数值以二进制形式进行移动。 而无符号右移（&gt;&gt;&gt;），对于正数来说，和右移&gt;&gt;操作一样；对于负数来说，会出现巨大的差异，无符号右移会继续给空位补0 而负数是以一种二补数的二进制编码存储，也就是 先转正数的二进制 0 -&gt; 1, 1 -&gt; 0 结果 +1 let oldValue = -64 let newValue = oldValue >>> 5; //得到134217726 加性操作符 当两个操作数，只有一个为字符串时，另外一个会转变为字符串，然后拼接 let a = 1 + '1'; // \"11\" \"12\" + null //\"12null\" 减法操作符 当任意一个操作数是字符串、布尔值、null或undefined，则先在后台使用Number()转换为数值，若是对象则调用其valueOf()方法取得表示它的数值 == 和 === ==和 !=都会先进行类型转换（强制类型转换），再确定操作数是否相等 而 === 和 !== 都不会转换操作数 break &amp; continue break和continue都可以使用标签语句退出多重循环 let num = 0; outermost: for(let i = 0; i &lt; 10; i++){ for(let j = 0; j &lt; 10; j++){ if(i === 5 &amp;&amp; j === 5)break outermost; num++; } } 第四章（变量、作用域与内存）原始类型初始化可以只是永远是字面量形式，如果是使用new关键字创建，则JavaScript会创建爱一个Object实例，其行为类似原始值 比如 let name1 = \"Allen\"; let name2 = new String(\"Bruce\"); name1.age = 18; name2.age = 19; console.log(name1.age) //undefined console.log(name2.age) //19 console.log(typeof name1) //string console.log(typeof name2) //object 引用值（比如对象、数组）传递参数时，会影响到函数外部的原始变量，因为传入的是指针，保存着数值存放的地址 function change(obj){ obj.name = 'allen' } let obj = {}; change(obj); //{ name: 'allen' } 实质上参数传递有点像let 一个变量 obj2 ，然后让 obj2 = obj的操作 为了补救垃圾回收时类似循环引用的问题，IE9把BOM、DOM对象都改成了JavaScript对象 第五章（基本引用类型）正则表达式 正则表达式使用到元字符需要使用 \\ 进行转义，如果正则表达式是使用 RegExp 构造函数来创建，由于参数模式是字符串，所以需要进行二次转义 \\\\ 比如字面量模式： /\\[bc\\]at/ 字符串模式：\\\\[bc\\\\]at RegExp实例的主要方法是 exec()，返回一个数组，包含匹配的信息，匹配不到返回null 如果要获取匹配的字符串：/.de/.exec(&#39;ffff&#39;)[0] g全局匹配： let text = \"cat, bat, sat, fat\"; let pattern = /.at/g; let matches = pattern.exec(text); //cat的数组 console.log(matches); let matches2 = pattern.exec(text); //bat的数组 console.log(matches2); 字符串方法 str.indexOf(子字符串)从字符串开头找子字符串 str.indexOf(子字符串, index)从字符串index位置开始找子字符串 str.lastindexOf(子字符串)从字符串末尾开始查找子字符串 单例内置对象 Global对象：它是ECMA中最特别的对象，因为代码不会显式地访问它。事实上，不存在全局变量或全局函数这种东西，在全局作用域中定义的变量的函数都会变成Global对象的属性，我们所了解的 isNaN()、 parseInt()、 parseFloat()实际上都是Global对象的方法；而NAN、undefined、Array也都是Global的属性。 而我们平时属性的window对象，是Global对象的代理（ECMA-262没有规定直接访问Global对象的方式） eval()方法：它可能是ECMAScript语言中最强大的方法，它就是一个完整的ECMAScript解释器 eval(\"console.log('good!')\"); //等同于 console.log(\"good\") 当解释器发现 eval()时，会将参数解释为实际的ECMAScript语句，然后将其插入到该位置，通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着包含上下文中的变量可以在eval()调用内部被引用 这里eval调用的msg属于外部上下文，因为第二行代码会被替换成一行真正的函数调用代码 let msg = \"Batman\"; eval(\"console.log(msg)\"); //\"Batman\" 函数say是在eval内部定义的，因为该调用会被替换为真正的函数定义 eval(\"function say(){ console.log('good!'); }\") say(); //good! eval(\"let msg = 'Batman'\") console.log(msg); //Err 第六章（集合引用类型）对象属性 一般通过点语法进行获取，但也可以使用中括号 console.log(person[\"name\"]); console.log(person.name); 只不过中括号的主要优势在于可以通过变量访问属性 let s = \"name\"; console.log(person[s]); 数组 数组空位： 使用数组字面量初始化数组时，可以使用一串逗号来创建空位。ES6之前的方法会忽略空位，ES6新增方法普遍将这些空位当成存在的元素，只不过值为undefined。 const option = [,,,,]; 索引自动扩容 如果把一个值设置给超过数组最大索引的索引，数组长度就会自动扩展到该索引值+1 let colors = [\"red\", \"blue\", \"green\"]; colors[2] = \"black\"; colors[3] = \"white\"; console.log(colors); //red, blue, black, white 修改length 数组length的独特之处在于，它不是只读的，通过修改length属性，可以实现从数组末尾删除 / 添加元素（Vue2.0的缺点之一就是不能通过修改数组length得到响应式的结果），添加的元素通过undefined进行填充 搜索位置和方法 indexOf() lastIndexOf() includes()其中前两个在任何版本都可以使用，第三个时ES7新增 indexOf() includes()从开头搜索匹配元素，lastIndexOf()从结尾开始搜索 indexOf() lastIndexOf()找不到返回-1， includes()返回布尔值 它们都是用全等 ===进行比较的 定性数组 ArrayBuffer是所有定型数组及视图引用的基本单位，它是一个普通的JS构造函数，可用于在内存中分配特定数量的字节空间。 一经创建便不能再调整大小 const buf = new ArrayBuffer(16) //在内存中分配16个字节 第七、八章（迭代器和生成器，对象和类）生成器Generator 可以使用星号增强 yield行为，让他能够迭代一个可迭代对象，从而一次产出一个值 function * generatorFn(){ for(const x of [1,2,3]){ yield x; } } //可以转化为 function * generatorFn(){ yield * [1,2,3]; } 实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把yield放到一个循环里没什么不同 和迭代器类似，生成器也支持 “可关闭概念”，因为 generator实现了 iterator接口，一个实现 iterator接口的对象一定有 next()，还有一个可选的 return()方法用于提前终止迭代器，生成器对象除了这两个方法，还有第三个方法 throw() throw()会在暂停的时候将一个提供的错误注入到生成器对象中，如果错误未处理，生成器就会关闭；如果生成器内部函数处理了这个错误，那生成器就不会关闭，跳过对应的 yield，继续执行。 对象方法 对象定义属性（访问器属性）使用Object.defineProperty()，读取属性的特性可以使用 Object.getOwnPropertyDescriptor()方法，它返回一个对象 对于访问器属性包含 configurable、enumberable、get、set 对于数据属性包含 configurable、enumberable、writable和 value属性 （有点像对对应Object.definePRoperty的属性） Object.assign(target, ...sources)方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举和自有属性复制到目标对象（浅拷贝） const target = { a: 1, b: 2 }; const source = { b: 4, c: 5 }; const returnedTarget = Object.assign(target, source); console.log(target); // expected output: Object { a: 1, b: 4, c: 5 } console.log(returnedTarget); // expected output: Object { a: 1, b: 4, c: 5 } 全等升级 -&gt; 对象标识及相等判定 console.log(true === 1); //false console.log({} === {}); //false console.log(\"2\" === 2); //false console.log(+0 === -0); //true console.log(+0 === 0); //true console.log(-0 === 0); //true console.log(NaN === NaN); //false console.log(isNaN(NaN)); //true ES6规范新增了 Object.is() 这个方法和=== 很像，但也同时考虑了上述边界情形 console.log(Object.is(true, 1)); //false console.log(Object.is({}, {})); //false console.log(Object.is(\"2\", 2)); //false console.log(Object.is(+0, -0)); //false console.log(Object.is(+0, 0)); //false console.log(Object.is(-0, 0)); //false console.log(Object.is(NaN, NaN)); //true 对象的可计算属性（使用变量定义属性时，必须放在方括号内，与普通键值(String)进行区分。） const name = 'Mike'; let person = {[name]: 'Matt'} 原型链 原型对象.isPrototypeOf(实例)方法确定两个对象之间的 [[Prototype]]关系 还有一个 getPrototypeOf() 和 setPrototypeOf()方法，分别对应湖片区参数的原型对象和修改参数的原型对象，但是 Object.setPrototypeOf()会严重影响代码性能 console.log(Person.prototype.isPrototypeOf(person1)) //true 可以使用hasOwnProerty()方法用于确定某个属性是实例上还是在原型对象，这个方法是继承自Object的，会在属性存在于调用它的对象实例上时返回true（这个方法也应用于Vue3.0检测数组属性的存在 + 修改属性 + 新增属性） //person1有name属性、但是没有othername属性 console.log(person1.hasOwnProperty(\"name\")) //true console.log(person1.hasOwnProperty(\"othername\")) //false 但是hasOwnProperty是确定该实例上有没有这个属性 ，如果该实例的对象原型上有这个属性，也会返回false in操作符就不一样了，in在 for in循环中使用，也可以单独使用，in操作符会在可以通过对象访问指定属性时，返回true //person1有name属性、但是没有othername属性 person1.name = \"Bruce\" person1.prototype.othername = \"Allen\" console.log(\"name\" in person1) //true console.log(\"othername\" in person1) //true 对象迭代 ECMAScript2017新增了两个静态方法：Object.values()（返回对象值的数组）、Object.values()（返回键/值对的数组） 继承拓展 原型式继承： 适用情况于你有一个对象，想在它的基础上再创建一个新对象 它是一种不涉及严格意义上的构造函数继承方法，他的出发点是即使不自定义类型 ES5通过增加 Object.create()方法把原型是继承的概念规范化了 let person = { name:\"Allen\", friends:[\"Bruce\", \"Curry\", \"Devid\"] } let anotherPerson = Object.create(person); //object(person)也可以 anotherPerson.name = \"Greg\"; anotherPerson.fridens.push(\"Rob\"); let yetAnotherPerson = Object.create(person); yetAnotherPerson.name = \"Faker\"; yetAnotherPerson.fridens.push(\"Ariana\"); console.log(person.friends); //\"Bruce\", \"Curry\", \"Devid\", \"Rob\", \"Ariana\" console.log(person.name); //\"Allen\" （即引用类型存共享属性，基本类型存取实例属性，个人理解为该继承方式是运用了浅拷贝） 寄生式继承： function createAnother(original) { let clone = object(original); clone.sayHi = function () { console.log(\"hi!\"); } return clone; } let person = { name:\"Allen\", friends:[\"Bruce\", \"Curry\", \"Devid\"] } let another = createAnother(person); another.sayHi(); 它让新返回的对象具有person的所有属性和方法，还创建了一个新的方法sayHi。 但寄生式继承给对象添加函数会导致函数难以重用，和构造函数模式（构造函数继承）类似。 传统的组合继承也存在效率问题，主要在于父类构造函数始终会被调用两次， 一次在创建子类原型时调用（Son.prototype = new Father();） 一次在子类构造函数中调用（function Son(uname, age) {Father.call(this, uname, age);}） 由此寄生式组合继承的方式可以解决这个问题 //替代原来的Son.prototype = new Father(); function inheritPrototype(subType, superType) { let prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype; } JS实现抽象类(仅继承，本身不会被实例化) class Vehicle{ constructor(){ console.log(new.target); } if(new.target === Vehicle){ throw new Error(\"Vehicle annot be directly instantiated\"); } } 第九章（代理与反射）代理与反射 代理为目标对象的抽象，从很多方面来看，代理类似于C++的指针，因为他们可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以被直接操作，也可以通过代理来操作 const target = { id:'target' } // 传入参数为目标对象和处理程序对象 const proxy = new Proxy(target, {}); console.log(target.id); //target console.log(proxy.id); //target target.id = \"foo\" console.log(target.id); //foo console.log(proxy.id); //foo console.log(target.hasOwnproperty('id')); //true console.log(proxy.hasOwnproperty('id')); //true // 可以通过严格模式区分 console.log(target === proxy); //false 使用代理的主要目的是定义捕获器（基本操作拦截器），我们在处理程序对象中定义即可，比如这里我重新定义了 该对象的 get 方法 const handler = { get() { return 'handler override'; } } const proxy = new Proxy(target, handler); console.log(target.id); //foo console.log(proxy.id); //handler override 根据ECMAScript规范，每个捕获器都知道目标对象的上下文，捕获函数签名，而捕获程序的行为必须遵循“捕获器不变式”，捕获器不变式因方法不同而异，但通常都会防止捕获其定义出现过于反常的行为（比如目标对象有一个不可配置切不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出TypeError） 可撤销代理 使用new Proxy()创建的普通代理，这种联系会在代理对象的生命周期内持续存在，所以有时可能需要中断代理对象和目标对象之间的联系。 Proxy也暴露了 revocable()方法，这个方法支持撤销代理对象和目标对象的关联，撤销代理后再次调用代理会抛出TypeError const {proxy, revoke} = Proxy.revocable(target, handler); //此时我们可以撤销代理 revoke(); //撤销代理 console.log(proxy.id); //TypeError 代理的问题和不足 如果target目标对象过于依赖对象标识，可能会出现意料之外的内容（比如WeakMap） const wm = new WeakMap(); class User { constructor(userId) { wm.set(this, userId) } set id(userId) { wm.set(this, userId); } get id() { return wm.get(this) } } const user = new User(123); console.log(user.id); //123 const proxy = new Proxy(user, {}); console.log(proxy.id); //undefined 有些ECMAScript内置类型可能会以来代理无法控制的机制，导致代理商调用某些方法出错，比如Date类型 代理捕获器与反射方法 get()捕获器会在获取属性值的操作中被调用，反射API为 Reflect.get() set()捕获器会在设置属性值的操作中被调用，反射API为 Reflect.set() has()捕获器会在in操作符中被调用，反射API为 Reflect.has() defineProperty()捕获器会在 Object.defineProperty() 中被调用，反射API为 Reflect.defineProperty() ……. 代理模式还可以实现属性隐藏功能、属性验证功能等 const hiddenProperties = ['foo', 'bar']; const target = { foo: 1, bar: 2, baz:3 } const proxy = new Proxy(target, { //隐藏属性功能 get(target, property) { if (hiddenProperties.includes(property)) return undefined; else return Reflect.get(...arguments); }, //属性验证 set(target, property, value) { if (typeof value !== Number) return false;//拒绝赋值 else return Reflect.set(...arguments); } }) 第十章（函数）实质上，函数是一个对象，是Function类型的实例 ECMAScript6的所有函数对象都会暴露一个只读的name属性，其中包含关于函数的信息（如果它是使用Function构造函数创建，则会表示成”anonymous”） function foo() { } let bar = function () { } let baz = () => { } console.log(foo.name); //foo console.log(bar.name); //bar console.log(baz.name); //baz console.log((new Function()).name); //anonymous 注意：ECMAScript的函数没有重载（重载指同个函数名通过接收不同的参数，包括个数、类型，而实现同函数名实现不同的方法） 事实上，JavaScript引擎在加载数据时对函数声明和函数表达式区分对待的。 JavaScript引擎在任何代码执行之前，都会读取函数声明，并在执行上下文中生成函数定义；而函数表达式必须等到代码执行到他那一行，才会在执行上下文中生成函数定义。 //没问题 console.log(sum(10, 10)); function sum(num1, num2){ return num1 + num2; } //会出错，使用var也会出错 console.log(sum(10, 10)); let sum = function(num1, num2){ return num1 + num2 } 我们学习过arguments，是一个伪数组，包含调用函数时传入的所有参数。实际上它还有一个callee属性，是一个指向arguments对象所在函数的指针，从而实现函数逻辑与函数名解耦 function dfs(num){ if(num &lt;= 1)return 1; else return num * arguments.callee(num-1); //相当于num * dfs(num-1) } 严格模式下，运行的代码不能访问arguments.callee，因为访问会出错 闭包延伸 函数执行时，每个执行上文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中叫做活动对象，只在函数执行期间存在。 函数内部的代码在访问变量时，就会使用给定的名称从作用域链1中查找变量，函数执行完毕后，局部活动对象就会被销毁，内存中就只剩下全局作用域，不过，闭包就不一样了。 在一个函数内部定义的函数，就会把其包含的函数的活动对象添加到自己的作用域链中 第十一章（期约与异步函数）promise.all：如果有期约拒绝，则第一个拒绝的契约会将自己的理由作为合成期约的拒绝理由（交给onReject或者catch处理）。之后再拒绝的期约不会影响最终期约的拒绝理由 如果至少有一个包含的期约待定，则合成期约待定（pedding），如果有一个包含的期约拒绝，则合成的期约也会拒绝（一个rejected，则all rejected） promise.race：谁快用谁的状态； 第一个落定的拒绝期约，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约拒绝的理由。 和all类似，合成的期约会静默处理所有包含期约的拒绝操作，不会有错误跑掉。 ES6不支持取消期约和进度通知，一个主要原因是这样会导致期约连锁和期约合成过度复杂化。 但是我们可以利用闭包传入回调函数实现七月的取消和进度通知 async async关键字用在函数声明、函数表达式、箭头函数和方法上 async function foo(){} let bar = async function(){} let baz = async() => {} class Quex(){ async qux(){} } 异步函数如果使用return关键字返回了值（默认返回undefined），这个值会被Promise.resolve()包装成一个期约对象 async function foo(){ console.log(1); return 3; //return Promise.resolve(3) } foo().then(console.log(2)); console.log(2) //1 //2 //3 异步函数async和promise期约一样，抛出错误（throw err）会返回拒绝的期约 async function foo(){ console.log(1); throw 3; } foo.catch()(console.log); console.log(2) //1 //2 //3 不过，拒绝期约的错误不会被异步函数捕获 async function foo(){ console.log(1); Promise.reject(3); } foo.catch()(console.log); console.log(2) //1 //2 //Uncaught 3 对于await，面对拒绝的期约，会释放（unwrap）错误值（将拒绝期约返回） async function foo(){ console.log(1); await Promise.reject(3); console.log(4); //这一行不会被执行 } foo.catch()(console.log); console.log(2) //1 //2 //Uncaught 3 await的限制：await关键字只能在异步函数（async）中使用 要完全理解await，必须知道他并非只是等待一个值可用这么简单，JavaScript运行时碰到await关键字时，会记录那里暂停执行，等到await右边的值可用了，JavaScript运行时会向消息队列推送一个任务，这个任务会恢复异步函数的执行 因此，即使await后面跟着一个立即可用的值，函数的其余部分也会被异步求值 async function foo(){ console.log(2); await null; //await暂停执行，为立即可用的值null向消息队列中添加一个任务，等到同步任务执行完毕后，再取出来 console.log(4) } console.log(1); foo(); console.log(3); //1 //2 //3 //4 async关键字无论从哪个方面来看，都不过是一个标识符，毕竟，异步函数如果不包含await关键字，其执行基本上跟普通函数没有什么区别。 async function foo(){ console.log(2); } console.log(1) foo(); console.log(2) //1 //2 //3 期约和异步函数 栈追踪和内存管理 期约（promise）和异步函数（async）的功能有相当程度的重叠，但是他们在内存中的表示则差别很大。 function fooPromiseExecutor(res, rej) { setTimeout(rej, 1000, 'bar'); } function foo() { new Promise(fooPromiseExecutor); } foo(); //Uncaught (in promise) bar //setTimeout //setTimeout (async) //fooPromiseExecutor //foo 栈追踪信息应该是相当直接地表现JavaScript引擎在当前栈内存中函数调用之间的嵌套关系。在超时处理程序执行时和拒绝期约时，我们看到错误信息包含嵌套函数的标识符，那是被调用以创建初期约实例的函数。可是我们知道这些函数已经返回，因此在追踪栈中不应该看到它们。 而这是因为JavaScript引擎在创建期约时尽可能保留完整的调用栈，在抛出错误时调用栈可以由运行时的错误处理逻辑获取。当然，这意味着栈追踪信息会占用内存，带来计算存储成本。 function fooPromiseExecutor(res, rej) { setTimeout(rej, 1000, 'bar'); } async function foo() { await new Promise(fooPromiseExecutor); } foo(); //Uncaught (in promise) bar //foo //async function (async) //foo 这样一改，栈追踪信息就能准确地反映了当前的调用栈。fooPromiseExecutor()已经返回，所以它不在错误信息中，但foo()由此被挂起了，并没有退出。JavaScript运行时可以简单地在嵌套函数中存储指向包含函数的指针，就跟对待同步函数调用栈一样。这个指针实际上存储在内存中，可用于再出错时生成栈追踪信息。 （这段看不太懂，不过只要理解到异步函数对比期约会减少内存消耗，因此在重视性能的应用中可以优先考虑即可） 第十二章BOMBOM核心是window对象，window对象在浏览器有双重身份，一个是ECMAScript的Global对象，一个就是浏览器窗口的JavaScript接口。 窗口关系 top对象始终指向最上层窗口，即浏览器窗口本身 parent对象始终指向当前窗口的父窗口，如果当前窗口是最上层窗口，则parent = top self对象始终指向window，是window的终极属性，实际上self和window就是同一对象，暴露self是为了和top、parent保持一致 导航和打开新窗口 window.open()用于导航到指定的URL，分别接受四个参数，返回一个对新建窗口的引用 加载的URL 目标窗口 如果不是已有窗口，则会打开一个新的窗口或标签页 特性字符串（配置） 以逗号分隔，设置字符串 比如fullscreen，表示窗口是否最大化；height，新窗口的高度 新窗口在浏览器历史记录中是否替代当前加载页的布尔值（通常不传这个参数） let wroxWin = window.open(\"https//www.wrox.com/\", \"wroxWindow\", \"height=400, width=400, top=10, left=10, resizable=yes\") 而弹出窗口有点时间被在线广告用滥了，于是，IE7之后、Firefox、Opera等开始弹窗施加限制；此外网页加载过程中调用window.open()没有效果，而且可能导致向用户显示错误，弹窗通常可能在鼠标点击或按下键盘中的某个键才能打开。 弹窗屏蔽：所有现代浏览器都内置了屏蔽弹窗的程序，如果是浏览器内置的弹窗屏蔽组织了弹窗，那么 window.open()返回null let wroxWin = window.open(\"https//www.wrox.com\", \"_blank\"); if (wroxWin == null) { alert(\"The popup was block\") } 如果是浏览器拓展或者其他程序屏蔽弹窗时，window.open()通常会抛出错误 系统对话框 console.log() alert() confirm() ，有点像alert()，但是确认框有两个按钮 Cancel、OK，返回一个布尔值 prompt()，有点像 confirm()的升级版，还多了一个文本框让用户输入，prompt会返回文本框中的值 十三章客户端的检测用户代理检测通过浏览器的用户代理字符串确定使用的是什么浏览器。用户代理字符串包含在每个HTTP请求头部，在JavaScript中可以通过 navigator.userAgent访问。 在服务器端，常见的做法是根据接收到的用户代理字符串确定浏览器并执行相应的操作。而在客户端，用户代理检测被认为是不可靠的（字符串可以造假）。 本来 userAgent是一个只读属性 console.log(window.navigator.userAgent); window.navigator.userAgent = 'foobar'; //无效 不过，通过简单的方法可以绕过这个限制，比如有些浏览器提供伪私有的 __defineGetter__方法，利用它可以篡改用户代理字符串。 console.log(window.navigator.userAgent); window.navigator.__defineGetter__('userAgent', () => 'foobar'); //无效 十四章DOMcloneNode()：会返回与调用它的节点一模一样的节点，该方法接收一个布尔值参数，表示是否深复制 深复制会复制节点及其整个子DOM树，如果传入false，则只会复制调用该方法的节点。 document.URL取得当前页面的完整URL document.domain取得当前页面的域名 document.referrer取得来源","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"算法知识","slug":"算法知识","date":"2021-04-16T10:35:53.704Z","updated":"2021-08-22T12:17:27.454Z","comments":true,"path":"2021/04/16/suan-fa-zhi-shi/","link":"","permalink":"https://taylor12138.github.io/2021/04/16/suan-fa-zhi-shi/","excerpt":"","text":"判断链表是否有环使用快慢指针，当他们相遇时，则有环 bool IsExitsLoop(slist *head) { slist *slow = head, *fast = head; while ( fast && fast->next ) { slow = slow->next; fast = fast->next->next; if ( slow == fast ) break; } return !(fast == NULL || fast->next == NULL); } 找到环的入口参考博客地址：http://www.cppblog.com/humanchao/archive/2012/11/12/47357.html 公式推导： 快指针经过的路径：2s 慢指针经过的路径：s nr：走了n圈 假设真个链表长度为L，入环口与相遇点距离为x，起点到入环口的距离为a 则有： 2s = s + nr s = nr a + x = nr a + x = (n - 1)r + r = (n-1)r + L - a a = (n - 1)r + (L - a - x)由公式推导可知，只需要我们让两个指针分别指向起点和相遇的点，每次分别next走一步，则一定会在入环点相遇。 求环的大小只需让这两个快慢指针，继续在环里面走，再次相遇时，所走的步数 = 环的长度 背包问题01背包求最大值 x轴代表bag的容量提升，y轴代表不同物体的序号 物品定义： int w[5] = { 0 , 2 , 3 , 4 , 5 }; //商品的体积2、3、4、5 int v[5] = { 0 , 3 , 4 , 5 , 6 }; //商品的价值3、4、5、6 int bagV = 8; //背包大小 状态转移方程： for (int i = 1; i","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"Echart","slug":"Echart","date":"2021-03-26T12:37:21.458Z","updated":"2021-04-19T16:52:46.660Z","comments":true,"path":"2021/03/26/echart/","link":"","permalink":"https://taylor12138.github.io/2021/03/26/echart/","excerpt":"","text":"Echart.jsEchart.js，它是由百度公司开发的一个使用JavaScript实现的开源可视化库（同时也有D3.js，它是国外的可视化库），兼容性强，底层以来矢量图形ZRender，可高度个性化定制数据可视化图表（移动端pc端都兼容） 安装： npm install echarts --save 官网：https://echarts.apache.org/zh/index.html 使用步骤 引入Echart文件 准备呈现图表的盒子（一定要有宽高，比如width: 600px; height: 400px） 初始化echarts对象 准备配置项 将配置设置给echarts实例对象（配置是可以设置多次，叠加设置，这样可以分离数据的代码和初始化的代码） import * as echarts from 'echarts'; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 绘制图表 myChart.setOption({ //标题 title: { text: 'ECharts 入门示例' }, //通用配置，可设置对图表接触事件 tooltip: { //默认mousemove，移动到每一项触发光标和详情信息 trigger:'item', //设置后要click，点击才会有信息提示 triggerOn:'click' }, //工具栏，里面有很多好用的工具 toolbox:{ feature:{ //可以直接到导出图片的功能 saveAsImage:{} } } //x轴 xAxis: { type: \"category\", data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子'] }, //y轴 yAxis: { type: \"value\", scale:true //让数据不会从0开始 }, //系列列表，通过type决定图表类型，可以有多个对象 series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); 轴的type： category 类目轴 value数值轴（一般为数值轴则不用设置data属性，它会去另一个轴每个类别取series找到对应的数据） 系列表的type：line（折线图）、bar（柱状图）、pie（饼图）、scatter（散点图）、graph（关系图）、tree（树图） 折线图数据曲线平滑：smooth:true 散点图、涟漪散点图（effectScatter） 需要二维数组配合使用 饼图的数据：{name:&#39;allen&#39;, value:100}，不需要x轴、y轴 map地图的tooltip：提示框组件，可在里面进行修改，得到提示的内容不同 更多配置项详情查看官方文档","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Vue(下)","slug":"Vue(下)","date":"2021-03-21T16:00:00.000Z","updated":"2021-08-22T15:57:22.073Z","comments":true,"path":"2021/03/22/vue-xia/","link":"","permalink":"https://taylor12138.github.io/2021/03/22/vue-xia/","excerpt":"","text":"8.其他事件总线事件总线和vuex的作用很像，只不过vuex用于管理状态（变量），而事件总线用于管理事件，利用事件传参（感觉vuex有点面向受控组件，而eventbus面向非受控组件） 1.在main.js 文件中 创建一个新的Vue实例，以得到一个bus Vue.prototype.$bus = new Vue(); 2.发射 this.$bus.$emit(&#39;事件名&#39;[, 参数]) 3.接受 this.$bus.$on(&quot;事件名&quot;, 回调函数(参数)) 4.可以在deactivated里设置离开时不接受该事件的传递（取消全局事件监听）：this.$bus.$off(&quot;事件名&quot;, 接收时的回调函数(参数));，回调函数要和接收时发生的回调函数保持一致 mixin（混入）Vue中相同逻辑的代码如何抽离？ 为了减少两个对象之间重复的代码，Vue官方提供了 minxin（较少类重复的代码可以用es6的继承） 官方示例： var mixin = { created: function () { console.log(1) } } var vm = new Vue({ created: function () { console.log(2) }, mixins: [mixin] }) // => 1 // => 2 自定义插件正常情况下，我们都可以使用组件完成对应的模块功能，使用组件需要 1.在模板中引用 2.引入模块 3.组件的components中声明 但是如果想要在该组件完成固定功能，可能还需要 4.声明对应的data 5.写入对应的方法 6.组件之间传递变量 4、5、6步骤如果放在不同的组件使用一样的功能，可能要声明很多次，这时我们可以使用插件来简化（降低耦合）操作 下面以制作 Toast 自定义插件为例子（冒泡提示插件） 先建立toast组件 &lt;template> &lt;div class=\"toast\" v-show=\"isShow\"> {{ message }} &lt;/div> &lt;/template> &lt;script> export default { name: \"Toast\", data() { return { message: \"\", isShow: false, }; }, methods: { //duration时间间隔默认2s showMessage(message, duration = 2000) { this.message = message; this.isShow = true; setTimeout(() => { this.isShow = false; this.message = \"\"; }, duration); }, }, }; &lt;/script> &lt;style scoped> &lt;/style> 在toast组件的文件夹下，新建index.js文件 //引入toast组件 import Toast from \"./Toast\"; const obj = {}; // 可以选择传进来一个Vue，对Vue对象进行操作 obj.install = function (Vue) { // 1.创建组件构造器（在vue外面使用组件就要用到组件构造器） const toastConstructor = Vue.extend(Toast); // 2.使用new的方式创建组件对象 const toast = new toastConstructor(); // 3.将组件对象挂载到某元素上,和组件使用也一样，内部也调用了$mount()进行挂载 toast.$mount(document.createElement('div')); // 4.toast.$el 对应的就是 div document.body.appendChild(toast.$el); // 5.设置prototype之后，以后调用插件方法只需要$toast即可 Vue.prototype.$toast = toast; } export default obj 在全局的main.js中使用该插件 import toast from \"@/components/common/toast\" Vue.use(toast); 这时我们就可以再各个组件中直接使用该插件了（此时只需要执行以下代码，即可出现冒泡提示） this.$toast.showMessage(\"你想要输入的信息\", 2000); //2000为自定义的时间间隔 Vue.nextTick[Vue.nextTick( [callback, context\\] )] Vue中DOM更新是异步的，而nextTick在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 // 修改数据 vm.msg = 'Hello' // DOM 还没有更新 Vue.nextTick(function () { // DOM 更新了 }) // 作为一个 Promise 使用，如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise Vue.nextTick() .then(function () { // DOM 更新了 }) 主要应用：需要注意的是，在 created 和 mounted 阶段，如果需要操作渲染后的视图，也要使用 nextTick 方法。 官方文档说明： 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted vue图片懒加载可以使用vue-lazyload插件 $ npm i vue-lazyload -S （在main.js里）引用时可以传递一些想要的参数，比如加载前的图片显示等 import VueLazyload from 'vue-lazyload' Vue.use(VueLazyload) Vue.use(VueLazyload, { preLoad: 1.3, error: errorimage, loading: loadimage, attempt: 1 }) 安装和引用之后，将原来的 &lt;img :src=&quot;img.src&quot; &gt; –&gt; &lt;img v-lazy=&quot;img.src&quot; &gt;即可 Vue和React相同之处： React与Vue存在很多相似之处，例如他们都是JavaScript的UI框架，专注于创造前端的富应用。不同于早期的JavaScript框架“功能齐全”，Reat与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。 Vue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了’Virtual DOM’（虚拟DOM），如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM，这样可以减少开销；当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。 不同之处： React与Vue最大的不同是模板的编写。Vue鼓励你去写近似常规HTML的模板（template），写起来很接近标准HTML元素，只是多了一些属性，然后用类似于Angular风格的方法去动态输出内容；而React推荐你使用 JSX 来写模板，JSX只是JavaScript混合着XML语法，有部分人使用起来会觉得很畅快。值得一提的是，与React一样，Vue在技术上也支持render函数和JSX，但只是不是默认的而已 在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理，而Vue提供响应式的数据，当数据改动时，界面就会自动更新；React的数据使用state对象（状态）保存，在React中你需要使用setState()方法去更新状态 （我在观看视频老师对比React and Vue的时候看到的结果（虚拟DOM与DOM Diff 的原理，作者饥人谷，第二集））在测试插入10w个div标签的时候，DOM的原生渲染速度是大概2s；React的速度大概接近30s；Vue竟然是接近原生DOM，1s-3s 自我学习感受，React很多操作要比Vue麻烦（可能也是因为不熟练），学习React有扎实的JS基础要求 Vue常见性能优化 不要把所有数据放在data，data的数据会增加 getter 和 setter，会收集对应的 watcher vue在v-for时给每项元素绑定事件需要用事件代理 SPA采用keep-alive 拆分组件，减少耦合度，提高维护度 合理分配 v-if 和 v-show key保证唯一性 Object.freeze 冻结数据 合理使用路由懒加载 尽量采用 runtime运行时版本 合理运用防抖节流 9.ElementElement，一套为开发者、设计师和产品经理准备的基于 Vue 的桌面端组件库 详情可以去官方文档进行学习 Element-ui 的validate方法validate() 是elment-ui封装好的用于对整个表单进行验证，若不传入回调函数，则会返回以promise =&gt; Function(callback : Function(boolean,obj))，当第一个参数位true，则校验通过 Element组件时样式修改的问题通常在vue组件样式中添加scoped，该组件样式只能够在本组件才能执行，这样我们就无法更改Element组件样式了。 如果我们取消了scoped的话，全局的样式有可能就会发生冲突。 解决方法是： 如果使用style修改样式，可以添加 &gt;&gt;&gt;的前缀 如果使用sass或者less修改样式，可以添加/deep/的前缀 思路提供：https://zhuanlan.zhihu.com/p/58942147 10.原理相关双向绑定Object.defineProperty( )的 get （读取属性值触发的函数）和 set（set就是在设置属性值触发的函数），所以Vue会根据数据变化，重新渲染到虚拟DOM，然后根据虚拟DOM，把真实DOM进行修改 Object.defineProperty(对象名, 属性名, desciptor) Object.defineProperty(obj, key, { set(newValue) { console.log(\"监听\" + key + \"改变\"); value = newValue; }, get() { console.log(\"获取\" + key + \"的值\"); return value; } }) Object.freeze()会阻止修改现有的 property，也意味着响应系统无法再追踪双向绑定变化。 当数据发生改变，Vue是如何通知哪一部分发生刷新？(set() {} 里面该如何进行操作？) 发布订阅者模式： // 发布者类 class Dep { constructor() { // 用于存储订阅者的数组 this.subs = []; } // 增加订阅者方法 addSub(watcher) { this.subs.push(watcher); } // 调用之后，每个订阅者都会进行更新 notify(){ this.subs.forEach(item => { item.update() }) } } // 订阅者类 class Watcher { constructor(name) { this.name = name; } update(){ console.log(this.name, \"发生更新\"); } } const dep = new Dep(); const watcher1 = new Watcher(\"item1\"); const watcher2 = new Watcher(\"item2\"); const watcher3 = new Watcher(\"item3\"); dep.addSub(watcher1); dep.addSub(watcher2); dep.addSub(watcher3); dep.notify(); data中每一个属性，都添加一个发布者类（new 一个 发布者实例） 谁通过 get(){}对数据进行获取，则对其添加订阅者类（new 一个 订阅者实例），然后将订阅者push进发布者的subs数组中 当数据发生修改，即触发 set(){}函数，在里面使用notify： set(){ dep.notify(); } 让所有订阅者随之发生更新（调用了所有订阅者的update方法） （实际上watcher有很多种，正常的data属性的渲染页面watcher（下面这个）、computed的watcher、watch（用户自定义）的watcher） Observer：每个属性创建一个Dep对象（发布者），若data数据发生改动，则调用Dep对象的notify方法 Compile：解析el中的指令，每次使用到data的数据，就创建一个Watcher（订阅者），然后加入到该属性对应的发布者 响应式的注意事项 Vue的缺点： 1.必须在 data 对象上存在才能让 Vue 将它转换为响应式的 var vm = new Vue({ data:{ a:1 } }) // `vm.a` 是响应式的 vm.b = 2 // `vm.b` 是非响应式的 2.若原来属性不存在，对象新增属性，Vue也检测不到 3.Vue 不能检测以下数组的变动： 1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 2.当你修改数组的长度时，例如：vm.items.length = newLength 上述数组的改变无法检测得到，使用Vue.set()才能新增一个属性 实际上尤大已经回答了，是考虑到性能原因，才不用Object.defineProperty 对对象属性进行监听 4.还有个小缺陷，就是默认会递归，递归你data里的属性，可能导致性能不高 注意 2020年后 Vue3.0已经换成用proxy代理了 Vue原理小知识Vue检测数组中的变化 我们都知道数组有push、shift、pop这些方法 而Vue对data里数组的原型方法（prototype）进行了重写，__proto__指向新的原型对象， 通过原型链定义函数，这样的话我们就可以在其中设置响应式（原来的函数.apply + 调用更新视图方法 notify()） 然后，利用observer对数组里的每一项进行监控 Vue采用异步渲染 为何Vue采用异步渲染（数据）？ 防止一更改数据就更新视图 ，多个数据发生更改后，可以先过滤掉同一个订阅者（内置di，根据id过滤同一watcher，即不用导致watcher进行多次update），提高性能 虚拟DOMDOM实际操作是挺快的，任何基于DOM的库（Vue/React）都不可能操作DOM时比DOM快 虚拟DOM：一个能代表DOM树的对象，通常含有标签名、标签上属性、事件监听和子元素们，以及其它属性 在控制台上打印可以看得出它是一个对象，它对比真实DOM更加轻量级，使用 debugger可以在浏览器的 Sources 看得到它的属性对比真实DOM少得多，它最终会被Vue / React 转化为真实DOM，呈现在页面上 为什么虚拟DOM比真实DOM快？ 减少DOM操作：可以将多次DOM操作合并为一次操作，比如添加100个节点原来是一个一个添加，现在是一次性添加 虚拟DOM借助DOM diff 可以把多余的操作省略掉，比如如果它发现有一些节点已经在页面里，就不选择更新，只更新不一样的部分（比如上面“虚拟DOM渲染特殊案例”提及到的） 跨平台，虚拟DOM不仅可以变成DOM，还可以变成小程序、ios应用、安卓应用，因为虚拟DOM本质上只是一个JS对象 （图片源自饥人谷） 创建虚拟DOM（原始方法）（分别对应React和Vue） （将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的） 虚拟DOM的缺点：需要额外创建函数，如createElement或h，但是有解决方法，如下：（通过babel、vue-loader转换） 现在创建DOM的方法： 虽然克服了虚拟DOM的缺点，但是新增了另外一个缺点，也就是严重依赖打包工具！！ 但其实当规模比较合理的时候，比如几千的时候，使用虚拟DOM是很好的，他可以通过算法优化很多多余的操作，但是当规模大到一定的程度，10w以上等等，在这个情况下原生DOM能保持稳定性，而React就崩了（我在Vue和React的对比里面提及到） DOM diffdiff就是一个函数，我们称之为patch； pathces= patch(oldVNode, newVNode)，分别对应旧节点和新节点，patches就是运行的DOM操作 把虚拟DOM想象成树型，让新的虚拟DOM和旧的虚拟DOM进行对比 只更新不一样的部分（比如上面“虚拟DOM渲染特殊案例”提及到的） Tree diff逐层对比，查看哪里需要更新；看节点（Element diff）/组件（Component diff），查看标签名/组件类型 若标签类型没变，只更新div对应的DOM属性，变了的话直接替换 / 删除 若没有发生替换或者删除的话，进入标签后代/深入组件 后继续做 Tree diff 递归 但DOM diff也有 bug 更新的时候，直接看第一个children， 把 hello -&gt; world，然后再删除掉原来的 span -&gt; world；而不是直接删除掉hello的children 所以我个人理解 优点就是：复用性提高； 缺点就是由于diff算法，导致了实际上比较简便的操作变得复杂了（可以使用key避免） 时间复杂度：两棵树的diff时间复杂度为O(n^3)，但是Vue优化了（双指针），O(n^3) -&gt; O(n)，即4个指针分别指向新节点头，新节点尾、旧节点头、旧节点尾，两两进行比较 10.Vue3.0他在介绍中表明的是： 更小、更快、更易维护，一些命令的变化。 3.0 新加入了 TypeScript 以及 PWA 的支持 支持了 composiiton API vdom的对比算法更新，只更新绑定了动态数据部分 而我主要关注的是（在响应式原理上变化比较大）：放弃 Object.defineProperty ，使用更快的原生 Proxy 细节方面： 单独功能可以抽离 取代了mixin（尤雨溪作者本人指出minxin模块来源不清晰、命名问题、性能开销问题） 引入 setup函数，在props初始化之后调用，可以用来取代 beforeCreate 、 created钩子函数，因为它在 beforeCreate之前调用 。 在 setup 内部可以使用 this，但你大部分时候不会需要它。 ，因为未执行 Created 无法使用 data 和 methods 的变量和方法 setup() 可以返回一个对象 —— 这个对象上的属性将会被暴露给模版的渲染上（即 setup里的属性可以类似于data在模板中直接使用） 所有现有的生命周期钩子都会有对应的 onXXX 函数（只能在 setup() 中使用） import { onMounted, onUpdated, onUnmounted } from 'vue' const MyComponent = { setup() { onMounted(() => { console.log('mounted!') }) onUpdated(() => { console.log('updated!') }) // destroyed 调整为 unmounted onUnmounted(() => { console.log('unmounted!') }) } } Vue2.x版本中的双向绑定不能检测到下标的变化，不存在的属性不能被拦截（其实也是因为 Object.defineProperty方法必须传入对象、属性参数），属性中还有属性嵌套还得递归 proxy可以劫持整个对象，并返回一个新对象，管你属性存不存在都可以拦截 响应式方面 性能得到很大提升 不用初始化的时候就递归遍历属性；响应式不区分数组和对象 Proxyvue3.0 使用proxy代替了vue2.0版本中的defineProperty的数据拦截 Proxy代理Object 控制和修改Object的基本行为，比如属性调用、属性赋值、删除属性、方法调用等 target是被代理的对象，handler是一个对象，属性是各种控制或修改target基本行为的方法 const p = new Proxy(target, handler); 它里面的get()、set()和Object.defineProperty()的get方法、set方法有点像，重新定义了属性的读取、设置行为 get()拦截某个属性的读取操作。可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。 set()拦截某个属性的赋值操作。可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。 里面的方法一般都需要返回值 var obj = new Proxy({}, { get: function (target, propKey, receiver) { console.log(`getting ${propKey}!`); return Reflect.get(target, propKey, receiver); }, set: function (target, propKey, value, receiver) { console.log(`setting ${propKey}!`); return Reflect.set(...arguments); } }); 元编程：指某种计算机程序的编写，操纵其他（或自身）程序作为他们的资料，或在运行时完成部分本应在编译时完成的工作，让程序员获得更高的工作效率，或给予程序更大灵活度而无需重新编译 编写元程序的语言为元语言，一门编程语言同时也为自身的元语言称为反射 more: 这里Proxy相对与原来Vue2.0的响应式的 “不管三七二十一，上来就给你判断对象 + 递归 ” 不一样，做了小优化，他在修改数据时并不是一上来就递归，而是先通过get方法获取，如果获取到的结果是一个对象，则再做一层代理，进行递归，然后再通过set修改 既然Proxy可以改属性 + 新增属性，那他怎么识别？通过 if 语句 + 对象.hasOwnProperty(属性) 判断，原来是否有这个属性 为什么以前不用Proxy？兼容性差。。。ie11就不兼容 Reflect通过Proxy的捕获器（handler），我们可以完成基于自己的参数重建原始操作，但是并非所有捕获器都像 get 一样那么简单，直接返回就行了，所以通过手动写码如法炮制的想法是不现实的，所以我们使用到了Reflect完成轻松重建，确保完成原有的行为，然后再部署额外的功能。 Reflect 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上，也就是说，从Reflect对象上可以拿到语言内部的方法。 Reflect修改某些Object方法的返回结果，让其变得更合理。 比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 上面两点表明 Reflect可能将成为日后替代 Object对象方法的新的王！ 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 // 老写法 'assign' in Object // true // 新写法 Reflect.has(Object, 'assign') // true Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 Proxy(target, { set: function(target, name, value, receiver) { var success = Reflect.set(target, name, value, receiver); if (success) { console.log('property ' + name + ' on ' + target + ' set to ' + value); } return success; } }); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。 个人认为：这样就形成了Proxy和Reflect的最佳搭配，既保证了原来（默认）的行为，又可以自己添加额外的行为","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"深入JavaScript内存","slug":"深入JavaScript内存","date":"2021-03-20T16:00:00.000Z","updated":"2021-05-15T02:32:05.701Z","comments":true,"path":"2021/03/21/shen-ru-javascript-nei-cun/","link":"","permalink":"https://taylor12138.github.io/2021/03/21/shen-ru-javascript-nei-cun/","excerpt":"","text":"内存概述内存也是有生命周期的，不管什么程序语言，一般可以按顺序分为三个周期： 分配期 分配所需要的内存 使用期 使用分配到的内存（读、写） 释放期 不需要时将其释放和归还 定义变量自动分配内存 绝大部分情况下也不需要手动释放内存 而我们程序员大多只需关注使用内存 内存泄漏当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用（或者由于设计错误）而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。 而内存泄漏也是造成应用程序OOM（内存严重不足）的罪魁祸首之一 内存泄露的问题其困难在于 1.编译器不能发现这些问题。 2.运行时才能捕获到这些错误，这些错误没有明显的症状，时隐时现。 3.对于手机等终端开发用户来说，尤为困难。 解决方法： 避免创建全局变量，开启严格模式 不能滥用闭包 清除没有用的DOM元素引用 (document.body.removeChild(DOM元素)) 定时器用完离开页面记得手动删除（clearInterval()） 使用Vue的时候，在页面销毁时记得对事件解绑，对EventBus进行解绑 beforeDestory () { window.removeEventListener('事件名', 接收时的回调函数(参数)) } destroyed () { this.$bus.$off(\"事件名\", 接收时的回调函数(参数)); } 在ES6 里可以使用 WeakMap、WeakSet JavaScript的垃圾回收机制（GC）标记清除算法设置一个根对象（root）（在Javascript里，根是全局对象）），然后垃圾回收器会定期从根（root）扫描内存中的对象，凡是能从根到达的对象，就是还需要用的，到达不了的进行标记，稍后回收 所有标记清除算法有两个阶段： 标记阶段 清除阶段 算法缺陷：无法从根对象查询到的对象都会被清除，垃圾收集完毕后会造成大量内存碎片 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进 引用计数算法古老的垃圾回收算法，没那么常用了 原理是跟踪记录每个值被引用的次数，被引用一次，则count + 1（除了弱引用类型WeakMap、WeakSet） 垃圾回收程序下次运行的时候就会释放引用数为0的内存 它有很多计数问题，比如引用循环，对象A有一个指针指向对象B，而对象B也引用了A，他们的引用书永远不会变成0 chrome V8 回收算法Chrome 浏览器所使用的 V8 引擎就是采用的分代回收策略。这个和 Java 回收策略思想是一致的。目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（新生代younggeneration），少回收「持久对象区」（老生代 tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。 减少垃圾回收对性能的影响：1.让垃圾回收尽量少地进行 2.避免内存泄露 提升性能避免JavaScript的先创建再补充的动态属性赋值，而是一次性声明所有属性，让实例们共享一个隐藏类 //错误示范❌ function Article(){ this.title = 'my name is title'; } let a1 = new Article(); let a2 = new Article(); a1.author = 'Allen'; //正确示范√ function Article(author){ this.title = 'my name is title'; this.name = author; } let a1 = new Article('Allen'); let a2 = new Article(); 由于JavaScript数组大小是动态可变的，，引擎会删除大小为100的数组，在创建一个新的大小为200的数组，垃圾回收程序看到这个删除操作，说不定看你对象更替速度那么快，就加快对你这里垃圾回收的频率，从而降低性能。要避免这种动态分配的操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作，不过，你必须事先想好这个数组有多大。 （实际上静态分配是优化的一种极端方式，如果你的应用程序被垃圾回收严重拖了后腿，可以利用它来提升性能，但这种情况并不多见，大多情况下，这都属于过早优化。） 缓存雪崩缓存雪崩就是指缓存由于某些原因（比如 宕机、cache服务挂了或者不响应），导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。 其实也可以解释为cache crash之后，牵一发而动全身，导致后端的各大区域接而无法进行服务而崩溃，全部拖死 前情提要：redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。 类似于： 1、redis集群彻底崩溃 2、缓存服务大量对redis的请求hang住，占用资源 3、缓存服务大量的请求打到源头服务去查询mysql，直接打死mysql 4、源头服务因为mysql被打死也崩溃，对源服务的请求也hang住，占用资源 5、缓存服务大量的资源全部耗费在访问redis和源服务无果，最后自己被拖死，无法提供服务 6、nginx无法访问缓存服务，redis和源服务，只能基于本地缓存提供服务，但是缓存过期后，没有数据提供 7、网站崩溃 产生原因1、例如 “缓存并发”，“缓存穿透”，“缓存颠簸” 等问题，这些问题也可能会被恶意攻击者所利用。 2、例如 某个时间点内，系统预加载的缓存周期性集中失效了，例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期。 解决方法：可以通过设置不同的过期时间，来错开缓存过期，从而避免缓存集中失效。 预防和解决 保证缓存层服务高可用性，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。 部署方式一：双机房部署，一套Redis Cluster，部分机器在一个机房，另一部分机器在另外一个机房。 部署方式二：双机房部署，两套Redis Cluster，两套Redis Cluster之间做一个数据同步。 Redis数据备份和恢复、快速缓存预热 对源服务访问进行 限流、资源隔离（熔断）、Stubbed 降级。 对缓存访问进行 资源隔离（熔断）、Fail Silent 降级 （降级：某些特殊情况下，在出现大量占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；降级的最终目的是保证核心服务可用，即使是有损的）","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"安全问题汇总","slug":"安全问题汇总","date":"2021-03-14T16:00:00.000Z","updated":"2021-08-22T12:45:52.412Z","comments":true,"path":"2021/03/15/an-quan-wen-ti-hui-zong/","link":"","permalink":"https://taylor12138.github.io/2021/03/15/an-quan-wen-ti-hui-zong/","excerpt":"","text":"1.XSS什么是XSSCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击，通过注入恶意脚本，，使之在用户浏览器上运行，然后利用这些恶意脚本，攻击者可以获取用户的敏感信息Cookie、SessionID等 XSS 常见的注入方法： 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。 在标签的 href、src 等属性中，包含 javascript: (伪协议)等可执行代码。 等等。。。。 XSS攻击类型 存储型XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大 攻击者将恶意代码提交到目标网站数据库中 客户端最后从服务器得到的就是恶意代码，在浏览器执行的也是该恶意代码 恶意代码将用户数据发送至攻击者网站 反射型XSS（有点像那种色情小广告，点进去你就没了） 攻击者构建特殊URL，里面包含恶意代码 当用户打开此URL时，网站的服务端将恶意代码从中取出，并且拼接在HTML返回给浏览器（这应该属于后端渲染范围） 恶意代码被浏览器执行，然后将用户数据发送给攻击者网站 DOM型XSS（感觉和反射型XSS很像，只不过这个是属于JavaScript的安全漏洞（浏览器的DOM解析），反射型XSS时属于服务端的安全漏洞），所以防范DOM型XSS是前端的责任 同样的，攻击者构造特殊URL，其中包含恶意代码 用户打开后，浏览器解析，JavaScript取出URL然后执行 恶意代码被浏览器执行，然后将用户数据发送给攻击者网站 防范XSS常用的防范手段： httpOnly: 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。 输入过滤: 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。 转义 HTML: 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义 添加白名单：对于显示富文本来说，以上方法可能会将需要的格式也过滤掉，这时我们可以添加白名单的方式 预防存储型XSS和反射型XSS攻击： 纯前端渲染（这样就不会拼接html返回了） 同上面常用的防范手段一样的转义html 预防DOM型XSS攻击 DOM型XSS攻击实际上是JavaScript代码本身不够严谨， .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。（尽量避免这种直接插入式的写法） Vue的 v-html也容易导致xss攻击（原理也是innerHTML），与此同时，v-html也会替换掉标签内部子元素，所以 v-html尽量别用 减少eval()的使用 2.CSRF什么是CSRFCSRF是一种跨站请求伪造，也被称为 one-click-attack 或者 session riding 下面的图源自这个大佬 ： https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html （随便点开，放心绝对不是XSS或者CSRF ，手动狗头） 触发条件： 用户登录并且信任网站A，并产生cookie 未登出A的情况下，访问网站B（此网站虽然是攻击网站，但是它可能是一个存在其他漏洞的可信任的经常被人访问的网站） （感觉通俗来讲就是，你在存放重要信息的网站A登录后，没有关闭 且 本地的cookie没有过期，登陆了另外一个（攻击）网站，它就会偷你的cookie，冒充你来操作你网站A的账号） 常见类型 Get类型的CSRF POST类型的CSRF 链接类型的CSRF，上面两种打开网页就中招，这种要点击的，比较low 防御CSRF 验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差 Referer check：请求来源限制，即同源检测，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。 token：token 验证的 CSRF 防御机制是公认最合适的方案。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈，因为XSS攻击有可能泄露Token * - * 3.劫持DNS劫持 DNS ： 域名 -&gt; ip地址 ，进行域名解析的服务器 （DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在/etc/resolv.conf文件。） DNS劫持又称域名劫持,是指通过某些手段取得某域名的解析控制权，修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址。 DNS劫持其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了 防止DNS劫持 网络层面： 手动修改DNS 修改路由密码 应用层面： 有点复杂，可以网上查询（泪。。） HTTP劫持 你DNS解析的域名的IP地址不变。在和网站交互过程中的劫持了你的请求。在网站发给你信息前就给你返回了请求。 HTTP劫持很好判断，当年正常访问一个无广告的页面时，页面上出现广告弹窗，八成就是运营商劫持了HTTP。下图中，右下角的广告并不是所访问的网站放置的。 4.SQL注入攻击什么是SQL注入攻击sql作为一种解释型语言（数据库语言），在运行时是由一个运行时组件解释语言代码并执行其中包含的指令的语言。基于这种执行方式，产生了一系列叫做代码注入（code injection）的漏洞 程序员在web开发时，没有过滤敏感字符，绑定变量，导致攻击者可以通过sql灵活多变的语法，构造精心巧妙的语句，不择手段，达成目的，或者通过系统报错，返回对自己有用的信息。 个人感觉有点像XSS攻击，都是利用语言漏洞进行代码注入 类似于合成这种永真的语句，让黑客用户登陆成功 select * from users where username=&#39;&#39; or 1=1 防御SQL注入1、预编译，在SQL映射文件中尽量使用#指示符标识参数位置，避免使用$。 2、确认每种数据的类型，比如是数字，数据库则必须使用int类型来存储 3、规定数据长度，能在一定程度上防止sql注入 4、严格限制数据库权限，能最大程度减少sql注入的危害 5、避免直接响应一些sql异常信息，sql发生异常后，自定义异常进行响应 6、过滤参数中含有的一些数据库关键词 5.序列化反序列化漏洞简单来说，序列化可以理解为就是将对象转化为字节流，字节流中包括这个对象的数据和信息，序列化和反序列化便于类的持久保存，并且很利于网络传输 而在反序列化处理中，如果攻击者通过构建恶意输入，使得反序列化产生非预期的类或者对象，这个类或者对象就有可能带来任意代码的执行 所以这个问题的根源在于，字节流进行还原时，即用到ObjectInputStream在反序列化时，没有对生成的对象的类型做限制","categories":[{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"Hello"},{"title":"超文本传输协议","slug":"超文本传输协议","date":"2021-03-14T16:00:00.000Z","updated":"2021-08-22T12:59:47.713Z","comments":true,"path":"2021/03/15/chao-wen-ben-chuan-shu-xie-yi/","link":"","permalink":"https://taylor12138.github.io/2021/03/15/chao-wen-ben-chuan-shu-xie-yi/","excerpt":"","text":"1.http概述从计算机网络的学习我们了解到：HTTP协议[超文本传输协议]，协议详细规定了浏览器和万维网服务器之间相互通信的规则 http 2.0 使用二进制传输（二进制分帧），减少服务端压力，连接吞吐量更大，改善TCP拥塞状况，同时慢启动时间减少 多路复用，多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。 不同浏览器在http1或http1.1对请求的限制数量 压缩headers（最小数据量化） 支持server push（服务端推送），他可以对客户端的一个请求发送多个响应，，而且它特有的缓存机制，使用场景如下，「如果客户端早已在缓存中有了一份 copy 怎么办？] 这种情况下，HTTP/2 允许客户端通过 RESET_STREAM 主动取消 Push ，然而这样的话，原本可以用于更好方向的 Push 就白白的浪费掉数据往返的价值。 对此，一个推荐的解决方案是，客户端使用一个简洁的 Cache Digest 来告诉服务器，哪些东西已经在缓存，因此服务器也就会知道哪些是客户端所需要的，因为 Cache Digest 使用的是 Golumb Compressed Sets，浏览器客户端可以通过一个连接发送少于 1K 字节的 Packets 给服务端，通知哪些是已经在缓存中存在的； http/1处理减少请求的方式是线头阻塞（合并多个请求为一个请求），但实质上有一定的开销 下面我们阐述http 1.x版本的内容 http协议的特点 永远都是客户端发起请求，服务器回送响应 http协议是无状态的，但是在实际工作中，一些万维网网站希望能识别用户（给用户推销产品）=&gt;诞生了cookie小饼干，cookie是存储在用户主机的文本文件，记录一段时间内某用户的访问记录（不太敏感的数据） http采用TCP作为运输层协议，但是http协议本身是无连接的 （交换http报文之前不需要建立连接） http连接方式：持久连接（非流水线式（有点像停等协议）、流水线式（有点像GBN或SR协议，即后退N帧协议和选择重传协议））、非持久连接（每次传输都要三次握手） URL URL：统一资源定位器 URL和域名的区别域名，Domain Name，通常指一个网址的顶级域名。URL，website address，网页或网站的地址。 URL中包含了网站的域名.比如一个网址：www.cnblogs.com/gopark/p/8430916.html其中cnblogs.com是域名，cnblogs是网站名字，com是域名后缀；www.cnblogs.com代表一个二级域名，通常www被用来用为首页标识；https://www.cnblogs.com/gopark/p/8430916.html，这个则是一个完整的网站首页URL地址。https://，这是一个协议，是网站在网上传输的协议 URL和URI的区别： URI，统一资源标志符，表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行标识的。 URL是URI的一个子集，通俗地说，URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上 输入url到网页呈现的过程： 域名解析 建立TCP连接 浏览器发送http请求 服务器返回响应 浏览器渲染页面 TCP断开连接 url编码过程 对于正常英语，使用ASCII编码方式 对于其他语言，Unicode编码方式，而我们常说的 UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。（阮一峰老师said） utf-8 它是一种变长的编码方式。它可以使用1~4个字节表示一个符号 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 http请求 get 获取资源。get注重url获得的参数，且只产生一个TCP数据包 数据格式：获得get请求的内容，它的内容是在url的? 之后的部分 长度限制：Get方法提交的数据大小长度并没有限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制；而这个长度限制，每个浏览器对应的限制都是不一样的。 post 创建资源（带请求体）。post的信息放在Request body中，且产生TCP两个数据包（firefox浏览器除外） 数据格式：post回退时会再次提交请求；一般情况下，私密数据传输用POST + body就好 长度限制：理论上讲，POST是没有大小限制的。HTTP协议规范也没有进行大小限制，起限制作用的是服务器的处理程序的处理能力。 put 更新资源（带请求体） delete 删除资源 connect方法建立一个到由目标资源标识的服务器的隧道。 options方法用于描述目标资源的通信选项。 请求报文： 1.行 第一部分是请求类型（GET、POST之类的） 第二部分是url的路径 第三部分是http协议的版本（目前使用最多的是1.1） 2.头（首部） 格式是值键对的形式 Host: atguigu.com Cookie: name=guigu Content-type = application/x-www-form-urlencoded User-Agent: chrome 83 3.空行 4.体 GET的话，请求体为空，POST的话，请求体可以不为空 响应报文 1.行 第一部分是http协议的版本（目前使用最多的是1.1） 第二部分是响应状态码 第三是响应状态字符串 2.头 （首部） 格式和请求头一样 3.空行 4.体 html的内容 报文和实体 http报文和http实体是不同的概念，http报文类似于运输的箱子，http实体类似于箱子中的货物（个人感觉 实体 = 报文 - 行 - 除了实体首部字段的所有首部字段） 报文：网络中交换和传输的数据单元，即一次性要发送的数据块，包含了发送的完整数据信息 实体：作为请求和响应的有效载荷数据 http工作 地址解析，通过DNS解析域名,得主机的IP地址 封装http的请求数据包 封装成TCP包，建立TCP连接（三次握手） 客户端向服务器发送请求 服务器向客户端返回响应 关闭TCP连接（四次挥手） http only如果想要实现服务端设置cookie，返回时让客户端无法查看，可以使用 HttpOnly属性 （MDN：有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：Secure 属性和HttpOnly 属性。） HttpOnly = true 的话，那此Cookie 只能通过服务器端修改，Js 是操作不了的，对于 document.cookie 来说是透明的 此预防措施有助于缓解跨站点脚本（XSS） (en-US)攻击。 2.持久连接在http初始协议版本中，每进行一次http通信都要断开一次TCP连接，如果需要同时请求多个资源时就造成了无缘无故的TCP连接建立和断开，造成资源浪费，增加通信开销。 为了解决上述问题，http/1.1和http/1.0想出了持久连接的方法，其特点是只要一方没有明确提出断开，就保持TCP连接。在 http/1.1 中，所有的连接默认都是持久连接 延伸出来的管线化持久连接使得管线化的方式成为可能，管线化技术出现后，不用等待即可发送下个请求 3.首部字段概述HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段。 在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。 结构 格式是值键对的形式 类型分为： 通用首部字段（请求和响应通用）Cache-Control、Connection等 请求首部字段（请求专用）Accept、Accept-Charset、Host（请求资源所在服务器）等 响应首部字段（响应专用）Accept-Ranges、Location（令客户端重定向至指定 URI）、Server（HTTP 服务器应用程序的信息）等 实体首部字段（通用，针对报文的实体部分）Allow、Content-Encoding等 4.http和httpshttp：超文本传输协议，它是以一种明文的方式（传输是明文的），没有任何加密，如果我们在该网站输入登录密码等信息，发送请求到服务器时，如果有人在中途截取我们的信息，那我们的信息可能就暴露了，默认80 https：超文本传输安全协议，利用SSL/TLS来加密数据包。默认443，需要到 CA 申请证书，一般免费证书很少，需要交费，握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； 对称密钥：直接发密钥，之后的通信都用过这个密钥打开。它的弊端就是，可能被中间人拦截，这样中间人就可以获取到了密钥，就可以对传输的信息就行窥视和篡改。 非对称密钥（RSA）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密 但它的弊端就是，算法很慢 我们使用结合的方式！ 使用 非对称密钥（RSA） 发送 对称密钥，然后双方使用 对称密钥 进行通信 SSL协议：这个协议简单来说就是提供数据安全和完整性的协议，也就是负责网络安全的加密。比如我们访问了一个https网站，客户端和服务端会（握手阶段） 先建立安全的连接通道，客户端先给出协议版本号 + 支持的加密方法 + 随机数等 确认信息后，服务器会生成一个加锁的箱子，但是这把锁有两把不一样的钥匙，一把留给服务器自己（私钥），一把提供给客户端（公钥） 服务器发送 — &gt; 未上锁的箱子 + （里面放着一份网站的证书（证书包括公钥和数字签）到 – &gt; 客户端（你访问的服务器没问题）） 客户端生成两把对称密钥，一把留给自己，然后把信息 + 另一把对称密钥放到箱子中，用钥匙锁上（只能用私钥开）发送 —&gt;服务器 然后服务器用另外一把钥匙（私钥）打开箱子，然后双方可以通过对称密钥通信了 在这个过程中，即使箱子被拦截了，也很难打开箱子 中间人攻击因为传输非对称密钥的时候，服务端发送的是公钥，，有可能被中间人拦截后进行篡改 这时我们就需要数字证书，确定服务端的身份，一定是服务端发送的，而数字证书类似于我们的公证处 这篇文章可以生动形象地了解到 https 的原理 https://juejin.cn/post/6844903504046211079 （而我们熟知的自动打卡，有些就是利用中间人攻击的原理（fiddler抓包），模拟客户端和服务端通信，当然，它也通过不了数字证书的校验，fiddler伪造的数字证书，是建立在我们手动信任的基础上） （所以连接陌生wifi、下载乱七八糟的软件，有可能会被装上乱七八糟的私发证书，从而出现中间人攻击） TLS协议它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本 对比SSL的增强内容： 更安全的MAC算法 更严密的警报 “灰色区域”规范更加明确定义 session恢复握手阶段通过SSL/TLS进行连接，如果出于某种原因，对话中断，就需要重新握手 此时有两种方法可以恢复原来的session session ID session ticket Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过Session ID来区分不同的客户，通过这个Session ID，双方还可以重新使用已有的”对话密钥“，无需重新生成 session ID的优点是高兼容性，但缺点是只能保留在一个服务器上 session ticket优点可在其他服务器上使用，它原理上就是让xx的的请求一直粘连在机器A上。缺点：目前只有火狐和谷歌支持 session ticket是加密的，只有服务器才能解密，其中包括对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。 5.响应状态码200：ok 204：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。 206：客户端进行了范围请求，服务器成功执行部分get请求 301：永久重定向 第一次进入a.com，请求-&gt;b.com，以后每次进入a.com就不用请求直接去b.com（请求的资源已被永久分配了新的 URI） 302：临时重定向（暂时性转移） 每一次都会进入a.com，然后请求-&gt;b.com（请求的资源已被临时分配了新的 URI） 303：有点像302，只不过303提醒你应该使用get请求 304：自从上次请求后，请求的网页未修改过，所以没有响应主体部分 307：同302 400：报文存在语法错误 401：未授权，请求用户身份认证 403：服务器理解了请求但拒绝对其进行授权，被禁止，资源访问被服务器拒绝了 404：找不到， 413：表示http请求实体太大。 500：内部错误 502：错误网关，从上游服务器收到无效响应，可能也是停机维护，或者服务器暂未开启， 503：服务器目前无法使用（由于超载或停机维护）通常，这只是暂时状态。（服务不可用） 504：网关超时 6.http缓存常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力。对于开发者来说，长久缓存复用重复不变的资源是性能优化的重要组成部分！！！ 浏览器第一次向一个web服务器发起http请求后，服务器会返回请求的资源，并且在响应头中添加一些有关缓存的字段（添加后浏览器才知道是否应该缓存资源）如： Cache-Control（控制浏览器是否可以缓存资源、强制缓存校验、缓存时间）（通用头部） no-cache：含义是不使用本地缓存，需要使用协商缓存，也就是先与服务器确认缓存是否可用。 no-store：禁用缓存。 public：表明其他用户也可使用缓存，适用于公共缓存服务器的情况。 private：表明只有特定用户才能使用缓存，适用于公共缓存服务器的情况 Expires（与响应头中的 Date 对比）（实体头部） Expires 更多的是为了兼容旧浏览器（只支持 HTTP/1.0 的上古时代浏览器）的响应标头。 从 HTTP/1.1 以后就有了 Cache-Control 标头中的 max-age，设一个秒数；而是 Expires 设一个具体的时间点，显然 Expires 可能因为客户端与服务端时间不一致、或网络延迟导致过期时间不准确，并且 Cache-Control 能设的值更多也就更灵活。 Last-Modified（弱校验， 根据文件修改时间校验，可能内容未变，不精确）（实体头部） ETag（强校验，根据文件内容校验精确，这也是有了Last-modified还要有ETag的原因， 可以看作 Etag是last-Modifed的补充，但是检查时 Etag先检查 ）（响应头部） Date等等。 http缓存都是从第二次请求开始的。第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存（当ETag和Last-Modified同时存在时，服务器先会检查ETag，然后再检查Last-Modified），命中则返回304，否则服务器会返回新的资源 为什么有Last-Modified还要有ETag？ 考虑以下情况： 1.一些文件也许会周期性的更改,但是他的内容并不改变(仅仅改变的修改时间),这个时候,我们并不希望客户端认为这个文件被修改了,而重新 get2.某些文件修改非常频繁,比如在秒以下的时间内进行修改(比方说 1s 内修改了 N 次),If-Modified-Since能检查到的粒度时 s 级的,这种修改无法判断(或者说 UNIX 记录 MTIME只能精确到秒)3.某些服务器不能精确得到的文件的最后修改时间 强缓存 + 协商缓存之后浏览器再向该服务器请求该资源就可以视情况使用强缓存和协商缓存。 强缓存：（当前缓存未过期）浏览器直接从本地缓存中获取数据，不与服务器进行交互。 协商缓存：（当前缓存过期）浏览器发送请求到服务器，服务器判定是否可使用本地缓存。 联系与区别：两种缓存方式最终使用的都是本地缓存；前者无需与服务器交互，后者需要。 缓存过期策略1、设置 Cache-Control: max-age=1000 。响应头中的 Date 经过 1000s 过期（比起首部字段Expires，会优先处理s-maxage或max-age。）（Cache-ControlHTTP / 1.1通用头字段被用于为请求和响应缓存机制指定指令l）2、设置 Expires 。此时间与本地时间(响应头中的 Date )对比，小于本地时间表示过期，由于本地时钟与服务器时钟无法保持一致，导致比较不精确（http1.0时代，Pragma也是1.0时代的产物）3、如果以上均未设置，却设置了 Last-Modified ，浏览器隐式的设置资源过期时间为 (Date - Last-Modified) * 10% 缓存过期时间。 前端缓存图： 7.其他范围请求假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载，要实现该功能，这就要用到范围请求。（前提是上一次请求到这一次请求时间段内，下载对象没有发生改变） 8.QUICQuic 全称 quick udp internet connection ，“快速 UDP 互联网连接”，也可以理解为http3.0 应用：速度更快、网络切换（wifi -&gt; nG）无感知等、弱网络环境better 对比http2.0： 减少了 TCP 三次握手及 TLS 握手时间。 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT，而QUIC由于建立在UDP的基础上，只需要0RTT即可完成安全握手。 改进的拥塞控制。 为啥你用UDP也能可靠啊？ TCP 使用ACK（确认），还有基于字节序号的 Sequence Number为了保证可靠性，而QUIC也有使用ACK（确认）并且以 Packet Number 代替了 TCP 的 sequence number； 传统TCP：超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。但是因为序列号一样，所以我们分不清这个 Ack 数据到底是原始请求的响应，还是重传请求的响应 Sequence Number：当Packet Number 发生了丢失，Packet Number 传递的数值（也就是那个Number）会不一样，因为他是按照严格递增的，此时就可以发现传送的失误了。（在RTO 发生后，可以精确判断Ack 数据是原始请求的响应，还是重传请求的响应） 还有可插拔、更多ACK块等 避免队头阻塞的多路复用。 QUIC的多路复用，也可以实现在一条 QUIC 连接上可以并发发送多个 HTTP 请求 （stream），但是stream之间没有相互依赖，这导致了彼此不会相互影响，极大程度消除了对头阻塞的影响； 并且QUIC 最基本的传输单元是 Packet，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞。 而对比QUIC，http2.0的多路复用会队头阻塞，本身强制使用的TLS协议也存在一个队头阻塞 连接迁移。 WIFI 和 4G 移动网络切换时， ip发生变化 -&gt; 重新建立TCP连接；而任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为 ID 来标识，继而上层业务逻辑感知不到变化 前向冗余纠错 QUIC参考链接https://zhuanlan.zhihu.com/p/32553477","categories":[{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"Hello"},{"title":"项目部署","slug":"项目部署","date":"2021-03-07T16:00:00.000Z","updated":"2021-08-22T12:16:46.342Z","comments":true,"path":"2021/03/08/xiang-mu-bu-shu/","link":"","permalink":"https://taylor12138.github.io/2021/03/08/xiang-mu-bu-shu/","excerpt":"","text":"1.部署方式利用脚手架打包后得到dist文件 将自己电脑作为服务器，部署本地 ：window -&gt; 使用nginx或者tomcat 远程主机，进行部署：linux centos -&gt; nginx 如 注意 ：使用nginx时，关闭不用粗暴乱结束进程关闭，可能会产生一些关不掉等小bug，记得cmd进去nginx根目录下 nginx -s stop即可 在部署Vue、Node.js和MongoDB部署上给予一定帮助的网址：https://segmentfault.com/a/1190000022921908 部署时踩的坑： 面对404时，是找不到资源，在本地上可以运行，而部署到服务器上却出现了404，很有可能是api链接等没有写对，导致找不到真正的地址；部署后台项目的时候，我将异步请求的 axios baseURL 改成：自己的公网地址:端口号，实际上是只需改成：自己的公网地址就可以了，害我看了半天 面对502时，可能是服务器暂未开启 面对500时，是服务器发生内部错误，我看了半天的服务端代码，发现没错，实际上是请求的数据有一段时number类型，我测试的时候胡乱输入字符串，也会发生500错误 当服务器一直开不了时，可以查看在linux命令里查看pm2日志查找问题 pm2 logs 组件化有个缺点，就是，可能不能及时发现变量名，语法错误导致的结果出不来，已经卡住两次了，记住语法、变量名基本错误不能犯 还有一些PM2任务管理器的一些操作符献上： pm2 start app.js # 启动app.js应用程序 pm2 list # 列表 PM2 启动的所有的应用程序 pm2 restart all # 重启所有应用 2.github actionsGitHub action产生的初衷是用于CI的，也就是持续集成。但我发现实际上很多GitHub上的项目，使用到GitHub actions 定时跑自己的脚本，比如签到类、每天自动做任务类的脚本（当然我还看到很多csdn的老哥使用它来哔哩哔哩签到投币等 0.0 ） github老哥的入门指南https://github.com/shfshanyue/you-dont-need-vps/blob/master/github-action-guide.md 与此同时，还可以使用linux命令 crontab命令定时执行脚本，实现以上功能 3.服务器软件 Web服务器：提供Web化服务，当下几乎所有服务器软件都可以成为Web服务器 Http服务器：侧重静态资源传输的支持 应用服务器：常被称作动态服务器 1.Nginx：http服务器，性能好、稳定好、一般放在最前面 2.Tengine：基于Nginx，加强和封装 3.Apache：静态服务器，性能不如Nginx，所以Nginx使用居多 4.IIS：微软阵营的Web服务器，只能运行在windows，http静态服务器 5.Tomcat：典型java应用服务器软件，动态服务器， 一般和Nginx这种静态服务器一起打配合 NginxNginx 是高性能的 HTTP 和反向代理的web服务器，处理高并发能力是十分强大的，能经受高负 载的考验,有报告表明能支持高达 50,000 个并发连接数。 正向代理 正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。 简单一点：通过代理服务器来访问服务器的过程 就叫 正向代理。 需要在客户端配置代理服务器进行指定网站访问 正向代理的用途： （1）访问原来无法访问的资源，如Google （2） 可以做缓存，加速访问资源 （3）对客户端访问授权，上网进行认证 （4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问。 我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。 反向代理的作用： （1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 （2）负载均衡，通过反向代理服务器来优化网站的负载 负载均衡将原先请求集中到单个服务器上的 情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负 载均衡 客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服 务器处理完毕后，再将结果返回给客户端 实际上用一种通俗比喻来形容正反向代理，可以解说为正向代理为我国的海关关口，反向代理是目标国家（外国）的海关关口 4.自建服务器借助serve库，能让某一指定文件夹（作为根目录）快速开启一台服务器 npm i serve -g 然后在自建的文件夹下开启服务器： serve 或者该目录下（“文件名”的文件作为根目录） serve 文件名 5.大前端大前端实际上就是所有前端的统称，大前端最大的特点在于一次开发，适配所有平台，实现代码复用，是一个web走向统一的时代。 是前端方向进阶，践行工程化、迈进全球化、深入组件化的过程 在node出现后，前端工程师可以暂时不依赖后端程序而运行自己的整体项目，从而实现先后端分离 大前端势必称为移动开发 &amp; Web前端的发展趋势，在学习原生的同时，前端人员也要学习Android 或 IOS 的原生开发技术，才能更好地融入大前端的圈子 跨平台跨多平台的方案有： H5+原生（Cordova、Ionic、微信小程序），这种模式又称为Hybrid开发 社区及资源丰富，缺点是性能不好 JavaScript开发+原生渲染 （React Native（FaceBook）、Weex（阿里）、Picasso（美团）、快应用） 性能相比H5提高很多；动态化较好，支持热更新 渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿 自绘UI+原生(Flutter） Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，避免对原生控件依赖而带来的限制及高昂的维护成本 不支持动态下发代码和热更新 增强版Web App(PWA) 等 现在很多大公司都加入了多端大战，自己公司分别研发多端跨平台统一框架 跨端优势 从开发者角度看： 降低开发成本（研发效率、代码重用、多平台支持） 快速开发原型 UI 一致性 从企业角度看： 支持多平台 触及更广的市场 降低前期成本 附上前端本人的照片（美人部分） RPCRPC是指远程过程调用，比如说服务器A上的项目调用服务器B上提供的函数和方法 rpc需要面临的问题 1.由于网络协议是基于二进制的，所以需要序列化和反序列化 2.解决通信、寻址等网络问题","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Vue(中)","slug":"Vue(中)","date":"2021-02-28T16:00:00.000Z","updated":"2021-08-22T15:57:43.570Z","comments":true,"path":"2021/03/01/vue-zhong/","link":"","permalink":"https://taylor12138.github.io/2021/03/01/vue-zhong/","excerpt":"","text":"5.Vue router前后端路由概述路由就是网络把信息从源地址传输到目的地址的活动 后端渲染是将数据在后端处理生成html发给浏览器，前端渲染是通过ajax拿到数据，操作dom节点 渲染ui （相当于Node.js里的服务器渲染和客户端渲染） 1.后端路由（后端渲染）：服务器处理一个url映射一个页面，通过正则匹配，交给controller进行处理，然后生成html等数据返回前端 2.前后端分离（前端渲染）： 输入url 去静态服务器里获取 html + css + js 浏览器执行JS代码 -&gt; JS代码中有API请求，去到API接口服务器中获取数据 随着Ajax的出现，有了前后端分离的开发模式，前后端分离最大的优点就是责任清晰，分工明确，并且在移动端（IOS/Android）出现后，后端使用之前一套API即可 前端路由 在前后端分离中，静态资源服务器放了好几套的 HTML + CSS +JS，每个对应不同的页面 SPA页面（单页面富应用）：整个网站只有一个html页面（React、Vue） 而在前端路由中： 静态资源服务器只有一个html（甚至也只有一个CSS + 一个JS） 网页获取到静态资源后，由前端路由配置映射关系 点击url，通过JS代码判断，从那个获取的一个静态资源里再抽取资源，然后显示出来（这里抽取的资源，再vue里，相当于一个url映射一个组件，一个组件对应一个网页） 改变url，依然是页面不发生整体刷新 url的hash 为了改变url，而让也页面不发生刷新，可以使用 url的hash 或者html5 的 history模式 Push：通过window.location.hash = &#39;xxx&#39;更改href，网页不会刷新（默认），也就是重定向（带有hash的前端路由，优点是兼容性高，缺点是URL带#号不好看） hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置； Push：也可以通过history.pushState({}, &#39;&#39;, &#39;xxx&#39;)更改href，进行重定向 可以使用history.back()或者history.go(-1) 后退功能进行回退 Push，入栈顶，可回退 Replace：还可以通过 window.replace、 history.replaceState({}, &#39;&#39;, &#39;xxx&#39;)来更改，不可回退（替换掉原先栈顶的路由） 在Vue实例中使用 this.$router.back() 也可以实现回退 （源码上除了hash、history、其实还有一个abstract模式） vue-router关于url改动的问题 由于默认是使用hash改动url，如果想要改成Html5的history模式，则在router对象里利用mode属性进行修改 const router = new Router({ routes, mode: 'history', LinkActiveClass: 'active' //可以把router-link当前被选中（点击）的标签的类名，改为active }) 基本使用目前三大框架都有自己的路由实现：Angular的ngRouter、React的ReactRouter、Vue的vue-router 安装：(或者脚手架选择的时候，可以自动帮你安装路由，并且以下步骤不用实施) npm install vue-router --save 于src文件夹里创建 router文件夹 -&gt; index.js 1.通过Vue.use(插件)，来安装插件 （在vue内部执行了插件.install方法） 2.创建路由对象，routes属性用于配置路由和组件的映射关系 3.将router对象传入Vue实例当中 import Router from 'vue-router' import Vue from 'vue' Vue.use(Router); const routes = [ ]; const router = new Router({ routes }) export default router; router 为 Vue的 路由属性，直接赋值即可 //main.js import Vue from 'vue' import App from './App' import router from './router' //自动找到该目录下的index文件 Vue.config.productionTip = false new Vue({ el: '#app', router, render: h => h(App) }) 使用 1.在components文件夹里新建组件 如： home.vue 和 about.vue，里面自己适配好template 和 script 2.在routes里编写映射关系，一个对象对应一个映射关系 踩坑：配置路由映射时，component不能加s url 中出现 path,则显示该对象里的组件component import Home from '../components/home' import About from '../components/about' const routes = [ { path: '/home', component: Home }, { path: '/about', component: About } ]; 3.通过&lt;router-link&gt;和&lt;router-view&gt;使用路由: vue-router模块源码中，注册了全局组件 RouterView 和 RouterLink 所以可以使用这两个标签 由于这里我们把Vue实例的渲染属性绑定了 App.vue 的组件对象，我们把&lt;router-link&gt;和&lt;router-view&gt;添加至 App.vue组件的template中使用 &lt;template> &lt;div id=\"app\"> &lt;!-- &lt;router-link >是Vuerouter已经注册的的内置标签，最终会被渲染成a标签 --> &lt;router-link to=\"/home\">首页&lt;/router-link> &lt;router-link to=\"/about\">关于&lt;/router-link> &lt;!-- &lt;router-view>是Vuerouter已经注册的，决定路由的页面渲染 --> &lt;router-view>&lt;/router-view> &lt;/div> &lt;/template> 配置首页 const routes = [ { path: '/', // redirect 重定向 redirect: '/home' } ]; router-link的其他属性的补充 to属性：写上路径，点击后则会把网页的url进行路径的改动，然后router-view就会根据这个路径渲染网页 tag属性：默认最终渲染为为 a 标签，tag=&quot;button&quot; 则渲染为button标签 replace属性：如果当前的router对象中mode属性为 ‘history’，增加该属性，则url的改变方法改为： history.replaceState() router-link的原理： &lt;template> &lt;div id=\"app\"> &lt;button @click=\"homeClick\">首页&lt;/button> &lt;button @click=\"aboutClick\">关于&lt;/button> &lt;router-view>&lt;/router-view> &lt;/div> &lt;/template> &lt;script> export default { name: \"App\", methods: { // 通过代码修改路径 // vue-router源码往所有组件里都添加了$router属性 // history的pushStatus， push => pushStatus // 但是连续点击会报错，可以试一试this.$router.push('home').catch(err => err) homeClick() { this.$router.push(\"/home\"); }, aboutClick() { this.$router.push(\"/about\"); }, }, }; &lt;/script> //选择hash的mode $router.push() --> HashHistory.push() --> History.transitionTo() --> History.updateRoute() --> {app._route = route} --> vm.render() 1 $router.push() //调用方法 2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶） //（其实也就是window.location.hash= XXX） 3 History.transitionTo() //监测更新，更新则调用History.updateRoute() 4 History.updateRoute() //更新路由 5 {app._route= route} //替换当前app路由 6 vm.render() //更新视图 其他知识点动态路由 某些情况下，一个页面的path是不确定的，比如我希望我的路径是 /user/aaa 或 /user/bbb /user/:id 这种path和Component的匹配关系，我们称之为动态路由（也是路由传递数据的一种方式） 动态路由的绑定：新建一个user.vue文件，然后把vue文件映射到路由的js文件中（router的index.js） &lt;template> &lt;div> &lt;h2>用户界面&lt;/h2> &lt;h2>{{ userId }}&lt;/h2> &lt;/div> &lt;/template> &lt;script> export default { name: \"User\", computed: { // route指当前处于活跃状态的路由，属性使用类似上面 ‘router-link的其他属性的补充’中 的$router属性 // vue-router源码往所有组件里都添加了$route属性 // 不要搞错成router，router是路由对象，用来配置路由和组件的关系 // params是参数的意思 userId() { //这里的userId对应的是映射时的/:userId return this.$route.params.userId; }, }, }; &lt;/script> import User from '../components/user' const routes = [ { path: '/user/:userId', component: User } ]; 接着在大组件app.vue中使用该模板 &lt;router-link :to=\"'/user/' + userId\" tag=\"button\">用户&lt;/router-link> 或者利用事件进行跳转+传递params this.$router.push(\"/detail/\" + userId); 在app.vue导出的实例对象里添加相应的data属性： data() { return { userId: \"zhangsan\" }; }, 路由懒加载 由于打包时，除了其他一些文件，主要的部分丢存放于一个js当中，然后在请求静态资源服务器时，可能因为文件太大，导致第一次请求资源时（即那一个主要的js文件），花费过长的时间，可能在请求过程，浏览器出现短暂的空白。 vue搭建脚手架时，对js、css文件等进行了分包 npm run build /dist/static/js 文件中 app.xxx.js 是业务代码 、vendor.xxx.js是提供商/第三方包的源码、mainfest.xxx.js是为打包的代码做底层支撑（让浏览器识别ES6、commonJS语法等） 当打包构建应用时，JavaScript包会变得特别大，如果我们把不同路由由对应的组件分割成不同同代码块，然后当路由被访问时才加载对应组件，这样才会更加高效（采取一个路由打包一个js文件的方法，先向静态资源服务器请求当前最需要的js文件） 懒加载：用到时，再加载 于router文件夹的index.js中每个加载修改为函数的形式 // 懒加载 const Home = () => import('../components/home'); const About = () => import('../components/about'); const User = () => import('../components/user'); const routes = [ { path: '/', redirect: '/home' }, { path: '/home', component: Home }, { path: '/about', component: About }, { path: '/user/:userId', component: User } ]; 路由嵌套如果想要进行路由细分（比如进入 /home 之后，还想要在进入 /home/message ），则形成了路由嵌套 嵌套的实现： 创建相应的子组件，并且在路由映射中配置相应的子路由 在组件内部再次使用 &lt;router-view&gt;标签 以下操作作为例子进行路由嵌套 新建两个vue文件（用于嵌套在home路由上） 在路由的js文件中的routes数组里，每个对象都可以有一个children属性，里面可以保存嵌套的路由 const HomeNews = () => import('../components/HomeNews') const HomeMessage = () => import('../components/HomeMessage') { path: '/home', component: Home, children: [ { path: '', redirect: 'news' }, {// 子路由不需要加 '/' path: 'news', component: HomeNews }, { path: 'message', component: HomeMessage } ] }, 然后再home组件中添加 router-view 进行子路由页面渲染 &lt;template> &lt;div> &lt;h2>首页&lt;/h2> &lt;!-- 这里需要给完整的路径， 不能直接to=\"/news\" --> &lt;router-link to=\"/home/news\" tag=\"button\">新闻&lt;/router-link> &lt;router-link to=\"/home/message\" tag=\"button\">信息&lt;/router-link> &lt;router-view>&lt;/router-view> &lt;/div> &lt;/template> 参数传递从一个路由页面跳转到另外一个路由页面时，我们可能希望传递一些消息 传递参数主要有两种类型：params和query params类型：如动态路由的配置 /router/:参数名 传递方式：在配置路由映射时，path后面跟上响应的值进行接收声明 路由路径名/:参数名； 接着在组件的router-link的to属性添加参数进行传递 / 或者利用this.$router.push(&quot;/detail/&quot; + userId)进行进行跳转 传递后形成的路径 /router/123， /router/abc 子组件通过 this.$route.params.参数名获取参数 query类型： 正常路由配置方式 传递方式：对象中使用query的key作为传递方式 传递后形成的路径： /router?id=123, /router?id=abc 在总组件 app.vue 中进行配置 &lt;router-link :to=\"{ path: '/Profile', query: { name: 'Allen', age: 18, heigh: 1.88 } }\" tag=\"button\"> 档案&lt;/router-link> 或者利用事件进行跳转+传递query 事件名(){ this.$router.push({ path:'/detail', query:{ name: 'Allen', age: 18, heigh: 1.88 } }) } 若想在子组件的template模板中中获取该参数，则使用 route.query进行获取（得到一个对象，里面存储参数） &lt;p>{{ $route.query }}&lt;/p> 总结：大量数据使用query，因为query传过去是对象 router和route 大前提：所有的组件都继承vue类的原型 vue-router源码往所有组件里都添加了$router属性（往vue的原型上加的，用的是vue.prototype在原型对象上添加） 所以在任何一个组件里，都可以使用 this.$router进行获取 前端路由使用history刷新页面时，router-link的原理中使用到 $router.push(&quot;路径&quot;)，router对象为路由文件夹router中index.js导出的router对象 而 route 是当前活跃的路由，vue-router源码往所有组件里也添加了$route属性（往vue的原型上加的，用的是vue.prototype在原型对象上添加） 所以在任何一个组件里，都可以使用 this.$route进行获取 导航守卫在发生路由跳转时，我们有时需要去监听这个跳转事件，然后对网页进行相应的变化（比如网页标题的改变） 方法一：使用生命周期函数 vue的生命周期函数 created() {} 来定制，缺点：一个功能的实现需要在多个（甚至是每个）子组件上定义。 方法二：导航守卫 先给每个路由添加 元数据 meta （描述数据的数据） const routes = [ { path: '/about', component: About, meta: { title:'关于' } }, { path: '/home', component: Home, meta: { title: '首页' }, children: [ { path: '', redirect: 'news' }, {// 子路由不需要加 '/' path: 'news', component: HomeNews }, { path: 'message', component: HomeMessage } ] } ] 使用导航守卫，这时可以使用to.meta.title获取，但是如果路由中使用了路由嵌套，还得格外注意使用 to.matched[0].meta.title获取，使用下标为0的进行获取，则当你未进行嵌套时，还能正常获取，因为确实是当前选定路由的第一个 next() 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 // 导航守卫 router.beforeEach(function (to, from, next) { //从from跳转到to， from和to都是Route类型 document.title = to.matched[0].meta.title; //有next才能实现路由跳转，一定要加上 next(); }) 这里的beforeEach 是前置守卫，是路由跳转之前进行的回调 后置钩子 afterEach(to, from) 不需要主动调用next函数，等待路由跳转结束后也会调用函数 无论是前置守卫还是后置钩子，都被称为全局守卫，除此之外，还有路由独享守卫 beforeEnter、 组件内守卫 beforeRouteEnter 等 守卫分类全局守卫： router.beforeEach((to, from, next) =&gt; {}) 全局前置守卫，每一个导航被触发时，被调用的总是全局前置守卫 router.beforeResolve((to, from, next) =&gt; {})，全局解析守卫，和 beforeEach类似，区别是导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，才被调用 router.afterEach((to, from) =&gt; {})后置钩子 路由独享守卫： const router = new VueRouter({ routes: [ { path: '/play', component: Play, beforeEnter: (to, from, next) => {} } ] }) 组件内路由守卫： beforeRouteEnter(to, from, next){} beforeRouteUpdate(to, from, next){} beforeRouteLeave(to, from ,next){} const Foo = { template: `...`, beforeRouteEnter (to, from, next) { // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 }, beforeRouteUpdate (to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` }, beforeRouteLeave (to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` } } 导航流程（官网） 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。 keep-aliverouter-view也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存（比如实现功能：进入 /home ， 默认进入 /home/news，如果跳转到 /home/messgae 之后，再跳转到其他页面，此时回到 /home 可以直接进入上一次查看的页面/home/messgae，而不是默认页面/home/news） keep-alive 是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染，它的原理是避免组件被销毁（所以使用keep-alive之后，组件不会触发destoryed 钩子函数） 生命周期函数 activated 和 deactivated 只有在组件被保持了 keep-alive 时，才能被正常使用 里面还有个 LRU （最近最久未用算法，同操作系统的LRU），缓存的太多超过max，就需要删除掉 SPA（单页面富应用）常用 kepp-alive，提高性能！ &lt;keep-alive> &lt;router-view>&lt;/router-view> &lt;/keep-alive> //home.vue的script部分 export default { name: \"home\", data() { return { path: \"/home/news\" }; }, // 使用组件内守卫记录离开时的路径信息，并且再用生命周期函数activated实现跳转 //activated为当前页面活跃状态的钩子函数 activated() { this.$router.push(this.path).catch((err) => {}); }, beforeRouteLeave(to, from, next) { this.path = this.$route.path; next(); }, }; keep-alive有两个非常重要的属性 include：字符串或正则表达，只有匹配的组件才会被缓存 exclude：字符串或正则表达，任何匹配的组件都不会被缓存 注意：这里的 “,”不能加空格 &lt;!-- 使用keep-alive include=\"组件的name\" --> &lt;keep-alive include=\"home,User\"> &lt;router-view>&lt;/router-view> &lt;/keep-alive> 6.Vuex概念Vuex是一个转为Vue.js应用程序开发的状态管理模式 其实可以简单看成把需要多个组件共享的变量全部存储在一个对象里面（状态：变量），然后把这个对象放在顶层的Vue实例中，让其他组件一起使用（而且交给Vuex大管家来管理，其数据还是响应式的） 我们其实可以自己通过prototype封装共享的变量对象，但是做不到响应式 多界面共享的例子：用户登陆状态、用户名称头像、地理位置、购物车信息 单页面状态管理： View(视图template部分) -&gt; Actions(事件行为) -&gt; State(变量) -&gt; View 多页面状态管理：Vuex 使用安装 npm install vuex --save 初始化 然后新建一个store文件夹，在里面创建 index.js 文件，以下步骤和创建router路由插件几乎相同 1.通过Vue.use(插件)，来安装插件 （在vue内部执行了插件.install方法） 2.创建store对象 3.将store对象传入Vue实例当中(在mian.js里面)，类似于添加了Vue.prototype.$store = store，但是却具有响应式能力 import Vuex from 'vuex' import Vue from 'vue' // 1.安装插件 Vue.use(Vuex) // 2.创建对象 const store = new Vuex.Store({ }) // 3.导出store对象 export default store //main.js import Vue from 'vue' import App from './App' import store from './store' Vue.config.productionTip = false new Vue({ el: '#app', store, render: h => h(App) }) ​ Vuex状态管理图 Devtools 是Vue开发的一个浏览器插件，用来记录每一次改变State 需要在浏览器上安装：可以去谷歌应用商店安装Vue.js devtools 插件 Vue官方不建议Components直接修改State ，但是官方允许Components直接修改Mutations Actions用于处理异步操作（Backend，也就是后端），Mutations一般都是存储同步操作 store对象内置属性： state：保存状态（变量），其他组件可以通过 $store.state.变量名进行获取（类似data） getters：类似于组件里的计算属性computed, 里面的函数默认可以传入state作为参数 mutations：定义修改状态的方法，里面的函数默认可以传入state作为参数（类似methods） actions：在里面处理异步操作 modules：用于划分模块 具体操作 const store = new Vuex.Store({ state: { counter: 10, }, mutations: { increment(state) { state.counter++; }, decrement(state) { state.counter--; }, actions:{}, getters: {}, modules:{} } }) 使用共享变量的组件，这时调用共享的方法Mutations需要用commit来提交 &lt;template> &lt;div id=\"app\"> &lt;h2>{{ $store.state.counter }}&lt;/h2> &lt;button @click=\"add\">+&lt;/button> &lt;button @click=\"sub\">-&lt;/button> &lt;/div> &lt;/template> &lt;script> export default { name: \"App\", methods: { add() { this.$store.commit(\"increment\"); }, sub() { this.$store.commit(\"decrement\"); }, }, }; &lt;/script> Vuex每个属性详解State单一状态树 vuex推荐只创建一个Vuex.Store实例，若创建多个，日后不方便进行维护 单一状态树可以最直接地找到某个状态 Getters基本使用 里面的函数默认可以传入state作为参数，但也可以默认传入 gatters 已有的数据（若传进来，第一个参数为state，第二个参数为getters）。如果要在组件中传入参数，则需要把返回的值改成返回一个函数 const store = new Vuex.Store({ state: { counter: 10, }, getters: { doubleCounter(state) { return state.counter * state.counter; }, doubleCountermore(state, getters) { return getters.doubleCounter + 1; }, add(state, getters) { return num => { return getters.doubleCountermore + num } } }, }) &lt;h2>{{ $store.getters.doubleCounter }}&lt;/h2> &lt;h2>{{ $store.getters.add(10) }}&lt;/h2> 在子组件使用getters时，还可以使用：mapGetters 辅助函数，它仅仅是将 store 中的 getter 映射到局部计算属性： 此时，我们便可以在子组件直接使用该数据：&lt;div&gt;&lt;/div&gt; import { mapGetters } from 'vuex' export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doubleCounter', 'doubleCountermore', 'add', // ... ]) } } 当然，除此之外，还有辅助函数 mapState、mapAction等 Action基本使用 Action类似于Mutation，但是是用来替代Mutation进行异步操作的（其实也可以来替代一些功能复杂的操作） 和Getter、Mutation不同，默认传入的参数不是state，而是 context：上下文，在下面的例子里，可以把context理解成store对象 但是也不支持在action里直接修改state，即不支持 context.state.info.name = ‘Mikasa’ 详情关系图可以看Vuex状态管理图，在action使用commit进行提交 -&gt; mutation 第二个参数可选，为传入的对象payload，类似mutation的payload 在组件中调用action的异步方法，使用 this.$store.dispatch(&quot;方法名&quot;[, 传入参数]); const store = new Vuex.Store({ state: { counter: 10, info: { name: 'Allen', age: 18, feature: '始祖巨人' } }, mutations: { update(state) { Vue.set(state.info, 'address', '帕拉迪亚岛') } }, actions: { aupdate(context, payload) { setTimeout(() => { context.commit('update'); console.log(payload); }, 1000); } }, }) //Vue对象的methods属性里 update() { this.$store.dispatch(\"aupdate\", \"我是payload\"); }, 使用Actions时可以返回一个Promise 当然，碰到了异步操作，且想要确认异步操作是否完成，少不了Promise的优雅加成： actions: { aupdate(context, payload) { return new Promise((resolve, reject) => { setTimeout(() => { context.commit('update'); console.log(payload); resolve(); }, 1000); }) } }, update() { this.$store .dispatch(\"aupdate\", \"我是payload\") .then(() => { console.log(\"执行成功！\"); }) .catch(() => { console.log(\"执行失败\"); }); }, 同样的，在子组件使用Actions时，也可以使用：mapActions 辅助函数，将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：（此时用 this.方法名即可调用） import { mapActions } from 'vuex' export default { // ... methods: { ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) } } Module基本使用 store推荐state单一状态树、但是state里包含太多数据会显得十分臃肿 为此，Vuex允许我们讲store分割成模块（Module），每个模块拥有自己的state、mutation等 const store = new Vuex.Store({ modules: { a: { state: {}, mutations: {}, actions: {}, getters:{} }, b: { state: {}, mutations: {}, actions: {}, getters:{} } } }) 或者在store的外部定义 module对象，然后直接在store的modules里面引用就可以了 const moduleA = { state:{}, mutations:{} } const store = new Vuex.Store({ modules: { a:moduleA } }) 在组件中使用模块的state数据： $store.state.模块名称.状态 &lt;h2>{{$store.state.a.name}}&lt;/h2> 组件中使用模块的mutation则使用方法和原来放在store里一样，在组件中直接this.$store.commit(事件类型)就可以了 getters也是也原来放在store里一样去使用，但是如果模块的getter想要使用到原来的store中的state，则此时模块的getter可以传入三个参数，分别是： 自身的state getters store的state const moduleA = { state: { name: 'Armin' }, getters: { fullname(state, getters, rootState) { return state.name + rootState.counter } } } 4.它的actions中 context.commit(&#39;函数&#39;); ，函数只能是模块中mutations里面的函数 Mutations基本使用mutations作为Vuex的一个属性，但是包含的东西比较多，就单独拉出一个篇章来讲 官方认可：Vuex的store状态的更新唯一方式：提交Mutation mutations里每个方法完成的事件尽量单一（也就是一个方法，不要有对于state的多种修改功能），方便跟踪Devtools的跟踪，可以选择放在Actions里，然后Action里的函数commit到不同的mutation函数对state修改 Mutation主要包括两部分： 字符串的事件类型 一个回调函数，该回调函数的第一个参数就是state 比如上述 使用 部分的例子中（代码放在了下方），increment为事件类型，(state) {state.counter++;}为回调函数 increment(state) { state.counter++; } 然后在组件中通过mutation更新进行使用 this.$store.commit(事件类型) mutations传参问题： 里面的函数默认可以传入state作为参数，第一个参数为state 第二个参数为外部传进来的参数（如果要传递多个参数，则我们可以以对象的形式进行传递），它有个专业名词叫 payload：载荷 const store = new Vuex.Store({ mutations: { increment(state) { state.counter++; }, incrementCount(state, num) { state.counter += num; } }, //组件的methods methods: { add() { this.$store.commit(\"increment\"); }, addCount(num) { this.$store.commit(\"incrementCount\", num); }, }, mutations提交风格 除了上述的commit提交方式，Vue还提供了另外一种风格，它是包含type属性的对象，而传入的参数即使并不需要传递多个，但也需要（自动）变成一个对象 this.$store.commit({ type: \"incrementCount\", // 这时传过来的num变成一个对象 num: num, }); 此时mutation传入的是对象，所以也要发生相应改变 mutations: { incrementCount(state, payload) { state.counter += payload.num; } }, Mutations常量类型 定义常量是减少错误的基本方法 在store文件夹里定义一个js文件，比如 mutation-type.js 用于存储常量名，然后在其他文件里用 import导入，用常量名以 [常量名]的形式 替代mutations里的函数名，然后引用mutation函数的时候，继续先import导入存储常量名的js文件，直接引用 this.$store.commit(常量名); 就可以了 虽然过程十分繁琐，但有利于项目开发后的维护找错 Mutation同步函数 通常情况下，Vuex要求我们Mutation中方法必须是同步方法 主要原因是我们使用devtools时，devtools可以帮助我们捕捉mutation的快照 但如果是异步操作，那devtools将不能很好的追踪到这个操作什么时候会被完成 Vuex响应式原理Vuex的store中的state是响应式的 state其中每个状态都有对应的 Dep -&gt; [Watcher]，监听变化 包括状态里对象的每个属性的变化 但这要求我们必须遵守Vuex对应的一些规则： 提前在store初始化所需的属性 当给state对象添加新属性时，使用下列方式： 方式一：使用Vue.set(obj, &#39;newProp&#39;, 123) 方式二：用新对象给旧对象重新赋值 这里和数组的响应原理一样，有一些数组方法也不是响应的，需要借助其他方法来进行响应处理（如 this.arr[0] = &#39;nothing&#39;; ） 删除属性的方式也相应改成使用 Vue.delete(obj, &#39;newProp&#39;) 7.网络封装选择一：传统的Ajax基于XMLHttpRequest（XHR），但是配置和调用比较混乱、编码也甚是麻烦，所以真是开发很少直接使用，而是使用jQuery-Ajax 选择二：jQuery-Ajax，但是Vue开发里面已经不再需要jQuery，没必要为了使用其中jQuery部分功能去引用整个jQuery框架 选择三：Vue1.x的时候，官方推出Vue-resource，但是在Vue2.0推出后，Vue作者已经就将其去掉了，不再进行更新 选择四：Vue作者推荐：axios axios请求方式： axios(config) axios.get(config) axios.post(config) axios.request(config) 等等 安装axiosnpm i axios --save 导入 import axios from 'axios' 使用 在Ajax篇章中已经有描述","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"git基本命令符","slug":"git基本命令符","date":"2021-02-28T16:00:00.000Z","updated":"2021-08-22T11:34:51.216Z","comments":true,"path":"2021/03/01/git-ji-ben-ming-ling-fu/","link":"","permalink":"https://taylor12138.github.io/2021/03/01/git-ji-ben-ming-ling-fu/","excerpt":"","text":"版本控制它是一种软件开发过程中，管理我们对文件、目录、或工程等内容的修改历史、方便我们查看更改历史记录，备份以便恢复以前的版本软件工程技术。简单来说就是用于管理多人协同开发项目的技术 SVN：集中式版本控制、所有版本存在服务器上，需要连网才能看到历史版本，服务器坏了可能导致数据丢失。工作时我们首先需要从中央服务器的到最新版本 Git：分布式版本控制，每个人都拥有全部的代码（可能有安全隐患），这样就可以在本地查看历史版本，可以离线在本地提交，只需练网时push到相应服务器即可。协同方式：A修改了代码、B也修改了代码，这时只需要你们两人之间把各自修改的代码推送给对方，即可看到对方修改 Git是目前（2021年）世界上最先进的分布式版本控制系统 Git启动Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多 Git CMD：Windows风格命令行 Git GUI：图形界面，不建议初学者使用 Git基本命令符config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system -&gt; global -&gt; local 底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件 查看系统config git config --system --list 查看当前用户（global）配置 git config --global --list 安装Git后必须执行的(不然提交不了项目)：设置用户名和邮箱 git config --global user.name \"taylor12138\" git config --global user.email \"277421392@qq.com\" 查看当前仓库配置信息 git config --local--list 基本理论Git本地有三个工作区域： 工作目录（Working Directory）：平时存放项目代码的地方（主要跟我们挂钩的两个区域之一） 暂存区（Stage/Index）：临时存放改动，事实上只是一个文件 资源库（Respository/Git Directory）：安全存放数据的位置，这里有提交到所有版本的数据 再加上远程仓库（Remote Directory）：托管代码的服务器（主要跟我们挂钩的两个区域之一） 忽略文件有时我们不想把某些文件也一并上传，比如前端项目中的 npm_modules 可以在 .gitignore文件下添加忽略的文件 *.txt #忽略所有.txt结尾的文件 !lib.txt #将lib.txt除外（不被忽略） /temp #仅忽略根目录下的TODO文件，不包括其他目录的temp文件 build/ #忽略build/目录下的所有文件 doc/*.txt #忽略doc/notes.txt但不包括doc/server/arch.txt github建立连接的方法方法1：在GitHub网站上新建仓库 然后拷贝仓库的地址，进行克隆下载到本地 把自己原来项目除了git文件的所有文件拷贝进下载的文件夹里（克隆下载的文件本身自带.git文件） 利用工具 进入新的文件夹 可以查看状态：（可以查看文件是否被跟踪） git status 一般git上传只需要 1 放入暂存区 git add . 2 提交到git本地仓库， -m是提交信息 git commit -m '描述' 比如：git commit -m &#39;feat(buyvip): 补充埋点路径参数&#39; 提交规范： 3 推送到远程 git push 方法2：将本地项目直接push，不用拷贝 创建一个全空的仓库 然后该项目有提示：git remote add orgin https://github.com/xxxxxxxx.git的指令 和 git push -u origin master指令 在项目的终端执行 Git分支git branch #查看所有分支 git branch -r #查看远程分支 git branch dev #新建dev分支，但是现在仍停留在原分支 git branch -d dev #删除dev分支 git merge [branch] #合并指定分支到当前分支 如果多个分支并行执行，会导致代码并不冲突，也就是同时存在多个版本 一般来说master主分支非常稳定，用来发布新版本，工作一般在新建的dev分支上工作，等待dev分支稳定后才可合并到master主分支上 切换分支 git checkout “对应分支” git checkout - #切换到上一个分支 git checkout -b 命名(feat/v1.21) #新建分支feat/v1.21 此时我们可以push到新建的分支 git push --set-upstream origin feat/v1.21 Git提交错误Connection was reset in connection to github.com:443 解决方法： 1. git config --global http.sslVerify false 结果：失败 2. git config --global --unset http.proxy 结果：失败 3.cmd命令执行（可能是因为使用过vpn或者代理，关机时忘记关了。） ipconfig/flushdns 结果：失败 4.更改本地hosts文件，添加github的ip地址 结果：失败 5.：输入命令 git config --global http.proxy 127.0.0.1:7890 为全局的 git 项目都设置代理 git config --local http.proxy 127.0.0.1:7890 为某个 git 项目单独设置代理 结果：成功","categories":[],"tags":[],"author":"Hello"},{"title":"webpack","slug":"webpack","date":"2021-02-06T16:00:00.000Z","updated":"2021-08-22T15:58:12.294Z","comments":true,"path":"2021/02/07/webpack/","link":"","permalink":"https://taylor12138.github.io/2021/02/07/webpack/","excerpt":"","text":"1.Webpack概述webpack是一个现代的JavaScript应用的静态模块打包工具（依赖于node环境） 它可以帮你把AMD、CMD、CommonJS、ES6的一些模块化编写方式，转化为— &gt; 浏览器可以识别的模块化方案 而且不仅仅JS文件，CSS文件、图片文件等在Webpack也会被当成模块来使用 打包后生成一个文件夹，在服务器进行部署即可 首先推荐一个wepack入门 https://segmentfault.com/a/1190000006178770 起步新建两个文件夹，src放置开发的源码，dist放置之后打包的文件 方法一：webpack在打包的时候，会查看你有没有依赖其他文件，所以给一个入口文件(main.js或者index.js)就好了 webpack 入口文件.js ..\\dist\\打包后文件名.js 这时在html文件内用script引用打包后的js文件即可 方法二：新建一个 webpack.config.js，配置入口 entry和出口 output，output推荐用对象的形式来写 const path = require('path'); module.exports = { entry: './src/main.js', output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js' //打包后的文件名 } } 由于要依赖node的核心模块path以动态获得output的绝对路径，这里先进行npm初始化，得到package.json包， 这时在命令窗口直接输入 webpack 或者用映射来运行：（更推荐，因为它会优先在本地找依赖包，而不是全局找依赖包，全局依赖包可能因为版本原因导致代码报错） 在package.json文件中的 script 配置 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack\" }, 然后再命令窗口输入 npm run build 对比grunt和gule三者都是前端构建工具，grunt和gulp在早期比较流行，而webpack是现在的主流。 grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。 webpack基于入口，webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。 2.Loader(前言：你已经是一个成熟的webpack了，应该学会自己安装loader！！！) webpack主要用来处理我们js代码，进行模块化开发，并且自动处理js之间的依赖关系 但是在开发中，我们不仅仅有基本的js代码需要处理，也需要加载css、图片，包括一些高级的将ES6转化为ES5代码，或者TypeScript转化为ES5代码，将scss、less转化为css，css兼容低版本的等等 对于webpack本身能力来说，对于这些转化是不支持的，这时我们需要用到loader。 1.通过npm安装需要使用的loader 2.在webpack.config.js的module关键字下进行配置（根据官网给的配置信息填充就可以了） 处理CSS文件这里举一个CSS文件打包的例子，需要配置 style-loader （负责将导出的样式添加到DOM）和 css-loader（负责加载并解析import的CSS文件） 在 入口的js文件 里添加 指定的css文件，这时候打包使用webpack进行打包就会连同css文件也打包进去了 //依赖CSS文件 require('./css/normal.css') 兼容低版本浏览器，css还可以使用postcss-loader npm i -D postcss postcss-loader postcss-preset-env 处理图片在使用到图片的场景时，又需要对应的图片url-loader 关于url的loader中配置的option选项有一个limit 可以进行设置： limit: 8192, 当加载的图片小于这个limit时，会将图片编译成base64字符串形式 若大于limit，则还需要安装一个loader，即file-loader模块进行加载，从入口js文件打包会得到一张随机命名（32位的哈希值）的图片于dist文件夹中。（安装后并不需要配置file-loader） （如果index.html（想要加载到的页面）在dist文件外面，这时就还需要在webpack的配置文件里的output中，添加publicPath:&#39;dist/&#39;，这样以后涉及到url的路径，都会自动添加上 &#39;dist/&#39;；但是如果安装了HtmlWebpackPlugin插件之后，html文件将在dist文件夹中自动生成，此操作则要废弃） 但是真实开发中对打包的图片命名有一定要求，我们可以在url-loader的配置option里面，增加其他属性 options: { limit: 8192, // 按照这个规范进行命名 name: 'img/[name].[hash:8].[ext]', }, 处理ES6语法如果希望将ES6语法转化成ES5语法，我们可以使用babel对应的loader，配置打包得到新的js文件 npm install -D babel-loader @babel/core @babel/preset-env webpack @babel/core babel的核心工具 @babel/preset-env babel的预定义环境 @babel-loader babel在webpack中的加载器 其实还可以装一个core-js，core-js用来使老版本的浏览器支持新版ES语法（比如老版本没有Promise，它会给你引进去coreJs库里的Promise函数），然后按需加载可以使用到的 core-js 部分 配置： const path = require('path') module.exports = { entry: \"./src/index.ts\", output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js' }, module: { // 指定加载规则 rules: [ { //这里使用TypeScript test: /\\.ts$/,// test指定规则生效的文件,以ts结尾的图片 use: [ { loader: \"babel-loader\", options: { presets: [ [ '@babel/preset-env', { // 要兼容的目标浏览器 targets: { \"chrome\": \"58\", \"ie\": \"8\" }, // corejs版本 \"corejs\": \"3\", // 使用corejs的方式，按需加载 \"useBuiltIns\": \"usage\" } ] ] } }, // 如果使用typescript的loader，要把ts-lodaer放下方，babel-loader放上方 // webpack从后往前执行，所以必须要先执行ts -> Js转换，再执行js兼容性的转换 'ts-loader' ], exclude: /node_modules/ } ] }, } 处理Vue引入Vue.js 首先在项目中使用Vue.js，需要先通过npm安装Vue npm install vue --save 但是，vue在最终构建发布版本时，会构建两类版本，分别是 runtime-only 代码中不能有任何的template runtime-compiler 代码中可以有template。（此版本需要在webpack.config.js中配置信息，此时在module配置项的下方添加：） resolve: { // 别名,让vue结尾的指向一个具体的文件夹的文件 // 默认指向'vue/dist/vue.runtime.js' alias: { 'vue$': 'vue/dist/vue.esm.js' } } 如果想要通过vue文件分离组件和主要的main.js文件时，会是使用到vue文件 这时需要安装 vue-loader（负责加载） 和 vue-template-compiler（负责编译） 老样子在module的 rules 添加配置信息 test: /\\.vue$/, use: ['vue-loader'] 但是Vue Loader v15 现在需要配合一个 webpack 插件才能正确使用： // webpack.config.js const VueLoaderPlugin = require('vue-loader/lib/plugin') module.exports = { // ... plugins: [ new VueLoaderPlugin() ] } 除此之外，常用的Loader还有 eslint-loader：通过 ESLint 检查 JavaScript 代码 3.pluginplugin是插件的意思，通常用于对某个现有架构进行扩展 使用： 1.通过npm安装需要的插件（但是有些插件webpack已经内置了） 2.然后在webpack.config.js中的plugins进行配置 下面举一个加入版权的插件的例子 // webpack.config.js const webpack = require('webpack'); module.exports = { // ... plugins: [ new webpack.BannerPlugin('最终版权归Hello所有') ] } HtmlWebpackPlugin真是发布项目时，发布的是dist文件夹中的内容，但是打包的时候并没有将html文件也打包进dist文件夹中， 此时我们需要用到HtmlWebpackPlugin插件，它会自动生成一个index.html文件（可以按照指定模板来生成），并且将打包后的js文件，自动通过script标签插入到body中 1.安装插件 npm install html-webpack-plugin --save-dev 2.使用插件，在webpack.config.js中使配置信息 // webpack.config.js const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { // ... plugins: [ new HtmlWebpackPlugin() ] } 此时生成的html文件的body内还没有根元素绑定Vue，我们可以给个模板，模板里有我们理想的存放好的标签，让它根据模板生成该 div元素 new HtmlWebpackPlugin({ // 寻找当前目录下的index.html, 根据这个生成模板 template: 'index.html' }) js压缩的plugin压缩js代码空间（丑化）安装：这里我是用的 uglifyjs-webpack-plugin版本时1.1.1，和CLI2保持一致 npm install uglifyjs-webpack-plugin@1.1.1 --save-dev module.exports = { // ... plugins: [ new UglifyJsPlugin() ] } 除此之外，还有其他比较有用的压缩插件 extract-text-webpack-plugin 用于将 CSS 从主应用程序中分离 optimize-css-assets-webpack-plugin 压缩提取出的css，解决extract-text-webpack-plugin CSS重复问题 CommonsChunkPlugin 将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用 覆盖pluginnpm i -D clean-webpack-plugin 每一次打包后，会先清除原来dist目录下之前打包好的文件，保证dist里打包的文件是最新的 配置webpack.config.js const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin() ] } 4.其他Loader和Pluginloader类似于一个转换器，plugin相对webpack本身的拓展，类似于一个拓展器 不同的作用 Loader可以实现让Webpack加载和解析除了JavaScript以外的能力。 Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。 webpack搭建服务为了让webpack提供开发时服务，可以装载webpack-dev-server搭建本地服务器（脚手架2里使用的版本为2.9.3，所以这里我安装2.9.3），它内部使用了express框架 实际上Vue、React脚手架搭建完毕后，呈现的页面都用到了这个本地服务器 npm install webpack-dev-server@2.9.3 --save-dev 在webpack.config.js里配置 var path = require('path'); module.exports = { //... devServer: { contentBase: path.join(__dirname, 'dist'), // inline是否实时监听 inline:true, compress: true, port: 9000 } }; 此时还可以和起步配置 npm run build 一样顺便在package.json文件的script中增加 &quot;dev&quot;:&quot;webpack-dev-server&quot; 这时候运行起来就直接 npm run dev即可 配置文件分离开发时依赖的配置文件和发布时依赖的配置文件进行分离 新建一个build文件夹 -&gt; 新建一个 base.config.js文件 (公共的配置放在base里) 、prod.config.js文件（放置生产时的配置）和dev.config.js（放置开发时的配置） 这里还需要安装 npm i webpack-merge@4.1.5 --save-dev 然后分别在prod.config.js文件 和dev.config.js 写好各自的配置 const webpackMerge = require('webpack-merge'); const baseConfig = require('./base.config'); // 合并导出 module.exports = webpackMerge(baseConfig, { //各自配置 }); 最后在package.json配置文件中，修改 原来运行webpack 和 运行webpack服务器的 键位 改为 ： \"build\": \"webpack --config ./build/prod.config.js\", \"dev\": \"webpack-dev-server --config ./build/dev.config.js\" 这里如果打包后文件出现不是在原来的目录，可以检查一下base.config.js文件的 output出口，进行修改 5.关于webpackWebpack缩小体积原理将多个模块依赖，转变成单个静态资源（js、css、jpg、png） 打包，是指处理某些文件并将其输出为其他文件的能力。 entry: 编译入口 module: 模块，在 webpack 中，一切皆为模块，一个模块对应一个文件 Chunk: 代码块，一个 chunk 由多个模块组合而成，用于代码的合并与分割 Loader: 模块转换器，将非js模块转化为webpack能识别的js模块 Plugin: 扩展插件，在webpack运行的各个阶段，都会广播出去相对应的事件，插件可以监听到这些事件的发生，在特定的时机做相对应的事情 项目中使用的每个文件都是一个模块，在打包过程中，模块（module）会被合并成 chunk，chunk 合并成 chunk 组，并形成一个通过模块互相连接的图(ModuleGraph)。 那么如何通过以上来描述一个入口起点：在其内部，会创建一个只有一个 chunk 的 chunk 组。 所以chunk有两种形式 initial(初始化) 是入口起点的 main chunk。此 chunk 包含为入口起点指定的所有模块及其依赖项。 non-initial 是可以延迟加载的块。可能会出现在使用 动态导入(dynamic imports) 或者 SplitChunksPlugin 时。 然后loader是文件转换器（将webpack不能处理的模块转换成能处理的模块，也就是js模块）、plugin是功能拓展 Webpack构建流程初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数初始化 Compiler 对象（实例化），加载所有配置的插件，执行 compiler.run 开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理（对每个模块所依赖的对象进行收集。）； 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 为什么使用webpack在浏览器中运行 JavaScript 有两种方法。 第一种方式，引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈。 第二种方式，使用一个包含所有项目代码的大型 .js 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。 webpack运行在 Node.js中，npm + Node.js + modules实现大规模分发模块 + 依赖自动收集 6.webpack热更新热更新是：使得应用在运行状态下，不重载刷新就能更新、增加、移除模块的机制（有点像node的nodemon功能） 用通俗的话来说，就是修改代码以后，不刷新就可以查看到页面更改后变化的效果，提升了开发效率 开启热更新： 使用 HotModuleReplacementPlugin 插件 打开 webpack-dev-server 的热更新开关 // webpack.config.js module.exports = { // ... plugins: [ webpack.HotModuleReplacementPlugin(), //使用插件 // ... ] devServer: { hot: true, //开启开关 // ... } } 实现热更新 图片来自饿了么前端@知乎专栏 第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。 第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。 第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。 第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。 webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。 HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。 而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。 最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。 小笑话 部分资料参考地址https://juejin.cn/post/6844903877771264013","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Vue(上)","slug":"Vue(上)","date":"2021-01-31T16:00:00.000Z","updated":"2021-08-22T15:57:06.083Z","comments":true,"path":"2021/02/01/vue-shang/","link":"","permalink":"https://taylor12138.github.io/2021/02/01/vue-shang/","excerpt":"","text":"1.邂逅VUEvue是一个渐进式框架，这意味着可以作为你应用的一部分嵌入其中，对项目一点点进行重构，响应式：界面随着数据随时发生改变 以前JS原始编写的方法：命令式编程； Vue编写方法：声明式编程 vue全家桶：Core + Vue-router + Vuex Vue特点： 解耦视图和数据 可复用组件 前端路由技术 状态管理 虚拟DOM 引入vue $ npm install vue 体验： &lt;div id=\"app\"> &lt;ul> &lt;li v-for='item in message'>{{item}}&lt;/li> &lt;/ul> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { message: ['i', 'wanna', 'be', 'with', 'you'] } }) &lt;/script> Vue的MVVMMVVM 模式，顾名思义即 Model-View-ViewModel 模式，最标志性的特性就是 数据绑定 ，操作数据 = 操作视图，操作DOM Model 层: 仅仅关注数据本身，对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步 View 层:作为视图模板存在， 数据绑定的声明、 指令的声明、 事件绑定的声明。 ViewModel 层（vue）:把 View 需要的数据暴露，并为 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责 MVVM是MVC的改进版，MVC中的M就是单纯的从网络获取回来的数据模型，V指的我们的视图界面，而C就是我们的ViewController。 MVC的通信方式时单向的，view -&gt; controller -&gt; model -&gt; view 控制器（Controller）- 控制器是模型和视图之间的纽带，接收View传来的用户事件并且传递给Model，同时利用从Model传来的最新模型控制更新View. ViewModel充当了一个UI适配器的角色，也就是说View中每个UI元素都应该在ViewModel找到与之对应的属性。除此之外，从Controller抽离出来的与UI有关的逻辑都放在了ViewModel中，这样就减轻了Controller的负担。 MVC缺点： 不适合小、中型项目 增加结构、实现复杂性 视图（view）和控制器（controller）过于紧密的连接 视图（view）对模式数据的低效访问 一般的高级界面工具或构造器不支持该模式 2.基础语法Vue对象传入的option： el：决定Vue对象挂载在哪个元素上 data：存储数据，类型为对象或者函数 methods: 用于在Vue对象中定义方法 在官网中还有一些其他的option 在开发中在对象/类里面定义的叫方法（method），独立出来作用全局的称为函数（function） 双括号语法被称之为mustache语法，八字胡 &lt;!-- item和message分别为data中的字符串 --> &lt;li>{{item + '' + message}}，hello&lt;/li> &lt;!-- counter为data中的数字 --> &lt;li>{{counter * 2}}&lt;/li> &lt;!-- 得到getNumber函数返回值 --> &lt;li>{{getNumber()}}&lt;/li> Vue的生命周期在创建Vue对象的时候，内部会一步一步做出一系列复杂的事情/操作，而在做每一系列事情的过程当中，如果中间穿插 created、mounted、updated、destroyed等生命周期钩子函数它会指示你（它会内部自动执行，不需要手动调用），目前做到事情的哪一步。 这样我们才能更好地依照某种顺序（等待某一步的完成），去完成另外一件 “需要上一步已达成” 这个条件下执行的事件 生命周期就是一个对象（如vue)从声明到使用到销毁的各个阶段，为了开发方便框架会在每个阶段的节点上定义一个特定函数，这个特定函数就是生命周期函数，也叫钩子函数 官网附有生命周期示意图 父子组件生命周期 父 beforeCreate - &gt; 父 created -&gt;父 beforeMount -&gt;子 beforeCreate-&gt; 子 created-&gt; 子 beforeMount-&gt; 子 mounted-&gt; 父 mounted 父组件更新：父 beforeUpdate-&gt; 父 updated 子组件更新：父 beforeUpdate-&gt;子beforeUpdate -&gt; 子 updated -&gt;父updated 组件的调用 先父后子，渲染完成顺序先子后父 组件销毁 先父后子，销毁完成 先子后父 V-指令v-once 只会在第一次渲染数据，随后数据发生改变，元素内的数据不会再发生改变，阻止了响应式，可以添加在标签属性上 &lt;h2 v-once>{{message}}&lt;/h2> v-html 类似于JS原生里的innerHTML，可以添加在标签属性上 &lt;h2 v-html=\"数据名称\">&lt;/h2> v-pre 进行原封不动的解析，可以添加在标签属性上 &lt;!-- 页面得到结果{{message}} --> &lt;h2 v-pre>{{message}}&lt;/h2>` v-cloak 为了防止用户加载页面时，加载JavaScript卡住，导致页面显示源码 ‘‘ ，添加 &lt;h2 v-cloak>{{message}}&lt;/h2> 等到Vue对该元素进行解析渲染，页面中才会显示该元素（原理应该是使用了display: none） v-bind 使用{{值}}可以将Vue的数据插入元素内容中，但是如果想让Vue的数据动态绑定元素标签属性中的值（比如img的src，a标签的href）,可以使用v-bind。v-bind还有一个对应的语法糖 :（简写方式），方式如下 &lt;a v-bind:href=\"bdurl\">baidu&lt;/a> &lt;a :href=\"bdurl\">baidu&lt;/a> 如果使用别人写好的组件，传入批量的props时（子组件中的props对象的每个属性都声明好了），直接写一个对象，然后 v-bind=&quot;对象名&quot;即可 与此同时v-bind也可以动态绑定class属性值，但是它动态绑定class属性的重大意义在于可以写入对象，以键-值的形式，通过布尔值修改，来动态修改元素是否使用该类（在标签上还可以再自定义添加上自带的class，不参与动态绑定变化） 其实动态绑定class还可以采用数组语法，只不过目前用的比较少了 &lt;div id=\"app\"> &lt;ul> &lt;li v-for=\"(item, index) in movies\" @click=\"colorch(index)\" :class=\"{active: index === iscolor}\">{{item}}&lt;/li> &lt;/ul> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { movies: ['batman', 'superman', 'spiderman'], iscolor: -1 }, methods: { colorch: function (index) { this.iscolor = index; } } }) v-bind还能动态绑定元素style样式的某个的单个属性，但是添加的时候注意，vue的语法中最好采用驼峰命名法，而且属性值外加单引号&#39;&#39; &lt;h2 :style=\"{fontSize: '100px'}\">{{message}}&lt;/h2> 注意，绑定属性名的时候，不能用驼峰命名法，可能html不能正确识别，如果要用的话，则属性名要发生改动：:topImages -&gt;改成-&gt; :top-images=&quot;xxx&quot; 在以对向形式绑定类名时，不能用 -，驼峰命名也不能奏效，可以使用 &lt;div :class=\" { 'tip': item.type === 3, 'my-msg': item.type === 1, 'other-msg': item.type === 2, }\" > computed计算属性Vue对象的option之一,当成属性去使用，不用加()进行函数调用，计算属性不像methods会被多次调用，它只会被调用一次（因此效率相对于methods更高），内部对计算属性做了缓存 &lt;div id=\"app\"> &lt;h2>{{fullname}}&lt;/h2> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { firstname: 'Lebron', lastname: 'James' }, computed: { fullname: function () { return this.firstname + ' ' + this.lastname; } } }) &lt;/script> 实际上计算属性一般只使用了它本身的get方法，而它的完整写法为： fullname: { set: function () { //一般情况下，我们不希望计算属性使用set方法,这样的话它就变成了一个只读属性 }, get:function() { return this.firstname + '' + this.lastname; } } Computed 默认调用的是get方法 不能传参，想要传递参数得用set设置好，再用get取 watch属性watch也是属于组件中的属性（和data，props，methods等并列），对应一个对象类型，里面存放函数方法，这些函数适用于监听某些data中属性的改变。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 函数命名方式：data中的属性名(改变后的值[, 改变前的值]){} watch:{ // 监听data中message的改变 message(){ console.log(\"hello\"); } //相当于message:function(){console.log(\"hello\")} } 除了传入函数外，其实watch里面传的是键值对，值除了函数还可以包含两个参数 immediate：组件加载立即触发回调函数执行， deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用（内部实际上是通过递归取值，然后进行逐个监听），而computed不需要deep，是因为它是从模板双括号取值，即使用JSON.stringfy()把对象的值一次性取出来 因为是递归，比较耗性能，尽量不要采用 watch: { message: { //使用deep、immediate参数时，对应的函数名必须为handler handler(newVal, oldVal) { console.log(oldVal) console.log(newVal) }, deep: true } }, computed和watch computed： 支持缓存，只有依赖数据发生改变时才会重新计算 不支持异步，当computed内有异步操作时无效，无法监听数据的变化 如果一个属性是由其他属性计算而来的，且一对一或者多对一，则一般用computed watch： 不支持缓存，数据变化则会直接触发相应操作 支持异步 监听的函数接收两个参数，第一个参数是最新的值（newValue）；第二个参数是输入之前的值（oldValue） 可以监听具体到数据的某个属性（对象） 缓存实现原理：new watcher -&gt; 这里有个dirty属性，默认为true - &gt; 求值计算，然后dirty = false -&gt; 当依赖数据再次发生改变时 dirty = true 事件监听v-on 绑定事件监听器，缩写（语法糖）为 @ ，类似于jQuery的 on 事件处理 &lt;button @click=\"increment\">+&lt;/button> &lt;button @click=\"decrement\">-&lt;/button> 正常情况下，函数如果需要传递参数，然而你没有传递，则函数形参为undefined v-on参数问题： 如果该方法不需要传递参数，则方法后面的()可以不用添加 但是如果方法本身是需要一个参数的，但是传进来的时候没有加 ()，（如@click=”decrement”），则Vue会将浏览器中生成的事件对象Event作为参数，传入方法中 方法定义时，我们需要event对象，同时又需要其他参数时，在html标签内的方法括号中只添加参数 + $event &lt;button @click=\"cclick(123, $event)\">call&lt;/button> methods: { cclick(number, event) { console.log(number, event); } } v-on修饰符 @事件名.stop阻止事件冒泡：相当于原生的e.stopPropagation() &lt;div @click=\"cclick\"> &lt;button @click.stop=\"cclick\">call&lt;/button> &lt;/div> @事件名.prevent阻止默认事件 =&gt; 相当于原生的 e.preventDefault(); @事件名.{keyCode | ketAlias} 从键盘特定键位触发回调（ @keyup.enter=&quot;xxx&quot; ） @事件名.native 监听根元素原生事件（在组件中使用） &lt;Compon_test @click=&quot;() =&gt; {}&quot;&gt;&lt;Compon_test&gt; =&gt; Compon_test.$on(&#39;click&#39;, () =&gt; {}) Compon_test.$emit(&#39;click&#39;) &lt;Compon_test @click.native=&quot;() =&gt; {}&quot;&gt;&lt;Compon_test&gt; =&gt; Compon_test.addEventListener @事件名.once 只触发一次回调 条件判断 + 循环遍历v-if=&quot;布尔值(或vue对象中存储的变量)&quot;来决定元素标签是否显示出来 v-if 可以搭配 v-else 来决定显示哪一些元素标签 &lt;h2 v-if=\"score>=90\">优秀&lt;/h2> &lt;h2 v-else-if=\"socre>=80\">良好&lt;/h2> &lt;h2 v-else-if=\"socre>=60\">及格&lt;/h2> &lt;h2 v-else>不及格&lt;/h2> v-show决定一个元素是否渲染出来（用法和 v-if相似），只是 v-show控制结点的display，而v-if是删除/创建节点 当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。 v-for遍历数组/对象 遍历过程额外获取数组索引值使用 v-for=&quot;(item, index) in 数组名&quot; 遍历过程额外获取对象属性名使用 v-for=&quot;(value, key) in info&quot; （如果只有value,，则遍历对象每个属性的属性值） 遍历过程额外获取对象属性名，数组索引值使用 &quot;(value, key, index) in info&quot; （如果只有value,，则遍历对象每个属性的属性值） &lt;ul> &lt;li v-for=\"item in strs\">{{item}}&lt;/li> &lt;li v-for=\"(item, index) in strs\">{{index}}.{{item}}&lt;/li> &lt;li v-for=\"value in info\">{{value}}&lt;/li> &lt;li v-for=\"(value, key) in info\">{{key}}:{{value}}&lt;/li> &lt;li v-for=\"(value, key, index) in info\">{{index}}.{{key}}:{{value}}&lt;/li> &lt;/ul> 官方推荐我们使用 v-for的时候，给元素或组件添加上 key属性（能更好的复用，提高增删时的性能，高效更新虚拟DOM），并且此时key属性绑定为item或者 item.id 比较好，能形成一一对应（也可以是item对象中的id）。这时候就可以唯一标识元素或组件，用diff算法正确识别节点，找到正确位置插入/删除节点。 如果key用index，是不可以的，因为index，即下标，会随着DOM元素的位置而改变，导致key = “index”，加了和没加一样！！ 如果item不是字符串、数字之类的，也不推荐使用 原因：没有key会像操作顺序表（或者数组）一样操作改变位置及之后所有数据，有key就会像链表一样断链后链接，只进行一次操作 &lt;li v-for=\"item in strs\" :key=\"item\">{{item}}&lt;/li> v-for and v-if 由于v-for的优先级是大于v-if的，当 v-for遍历出来后再每次都v-if进行判断比较消耗性能， 所以建议把v-if放在外层（比如直接放在template模板上） 哪些数组的方法是响应式的： 和对象不同的是，有些数组方法使用后Vue的页面不会及时响应 实际上这个响应式最好记的就是数组方法 看他是否真的改变原数组，而不是返回一个新数组（或者通过官方文档查看它是否为被包裹过的方法） // 1.push this.arr.push('David'); // 2.pop 删除数组中最后一个元素 this.arr.pop(); //3.shift 删除数组第一个元素 this.arr.shift(); //4.unshift 数组最前面添加元素 this.arr.unshift('David', 'Eason'); // 5.splice 用于删除多组元素且添加数据 // splice(开始位置, 删除个数, ...要添加的元素) this.arr.splice(1, 0, 'David'); // 6.sort this.arr.sort(); // 7.reverse this.arr.reverse(); 通过索引值修改数组元素并不会向页面及时响应结果： //修改对象用splice或者 Vue.set(修改对象, 索引值, 修改后的值) this.arr[0] = 'nothing'; 虚拟DOM渲染特殊案例这里在输入input数据之后，再点击切换按钮，会出现另外一个input框内仍保留之前输入的数据的情况 这是因为Vue在进行DOM渲染的时候，会先把所有元素标签通过一个虚拟DOM（virtual DOM）放到内存里，然后再渲染到浏览器上；所以出于性能考虑，会尽可能复用已经存在的元素，而不是创建新元素；复用的时候对比每个层级，把修改之后的套在原来的元素上（比如属性类型，属性id等） 在以下的案例中，Vue内部会发现原来的input元素不再使用，直接作为else中的input来使用（类似于让现任穿前任的衣服） 也就是说，在第一个input输入字符，然后“切换类型”，转为第二个input后，你依旧可以看到刚才输入的字符 解决方法：增加key属性，作为唯一的标识，key不同不进行复用 &lt;input type=&quot;text&quot; placeholder=&quot;用户名&quot; key=&quot;username&quot;&gt; &lt;div id=\"app\"> &lt;div v-if=\"loginType\"> &lt;label for=\"email\">用户邮箱&lt;/label> &lt;input type=\"text\" placeholder=\"用户邮箱\"> &lt;/div> &lt;div v-else> &lt;label for=\"nickname\">用户名&lt;/label> &lt;input type=\"text\" placeholder=\"用户名\"> &lt;/div> &lt;button @click=\"loginType=!loginType\">切换类型&lt;/button> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script> const app = new Vue({ el: '#app', data: { loginType: true } }); 过滤器filtersVue对象的option之一,当成属性去使用，调用需要在元素标签中添加 {{传入的参数 | 过滤器函数名}}可以把过滤器简单理解为一种格式化，比如时间，数字等等；它的实际效果和methods调用函数方法也差不多，只是编写样式更易懂、简洁 &lt;td>{{book.price | Price_str}}&lt;/td> 过滤器里面一般存函数，参数为过滤的数据 //toFixed为保留两位小数 filters: { Price_str(price) { return '$' + price.toFixed(2); } } V-modelv-model也常常被用来实现表单（input、checkbox、select）和数据的双向绑定 v-model如果用在普通div上，只能用来作数据绑定功能（无事件功能、实际上div不支持 v-model，但是组件就可以 ） &lt;input type=\"text\" v-model=\"message\"> {{message}} //在Vue对象中的data data: { message: 'nothing' } 利用 v-model实现单选框互绑 &lt;!-- 添加v-model之后，radio的input不需要加name属性来互斥radio（单选框） --> &lt;label for=\"male\"> &lt;input type=\"radio\" id=\"male\" value=\"male\" v-model=\"sex\">男♂ &lt;/label> &lt;label for=\"female\"> &lt;input type=\"radio\" id=\"female\" value=\"female\" v-model=\"sex\">女♀ &lt;/label> &lt;h2>你选择的性别是：{{sex}}&lt;/h2> v-model其实是是一个语法糖，两个指令的结合 v-bind绑定data数据 + v-on绑定input事件改变data数据 &lt;input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\"> &lt;h2> {{message}}&lt;/h2> v-model还有修饰符 lazy、number、trim &lt;!-- 修饰符lazy 使用之后使得input事件变得类似于change事件，等到用户输入完字符，敲回车/失去焦点才会修改数据 --> &lt;!-- &lt;input type=\"text\" @change=\"message = $event.target.value\"> --> &lt;input type=\"text\" v-model.lazy=\"message\"> &lt;!-- 修饰符number v-model默认给data赋值时，都是赋值为string类型，增加number修饰符可改变v-model赋值类型--> &lt;input type=\"number\" v-model.number=\"age\"> &lt;!-- 修饰符trim，v-model默认给data赋值时剥除两边空格 --> &lt;input type=\"number\" v-model.trim=\"name\"> 由于默认 v-model是 data数据 + input事件，我们可以在源码上自定义 v-model 自定义组件上使用 自定义 v-model ： &lt;el-checkbox v-model=\"check\">&lt;/el-checkbox> //全局注册组件 Vue.component('el-checkbox', { template:`&lt;input type=\"checkbox\" :checked=\"check\" @change=\"$emit('change', $event.target.checked)>\"` //model属性,服务于v-model model:{ prop:'check', //更改默认value名字 event:'change' //更改默认方法名,input事件改为change事件 }, props:{ check:Boolean } }) 原生标签上使用自定义 v-model const VueTemplateCompiler = require('vue-template-compiler'); const ele = VueTemplateCompiler.compiler('&lt;input v-model=\"value\"/>'); /** with(this) { return _c('input', { //_c createElement directives:[{ //directives是对输入框的配置 name:\"model\", rawName:\"v-model\" vale:(value), expression:\"value\" }], domProps:{ \"value\":(value) //这里value是默认，可以自定义为check }, on:{ \"input\":function($event) { //这里的默认input可以自定义为change if($event.target.composing) return; value = $event.target.value } } }) } **/ el和template同时有el和template，则将template里的模板，直接把el绑定的元素替换掉 3.组件化开发组件化开发思想即把页面拆分成一个个小的功能块，每个功能完成属于自己那部分的独立功能，分而治之 组件使用三个步骤 创建组件构造器 Vue.extend()，通常我们在创建组件构造器时会传入template作为自定义模板 注册组件 Vue.component(自定义组件标签名, 组件构造器对象) 注意：定义的标签必须小写 使用组件 必须在Vue的实例范围内使用组件，即使用该组件时，必须把标签放在Vue绑定的标签内 最终内部调用 $mount()进行挂载 &lt;div id=\"app\"> &lt;!-- 3.使用组件 --> &lt;!-- 比如这里绑定了id为app的块元素，则该自定义标签可以在该块内使用 --> &lt;my-cpn> &lt;/my-cpn> &lt;/div> &lt;script> // 1.创建组件构造器对象 const cpnConstructor = Vue.extend({ // 模板 template: `&lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div>` }); // 2.注册组件 // 严重注意：定义的标签必须小写 Vue.component('my-cpn', cpnConstructor); const app = new Vue({el: '#app'}); &lt;/script> 注意：在父组件中使用子组件不能使用 v-on 监听原生事件，必须添加 native修饰符，才能进行监听 获取组件内的元素，需要用到 $el，所有组件都有一个元素 $el 用于获取组件中的元素，比如获取 组件 的 offsetTop console.log(this.$refs.tabControl.$el.offsetTop;) 组件分类全局注册&amp;局部注册：上面的例子为注册全局组件，意味着可以再多个Vue实例下使用 以下的例子为局部注册组件（局部注册组件自定义标签名不支持 -） Vue对象中的components属性来注册局部组件,在开发过程用的最多的还是局部组件 const app = new Vue({ el: '#app', components: { //自定义组件标签名:组件构造器对象 my_cpn: cpnConstructor } }); 父组件和子组件 在组件构造器(组件二)中对另外一个组件(组件一)进行注册（components{}），这样的好处是可以在组件二模板里面,使用组件一,这样子就形成了父子组件的关系 父组件模板的所有东西都会在父级作用域进行编译，子组件模板的所有东西都会在子级作用域进行编译 注意: 在模板中，子组件的标签一定要写在父组件的DIV里面，因为定义模板时一般要有一个外层包裹的根元素（一般使用div） &lt;div id=\"app\"> &lt;cpn2>&lt;/cpn2> &lt;/div> &lt;script> //子组件,子组件要比父组件先创立 const cpnConstructor = Vue.extend({ template: ` &lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div> ` }); //父组件 const cpnConstructor2 = Vue.extend({ template: ` &lt;div> &lt;h2>模板2内容&lt;/h2> &lt;cpn1>&lt;/cpn1> &lt;/div> `, components: { cpn1: cpnConstructor } }); // root组件 const app = new Vue({ el: '#app', components: { cpn2: cpnConstructor2 } }); &lt;/script> 组件语法糖Vue为了简化组件使用的过程，提供了创建 + 注册合并的语法糖，直接适用对象替代extend步骤 //创建+注册全局组件语法糖 Vue.component('mycpn', { template: ` &lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div> ` }) //创建+注册局部组件语法糖 const app = new Vue({ el: '#app', components: { mycpn2: { template: ` &lt;div> &lt;h2>模板2内容&lt;/h2> &lt;/div> ` } } }); 组件模板的分离写法 为了使结构更加清晰，最好将html分离出来写，这里有两个组件模板分离的写法 1.script标签，注意类型必须是text/x-template（但是现在比较少使用了） 2.使用template标签 &lt;template id=\"cpn\"> &lt;div> &lt;h2>模板1内容&lt;/h2> &lt;/div> &lt;/template> &lt;script> Vue.component('mycpn', { template: '#cpn' }) &lt;/script> 组件的数据访问组件的data 组件内部不能直接访问Vue实例里的数据，包括data，methods等 组件是一个单独功能模块的封装，也有属于自己的data属性（其实可以把Vue实例也看成一个特殊的组件，组件在自己的标签里只能访问自己的data），当然也有自己的methods属性 但是！！：和Vue的data不同的是，组件自己的data必须用函数写（methods不用），然后再返回一个实例对象 组件中的data写成一个函数，数据以创立新一个对象的函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，（因为函数会创建自己的作用域）类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。（同一个组件标签名用的是同一个组件构造器对象） 而单纯的写成对象形式，就使得所有组件实例在使用的时候直接引用同一个对象，导致共用了一份data，就会造成一个改变，全都会发生改变的局面。 &lt;template id=\"cpn\"> &lt;div> &lt;h2>{{str}}&lt;/h2> &lt;/div> &lt;/template> &lt;script> Vue.component('mycpn', { template: '#cpn', data() { return { str: 'hello world' } } }) &lt;/script> 父子组件的通信 父组件传给子组件：子组件通过props方法接受数据; （外加 v-bind属性传值）Vue实例的data -&gt; 子组件的props数组中某个变量名进行接收，当作数据来使用，然后在渲染到template模板中（mustache语法） 子组件传给父组件：$emit方法（自定义事件）传递参数 在真实开发中，Vue实例和子组件的通信也可以当作父组件和子组件的通信来看 父组件传递给子组件实例： &lt;div id=\"app\"> &lt;mycpn :smovies=\"movies\" :smessage=\"message\">&lt;/mycpn> &lt;/div> &lt;template id=\"cpn\"> &lt;div> &lt;ul> &lt;li v-for=\"item in smovies\">{{item}}&lt;/li> &lt;/ul> &lt;h2>{{smessage}}&lt;/h2> &lt;/div> &lt;/template> &lt;script> // 父组件传子组件 props const app = new Vue({ el: '#app', data: { movies: ['ironman', 'batman', 'spiderman'], message: 'hello world' }, components: { mycpn: { template: '#cpn', props: ['smovies', 'smessage'] } } }); &lt;/script> 注意：props定义的属性名同样不要使用驼峰标识，因为HTML属性不支持大写（自定义组件名也是不要大写）（非要用大写则在html里时，将对应的大写前加 -，这样的话大写转小写） 对于通过props从父组件传递过来的值最好不要直接修改，而是在子组件的data创建数据，以传递过来的值对其进行赋值，然后想修改的手再在data的数据中修改 prop的赋值方式 // props: ['smovies', 'smessage'] // 这种对象写法还可以指定每个 prop 的值类型,甚至提供默认值,必传值,更常用 // 但是props里属性为对象或者数组时,默认值必须是一个函数 // props:{ // smovies:Array, // smessage:String // } props: { smovies: { type: Array, default() { return [] } }, smessage: { type: String, default: 'nothing', require: false // 使用该子组件的时候,是否必须要给这个smessage属性赋值 } } 子组件传父组件 流程： 1.子组件通过$emit()触发事件，子组件发送出去一个事件 this.$emit(事件名称, [传递参数]),是自定义事件 2.父组件通过 v-on监听子组件事件 &lt;!-- 父模板 --> &lt;div id=\"app\"> &lt;!-- 父组件需要使用事件监听 v-on 进行监听，然后自己在methods定义相对应的处理函数就可以了 --> &lt;!-- v-on不仅可以监听DOM事件，还可以监听组件之间的事件 --> &lt;mycpn v-on:Bigclick=\"FatherListener\">&lt;/mycpn> &lt;/div> &lt;!-- 子模版 --> &lt;template id=\"cpn\"> &lt;div> &lt;ul> &lt;li v-for=\"item in categories\" @click=\"itemclick(item)\">{{item.name}}&lt;/li> &lt;/ul> &lt;/div> &lt;/template> &lt;script> const app = new Vue({ el: '#app', components: { mycpn = { template: '#cpn', data() { return { categories: [ { id: 1, name: \"热门推荐\" }, { id: 1, name: \"手机数码\" }, { id: 1, name: \"家用家电\" }, { id: 1, name: \"电脑办公\" }, ] } }, methods: { itemclick(item) { this.$emit('Bigclick', item); } }, } }, methods: { //基本的事件默认传入event，但是子组件传来的事件，如果附带上参数，则如果父组件处理的函数自带传来的参数 FatherListener(item) { console.log(\"hello\", item); } } }); &lt;/script> 父子组件对象操作上面的组件数据访问我们已经提到了父子组件相互通信的方法（子组件传子组件信息给父组件，父组件传父组件的信息给子组件），但有时我们想直接访问组件（父组件获取子组件信息），而不是当子组件触发某个事件时，将子组件数据传给父组件再进行操作 父组件想要访问子组件：使用 $children 或者 $refs 子组件访问父组件：使用 $parent 父组件想要访问子组件： 但是真实开发中，我们不会通过$children去拿子组件对象进行操作，这是因为当使用$children[索引号]的方式拿取数据，当Vue绑定的标签内在中间新插入新子组件，会导致拿到的是新子组件的数据 所以用$refs比较多，无论Vue绑定的标签内是否有子组件，this.$ref 都默认为空 &lt;!-- 对应的html标签 --> &lt;div id=\"app\"> &lt;cpn> &lt;/cpn> &lt;cpn ref=\"cpn2\"> &lt;/cpn> &lt;button @click=\"btnClick\">打印子组件信息&lt;/button> &lt;/div> //子组件信息 cpn: { template: '#cpn', data() { return { name: 'Allen' } }, methods: { showMessage() { console.log('nothing'); } } } //Vue的mothods中的方法： btnClick() { // 1.$children // 调用Vue绑定的标签内第一个子组件的方法showMessage() this.$children[0].showMessage(); console.log(this.$children[0].name); // 2.$ref,在标签上加属性：ref=\"cpn2\",此时this.$ref不再为空 console.log(this.$refs.cpn2); } 使用前要注意：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。 ref如果绑定在组件中，那么通过 this.refs.ref绑定的名称获取到的是一个组件对象 ref如果绑定在元素中，那么通过 this.refs.ref绑定的名称获取到的是一个元素对象（此时ref的功能不是用于父组件获取子组件的数据，而是组件自己内部想要在某个地方获取到自己的某个标签（元素），这样有较高安全性，因为类名可能会重复，到时候项目开发时通过类名的获取，不一定能够准确获取目标） 子组件想要访问父组件：（开发中不建议用，因为引用了外部组件的数据，还是父组件的数据，这样会导致独立性、可复用性降低，有较大耦合性）$parent 如果想访问根组件数据用 $root //cpn的methods中： methods: { btn_click() { console.log(this.$parent); } } 插槽slot组件的插槽也是为了让封装的组件更具有扩展性（使用同一组件但能自定义特色风格） 在组件（模板）中增加 &lt;slot&gt;&lt;/slot&gt;，然后在html上使用组件时，往中间添加的标签/文字，都会放在template模板中slot标签内 推荐使用 div标签先将 slot包起来再使用 &lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;，可以避免很多bug &lt;!-- 组件cpn的模板中添加： --> &lt;div> &lt;h2>我是子组件&lt;/h2> &lt;p>这是子组件的段落&lt;/p> &lt;!-- 同时也可以定义一个默认值，这里没有传入则插槽内默认显示一个button --> &lt;slot>&lt;button>按钮&lt;/button>&lt;/slot> &lt;/div> &lt;!-- 使用插槽进行替换 --> &lt;cpn>&lt;button>其他&lt;/button> &lt;/cpn> 具名插槽 如果有多个插槽且想要替换掉指定的插槽，一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名字“default”。 注意 v-slot 只能添加在 &lt;template&gt; 上 &lt;!-- 组件cpn的模板中添加： --> &lt;div> &lt;slot name=\"left\">&lt;span>左边&lt;/span>&lt;/slot> &lt;slot name=\"mid\">&lt;span>中间&lt;/span>&lt;/slot> &lt;slot name=\"right\">&lt;span>右边&lt;/span>&lt;/slot> &lt;/div> &lt;!-- 如果是在&lt;template>上的话，可以使用新版的 v-slot了 --> &lt;!-- 替换掉name为mid的插槽--> &lt;cpn> &lt;template v-slot:mid> &lt;span>nothing&lt;/span> &lt;/template> &lt;/cpn> 旧版本的：&lt;div slot=&quot;插槽名&quot;&gt;首页&lt;/div&gt; 作用域插槽 大前提：父组件模板的所有东西都会在父级作用域进行编译，子组件模板的所有东西都会在子级作用域进行编译 当前需求：想办法在父组件的作用域拿到子组件的数据，然后再在父组件做一个插槽填充（这里不能使用$refs因为，还没渲染完毕，在初始渲染的时候你不能用$refs进行访问） 也就是说，普通插槽的渲染位置在父组件里面，将父组件渲染的结果直接替换到 slot中； 而作用域插槽的渲染位置是在子组件里面，所以这里就产生了作用域的不同 多个插槽写法：v-slot:插槽名=”数据调用方法名”， 首先在子组件模板中的 &lt;slot&gt;&lt;/slot&gt;查找中添加自定义属性，自定义属性=”想要绑定的数据名” &lt;!-- 子组件--> &lt;!-- 注意：:data属性名这里可以随便改自己喜欢的名字，但是必须要小写，v-slot的也是一样要注意小写 --> &lt;slot :data=\"pLanguages\"> &lt;ul> &lt;li v-for=\"item in pLanguages\">{{item}}&lt;/li> &lt;/ul> &lt;/slot> Vue里支持通过template，来拿到刚才的data属性，使用 v-slot:default=&quot;自定义插槽 prop 的对象&quot;（这里未定义插槽名，所以使用default）获取子组件通过属性传递过来的数据，然后通过 自定义插槽 prop 的对象.子组件自定义属性名调用子组件的数据 &lt;!-- 在html中使用组件 --> &lt;cpn> &lt;!-- &lt;span v-for=\"item in pLanguages\">{{item}}&lt;/span> 错误，不可以直接获取--> &lt;template v-slot:default=\"slot\"> &lt;span v-for=\"item in slot.data\">{{item}} - &lt;/span> &lt;/template> &lt;/cpn> JavaScript的模块化常见的模块化规范：CommonJS、AMD、CMD、ES6的Modules CommonJS可以在我的Node.js篇章里面了解 ES6模块化 ： export导出 import 导入 在 style 里导入使用 @import 首先将模块化的js文件引入时需要添加类型 module ：&lt;script src=&quot;js地址&quot; type=&quot;module&quot;&gt;&lt;/script&gt; 然后再所需模块内进行导出 / 导入（有模块代码自动进入严格模式） // 导出方式1 let name = 'allen'; export { name } // 导出方式2 export var num = 1000; export function sum() { } // 导出方式3,这种方法只能导出一个,使用一次default导出一个 export default adress 四种导入方法 // 1.导入单个num（要使用上面的导出方式2） import { num } from \"./aaa.js\"; console.log(num); // 2.导入默认的值（default），能够自己命名（要使用上面的导出方式3） import add from \"./aaa.js\"; console.log(add); // 3.统一全部导入（要使用上面的导出方式2） import * as aaa from \"./aaa\"; console.log(aaa.num); //1.下载后module的引用比较特殊 import Vue from 'vue' 为什么要使用异步组件如果组件功能多，打包的结果会变大，我们可以采用异步的方式来加载组件，主要依赖于 import 异步组件 （async component）一定是一个函数，新版本提供了对象的写法 components:{ AddCustomerSchedule:(resolve) => import(\"../components/AddCustomer\") } Vue.component('async-example', function (resolve, reject) { setTimeout(function () { // 向 `resolve` 回调传递组件定义 resolve({ template: '&lt;div>I am async!&lt;/div>' }) }, 1000) }) 4.Vue CLI在开发大型项目的时候，则必须使用到Vue CLI，CLI是Command-Line Interface ，翻译为命令行界面，俗称脚手架 使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置（终于不用自己配置webpack了！） Vue CLI 的使用前提：Node &amp; Webpack 安装脚手架（同时也自动装上vue）： npm install -g @vue/cli CLI 3+ 初始化 vue create my-project 但是我们这里也要使用cli 2 的功能所以还得 拉取 2.x模板 npm install -g @vue/cli-init CLI 2 初始化项目 vue init webpack my-project CLI 2 初始化vue init webpack 项目名称，这个项目名称为创建最终项目文件夹名 然后会出现选项： 然后得到一个文件，可以查看 package.json 文件里的 script，得知相应的运行命令；下面对存放在里面的每个文件进行介绍 build、config（配置基础变量）存放webpack的配置区域 src 放置源代码区域 static 放置静态资源的区域，原封不动复制到dist文件夹里 .babelrc 关于转化为ES5的相关配置 部分配置的介绍关闭ESLint代码规范（可能不符合部分代码风格，比如不加分号，定义函数时函数名后空一格等） config -&gt; index.js -&gt; useEslint: false Runtime-only 和 Runtime + Compiler的不同之处在main.js里面 //runtime compiler new Vue({ el: '#app', components: { App }, template: '&lt;App/>' }) //runtime-only //直接render，跳过template部分 new Vue({ el: '#app', render: h => h(App) }) Runtime-only在实际公司开发中使用的比较多，性能更好，代码更少（不用处理template和ast， 它的 .vue文件由 webpack用到的loader：vue-template-compiler 解析成render， 也就是render(App) -&gt; 组件App的 template 替换掉绑定的元素 ） 实际上，Vue实例的template -&gt; 会保存在option里 -&gt; 进行parse解析成抽象语法树（ast）（描述了我们标签的详情数据情况） -&gt; compile编译成 render函数 -&gt; 翻译成虚拟DOM（virtual DOM） -&gt; 渲染成UI 所以实际上compiler是处理 template部分和 ast部分 动态创建标签：createElement(&#39;标签&#39;, {标签属性}, [&#39;&#39;]), createElement(组件)也可以 //render函数的真身：(APP为组件对象) render: funciton(createElement) { return createElement(APP); } CLI 3与2版本有很大区别 基于webpack 4 打造 设计原则是“0配置”，移除根目录下的build、config 提供了vue ui 命令，提供了可视化配置，更加人性化 移除了static，新增了public，并且将index.html移动到public中，public类似于新的static 初始化后同样会出现初始化的配置选项 preset 预设：default是默认；manually select features是手动 feature特性：按空格选中/取消（Linter代码规范可以取消掉、Babel为支持es6以上语法 ） placing config配置的存放：config files 独立存放；package.json 放在package.json中 save prest：是否保存刚才配置好的预设 （如果想删除，则要找到.vuerc文件，进入后进行修改删除） CLI 3 的配置去哪里了？ -&gt; 启动配置服务器（可视化配置）： vue ui 导入当前项目脚手架的文件夹，然后可以在当前页面添加需要的插件，配置甚至运行等 如果真的要手动修改掉基础的配置，需要新建vue.config.js在当前项目目录下（原来build和Config文件的配置都放在node_modules里面了），在里面进行 module.exports = {}配置，到时会和原来的配置进行合并作为整体配置 module.exports = { devServer: { //运行后默认打开浏览器 open: true } } 脚手架的模块化样式当style标签具有该scoped属性时，其CSS将仅应用于当前组件的元素 我们通常在vue.config.js配置路径别名 module.exports = { devServer: { //运行后默认打开浏览器 open: true }, //publicPath为部署的配置 publicPath: process.env.NODE_ENV === 'production' ? './' : '/', configureWebpack: { resolve: { // 配置别名,内部其实已经配置过一个，就是 '@':src // 在cli3以上版本，配置别名的值可以引用之前配置过的别名，如'@/assets',不过cli4好像这里用不了。。 alias: { 'assets': '@/assets', 'components': '@/components', 'view': '@/view' } } } } 但是该别名 @ 在css中无法直接使用，需要变成 ~@的形式；还有 img 标签的 src中，也需要 ~@的形式","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Express","slug":"Express","date":"2021-01-30T16:00:00.000Z","updated":"2021-08-22T15:56:07.086Z","comments":true,"path":"2021/01/31/express/","link":"","permalink":"https://taylor12138.github.io/2021/01/31/express/","excerpt":"","text":"Express框架基于Node.js平台快速、开放、极简的Web开发框架，高度封装了http模块 （截至在2021/4/18，在GitHub上， express：52.7k star； koa：31k star； Hapi：13.2k star，express占领榜首，最高活跃度） 安装：用VScode打开文件目录，然后在该目录下右键-&gt;在集成终端打开-&gt;输入命令 npm init --yes 进行初始化，创建一个package.json文件-&gt; npm i express --save 安装框架 -&gt; 在js中输入 它！： 封装API，让开发者更关注于业务代码的开发 有一定的流程和标准 基本使用1.http.createServer() =&gt; express() 创建服务器 2.if (url.parse(req.url, true).pathname === 路径){} =&gt; app.get(路径, fn) 判断路径进行处理 3.app.use(&#39;public&#39;, express.static(&#39;./public/&#39;)); 处理公开目录，当以/public/开头的时候，去./public/目录中查找对应的资源，如 http://127.0.0.1:5208/public/404.html，直接进行访问（常用） 第一个参数其实是别名，app.use(&#39;a&#39;, express.static(&#39;./public/&#39;)); 处理公开目录，当以/a/开头的时候，去./public/目录中查找对应的资源，如 http://127.0.0.1:5208/a/404.html，直接进行访问 如果省略第一个参数：app.use(express.static(&#39;./public/&#39;))，则可以在原始网页网址+资源名称，如 http://127.0.0.1:5208/404.html，直接进行访问 4.url.parse(req.url, true).query=&gt; req.query 原来的get获取url ? 后的参数的方法的改变（只能拿get请求的参数） 模板对象：在Express中，模板引擎的使用有更好的方式res.render(‘文件名’, {模板对象})，可以自己尝试看art-template官方文档，让它们结合使用 5.express不需要 res.end()结尾来结束响应，而且它还提供了res.send(JSON.stringify(对象)) =&gt; res.json() 自动帮你把json对象转换成字符串，然后发送给浏览器 // 引包 var express = require('express'); // 创建服务器，相当于原来的http.createServer() var app = express(); //当服务器收到get请求 '/' 的时候，执行回调函数 // 不用再设置http头部文件，并且不用设置charset=utf-8:防止中文乱码，它会根据你的语言更改language //内置处理有不认识的路径时，自动发404 app.get('/', function (req, res) { res.send('Hello, world!'); }) app.get('/about', function (req, res) { //拿出get请求参数：在Express中可以直接通过req.query来获取查询字符串参数 //http://127.0.0.1:5208/about?a=1&amp;b=2 console.log(req.query); res.send('你好！！!'); }) // 公开指定目录（处理静态资源public那块） // 之后你就可以通过public的方式访问public目录的所有资源了 // 替代了原来判断路径+读文件+end结束的过程 app.use('/notebook/', express.static('./notebook/')); // 相当于server.listen app.listen(5208, () => { console.log('app is running at port!'); }) 然后继续右键在集成终端打开-&gt;输入命令 node 该js的文件名 这里的 app.get(&#39;/&#39;,(request, response) 中的 / 是路径（当然可以写成/路径名 之类的），当客户端浏览器向服务器发送请求时，如果url的路径，也就是请求行的第二部分，它的路径对应该路径的话，就会执行这个回调函数里面的 代码，并且由response做出响应 以上步骤来简单构建一个服务端，提供ajax使用 基本路由服务器中get和post部分相当于路由表，帮你映射关系： app .get('/login', callback) .get('xxx', callback) .post('yyyy', callback) 配置art-template模板引擎在官方文档可以看得到Express配合使用的安装导航：https://aui.github.io/art-template/ npm install --save art-template npm install --save express-art-template 注意：Express有个约定，把所有视图文件都放在views目录之中，如果想要修改，则app.set(&#39;views&#39;, render函数的默认路径) 然后 app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;)) 第一个参数表示当渲染以.art结尾的文件时，使用art-template模板引擎；express-art-template专门用在Express中把art-template整合，且express-art-template依赖了art-template 而这时就可以使用模板引擎的render了 app.engine('html', require('express-art-template')); app.get('/', (req, res) => { //去找views目录下的404.html res.render('404.html'); }) 接而根据导航一步一步指引，进行操作就行了 重定向注意：服务端重定向对异步请求是无效的（表单的异步提交），异步请求的重定向只能在客户端里面实现，可以在ajax的success里使用 window.location.href = '/' 原来是 res.statusCode = 302; res.setHeader('Location', '/'); //响应头的Loacation路径设置为 '/' 即首页 res.end(); 现在： res.redirect('/'); Express获取表单POST请求体数据当以post请求/post的时候，执行指定函数，获取数据的表单form添加 action=路径, method=&quot;POST&quot; 这样的话我们就可以利用不同的方法，让一个请求路径使用多次 app.post('/post', (req, res) => { // 1.获取表单post数据 // 2.处理 // 3.发送响应 }); 因为express内置没有获取表单post的api，所以需要借助第三方插件，在官网-&gt;资源-&gt;body-parser 注意：express4不再支持body-parser 如果仍想使用，可以npm install express@3 安装 npm install --save body-parser 然后跟着官网指示一步一步进行配置 配置body-parser，则会在request请求对象上多出一个body属性，然后此时我们可以使用req.body获取表单post请求体数据了 //引包 var bodyParser = require('body-parser'); //配置post插件body-parser // parse application/x-www-form-urlencoded app.use(bodyParser.urlencoded({ extended: false })); // parse application/json app.use(bodyParser.json()); app.post('/post', (req, res) => { // 1.获取表单post数据 // 2.处理 // 3.发送响应 console.log(req.body); //get使用的是req.query }); 定制404页面在挂载路由app.use(router);之后增加 app.use(function(req, res) =&gt; {})处理404页面，所有未处理的请求路径都会跑到这里 crud案例先初始化 npm init -y 装express：npm i -S express 建2个文件夹，分别为views和public 装模板引擎：npm install --save art-template express-art-template 装bootstrap的css：npm i -S bootstrap 外部备上一个index.html、db.json(用于存储数据) 将app.js作为执行的js文件，而router.js作为辅佐的路由js文件，并将其引入app.js，student.js作为增删改查封装的api 请求方法 请求路径 get参数 post参数 备注 get /students 渲染页面 get /students/new 渲染添加学生 post /students/new name、age、color、hobbies 处理添加学生请求 get /students/edit id 渲染编辑页面 post /students/edit id、name、age、color、hobbies 处理编辑请求 get /students/delete id 处理删除请求 //app.js var express = require('express'); var router = require('./router.js'); var bodyParser = require('body-parser'); var app = express(); // 一定要在挂载路由之前配置好模板引擎和bodyParser app.engine('html', require('express-art-template')); app.use(bodyParser.urlencoded({ extended: false })); app.use(bodyParser.json()); app.use('/node_modules/', express.static('./node_modules/')); app.use('/public/', express.static('./public/')); //挂载路由 app.use(router); //这里可以设置一个定制404页面，所有未处理的请求路径都会跑到这里 //app.use(function(req, res) => {}) app.listen(5208, () => { console.log('5208 is running!!...'); }) //处理路由的router.js文件 var fs = require('fs'); var express = require('express'); var Student = require('./student.js'); //这样也不太方便 // module.exports = function (app) { // app.get('/students', (req, res) => { // }); // } //express提供了一种更好的方式，专门用来包装路由 // 1.创建一个路由容器 // 2.把路由都挂载到router容器中 var router = express.Router(); router.get('/students', (req, res) => { Student.find((err, data) => { if (err) { return res.status(500).send('Service err 500'); } // 进行数据渲染 res.render('index.html', { fruits: [ '苹果', '雪梨', '西瓜' ], students: data }); }) }); router.get('/students/new', (req, res) => { res.render('new.html'); }); router.post('/students/new', (req, res) => { // 1.获取表单数据 // 2.处理,将数据保存与db.json中，用于持久化,即将db.json读取处理啊，转对象，往对象中push数据，再转回字符串，再把字符串写入文件 // 3.发送响应 var student = req.body; Student.save(student, (err) => { if (err) { return res.status(500).send('Service err 500'); } res.redirect('/students'); }) }); router.get('/students/edit', (req, res) => { // 1.在客户端处理链接问题，使用&lt;a href=\"/students/edit?id={{ $value.id }}\"> // 2.获取编辑的学生id // 3.渲染编辑页面 Student.findById(parseInt(req.query.id), (err, student) => { if (err) { return res.status(500).send('Service err 500'); } res.render('eidt.html', { student: student }) }) }); router.post('/students/edit', (req, res) => { Student.updateById(req.body, function (err) { if (err) { return res.status(500).send('Service err 500'); } res.redirect('/students'); }) }); router.get('/students/delete', (req, res) => { // 获取删除的id // 根据id，进行删除，然后发送响应 Student.remove(req.query.id, function (err) { if (err) { return res.status(500).send('Service err 500'); } res.redirect('/students'); }) }); // 3.导出 module.exports = router; // student.js用于纯粹对文件封装增删改查功能 // 只处理数据，不关心业务 // node的奥义所在：封装异步api var fs = require('fs'); var dbPath = './db.json'; //1.获取学生列表 // callback的第一个参数是err，第二个参数是结果 exports.find = function (callback) { //readFile 的第二个参数是可选的，传入utf8则按照utf-8编码转成正常字符 fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 callback(null, JSON.parse(data).students); }) }; // 根据id获取学生对象 exports.findById = function (id, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 var students = JSON.parse(data).students; student = students.find((item, index) => { return item.id === parseInt(id); }); callback(null, student); }) } //2.保存学生 exports.save = function (student, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 var students = JSON.parse(data).students; // 处理id唯一性问题 student.id = students[students.length - 1].id + 1; students.push(student); // JavaScript 值(对象或数组)转换为 JSON 字符串 var ret = JSON.stringify({ students: students }); ReRead(dbPath, ret, err, callback); }) }; //3.更新学生 exports.updateById = function (student, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 先把number类型的三个值从string转number student.id = parseInt(student.id); student.age = parseInt(student.age); student.color = parseInt(student.color); // 字符串转对象 var students = JSON.parse(data).students; // 使用ES6的find方法找到id对应的对象 var stu = students.find((item) => item.id === student.id); // 遍历拷贝对象 for (let key in student) { stu[key] = student[key]; } // JavaScript 值(对象或数组)转换为 JSON 字符串 var ret = JSON.stringify({ students: students }); ReRead(dbPath, ret, err, callback); }) }; //4.删除学生 exports.remove = function (id, callback) { fs.readFile(dbPath, 'utf8', function (err, data) { if (err) { return callback(err); } // 字符串转对象 var students = JSON.parse(data).students; // 获取要删除的id对象的下标 var deleteId = students.findIndex((item) => item.id === parseInt(id)); // 删除该id的对象 students.splice(deleteId, 1); var ret = JSON.stringify({ students: students }); ReRead(dbPath, ret, err, callback); }) }; // 重新读入的api function ReRead(dbPath, ret, err, callback) { fs.writeFile(dbPath, ret, (err) => { if (err) { return callback(err); } // 成功为null callback(null); }); } 关于Expresscookie和Session在express中，默认不支持Session和Cookie session是基于cookie实现的 但是我们可以使用大三方中间件：express-session来解决 npm install express-session 配置： var session = require('express-session'); app.use(session({ //配置加密字符串 secret: 'keyboard cat', resave: false, //无论你是否适用session,我都给你分配一把钥匙 saveUninitialized: true })); 添加session数据：req.session.foo = &#39;xxx&#39; 访问session数据：req.session.foo 这时候，服务器只需要调用req.session.xx就可以使用session保存的数据了 中间件使用express框架、一些其他的API之后，传进来的req和res经过了一些中间件（函数方法），使得req和res内部拥有了一些属性，可以直接使用req.body、req.query、req.session 等，并且在挂载路由后，在路由的js文件中，不用再次引用（require）这些api方法，同样可以使用req.body、req.query、req.session 等属性（其实也可以理解为，req、res等参数传进来路由器js文件时，已经被赋予以上属性，页面不用关心参数从中间件得到的属性，而是要关心是否需要引包才能使用方法） 中间件本身就是一个方法，它有三个参数：request、response、next（使用下一个中间件） 如果一个请求进入中间件，不调用next则会停留在当前中间件，调用了next后继续向后找到第一个匹配的中间件（平常我们看到很多组件好像没有next，其实已经吧next封装好了） 与ES6的Generator中的next()类似 在express中，对中间件有几种分类： （1）不关心请求路径和请求方法的中间件，也就是任何请求都会进入这个中间件 app.use(function(req, res, next)) （2）关心请求路径的中间件，以’/xxx’开头，需要匹配才会进入此中间件，如果不匹配自动跳过，去下一个中间件 app.use(&#39;/xx&#39;, function(req, res, next)) （3）严格匹配请求方法和请求路径的中间件 app.get() app.post() //127.0.0.1:5208/b app.use(function (req, res, next) { console.log(1); next(); }); app.use('/a', function (req, res, next) { console.log('a'); }); app.use('/b', function (req, res, next) { console.log('b'); }); app.use(function (req, res, next) { console.log(3); }); //输出: 1 b 上方为错误的代码， 下方利用next处理发生错误： //当调用next的时候，如果传递了参数，则直接往后找到带有四个参数的应用程序级别中间件 //if (err) { // next(err) // } //中间件要放到最后，搭配404处理一起使用 app.use(function (req, res, next) { res.render('404.html') }); app.use(function (err, req, res, next) { res.status(500).send(err.message) }); express实现中间件机制前提： express函数调用返回一个app实例 在express函数内部定义一个数组来存储中间件函数（队列数组） constructor() { // 存放中间件的列表 this.routes = { all: [],// 通用的中间件 get: [],// get请求的中间件 post: [],// post请求的中间件 }; } 在express函数内部定义一个app函数 在app函数的内部定义一个变量i保存执行的中间件的位置。 在app函数中定义一个next方法，这个方法通过i值自增调用中间件 在app函数内部调用next 在app函数上定义一个use方法，这个方法可以将中间件函数push进中间件数组中。 一个小案例加深中间件的作用和印象 function middlewareA(req, res, next) { console.log('middlewareA before next()'); next(); console.log('middlewareA after next()'); } function middlewareB(req, res, next) { console.log('middlewareB before next()'); next(); console.log('middlewareB after next()'); } function middlewareC(req, res, next) { console.log('middlewareC before next()'); next(); console.log('middlewareC after next()'); } app.use(middlewareA); app.use(middlewareB); app.use(middlewareC); 执行：A开始 -&gt; B开始 -&gt; C开始 -&gt; C结束 -&gt; B结束 -&gt; A结束","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"MongoDB","slug":"MongoDB","date":"2021-01-29T06:03:24.964Z","updated":"2021-04-09T03:16:20.832Z","comments":true,"path":"2021/01/29/mongodb/","link":"","permalink":"https://taylor12138.github.io/2021/01/29/mongodb/","excerpt":"","text":"1.MongoDB概述MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 mongoDB不需要学习sql语句 关系型数据库和非关系型数据库表就是关系 or 表与表之间存在关系 所有关系型数据都需要通过sql语言来操作 所有关系数据库在操作之前都需要设计表结构 而且数据表还支持约束 唯一性 主键 默认值 非空 非关系型数据库非常灵活，有的非关系型数据库就是key- value键值对 而MongoDB是长得最像关系型数据库的非关系型数据库 数据库 =&gt; 数据库 数据表 =&gt; 集合（数组） 表记录 =&gt; （文档对象） { 数据库:{ 集合:[ {name: &#39;Allen&#39;}, {name: &#39;Allen&#39;}, {name: &#39;Allen&#39;}, ] } } MongoDB不需要设计表结构 2.使用打开方式一：根据菜鸟教程提供的window MongoDB操作教程，就可以注册成window的一个服务，然后可以通过鼠标右键开启和停止这个服务了 方式二： #mongodb 默认使用执行 mongod 命令所处盘根目录下的/data/db作为自己的数据存储目录 #所以在第一次执行该命令之前，先手动新建一个 E(MongoDB所属盘):/data/db #然后再自己所属盘下 运行该命令 mongod 停止服务：ctrl + C或者直接关闭cmd窗口 如果想要修改默认的数据存储目录路径，可以（但是比较麻烦，不推荐） mongod --dbpath=数据存储目录路径 连接用一个命令窗口来打开MongoDB数据库 此时再打开一个窗口，输入以下命令进行连接 #该命令默认连接本机的MongoDB服务 mongo 断开连接 exit基本命令show dbs 查看显示所有数据库 db 查看当前操作的数据库，默认为test，供测试 show collections 查看当前数据库的集合 use 数据库名称 切换到指定数据库，如果没有该数据库则会新建一个 #在当前数据库的students集合中插入一个数据（对象） db.students.insertOne({\"name\": \"Jack\"}) #查看当前数据库的students集合中的数据 db.students.find() #移除 title 为“MongoDB”的文档 db.test.remove({'title': 'MongoDB'}) WriteResult({ 'nRemoved' : 2 }) #删除了两条数据 3.在Node中操作MongoDB数据方法一：使用官方的mongodb包来操作（并且根据文档提供的使用方法步骤进行操作） https://github.com/mongodb/node-mongodb-native 方法二：使用第三方mongoose来操作 MongoDB数据库 https://mongoosejs.com/ 而这个第三方包mongoose 是基于MongoDB 官方的 mongodb 包进行的二次封装 （mongoose所有api都支持promise） npm init -y npm i mongoose 以下代码在mongoose官网也能查看到 1.引包 require(&#39;mongoose&#39;); =&gt; 2.连接数据库 mongoose.connect (指定连接的数据库不一定需要存在，当你插入第一条数据之后就会被自动创建出来)=&gt; 3.创建模型mongoose.model(表名, 数据结构)（这里模型创建十分灵活，只需要在代码中设计你的数据库就可以了） =&gt; 4.实例化模型(new)，并将每个实例化的数据保存 save() 在该模型集合里 //demo.js // 引包 const mongoose = require('mongoose'); //连接MongoDB数据库（这里顺便创建了一个叫test的数据库） mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true }); //创建一个模型，说白了就是在设计数据库 // 这里第一个参数是表名：Cat，第二个参数是数据结构 const Cat = mongoose.model('Cat', { name: String }); for (let i = 0; i &lt; 10; i++) { // 实例化一个Cat（往cats集合里面插入每一个kitty数据） const kitty = new Cat({ name: 'Zildjian' }); // 持久化保存kitty实例 kitty.save().then(() => console.log('meow')); } 设计文档结构在第3步创建模型之前，其实还可以独立开来，使用Schema设置文档结构 字段名称就是表结构的属性名称 约束的目的就是为了保证数据的完整性，不要有脏数据 var mongoose = require('mongoose'); var Schema = mongoose.Schema; mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true }); var userSchema = new Schema({ username: { type: String, required: true //设置该属性必须有配置，使用required }, password: { type: String, required: true }, email: { type: String } }); 然后再用mongoose.model(表名, 数据结构)发布模型，此时把这个例子中userSchema放入第二个参数即可 var User = mongoose.model('User', userSchema); 第一个参数：为传入一个大写名词单数字符串，用来表示你的文档名称 第二个传的是对文档的约束，架构Schema 之后文档再变成复数，变成集合的名称，因为这才是一个集合，例如这里的User会变成users，即集合的名称 返回值是模型构造函数，我们有了模型构造函数之后，就可以对users集合数据进行操作了 操作数据确保数据库MongoDB被打开，并且再另外一个窗口进行连接 注意：mongoose增加数据是给你自动生成id 增加数据 利用返回的模型构造函数，new一个实例对象，顺便使用save()进行保存 let allen = new User({ username: 'allen', password: '123456', email: 'allen@qq.com' }); //ret是刚刚插入的那条数据 allen.save((err, ret) => { if (err) { console.log('保存失败'); } else { console.log('保存成共'); console.log(ret); } }) 查询数据 模型构造函数.find() 查询所有数据，ret返回一个数组，记录里面的数据（文档） User.find(function (err, ret) { if (err) { console.log('查询失败'); } else { console.log(ret); } }); 条件查询，查询username为Bruce的数据(按条件查找，ret返回一个数组，记录里面的数据（文档）) User.find({ username: 'Bruce' }, function (err, ret) { if (err) { console.log('查询失败'); } else { console.log(ret); } }); 只找到第一个匹配到的对象（文档）数据，ret返回一个对象 User.findOne({ username: 'Bruce', password: '123456' }, function (err, ret) { if (err) { console.log('查询失败'); } else { console.log(ret); } }); //promise格式，因为mongoose所有api都支持promise // User.findOne({ username: 'Bruce', password: '123456' }) // .then(data => { // console.log(data); // }, err => { // console.log('查询失败'); // }) 利用或，满足其中一个条件查询成功 User.findOne({ $or: [ { email: body.email }, { nickname: body.nickname } ] }, function (err, data) { if (err) { res.status(500).send('Server err'); }else { console.log(data) } }) 删除数据 remove现在似乎已经废弃了，所以采用delete 删除单个数据，删除条件为username: &#39;Zildjian&#39;的数据 User.deleteOne({ name: 'Zildjian' }, function (err) { if (err) console.log('删除失败'); }); 删除多个，删除条件为username: &#39;Zildjian&#39;的数据 User.deleteMany({ name: 'Zildjian' }, function (err) { if (err) console.log('删除失败'); }); 根据id删除： findByIdAndDelete 更新数据 根据id更改数据 User.findByIdAndUpdate('60142a5acbcef341281a7d18', { password: '789456' }, function (err, ret) { if (err) console.log('更新失败'); else console.log('更新成功！'); }) 还有其他更新数据方法可以在mongoose文档查看 4.About数据库基础知识事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）； 数据库的事务特性有：原子性、一致性、持久性、隔离性 A atomicity 原子性 指的是事务包含的所有操作，要么全部成功，要么全部回滚失败（要么都做，要么都不做） C consistency 一致性 指的是事务必须使数据库从一个一致性状态到另一个一致性状态，即事务执行前后全部处于一致性状态 I isolation 隔离性 指的是多个并发事物间互相隔离，也就是一个事务执行的过程中,不应该受到其他事务的干扰 D durability 持久性 指的是事务一旦提交了，那么对数据库中数据的修改就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失提交事务的操作 脏读：就是没有提交的数据，举个例子：比如某个事务在对数据库中某条记录进行修改，修改后没有提交也没有回滚，也就是让其处于一个待定的状态，这个时候如果有其他的事务来先一步对这条记录进行读取或者处理了的现象。 不可重复读取：一个事务先后读取某条记录，但在两次读取之间该条记录杯其他另一个事务给修改了，就造成了两次读取的数据不同的现象。 幻读：幻读就是一个事务按照查询条件查询以前检索过的数据可是发现该数据被其他事务插入了满足其查询条件的新数据的现象。 不可重复读和脏读的区别是一个是读取了前一事务提交的数据，而一个是读取了另一个事务未提交的数据 幻读和不可重复读不同的是，幻读针对的是数据条数的变化","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"计网personal note","slug":"计网personal note","date":"2021-01-08T06:57:51.068Z","updated":"2021-08-22T12:19:58.688Z","comments":true,"path":"2021/01/08/ji-wang-personal-note/","link":"","permalink":"https://taylor12138.github.io/2021/01/08/ji-wang-personal-note/","excerpt":"","text":"1.计网概念是将一个分散的，具有独立功能的计算机系统，通过通信设备和线路连接起来，由功能完善的软件实现资源共享和信息传递 计算机网络是互连的、自治的计算机集合 功能数据通信（连通性）（通信子网：网络层、数据链路层、物理层）（是点到点的通信） 资源共享（资源子网：应用层、表示层、会话层） （是端到端的通信） ​ 两个子网之间隔着传输层 主机在osi模型中有七层，而中间系统只有物理层、数据链路层、网络层三层（交换机和网桥这种甚至只有物理层、数据层两层） 分布式处理（多台计算机各自承担同一工作任务的不同部分） 提高可靠性 负载均衡 组成硬件、软件、协议（核心） 边缘部分（用户可以直接使用）、核心部分（为边缘部分服务） 功能组成：从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 分类分布范围划分：广域网WAN、城域网MAN、局域网LAN、个人区域网PAN 使用者划分：公用网（电信）、专用网（军队） 交换技术划分：电路交换、报文交换、分组交换 拓扑结构划分：总线型、星型、环型、网状型 传输技术划分：广播式网络（共享公共通信通道）、点对点网络 标准的划分法定标准：OSI 事实标准：TCP/IP（并不是指这两种协议，而是对许多大大小小的协议的泛指） 速率 &amp; 带宽 &amp; 吞吐量1.速率速率即数据率或数据传输率、或比特（bit）率，其实也就是速度 kb/s…. 存储容量是以 字节（Byte）作为单位 2.带宽原本：指某个信号具有的频带宽度，即最高频率和最低频率之差，单位是赫兹Hz 现在：它用来表示网络通信线路传送数据的能力，通常指单位时间内从网络某一点到另外一点的“最高数据率”，单位是比特每秒（和速率一样）（其实就是表示所支持最高速率为多少） 3.吞吐量单位时间内通过某个网络（信道、接口）的数据量，单位是 b/s…… 吞吐量还受到带宽或者网络额定速率的限制 吞吐量更像瞬时速率，带宽像最大速率 时延指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需要的时间，也叫做延迟或迟延，单位是秒s 分别为 发送时延（把所有数据从发送端推到信道上，发生在主机内部）=数据长度/信道带宽，高速链路指的是发送速率的提高，即带宽的提高，导致发送时延的减少 传播时延（在信道上传播一段距离所花费的时间，发生在信道上）=信道长度/电磁波速率 排队时延（等待处理） 处理时延（检错，找出口） 时延带宽积bit = 传播时延s * 带宽b/s，它又称为以比特位单位的链路长度，链路的容量 往返时延RTT：从发送方发送数据开始，到发送方收到接收方的确认经历的时延，RTT = 往返传播时延 + 末端处理时间 = 传播时延*2 + 末端处理时间 利用率信道利用率 = 有数据通过的时间 / 总时间 链路利用率=发送延时/总用时 = 发送延时/（发送时延+2*传播时延+确认帧传输时延） 网络利用率 = 信道利用率加权平均值 分层关于实体、协议、服务和接口： 1.实体：第n层元素称为n层实体，同层另外一端主机的实体叫对等实体 2.协议：对等实体（或多个实体）通信规则，分为语法、语义、同步（操作顺序） 3.接口：上层使用下层服务的入口 4.服务：下层为相邻上层提供功能调用（相邻，下层为上层才能为称之为服务） 计算机网络体系结构是计算机网络各层及其协议的集合 各层功能简洁概述 应用层：在所有能和用户交互产生网络流量的程序，实现协同工作的应用进程之间的通信过程控制。 表示层：用于处理两个通信系统中，交换信息的表示方式（语法和语义）功能：数据格式变换（翻译）、数据加密和解密、数据的压缩和恢复 会话层：向表示层实体/用户进程提供建立连接并连接上有序地传输数据。这是会话，也是建立同步 传输层：负责主机两个进程的通信，即端到端的通信，传输单位是报文段或用户数据段。功能： 可靠传输（有确认机制）、不可靠传输； 差错控制； 流量控制（发送速率，使用滑动窗口，比如停等协议、后退N帧的滑动窗口，选择重传的滑动窗口）； 拥塞控制（慢开始、拥塞避免、快重传、快恢复）； 复用分用（复用是多个应用层可同时使用下层运输层服务，分用是目的主机传输层把收到的信息分别交付给上面应用层中相应进程，应用：端口号）（osi面向连接，tcp/ip无连接+面向连接） 网络层：把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报（osi无连接+面向连接，tcp/ip无连接），路由的选择和分组转发 + 用拥塞控制 数据链路层：主要任务是把网络层传下来的数据组装成帧，同时包括流量控制和差错检测，数据链路层的传输单位是帧 物理层：主要任务是在物理媒体上实现比特流的透明传输 TCP/IP的应用层：合并应用层、表示层、会话层 5层参考模型数据封装与解封装应用层：单位：报文 传输层：单位：报文段 网络层：单位：数据报 数据链路层：单位：帧 物理层：单位：比特 香农定理 2.物理层物理层解决如何连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体（不同厂家生产的介质），它的任务是确定传输媒体接口有关的一些特性（定义标准，类似于水晶头规格，电压范围） 定义的特性：机械特性、电气特性、功能特性、过程特性 数据通信基础知识 数据：传送消息的实体，通常是有意义的符号序列 信号：数据在传输过程中的存在形式 数字信号/离散信号，计量单位是码元 模拟信号/连续信号 信源：产生和发送数据的源头 信宿：接收数据的终点 信道：信号传输的媒介，一般用来表示某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道 三种通信方式 单工信道：只有一个方向，仅需一条信道 半双工信道：双方都可以发送和接收，但是不能同时，类似于对讲机，需要两条信道 全双工信道：双方可同时收发，需要两条信道 两种数据传输方式串行传输 并行传输 编码与调制信道上的信号除了可以分为模拟信道和数字信道、无线信道和有线信道之外，还可以分为基带信号和宽带信号 基带信号：将数字信号1或0直接用两种不同的电压表示，再送到数字信道（在计算机中是使用数字信号，人类是模拟信号）上去传输（基带传输），基带信号最重要的一点就是来自于信源 宽带信号：将基带信号进行调制模拟后形成频分复（载波调制）用模拟信号，再传送到模拟信道上去传输（宽带传输）。载波调制（带通调制）把信号频率范围调到较高的频段以便在信道中传输 编码方式非归零编码：高1低0，容易，但是没有检错功能，无法判断码元的开始与结束，难以同步 归零编码：1：中间高，两边中等；0：中间低，两边中等 曼彻斯特编码：1：前高后低；0：前低后高，这种方法所占频带宽度是基带宽度的两倍，所以它的数据传输速率只有调制速率的1/2 差分曼彻斯特编码：同1异0，即码元为1，则前半段半个码元和上一个码元的后半段的电平相同，0则相反，抗干扰性强于曼彻斯特编码 数字数据调制为模拟信号调制解调器的调制：数字信号-&gt;模拟信号 调幅：0没幅度，1有幅度 调频：0低频，1高频 调相：调成正弦波和余弦波 QAM正交振幅调制，相当于调幅+调向 调制解调器的解调：模拟信号-&gt;数字信号 3.数据链路层结点：主机和路由器 网卡实现的主要功能是物理层与数据链路层的功能。 链路：网络中两个结点之间的物理通道，主要介质为双绞线、光纤等 数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议和硬件和软件加到链路上就构成数据链路 帧：链路层的协议数据单元，封装网络层数报 数据链路层 负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报，它最基本的服务是将源自于网络层的数据可靠的传输到相邻结点的目标机网络层（简单来说就是加强物理层传输原始比特流的功能），将物理层提供可能出现差错的物理连接改造成为逻辑上无差错的数据链路 功能一：为网络层提供：无确认无连接服务、有确认无连接服务、有确认面向连接服务（有连接一定有确认） 功能二：链路管理，即连接的建立、维持和释放（用于面向连接） 功能三：组帧 功能四：流量控制 功能五：差错控制 封装成帧实际上就是将网络层的ip数据报形成帧数据部分，加上帧首部，帧尾部 这样接收端在收到物理层上交的比特流后，就可以根据首尾标记进行识别 帧首部和帧尾部包含许多信息，其中有个重要作用就是：帧定界（确定帧的界限）； 帧同步：接收方应当能从接收到的二进制比特流区分帧的开始和结束 四种封装成帧方法： 1.字符计数法 2.字符填充法（帧首部SOH，帧尾部EOT）：为了保障字符填充的透明传输，在控制信息的前面+转义字符 3.零比特填充法（帧的首尾部都是01111110）：为了保障字符填充的透明传输，中间数据部分，只要有5个1，就立刻填入一个0，简称5110方法 4.违规编码法：曼彻斯特编码都是“高-低”，所以首尾帧用“高-高”、“低-低”定界帧的起始和结束 透明传输指不管所传的数据是什么样的比特组合，都应当能够在链路上传送，因此链路层“看不见”有什么妨碍数据传输的东西（保证传输透明，传输数据的比特组合可能和某控制信息一样（比如对数据链路层进行什么操作），但是数据链路层不管它，完全把它当作一个信息直接传递） 差错控制差错有：位错（比特位出错）和帧错（丢失、重复、失序） 差错控制：检测编码（奇偶校验码、循环冗杂码CRC）和纠错编码 冗余编码：在数据发送前，先按照某种关系加上一定的冗余位（比如余数），构成一个符合某一规则的码字后在发送，根据规则，接收端查看收到的码字是否符合原规则，从而判断对错 CRC循环冗余码： 发送端：要传的数据 / 生成多项式（一个数值） = 商…..FCS冗余码（余数）；最终要发送的数据为 要穿的数据 + FCS冗余码 接收端：收到的数据 / 生成多项式 = 商…0 余数为0，无差错 计算冗余码：（1）加0，生成多项式G(x)的阶（即生成多项式的位数-1）为r，则加r个0；（2）模2除法，同0异1 余数为0，接受，不为0，丢弃 此方法只能做到对帧的无差错接收，但是不能算作“可靠传输”，因为“可靠传输”的定义是数据链路层发送什么，接收端就接收到什么，但是此方法丢弃了部分错误的，没有完全接收 数据链路层流量控制较高发送速度和较低接收能力不匹配会出现传输错误 数据链路层的流量控制是点对点的（接收方收不下就不回复确认），传输层的流量控制是端对端的（接收端给发送端一个窗口公告） 停止等待协议：每发送完一个帧，等待对方确认再发下一个（停止等待协议类似于特殊的滑动窗口协议，但只是发送窗口和接收窗口都只有一个） 滑动窗口协议： 发送窗口指在发送端维持一段连续的，允许发送的帧的序号（正在发送的数据），相对应的是接收窗口，滑动窗口协议解决流量控制问题和可靠传输问题 后退N帧协议，发送窗口大小&gt;1，接收窗口大小=1 选择重传协议，发送窗口大小&gt;1，接收窗口大小&gt;1 在链路层在发送过程，发送窗口和接收窗口大小固定 停止等待协议除了比特出差错，底层还会出现丢包问题（线路、病毒等原因导致数据包的丢失） 停止等待协议重申：每发送完一个帧，等待对方确认再发下一个（停止等待协议类似于特殊的滑动窗口协议，但只是发送窗口和接收窗口都只有一个） 有差错的情况： 1.数据帧丢失或检测到帧出错 每发送一个帧，启动一个超时计时器 重传时间&gt;往返传播时延RTT 超时重传 注意：（1）发完一个帧后，要保留他的副本，（2）数据帧和确认帧必须编号、（3） 2.ACK丢失（确认丢失） 同上，但是接收方丢弃重复帧，重传确认帧 3.ACK迟到 仍然是超时重传，接收方丢弃重复帧，重传确认帧（当后面发送方终于等到一开始的确认帧时，直接收下并且丢弃） 协议的优点：简单，缺点：信道利用率低（发送时间Td / （发送时间Td + RTT + 确认分组时间Ta）） 滑动窗口后退N帧 发送窗口重申：发送窗口指在发送端维持一段连续的，允许发送的帧的序号（正在发送的数据） 接收窗口：接收方维持一组连续的允许接收帧的序号 后退N帧协议，发送窗口大小&gt;1，接收窗口大小=1 累积确认：接收方不用对于每个数据帧返回确认帧，可以隔一会返回一个确认帧，它保证这个帧，以及之前的所有帧都得到了确认 超时事件：发送方会重传所有已发送但是未被确认的帧，比如再等待1号帧，但是一直等不到，等来2，3号帧，会将其丢弃，直到重传的1号帧的到来，并且继续重传刚才已经发过的2、3号帧 滑动窗口长度：窗口大小W小于帧总类的一半 选择重传协议中的滑动窗口（信道利用率高） 和后退N帧不同的是，如果帧没有按序到达，也会将之后序号的帧暂存在接收窗口 如果接收方收到的帧序号是窗口的下界（最左边窗口对应的序号），则窗向前移动到最小序号未确认帧处 超时事件：一个超时事件发生后只重传一个帧 如果收到了窗口序号外的帧（小于窗口下界，可能因为某些原因传的慢，但是已经超时重传了），就返回一个ack 滑动窗口长度：发送窗口最好等于接收窗口 ；窗口大小W小于帧总类的一半 传输数据的链路点对点链路应用：ppp协议、广域网 广播式链路：局域网 广播信道介质访问控制就是采取一定措施，使得两对节点之间通信（因为广播式链路，是多个点共享信道）不会发生互相干扰的情况 静态划分信道：频分复用、时分复用、波分复用、码分复用 动态分配信道（CSMA/CD包含其中）：分为轮询访问介质访问控制、随机访问介质访问控制 随机访问介质访问控制：所有用户可随机发信息，发送信息时占全部带宽 CSMA/CD协议先听再说、边听边说 载波监听多点接入/碰撞检测 CSMA/CD CS：载波监听，每个站在发送数据之前以及发送数据时，都要检测一下总线上是否有其他计算机在发送数据。其实就是检测信道上电压的摆动幅值（在站点的位置检测有没有信号进来），幅值较大，则说明信道上有人在说话，就不发送，直到检测信道上空闲才发送 MA：多点接入，表示许多计算机以多点接入的方式连在一根总线上 ，其实也说明了该协议应用于总线型网络 CD：碰撞检测，“边发送边监听”，适配器边发送数据，边检测信道上信号电压变化，以判断自己发送数据时其他站是否也在发，也说明了该协议应用于半双工网络 为什么先听后还是有可能发生冲突？因为电磁波在总线上总是以有限速率进行传播，即传播时延对载波监听的影响 检测到数据帧有错误，则确定发生了碰撞和冲突，停发 只要经过 2T 时间没有检验出碰撞，就能肯定这次不会发生碰撞（T为单程端到端的传播时延） 采用截断二进制指数规避算法确定重传时机： 1.确定基本规避时间，争用期为2T，2T &lt;= 最小帧长 / 数据传输速率 2.定义参数k，它等于重传次数，但k不超过10，k = min[重传次数, 10] 3.从离散的整数集合[0, 2^k-1]中随机取出一个数r，重传所需要退避的时间，就是r倍的基本规避时间，即2r*T 4.当重传达到16次仍不能成功，说明网络太拥挤，则抛出此帧向高层报错 为了避免帧太短导致该协议的作用无效（传短帧后才知道发生碰撞），以太网定义了最小帧长64byte = 512bit，小于此大小为无效帧 MAC层在局域网中，硬件地址又称为物理地址或MAC地址，它是每个适配器（网卡）都有的一个全球唯一地48位二进制地址 MAC层主要功能包括数据帧的封装和卸装 MAC帧：是以以太网V2的格式 以太网由Xerox等公司联合开发地基带总线局域网规范，是当今现有局域网最通用的通信协议标准，使用CSMA/CD技术 以太网提供无连接、不可靠服务 PPP协议局域网普遍采取多点接入技术（总线型） 广域网中通常采用点对点技术（将多个局域网互联，资源共享） PPP协议是目前使用最广泛的数据链路层协议（拨号上网）只支持全双工 ppp协议的三个组成部分： （1）一个将ip数据报封装到串行链路 （2）链路控制协议LCP（身份验证） （3）网络控制协议NCP，为网络层协议建立和配置逻辑连接 PPP帧格式：零比特填充法 4.网络层主要任务就是把分组从源端传送到目的端，为分组交换网上的不同主机提供通信服务，传输单位是数据报（数据报是比较长的数据，分组是把数据包进行切割，划分出来的片段） 功能一：路由的选择和分组转发（选最佳路径） 功能二：异构网络互联 功能三：拥塞控制 数据交换方式两台主机通过网络核心【路由器】进行数据转发 （1）电路交换：比如电话网络，独占资源 （2）报文交换：报文是源应用发送的信息整体，无需建立连接、可靠、利用率高，且多目标，但报文大小不定，需要网络节点有较大缓存空间 （3）分组交换：大数据块分割成小数据块（把报文切割成小数据块），它相对于报文交换，存储管理更容易；但是乱序到达目的主机时，需要分组排序重组 数据报和虚电路数据报方式为网络层提供无连接服务（因特网在使用）（无连接服务为不事先为分组的传输确定传输路径，不同分组传输路径可能不同） 路由器根据分组目的地址转发分组，基于算法构建的转发表，为每个分组独立选路 虚电路方式为网络层提供连接服务（虚电路是一条源主机到目的主机类似于电路的路径（逻辑连接），路上所有结点都要维持这条虚电路的建立，并有一张虚电路表） 每个分组携带虚电路号，可以使得一系列的分组沿着相同路径转发出去 路由算法和路由器概述算法的“最佳”只能是相对于某一种特定要求下得出的比较合理的选择而已 静态路由算法：非自适应路由选择，即管理员手动配置，不适用于大型网络，适合小的、安全要求高的网络 动态路由算法：自适应路由选择 采用分层次的路由选择协议：（1）因特网规模大（2）许多单位不想让外界知道自己的路由选择协议 因此把互联网划分为许多较小的自治系统AS，一个AS的所有路由器在本自治系统内都应该相互连通；一个AS对其他AS表现出是一个单一的一致的路由选择策略（分层次是分成内部和外部） 内部网关协议IGP，一个AS内使用 外部网关协议EGP，AS之间使用 内部网关协议 RIP基于距离向量的路由选择协议，最大优点是简单（适用于小规模网络） 它要求网络中每个路由器维护它从其他每个目的网络的唯一最佳距离纪录（维护的是路由表），也就是最短跳数 RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达，所以只适合小规模互联网 RIP协议的特点： 1.仅和相邻的路由器交换信息 2.交换的信息时自己的路由表 3.固定时间间隔交换路由信息 路由器刚开始工作时，只知道直接相连的几个网络的距离（距离定义为1） 距离向量算法： 1.修改相邻路由器发来的RIP报文中所有表项，对地址为X的相邻路由器发来的RIP报文，下一跳地址改为X，并把所有“距离”字段+1 2.对修改后RIP报文的每个项目，若原路由表没有目的网络N则添加；若已经含有，且下一跳地址和原来一样，则即使跳数可能增大，但也必须发生更改；若已经含有，且下一跳地址不同，则将跳数相对较小的项目更新入路由表 3.若180s没收到相邻路由表的更新，则记为不可达路由器，距离设置为16 RIP其实是应用层的协议，使用UDP传送数据，使用UDP’无可靠保证，但是开销小 好消息传得快，坏消息传得慢 OSPF协议使用的是迪杰斯特拉最短路径算法，适用于大规模互联网 它最主要的特征就是使用了分布式链路状态协议 30min更新一次 传递协议：IP 外部网关协议 BGP和其他AS邻站BGP发言人交换信息，交换网络可达性信息，发生变化时更新有变化部分 不用找到最佳路径，找到较好路由选择就够了 传递协议：TCP，保证可靠的交付 IP数据报格式在TCP/IP标准中，数据报格式中的数据常常以32位（4Byte）为单位来描述 数据报长度不能超过MTU（1500字节byte），如果超过了就分片 分片流程： 数据报中有标识数据段，同一数据报分片使用同一标识 数据报中有标志数据段，DF = 1禁止分片；DF = 0，允许分片，在DF = 0的条件下，MF = 1后面还有分片；MF = 0最后一块没分片 数据报中有片偏移数据段，指出较长分组分片后，某片在原分组相对位置，以8B为单位，所以能得出除了最后一个分片，每个分片的长度都一定是8B的整数倍 ip数据报固定首部长度为20字节 ip地址ip地址，在全世界范围内唯一的32位标识符，可以唯一标识一个主机或者路由器等设备的接口 ip编制历史阶段： 1.分类的ip地址 2.子网的划分 3.构成超网 分类的ip地址：ip地址{&lt;网络号&gt;, &lt;主机号&gt;}，如果主机连在一个网络上，则网络号是相同的，主机号不相同 分类分成5类，分类方法靠前面的四位来区分 ，分类因为各网络差异比较大，有的网络主机数多，有的少，且ip地址是32位，我们为了便于书写，常常每八位插入一个空格（但在机器中并没有这样的空格） A类：2^7-2是因为全零指本网，全1；127指回环，2^24-2是因为全零指本机，全1指广播地址 B类：128.0.0.0不能指派，2^14-1 C类：192.0.0.0不能只派，2^21-1 特殊ip地址： 网络号全0，主机号全0，本网范围内标识本主机，只能作为源地址 网络号全0，主机号特定值，本网范围某主机，只能作为源地址 网络号全1，主机号全1，本网广播地址，只能作为目的地址 网络号特定值，主机号全0，网络地址，表示一个网络，啥也不能作 网络号特定值，主机号全1，直接广播地址，只能作为目的地址，表示对特定网络上所有主机广播 网络号127，主机号任意，用于本地软件测试 分类ip地址缺点：ip地址空间利用率有时很低；2级地址不够灵活 子网的划分ip地址{&lt;网络号&gt;, &lt;&lt;子网号&gt;，&lt;主机号&gt;&gt;}，三级的ip地址，但是就算划分子网后，对外表现仍然是一个网络，即本单位外网络看不见本单位内子网划分 子网号能否全0、全1要看情况，主机号部分仍然不能全0、全1 子网掩码：极力推荐子网掩码中使用连续的1：比如B类 11111111 11111111 11111111 00000000，子网掩码和ip地址相与，就可以得到子网网络地址 路由表中包含：目的网络地址、目的网络子网掩码、下一跳地址 使用子网分组转发 1.提取目的ip地址 2.判断是否可直接交付，用ip地址与子网掩码相与，匹配则交付 3.若1-2步骤不行，判断特定主机路由 4.若1-3步骤不行，检测路由表有无路径，也是相”与“判断 5.若1-4步骤不行，默认路由处理 0.0.0.0 6.最后还不行丢弃分组，报错 无分类编址CIDR是否可以使用一个变长的子网掩码，而非定长的？CIDR消除了传统A、B、C类和子网划分的概念 ip地址{&lt;网络前缀&gt;，&lt;主机号&gt;} CIDR的记法：ip地址后加上/，然后写上网络前缀的位数即可 128.14.32.0/20，则表示前20位位网络前缀 CIDR把网络前缀相同的连续ip地址组成一个CIDR地址块此时最小地址为：网络前缀保持不变，主机号全0，最大地址为：网络前缀保持不变，主机号全1 CIDR地址掩码为网络前缀的每个位，填充为1，后面的主机号位填充为0 构成超网定义：将多个子网聚合成一个较大的子网，叫作构成超网或路由聚合，使得路由器转发表不用写那么多数据 构成超网方法：将网络前缀缩短 最长前缀匹配：使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由，前缀越长，地址块越小，路由越具体 在CIDR中子网号可全0、全1 ARP协议ARP高速缓存：保存的是ip地址和mac地址的映射（对应），解决下一跳走哪的问题 （DNS）完成域名到 IP 地址的映射，（RARP）实现MAC到IP地址的映射;（ARP）实现IP到MAC. 在实际链路上传送数据帧时，最终必须使用mac地址 注意：硬件地址又称物理地址，从层次的角度，物理地址是给物理层和数据链路层使用的地址，而ip地址时网络层和以上各层使用的地址，是一种逻辑地址；以太网帧在传输过程中有关其内部的mac地址和ip地址的变化情况：源ip地址和目的ip地址不会产生变化，而源mac地址和目的地址逐网络（或逐链路）都发生变化 ARP协议的使用： 检查ARP高速缓存是否已经有对应的ip地址到mac的映射表项,如果没有执行以下步骤 局域网络内：某主机要发射数据帧，但是不知道目的主机的mac地址，但是直到发送主机、目的主机的ip地址，以及知道自身的物理地址，这时发射主机发送广播请求分组（全1），最后收到目的主机的单播响应分组，得到该主机的mac地址，写入ARP缓存 局域网外：寄希望于默认网关（与外界沟通的路由器），跳到路由器的mac地址，然后该路由器响应发送主机的广播请求，把路由器的mac地址映射返回；然后一直传到目的主机局域网的路由器的mac地址，这时该局域网路由器发送广播请求分组（全1），最后收到目的主机的单播响应分组，得到该主机的mac地址 ICMP协议ICMP循序主机或路由器报告差错情况和提供有关异常情况的报告 ICMP报文 + ip数据报首部 = ip数据报的数据部份 +ip数据报首部 = ip数据报 ICMP分为：ICMP差错报文和ICMP询问报文 ICMP差错报文：1.终点不可达（无法交付问题）；2.时间超过（数据报生存时间为0或者数据报片没有收集完整，应用：Traceroute）；3.参数问题（首部字段出问题）；4.改变路由（重定向） ICMP询问报文：1.回送请求和回答（测试目的栈是否可达，应用：ping xxip地址，测试两个主机的连通性）；2.时间戳请求和回答 IPV632位的IPV4地址空间已经分配殆尽了，IPV6从根本解决地址耗尽问题 更大的地址空间：原来的32位 -&gt; 128位 拓展的地址层次结构、灵活的首部格式、改进的选项。。。。。 IPV6由两大数据部分组成，基本首部和有效载荷 IPV6的表示方法为：冒号十六进制记法，允许零压缩 IPV6向IPV4过渡策略：双栈协议（同时启用IPV4和IPV6）、隧道技术（重新封装） 5.传输层主机才会有的层次，功能有： 提供进程和进程之间的通信（网络层提供主机和主机之间的逻辑通信） 复用和分用 对报文进行差错检测 两个协议，TCP和UDP 端口号传输层有一个端口（逻辑端口/软件端口），它可以唯一标识一个具体的进程，端口号只有本地意义 端口号长度为16bit，能表示65536个不同端口号 分为服务端口号和客户端口号 服务端口号：熟知端口号（给TCP/IP最重要的一些应用程序，0-1023，让所有用户都知道）、登记端口号（1024-49151） 客户端口号：49152-65535，仅在客户进程运行时才动态选择 重要端口号： 传输层两个好兄弟，大哥TCP和二弟UDP，大哥靠谱，二弟不靠谱 传输单元为报文段 TCP传送数据前必须建立连接，不提供广播或多播，时延大，适用大文件 1.面向连接（虚连接）的传输控制协议 2.每一条TCP只能有两个端点，点对点 3.TCP提供可靠交付服务 4.全双工通信，发送方的发送缓存：准备发送的数据&amp;已发送但尚未收到确认的数据；接收方的接收缓存：按序到达但违背接受应用读取&amp;不按序到达的数据 5.面向字节流 TCP首部格式最小长度为20字节 序号为发送的数据（报文段）的第一个字节的序号 确认号：用于接收方发送的TCP确认报文段，确认号是期待发送方下一个报文段第一个数据字节序号 数据偏移：实际上就是TCP首部长度 紧急URG：URG = 1，在发送报文段时拥有插队权力 同步SYN：建立连接时同来同步的 TCP连接管理连接的建立 -&gt; 数据的传送 -&gt; 连接的释放 tcp连接建立采用客户服务器方式，主动发起连接的应用进程叫作客户，被动等待连接建立的应用进程叫服务器 连接建立过程：三次握手 客户端发送报文段，里面无应用层数据，SYN（同步位） = 1，seq（序号） = x（随机） 服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据 SYN = 1，ACK（确认位） = 1，seq = y，ack（确认号） = x + 1. 客户端为TCP连接分配缓存和变量，并向服务器返回确认的确认，可以携带数据，SYN = 0，ACK = 1，seq = x + 1，ack = y + 1 2次不行： 客户端向服务器发送建立连接的请求报文段，有可能因为网络滞留了，之后等到这个滞留报文段到达服务端时，客户端早已重新发送请求连接的报文，而服务端不这么认为，服务端他以为你发了新的连接请求，此时服务端向客户端发送确认报文，而客户端收到这个响应，但是发现这个请求在之前就发过了，就会忽略，而此时服务端苦苦等待客户端的响应，这样就会造成资源浪费 4次不行： 意义不大，因为此时我们都知道双方的发送和接收功能都是正常的 洪范攻击：发生在osi第四层，利用三次握手的特性，拼命向服务器发送大量的TCP SYN，也就是三次握手的第一次数据包，当服务器返回ACK后，该攻击者就不对其进行确认，让TCP处于挂起状态，服务器收不到再确认，还会重复发送ACK给攻击者，然后浪费服务器资源，消耗CPU和内存，可能导致服务器死机 连接释放过程：四次挥手（参与一条TCP连接的两个进程任何一个都可以终止该连接，连接结束后主机中的“资源”将被释放） 客户端发送连接释放报文段，停止发送数据，主动关闭TCP FIN（释放位） = 1，seq（序号） = u 服务器回送确认报文段，客户端到服务器这个方向的连接就释放了—-半关闭状态 ACK = 1，seq = v，ack = u+1 服务器端发完数据，发送释放报文段，主动关闭TCP连接 FIN = 1，ACK = 1，seq = w，ack = u+1 客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后（防止服务器未接收到确认，这时服务器可以及时再次发送释放报文段），连接彻底关闭 SYN：同步序列号，是用来建立连接的握手信号。 ack：确认序号，当ACK为1时，ack有效，当ACK为0时，ack无效。 seq：序号。 ACK：确认序号有效。 FIN: 结束标志，用来表示断开连接。 MSL：的时长被 RFC 定义为 2分钟，但在不同的 unix 实现上，这个值不并确定，我们常用的 centOS 上，它被定义为 30s， 当 TCP 连接主动关闭时，都会经过 TIME_WAIT 状态： TCP 四次握手结束后，连接双方都不再交换消息，但主动关闭的一方保持这个连接在一段时间内不可用。 TCP可靠传输保证接收方从缓存区读出的字节流与发送方发出的字节流是完全一样的 1.检验，与UDP一样，增加伪首部 2.序号，对应TCP首部格式的序号 3.确认号，对应TCP首部格式的确认号 4.重传（超时重传），TPC采用自适应算法，动态改变重传时间RTTs（加权平均往返时间） 5.冗余ACK，当比期望序号大的失序报文段到达时，发送冗余ACK，指明下一个期待字节的序号（发送方收到3个冗余ACK，则认为报文段丢失，选择重发） TCP流量控制同数据链路层的滑动窗口进行流量控制 但是TCP的发送窗口是根据接收方的报文段（rwnd = 400，则窗口大小为400B），动态变化其大小（在链路层在发送过程，发送窗口和接收窗口大小固定），如果设置rwnd = 0，则发送端等待接收方再次发送rwnnd &gt; 0 的报文段，如果一直等不到（可能接收方返回的报文段丢失了），TCP连接的一方（此时仍是0窗口大小）启动计时器开始计时，一段时间结束后发送零窗口的试探报文段，然后接收方会再发一次原来要返回的报文段 TCP拥塞控制出现条件：对资源的需求&gt;可用资源 网络性能下降、网络吞吐量随输入负荷增大而下降 拥塞控制是全局性的过程，防止过多数据注入网络 拥塞控制的方法：慢开始、拥塞避免、快重传、快恢复 发送窗口 = Min{接收窗口，拥塞窗口} 接收窗口：接收方根据接收缓存设置的值，反应接收方容量 拥塞窗口：发送方根据自己估算的网络拥塞程度设置的值，反应当前网络容量 一个传输轮次 = 一个RTT WebSocketWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，是一个持久化的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。（打破了三次握手定律？？！NoNoNo，这里指的是一次握手指的是建立连接，完成握手归根到底于传输层tcp协议的三次握手） 但是WebSocket是基于http1.1（Websocket 通过HTTP/1.1 协议的101状态码进行握手。） + TCP协议的，http/2选择了基于SPDY （借用Wikipedia的） GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade （Connection：通用首部字段） Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: http://example.comWebSocket推送技术现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器 1.浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。（通过握手建立连接，http协议升级为websocket协议，服务端响应101状态码） 2.当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。（允许服务端主动向客户端推送数据） WebSocket推送技术和http2.0的服务端推送（server push）： HTTP协议和WebSocket协议都是应用层的协议，两者应用场景不一样。 HTTP主要用来一问一答的方式交付信息；WebSocket让通信双方都可以主动去交换信息。 HTTP2虽然支持服务器推送资源到客户端，但那不是应用程序可以感知的，主要是让浏览器（用户代理）提前缓存静态资源，所以我们不能指望HTTP2可以像WebSocket建立双向实时通信。 SocketSocket 其实并不是一个协议，是应用层与 TCP/IP 协议通信的中间软件抽象层，它是一组接口。 通过Socket，我们才能使用TCP/IP协议。 UDP无连接的用户数据报协议 1.传送数据前不用建立连接，收到报文后也不需要任何确认，不保证可靠交付 2.UDP是面向报文的（面对应用层交下来的报文，不拆分也不合并，保留报文边界），适合一次性传输少量数据的网络应用（够小就可以完整交付，不用拆分），适用小文件 3.无拥塞控制，适合很多实时应用 4.UDP首部开销小，8B；TCP则是20B，和ip数据报固定首部长度 它只在ip数据报服务上增加了复用分用、差错检测功能 在分用时，找不到对应端口，则向发送方发送ICMP“端口号不可达”差错报文 提供全双工服务 UDP校验时： 1.会发现有“伪首部”，它只在计算校验和时才出现，不向下传送也不向上递交 2.全0填充数据部分和校验和字段 3.伪首部+首部+数据部分采用二进制反码求和，把和，求它的反码，填入校验和字段，去掉伪首部，发送 4.接收端填上伪首部，采用伪首部+首部+数据部分采用二进制反码求和，全1无差错，否则丢弃数据报/交给应用层附上出差错的警告 二进制反码求和: 规则是从低到高位逐列进行bai计算，0和0加得0,0和1加得1,1和1加得0但要产生一个进位1，加到下一列，若最高位产生了进位，则最后得到的结果要加1。 6.应用层应用层对应用程序的通信提供服务 应用层协议的定义： 应用进程交换的报文类型，请求还是响应 各种报文类型的语法，如报文中各个字段及其详细描述 字段语义及其包含的信息含义 进程何时，如何发送报文 应用层功能： 文件传输、访问和管理 电子邮件 虚拟终端 查询服务和远程作业登陆 有两种模型：客户服务器模型（C/S）、P2P模型 客户服务器模型（C/S）： 服务器：提供计算服务的设备。1. 24小时永久提供服务；2.永久性访问地址 客户机：请求计算服务的主机，1. 与服务器通信，使用服务器提供的服务；2.间歇性接入网络；3.使用动态的ip地址；4.不与其他客户机直接通信 P2P模型： 无服务器 每个主机既可以提供服务，也可以请求服务，任意节点可以直接通讯 DNS域名解析系统域名：www.baidu.com DNS: 域名 -&gt; ip地址 域名自左向右，级别由低到高，分别对应三级域名、二级域名、顶级域名 交给域名服务器解析域名，域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器、本地域名服务器（最近） 首先 在本机域名解析的缓存中查找该域名 ，若找不到 -&gt; 发给本地域名服务器，无法解决-&gt;求助根域名服务器-&gt; 查询顶级域名服务器 -&gt; 查询权限域名服务器 亚洲平均2000万人平分一个根域名服务器，北美平均300万人平分一个根域名服务器，所以北美上网速度&gt;亚洲 域名解析过程：递归查询（靠别人，请求根服务器-&gt;根服务器请求顶级域名服务器。。。较少使用）、迭代查询（靠自己，由自己来查询根域名服务器，顶级域名服务器） 万维网和http协议万维网是大规模、联机式信息储藏所，无数个网络站点、网页的集合 统一资源定位符URL可以唯一标识资源（文字、视频、音频） URL： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; http默认80端口号 协议：http、ftp 主机：域名、ip地址 端口和路径有时可以被省略掉 http协议定义了浏览器怎么向万维网服务器请求万维网文档，以及万维网怎么把文档传送给浏览器：建立tcp连接 -&gt; http请求报文-&gt; http响应报文 -&gt; 释放TCP连接 http协议的特点 http协议是无状态的，但是在实际工作中，一些万维网网站希望能识别用户（给用户推销产品）=&gt;诞生了cookie小饼干，cookie是存储在用户主机的文本文件，记录一段时间内某用户的访问记录（不太敏感的数据） http采用TCP作为运输层协议，但是http协议本身是无连接的 （交换http报文之前不需要建立连接） http连接方式：持久连接（非流水线式（有点像停等协议）、流水线式（有点像GBN或SR协议，即后退N帧协议和选择重传协议））、非持久连接（每次传输都要三次握手） 无状态： 所谓的无状态是指协议对于事务处理没有记忆能力。服务器向客户机发送被请求的文件时，并不存储任何关于该客户机的状态信息，于是，两种用于保持HTTP状态的技术就应运而生了，一个是Cookie，而另一个则是Session。 无连接： 就是假如某个客户机在短时间多次次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，反而每次都不耐其烦重新响应请求。 7.其他臭名昭著的最后一英里问题。光纤固然很快，但是要将您的家庭或办公室连接到 Internet，您的本地 ISP 需要在整个社区布线、聚合信号并将其转发到本地路由节点。实际上，根据连接类型、路由方法和部署的技术，仅这些前几跳就可能需要数十毫秒。 我们都熟悉 IPv4 和 IPv6，但 IPv{1,2,3,5} 发生了什么？IPv4 中的 4 代表 TCP/IP 协议的第 4 版，它于 1981 年 9 月发布。最初的 TCP/IP 提案耦合了这两个协议，而 v4 草案正式将两者拆分为单独的 RFC。因此，IPv4 中的 v4 是其与 TCP 关系的遗产：没有独立的 IPv1、IPv2 或 IPv3 协议。 当工作组在 1994 年开始研究“下一代互联网协议”（IPng）时，需要一个新的版本号，但 v5 已经分配给另一个实验协议：互联网流协议（ST）。事实证明，ST 从未起飞，这就是为什么很少有人听说过它。因此是 IPv6 中的 6。 慢启动TCP三次握手之后，服务器为每个 TCP 连接初始化一个新的拥塞窗口 (cwnd) 变量，并将其初始值设置为一个保守的、系统指定的值（Linux 上的 initcwnd）。 此外，引入了一个新规则：客户端和服务器之间传输（未确认）的最大数据量是 rwnd 和 cwnd 变量中的最小值。到目前为止一切顺利，但是服务器和客户端如何确定拥塞窗口大小的最佳值呢？毕竟，网络条件一直在变化，即使在相同的两个网络节点之间，正如我们在前面的示例中看到的那样，如果我们可以使用该算法而不必为每个连接手动调整窗口大小，那就太好了。 解决方案是缓慢启动并在确认数据包时增加窗口大小：慢启动！原来cwnd的起始值设置为1个网段；RFC 2581 在 1999 年 4 月将此值更新为 4 个段；最近，RFC 6928 在 2013 年 4 月再次将该值增加到 10 个段。 新 TCP 连接的最大传输数据量是 rwnd 和 cwnd 值中的最小值；因此，现代服务器最多可以向客户端发送十个网段，此时它必须停止并等待确认。然后，对于每个接收到的 ACK，慢启动算法指示服务器可以将其 cwnd 窗口大小增加一个段——对于每个 ACK 数据包，可以发送两个新数据包。TCP 连接的这个阶段通常被称为“指数增长”算法（图 2-3），因为客户端和服务器正试图在它们之间网络路径上的可用带宽上快速收敛。 优化TCPTCP 是一种自适应协议，旨在对所有网络对等方公平并最有效地利用底层网络。因此，优化 TCP 的最佳方法是调整 TCP 如何感知当前网络条件并根据其下层和上层的类型和要求调整其行为：无线网络可能需要不同的拥塞算法，某些应用程序可能需要自定义服务质量 (QoS) 语义以提供最佳体验。 虽然每个算法和反馈机制的具体细节会不断发展，但核心原则及其含义保持不变： TCP 三向握手引入了完整的往返延迟。 TCP 慢启动应用于每个新连接。 TCP 流量和拥塞控制调节所有连接的吞吐量。 TCP 吞吐量由当前拥塞窗口大小调节。","categories":[{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"Hello"},{"title":"Ajax","slug":"Ajax","date":"2020-12-29T12:31:35.297Z","updated":"2021-08-22T10:22:45.036Z","comments":true,"path":"2020/12/29/ajax/","link":"","permalink":"https://taylor12138.github.io/2020/12/29/ajax/","excerpt":"","text":"1.Ajax概述它最大的特点是可以在网页不刷新的情况下向服务端http请求，然后得到http响应 它全称为 Asynchronous JavaScript And XML，就是异步的JS和XML，通过Ajax可以在浏览器中向服务器发送异步请求，最大优势：无刷新获取数据。AJAX不是新的编程语言，而是一种将现有标准组合在一起使用的新方式 Ajax在应用当中需要一个服务端，可以选择nodejs来配合使用 XML简介XML可扩展标记语言，是被设计用来传输和存储数据的，它和html很像，它们不同的是html中都是预定义标签，而xml没有预定义标签，全是自定义标签，用来表示一些数据 最开始ajax在进行数据交换的时候，所使用的格式就是XML 但是现在ajax都是使用json了，json相对xml更为简洁，而且在数据转换这块比较容易，可以借助json的一些api方法，快速将字符串转成js对象，灵活度远胜XML XML和HTML这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？ 区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。 显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。 Ajax特点优点： 1.可以无需刷新而与服务器端进行通信（提高用户体验） 2.允许根据用户事件来更新部分页面内容 缺点 1.没有浏览记录，不能回退 2.存在跨域问题（同源） 3.SEO不友好（搜索引擎优化）（源代码（响应体）没有部分商品信息，那些商品信息都是ajax向服务端发请求，通过服务端返结果，然后js动态创建到页面，所以爬虫也爬不到商品数据） Ajax原理Ajax请求数据流程最核心的依赖是浏览器提供的XMLHttpRequest对象，它扮演的角色相当于秘书，使得浏览器可以发出HTTP请求与接收HTTP响应。浏览器接着做其他事情，等收到XHR返回来的数据再渲染页面。 2.原生ajax的get/post请求先在script绑定事件对象 1.创建对象（控制平台中network也有XHR，它是对ajax请求做一个筛选） XMLHttpRequest（XHR）对象用于与服务器交互，是BOM的范畴内。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 ajax 编程中被大量使用。 2.初始化，设置请求方法（请求类型）和url xhr.open(请求类型, url)，请求类型为get或post 3.发送 xhr.send() 4.事件绑定，处理服务端返回的结果 onreadystatechange on 有 when的意思，即当。。。的时候readystate是xhr对象当中的属性，表示状态0/1/2/3/4，分别对应以上步骤完成与否的状态 0：未初始化 1：open方法已经调用完毕 2：send方法已经调用完毕 3：表示服务端返回了部分的结果 4：服务端返回了所有的结果change 改变的时候触发，这里一般会触发四次，改一次触发一次 5.此时xhr对象的属性有： status状态码（200等） statusText 状态字符串（OK等） getAllResponseHeaders() 所有响应头 response 响应体 ajax的get请求案例const btn = document.querySelector('button'); const result = document.querySelector('#result'); btn.addEventListener('click', function () { //1.创建对象，控制平台中network也有XHR，它是对ajax请求做一个筛选 const xhr = new XMLHttpRequest(); //2.初始化，设置请求方法（请求类型）和url xhr.open('GET', 'http://127.0.0.1:8000/server'); //3.发送 xhr.send(); //4.事件绑定，处理服务端返回的结果 xhr.onreadystatechange = function () { //判断,服务端返回了所有的结果 if (xhr.readyState === 4) { //判断响应状态码 if (xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) { //处理结果 行、头、空行和体 //1.响应行里的数据 console.log(xhr.status); //状态码 console.log(xhr.statusText); //状态字符串 console.log(xhr.getAllResponseHeaders()); //所有响应头 console.log(xhr.response); //响应体 //2.设置result文本 result.innerHTML = xhr.response; } } } }) &lt;/script> ajax的post请求注意post和get的不同点在于： 1.初始化xhr.open(&#39;POST&#39;, url) 2.get是在初始化时，xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/server?a=100&amp;b=200&#39;);进行参数传递的 而post是在发送时send(a=100&amp;b=200);进行参数传递的 3.ajax其他ajax请求头设置设置请求头，并且必须在open之后，send之前 xhr.setRequestHeader(头的名字, 头的值); xhr.open('POST', 'http://127.0.0.1:8000/server'); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send('a=100&amp;b=200&amp;c=300'); Content-Type是来设置请求体内容类型 与此同时还可以自定义属性，xhr.setRequestHeader(&#39;name&#39;, &#39;Allen&#39;); 但会报错，除非后端人员在服务器： 1.先把服务器对当前页面的post请求改成all，这样可以接受任意类型的请求 app.post(url, callback) =&gt; app.all(url, callback) 2.请求里设置 res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;); 响应json数据保存在json文件的是json字符串 JSON.stringify(对象) JavaScript 值(对象或数组)转换为 JSON 字符串 JSON.parse(data) 字符转对象 或者直接在xhr.open之前设置： xhr.responseType = &#39;json&#39;，这样通过xhr.response得到的响应体数据都是以对象形式，不需要再进行JSON.parse(xhr.response) IE缓存问题ie浏览器它会对ajax的请求结果做一个缓存，这样导致下次再次发送请求时，用的是本地之前的缓存进行响应，而不是最新数据，这样导致时效性比较强的使用场景，ajax这个缓存会影响最终的结果正确的呈现 ajax关于ie缓存问题解决方法：xhr.open(&#39;POST&#39;, &#39;http://127.0.0.1:8000/server/ie?t=&#39;+Date.now()); ajax请求超时问题与网络异常我们永远不能保证服务端快速、及时的响应 这时我们对超时、异常情况给用户进行提醒（超时后自动取消请求） //超时 2s 设置 xhr.timeout = 2000; //超时回调函数 xhr.ontimeout = function () { alert(\"网络异常，请稍后重试\"); } // 网络异常回调设置 xhr.onerror = function () { alert(\"您的网络似乎出了一点问题。。。\"); } ajax取消请求上方是超时自动取消请求 这里演示的是手动取消请求 let xhr = null; btn[0].addEventListener('click', function () { xhr = new XMLHttpRequest(); xhr.open('GET', 'http://127.0.0.1:8000/server/time'); xhr.send(); }); //取消按钮 btn[1].addEventListener('click', function () { xhr.abort(); }) 请求重复发送问题过于频繁地发送请求会导致服务器压力过大 这里可以设置，再次发送请求时，把上一个请求取消掉（这里地重复发送问题让我想起了节流阀） let isSending = false; btn[0].addEventListener('click', function () { // 判断标识变量,如果正是在发送，则取消该请求，创建新的请求 if (isSending) xhr.abort(); xhr = new XMLHttpRequest(); isSending = true; xhr.open('GET', 'http://127.0.0.1:8000/server/time'); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { // 在这里不加状态码判断，因为这可能是一个失败的请求，如果加判断的话，可能导致isSending永远不为false isSending = false; } } }); 表单的同/异步提交使用jQuery实现ajax的注册小案例 （异步提交，即使用submit事件来提交数据，同步提交是直接form表单上增加属性值： action=路径, method=&quot;POST&quot;） 表单具有默认的提交行为，默认是同步的，同步表单提交缺点： 1.浏览器会锁死（转圈儿）等待服务端的响应结果。 2.表单的同步提交之后，无论服务端响应的是什么，都会直接把响应的结果（res.send()）覆盖掉当前页面。（上面crude案例没有覆盖是因为，每次post请求后都直接重定向了） 3.用户提交表单之后，页面重新渲染显示仅仅有“密码/邮箱已存在，请稍后重试”的另外一个页面，重新更改需要后退网页进行再次表单修改、提交，所以体验很不好，所以后面采用了直接res.render(当前页面, {数据渲染})+提示的方法 优点：由服务端处理，更加安全一点 异步提交: 减少服务器压力，让客户端处理更多交互效果 //&lt;form id=\"login_form\"> &lt;button type=\"submit\">登录&lt;/button> &lt;/form> $('#register_form').on('submit', function (e) { e.preventDefault() var formData = $(this).serialize() $.ajax({ url: '/register', type: 'post', data: formData, dataType: 'json', success: function (data) { var err_code = data.err_code if (err_code === 0) { // window.alert('注册成功！') // 服务端重定向针对异步请求无效 window.location.href = '/' } else if (err_code === 1) { window.alert('邮箱已存在！') } else if (err_code === 2) { window.alert('昵称已存在！') } else if (err_code === 500) { window.alert('服务器忙，请稍后重试！') } } }) }) 4.AJAX的使用工具jQuery中的AJAX要去github下载包，或者用script加载工具的网址 又或者在BootCDN网站上找到工具包网址，用script加载使用（相对于github网址更快速） 但是不建议在React、Vue里使用 get和post $.get(url, 参数, callback, type) $.post(url, 参数, callback, type) 回调函数里接收的data为响应，即服务器里send的数据 type：如响应体类型’json’则将json字符串转化为对象 &lt;button>get&lt;/button> &lt;button>post&lt;/button> &lt;script> $('button').eq(0).click(function () { $.get('http://127.0.0.1:8000/server/jquery', { a: 100, b: 200 }, function (data) { console.log(data); }, 'json'); }); $('button').eq(1).click(function () { $.post('http://127.0.0.1:8000/server/jquery', { a: 100, b: 200 }, function (data) { console.log(data); }); }) 另外一种方式，可定义的属性操作比较灵活、结构清晰，但是相对以上两种方式代码以较复杂 $('button').eq(2).click(function () { $.ajax({ url: 'http://127.0.0.1:8000/server/jquery', data: { a: 100, b: 200 }, type: 'GET', //把接收到的数据转成对象 dataType: 'json', // 成功的回调 success: function (data) { console.log(data); }, timeout: 2000, // 失败的回调 err: function () { console.log('出错啦！'); }, //头信息 // headers: { // c: 300, // d: 400 // } }) }) Axios目前（2020）年最热门的ajax工具库，要去github下载包，或者用script加载工具的网址 又或者在BootCDN网站上找到工具包网址，用script加载使用（相对于github网址更快速） 项目中使用axios居多、支持Promise（当成Promise对象来看待） axios常见配置 url：请求地址 method：请求方法 baseURL：请求根路径 transformRequest:[function(data){}]：请求前数据处理 transformResponse:[function(data){}]：请求后数据处理 headers:{‘x-Requested-With’:’XMLRequest’}：自定义请求头 params：URL查询对象（一般用于get请求） axios的通用方式和jQuery的方式都很像 btn[2].addEventListener('click', function () { axios({ method: 'POST', url: 'http://127.0.0.1:8000/axios', params: { id: 100, level: 500 }, headers: { a: 100, b: 200 }, // 请求体参数 data: { username: 'allen', password: 123456 } }).then(res => { //处理返回结果 console.log(res); }) }) get&amp;postget方法：axios.get(url[, config]) 如果不想把对应参数直接拼接到 url 的后面，则可以把对应参数放到params btn[0].addEventListener('click', function () { axios.get('http://127.0.0.1:8000/axios', { // url参数 params: { ID: 12345 }, }).then(value => { //这里没有使用回调函数，因为axios支持Promise，所以使用痛恨处理回调 //value是一个对象，里面包含了响应的各类信息 console.log(value); }); }); post方法：axios.post(url[, data[, config]]) 一般可以把对应参数放到data（即request.body） btn[1].addEventListener('click', function () { axios.post('http://127.0.0.1:8000/axios', { // post第二个参数可以设置请求体 username: 'allen', password: 'allen' }, { //设置其他参数，如headers等 }) }); axios.all我们在Promise中学习过处理相互依赖的并发网络请求解决方法（多个并发网络请求的响应全部到达后才去做相应处理） 但是axios本身支持支持Promise语法，所以可以直接使用 axios.all([axios(), axios().....]).then(result =&gt; {}) axios.all([ axios({url: ''}), axios({url: ''}) ]).then(results => { // results是一个数组，它包含以上异步操作的结果 console.log(results[0], results[1]); }) 全局配置事实上，在开发中很多参数都是固定的 这时候我们可以进行一些抽取，也可以利用axios全局配置 axios.defaults.配置 axios.defaults.baseURL = 'http://123.207.32.32:8000'; axios.defaults.timeout = 5000; 之后不用再次在axios中设置了（除非你想更改），已经有了默认值 axios实例和模块封装有时我们需要从不同的服务器发送请求，则需要对应不同的ip地址，这时设置全局配置不太合适 所以一般都是创建对应axios实例进行配置 // 创建实例 const instance = axios.create({ // 在里面进行实例的基本配置 baseURL: 'http://123.207.32.32:8000', timeout: 5000 }); instance({ url:'/home/multidata' }).then(res => { console.log(res); }) 而且在开发过程中，不推荐组件内直接引用第三方的 axios 进行依赖，如果有一天axios不再进行维护，改动时会十分麻烦 所以我们可以对其进行模块封装： 在src文件夹下，新建一个network文件夹，然后再该文件夹下新建一个 request.js 文件 在里面撰写基于 axios 发送网络请求、不同实例的代码 //request.js import axios from 'axios' export function request(config) { // 1.创建axios实例 const instance = axios.create({ baseURL: 'http://123.207.32.32:8000', timeout: 5000, }) return instance(config); } //main.js // 使用封装request模块 import { request } from './network/request' request({ url: '/home/multidata' }).then(res => { console.log(res); }).catch(err => { console.log(err); }) axios拦截器axios提供了拦截器，用于我们在每次发送请求或者得到响应后，进行相应的处理 拦截请求：axios.interceptors.request.use(成功的回调, 失败的回调) 拦截响应：axios.interceptors.response.use(成功的回调, 失败的回调) 下面以instance为实例，进行演示 request拦截下来的config参数其实就是我们的网络请求的配置（但没有拦截下数据） response拦截下来的结果（包含数据） request拦截下来进行处理 比如：config一些信息不符合服务器要求，添加headers之类的 比如：每次发送网络请求，都希望在界面中显示一个请求的图标 比如：某些网络请求（登录（token）），必须携带一些特殊的信息 const instance = axios.create({ baseURL: '...', timeout: 5000, }) //每一次发送请求之前都会被调用 instance.interceptors.request.use(config => { console.log(config); // 拦截完后必须把配置给人还回去，不然网络请求会发送失败 return config; }, err => { console.log(err); }); //每一次得到响应，则会进入到该拦截器 instance.interceptors.response.use(res => { console.log(res); // 拦截完后必须把配置给人还回去，不然网络请求无返回结果（undefined） //这里我只返回data,不看其他res的信息 return res.data; }, err => { console.log(err); }) 利用fetch发送ajax请求fetch属于全局对象，可以直接去调用，不同下载什么包，返回的结果是一个promise对象 const fetchResponsePromise = fetch(resource [, init]) resource：url，或者一个request对象 init：可选的配置项 btn[0].addEventListener('click', function () { fetch('http://127.0.0.1:8000/fetch', { //请求方法 method: 'POST', // 请求头 headers: { name: 'Allen' }, //请求体,经MDN文档上介绍，这里可以以多种形式来撰写 body: 'username=allen&amp;age=18' }).then(res => { //返回的结果是一个promise对象,所以使用then回调方式接收和处理结果 //但是这里的res结果不是返回数据，而是提示联系服务器成功 or 失败 console.log(res); return res.json; },err => console.log(err)) //除非断网，联系不到服务器，才会被调用) .then(data => { //这里才能真正得到我们想要的数据 console.log(data); }) }) 详情可进入了解fetch介绍（十分推荐）https://segmentfault.com/a/1190000003810652 缺点：兼容性差 5.跨域同源策略同源，即（当前网页的url和ajax请求的目标资源的url之间）协议、域名、端口号必须完全相同，而ajax是默认遵从同源策略， 而违背同源策略就是跨域，假如当前网页时a.com，而你向b.com发送了请求，则此时是跨域请求 单台服务器的性能是有上限的，需要外加更多的计算机、服务器提升服务水平 满足同源的情况： btn.onclick = function () { const xhr = new XMLHttpRequest(); // 这里满足url同源策略，所以在以 //http://127.0.0.1:9000/home打开网站时,可以简写为/data xhr.open('GET', '/data'); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status >= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); } } } }; const express = require('express'); const app = express(); app.get('/home', (req, res) => { res.sendFile(__dirname + '/kuayu.html'); }); app.get('/data', (req, res) => { res.send('用户数据'); }) app.listen(9000, () => { console.log(\"服务已启动，9000端口监听中...\"); }) JSONP是一个非官方解决跨域的问题，只支持get请求。 在网页有一些标签天生具备跨域能力，比如img，link，script 而JSONP是利用script标签的跨域能力来发送请求 JSONP实现跨域原理优点：兼容性非常好 缺点：是只支持get请求，不支持post请求。 &lt;script src=\"http://127.0.0.1:9000/jsonp\">&lt;/script> app.get('/jsonp', (req, res) => { res.send('console.log(\"hello world\")'); }) JSONP跨域实例动态创建script标签，添加src值为请求的域名地址，再动态添加至body内部 const input = document.querySelector('input'); const p = document.querySelector('p'); // 声明handle函数 function handle(data) { input.style.border = \"solid 1px #f00\"; p.innerHTML = data.msg; }; input.addEventListener('blur', function () { let username = this.value; //1. 创建script标签 const script = document.createElement('script'); //2. 设置script的src属性 script.src = 'http://127.0.0.1:9000/jsonp'; //3.将script插入文档中(添加节点) document.body.appendChild(script); }) //服务器部分 //jsonp app.get('/jsonp', (req, res) => { const data = { exist: 1, msg: '用户名已经存在' }; // 转字符串再调用handle函数 res.send(`handle(${JSON.stringify(data)})`); }) 所以使用jsonp传输数据时，后端需要处理数据讲数据转换为json格式 jQuery实现跨域功能$(*selector*).getJSON(*url,data,success(data,status,xhr))* getJSON() 方法使用 AJAX 的 HTTP GET 请求获取 JSON 数据。而跨域的实现是通过在url后增加&#39;?callback=?&#39;，并且在服务器上调用接收jQuerycallback参数的函数 $('button').eq(0).click(function () { // 在jQuery里发送JSONP请求,这里第一个参数后一定要加'?callback=?' $.getJSON('http:127.0.0.1:9000/jQuery-jsonp?callback=?', function (data) { console.log(data); $('#result').html(` 名称: ${data.name},&lt;/br> 城市: ${data.city[1]} `) }); }) //服务器部分 app.get('/jQuery-jsonp', (req, res) => { const data = { name: 'Allen', city: ['北京', '澳门', '广州'] }; // 接收jQuerycallback那个参数 let cb = req.query.callback; // 转字符串再调用handle函数 //cb实际上是jQuery+一串数字，但他保存的其实是调用jQuerygetJSON里的回调函数 res.send(`${cb}(${JSON.stringify(data)})`); }) CORS解决跨域问题CORS，跨域资源共享，它是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊操作，完全在服务器中进行处理，支持get、post请求，跨域资源共享标准新增了一组http首部字段，允许服务器声明哪些源站通过浏览器权限访问哪些资源 工作原理：设置一个响应头（使用自定义的HTTP头部）告诉浏览器，该请求允许跨域，然后浏览器收到该响应以后对响应放行 setHeader(&quot;允许跨域响应头&quot;, &quot;*&quot;); 设置允许跨域的响应头,有Access-Control-Allow-Origin、Access-Control-Expose-Headers、Access-Control-Max-Age、Access-Control-Allow-Credentials、Access-Control-Allow-Methods、Access-Control-Allow-Headers 第二个参数*是通用的意思，也可以设置专用的url //服务器部分 app.all('/CORS', (req, res) => { // 设置允许跨域的响应头 res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); res.setHeader(\"Access-Control-Allow-Headers\", \"*\"); //这里表示的是只有地址为http://127.0.0.1:5500这样的网页，才能向我们这个服务发送请求 // res.setHeader(\"Access-Control-Allow-Origin\", \"http://127.0.0.1:5500\"); res.send('hello world'); }) 或者是这个（append是追加http响应头） app.use((req, res, next) => { res.append(\"Access-Control-Allow-Origin\", \"*\") res.append(\"Access-Control-Allow-Content-Type\", \"*\") next(); }) 如果设置请求头不行的话可以安装 CORS （1）安装cors： npm install cors express –save （2） 然后在文件中引用： var cors = require('cors'); var express = require('express'); var server = express(); server.use(cors()); 但实际上，上线的网站，很少用cors解决跨域，因为加上这个意味着很多网站都可以访问你 复杂请求和简单请求在涉及到CORS的请求中，我们会把请求分为简单请求和复杂请求。 浏览器限制跨域请求一般有两种方式： 浏览器限制发起跨域请求 跨域请求可以正常发起，但是返回的结果被浏览器拦截了 一般浏览器都是第二种方式限制跨域请求，那就是说请求已到达服务器，并有可能对数据库里的数据进行了操作，但是返回的结果被浏览器拦截了，那么我们就获取不到返回结果，这是一次失败的请求，但是可能对数据库里的数据产生了影响。为了防止这种情况的发生，规范要求，对这种可能对服务器数据产生不可预测影响的HTTP请求方法，浏览器必须先使用OPTIONS方法发起一个预检请求，从而获知服务器是否允许该跨域请求：如果允许，就发送带数据的真实请求；如果不允许，则阻止发送带数据的真实请求。 （OPTIONS不会携带请求参数和cookie,也不会对服务器数据产生副作用） 复杂请求：会发送发预检请求（OPTIONS请求） 简单请求 那么有哪些简单请求呢？以下是来自MDN官方引用： 1、使用下列方法之一： GET、 POST、 HEAD。 2、不得人为设置该集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type 3、Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded4、请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问 5、请求中没有使用 ReadableStream 对象 那什么是复杂请求呢，除了简单请求都是复杂请求。 postMessage这是由H5提出来的的API，IE8以上支持这个功能。window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，都遵循同源策略才能够实现通信。 window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全，原理是将通过消息事件对象暴露给接收消息的窗口。 nginx代理跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本（没有使用ajax，ajax遵守同源策略），不需要同源策略，也就不存在跨越问题。 实现思路： 通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 json文件实现代理代理未使用ajax，所以不需要遵守同源策略，但代理的域名、端口号、协议均和客户端同源，所以可以进行信息交互 比如在React中的package.json进行配置 { \"proxy\":\"http://localhost:5000\" } 然后axios向本地的代理服务器发送请求（此时本地搭建项目地址为localhost:3000） axios.get('http:localhost:3000/students').then(res => console.log(res)) //此时先去本地3000找该资源，找不到就去到5000找 优点：配置简单 缺点：但是注意这个方法只能代理一个网址，这是个取巧的方式，当我同时需要对 “http//localhost:5000”、”http//localhost:5001”发送请求，就不可以使用了，此时React可以新建一个setupProxy.js 进行正向代理 6.websocket实践在计网personnel篇章中我们阐述了websocket的实现原理，websocket协议让服务端实现向客户端主动推送消息的功能，不再需要采用旧版Ajax轮询这种浪费资源的方式。 websocket基于http 1.1协议 来自客户端的握手形式 GET ws://localhost/chat HTTP/1.1 Host: localhost Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Sec-WebSocket-Extension: permessage-deflate Sec-WebSocket-Version: 13 Upgrade表明是一个升级链接，升级为websocket Sec-WebSocket-Key是客户端采用base64位随机字符序列，服务器接收客户端HTTP协议升级的证明，用于标识该客户端，要求服务端响应一个对应的加密 Sec-WebSocket-Accept Sec-WebSocket-Extension协议拓展类型 来自服务端的握手形式 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Sec-WebSocket-Extension: permessage-deflate 客户端的实现创建websocket对象 var aWebSocket = new WebSocket(url [, protocols]); url 要连接的URL；这应该是WebSocket服务器将响应的URL。 protocols 可选 一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个WebSocket子协议（例如，您可能希望一台服务器能够根据指定的协议（protocol）处理不同类型的交互）。如果不指定协议字符串，则假定为空字符串。 // H5已经提供了websocket的API，可以直接使用 //这是人家websocket官方提供测试的url let socket = new WebSocket('ws://echo.websocket.org') websocket事件 事件 事件处理程序 描述 open websocket对象.onopen 建立连接时触发 message websocket对象.onmessage 客户端接收服务端数据时触发 error websocket对象.onerror 通信发生错误触发 close websocket对象.onclose 连接关闭触发 websocket方法 send()方法，，用于给服务端发送数据 然后再浏览器调试可以看到我们发送成功了 //H5已经提供了websocket的API，可以直接使用 //这是人家websocket官方提供测试的url let ws = new WebSocket('ws://echo.websocket.org'); // 1.连接成功的回调 ws.addEventListener('open', function () { console.log('连接成功'); }) // 2.主动给websocket发消息 button.addEventListener('click', function () { let val = input.value; ws.send(val) }) // 3.接收websocket服务的数据，通过事件对象e可以得到服务端返回的数据 ws.addEventListener('message', function (e) { console.log(e); div.innerHTML = e.data; }) 服务端的实现这里我使用的是nodejs带的websocket包（https://github.com/sitegui/nodejs-websocket 这个是该包对应的源码地点，里面有详解该包创建服务对象后，可以使用的方法） npm install nodejs-websocket 在新建的nodejs服务器上使用 每一次只要有用户进行连接，就会执行该回调函数，然后给当前用户创建一个connect对象 const ws = require(\"nodejs-websocket\") const server = ws.createServer(function (connect) { console.log(\"New connection\") //text事件用于接收用户请求，data为用户发送的数据 connect.on(\"text\", function (data) { console.log(\"Received \" + data) //服务器给客户端发送响应 connect.sendText(data.toUpperCase() + \"!!!\") }) //websocket连接断开（用户关闭网页等操作），执行的回调函数 connect.on(\"close\", function (code, reason) { console.log(\"Connection closed\") }) //一般使用注册close伴随着一个error事件，处理用户错误信息 connect.on('error', () => { console.log('用户连接异常'); }) //监听端口5208 }).listen(5208, () => { console.log('app is running at port!'); }) 给所有用户发送信息（广播）的方法 broadcast function broadcast(server, msg) { server.connections.forEach(function (conn) { conn.sendText(msg) }) } 然后在每个connect对象的事件里调用 broadcast(msg)即可，如果msg是一个对象，要将对象转化为字符串才能发送 send(JSON.stringfy(msg)) websocket框架可以从上面看到，我们使用websocket时每一步事件都需要我们自己去封装，支持的时间太少，可能会比较麻烦，在应对搞复杂度的代码是会略显冗杂； 我们可以使用websocket框架 socket.io 进行替代 + 完善 说是说框架，但官方也解释了socket.io并不是websocket的一个实践，即使他在其中有使用到websocket的传输协议，但它作出了许多拓展，这就是为什么 WebSocket 客户端无法成功连接到 Socket.IO 服务器，而 Socket.IO 客户端也无法连接到普通 WebSocket 服务器的原因。（但在实现功能上，我们可以看成是一致的） 附上官网 https://socket.io/ 服务端使用npm install socket.io 在express中可以使用（官网还有在typescript、koa等语言框架中使用的方法） const app = require(\"express\")(); const httpServer = require(\"http\").createServer(app); //以前我们使用原生nodejs创建服务器、发送请求调用过http包 const options = { /* ... */ }; const io = require(\"socket.io\")(httpServer, [options]); httpServer.listen(3000); 1.此时监听用户连接事件 io.on(&quot;connection&quot;, socket =&gt; {}) socket 参数表示当前用户 socket.emit(事件名, 传入数据参数)socket主动触发事件的方法 socket.on(事件名, 接收数据参数)socket监听浏览器（客户端）/ 服务器 事件的方法 事件名参数是自定义的，该传递方式有点像Vue的事件总线（eventbus），实行订阅和发布消息数据 广播消息: io.emit io.on io.on(\"connection\", socket => { /* ... */ socket.emit('send', {name:'Allen'}); //发送数据到客户端 }); 2.此时监听用户断开事件 io.on(&quot;disconnect&quot;, () =&gt; {}) 3.跨域问题 注意：在 socket.io 中使用 cors允许跨域时，必须在option选项里进行设置，不然会报错 // socket 初始化 const io = require(\"socket.io\")(server, { cors: true }) 客户端使用安装 &lt;script src = \"/socket.io/socket.io.js\" > &lt;/script> &lt;script> const socket = io(); &lt;/script> or $ npm install socket.io-client 在同一个域通信 const socket = io(); 不同域通信 const socket = io(\"服务器地址url\"); 相对服务端，客户端并不需要将监听和发布时间放在 io.on(&quot;connection&quot;, () =&gt; {})里面，直接在script/ js文件里使用 socket.emit(事件名, 数据参数) / socket.on(事件名, 数据参数) 来实施客户端的事件监听和发布 踩坑之路： 部署到服务器上时，url地址记得为协议名 + ip + 端口号","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript进阶ES6","slug":"JavaScript进阶ES6","date":"2020-12-27T02:02:23.693Z","updated":"2021-08-22T11:40:46.025Z","comments":true,"path":"2020/12/27/javascript-jin-jie-es6/","link":"","permalink":"https://taylor12138.github.io/2020/12/27/javascript-jin-jie-es6/","excerpt":"","text":"1.ESMAScript6ES6其实是一个泛指，泛指ES2015后续的版本 2.新增语法声明变量ES5之前因为if、for都没有块级作用域的概念，所以很多时候都需要借助 function的作用域 解决应用外部变量的问题 let 声明的变量 1.只在所处块级有效（大括号中有效，也就是说if和for都有它的块级作用域了），可以防止循环变量变成全局变量 2.不存在变量提升，只能先声明再使用，不可重复声明 3.暂时性死区（即在块级作用域中使用某变量，则会先在该块级中查找此变量） var num = 10; if(true) { console.log(num); //报错，变量声明在后面 let num = 20; } 利用let解决异步问题：（因为let仅在当前块级有效，每个迭代蓄奴含声明一个新的迭代变量，每个setTimeout引用的都是不同的实例） for (let i = 0; i &lt; lis.length; i++) { lis[i].onclick = function () { console.log(i); } } const声明常量，常量就是值（内存地址）不能变化的量（值可以改，内存地址不能变） 1.具有块级作用域 2.const声明常量时必须赋值 3.基本数据类型：常量赋值后，不可修改；复杂数据类型：对象赋值后（数组之类的）不可更改，但是可以更改数据结构内部的值 4.不存在变量提升，只能先声明再使用 const ary = [100, 200]; ary[0] = 'a'; //可以 //ary = ['a', 200]; //不可以 解构赋值ES6允许从数组或者对象（分别使用[]、{}）中一一提取值，按照对应的位置，对变量赋值 //数组 let ary = [1, 2, 3]; let [a, b, c, d, e] = ary; //1, 2, 3, undefined, undefined //也可以 let [a, b, c] = [1, 2, 3]; //对象 let person = {name: 'zhangsan', age: 20}; let {name, age} = person; let {name, age = 18} = person; //解构赋值，如果原来person没有age属性，则定义默认值age = 18 对象的另一解构写法（重命名） let {name: myName, age: myAge} = person; 如果name和age分别和person中的属性值匹配成功，则将左侧该属性值赋值给右边的myName，myAge变量 除此外，还有嵌套解构赋值写法 //4.对象的解构赋值 let obj = {a:{b:1}}; const {a:{b}} = obj; //我们得到b的数据 console.log(b); //1 箭头函数(形参) =&gt; {函数体} 箭头函数用来简化定义函数语法 const fn = () => { console.log('xx'); } // 也可以，返回undefined //const fn = () => console.log('xx'); 如果函数体只有一句话，且代码执行结果就是返回值，则可以省略大括号 //传统 function sum(num1, num2) { return num1+num2; } //new const sum1 = (num1, num2) => num1+num2; 如果形参只有一个，小括号可以省略 //传统 function sum(a) { return a; } //new const sum1 = a => a; 如果返回的是一个对象，不能直接加大括号 //const sum1 = a => {}; 错，返回undefined const sum1 = a => ({}); //对 箭头函数和传统函数不一样，箭头函数的this指向函数定义位置（使用了箭头函数的那个函数）的上下文this（定义函数地点最近作用域中的this），所以 1. 箭头函数不适合事件回调 function fn() { console.log(this); return () => { console.log(this); } } const obj = { name: 'zhangsan' }; const resFn = fn.call(obj); //这时this指向obj，所以箭头函数跟着指向obj 返回{ name: 'zhangsan' } resFn(); //箭头函数中this指向指向上下文this，此时箭头函数this跟着上下文this发生改动，输出{ name: 'zhangsan' } 2.不适合对象的方法 对象不能产生作用域，所以箭头函数实际被定义在全局作用域下，所以此处的this指向window，所以箭头函数处的this.age未定义 var obj = { age: 20, say: () => { alert(this.age); //undefined }, con: function () { console.log(this); //obj } } obj.say(); obj.con(); const obj = { aaa() { setTimeout(function () { setTimeout(function () { console.log(1, this); //window }) setTimeout(() => { console.log(2, this); //window }) console.log(3, this); //window }) setTimeout(() => { setTimeout(function () { console.log(4, this); //window }) setTimeout(() => { console.log(5, this); //obj }); console.log(6, this); //obj }); } } arguments的使用当我们不确定函数用多少个参数来传递的时候，arguments实际上是当前函数的一个内置对象（函数才拥有），arguments储存了传递的所有实参,它展示的方式是伪数组，因此可以进行遍历（使用for等） 注意： 箭头函数是用不了arguments（虽然箭头函数也用不了它，但是可以使用剩余参数补足） arguments对象的值不反应参数的默认值（当函数设置了默认参数值），它始终以调用函数时传入的值为准 function fn(){ console.log(agruments); console.log(agruments.length); } fn(1,2,3); //则输出1，2，3 arguements 的值始终会与对应的命名参数同步（修改arguments[i]，会对应修改第i个参数的值），但这并不意味着它们都访问同一个内存地址，这种同步是单向的，修改命名参数的值，不会影响argument[i] 对应的值 function a(a, b) { arguments[0] = 100; console.log(a, 'this is a'); //100 a = 50; console.log(arguments[0], 'this is argument[0]'); //100 } let aaa = 1, b = 2; a(aaa, b) console.log(aaa); //1 伪数组：1.具有length属性 2.按索引凡是储存数据 3.不具有push，pop功能 剩余参数剩余参数语法（展开运算符）允许我们将一个不定数量的参数表示为一个数组 ...args 潜规则： ...args要放到参数的最后，不然会报错 //1.作为传参（rest参数） function sum(first, ...args) { console.log(first); //10 console.log(args); //20, 30 } sum(10, 20, 30); //2.剩余参数配合解构 let students = ['allen', 'berry', 'david']; let [s1, ...s2] = students; //s1为allen，s2为[berry. david]的数组 //3.作为参数传入，将数组arr2里的数据划分成若干个，然后一个一个传入数组arr1：（扩展运算符） arr1.push(...arr2); 和arguments不一样的是，arguments得到的是一个对象，而…args中 args得到的是一个数组，可以使用数组方法（filter、some、map、every等） function data1(){ console.log(arguments); } function data2(...args){ console.log(args); } 利用args手写new function _new(Constructor, ...args) { var obj = {}; obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, args) return ret instanceof Object ? ret : obj; } function One(a) { this.a = a; } let a = new One('good'); let b = _new(One, 'good'); console.log(a); console.log(b); 展开运算符剩余语法(Rest syntax) 看起来和展开语法完全相同，不同点在于, 剩余参数用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：展开语法将数组展开为其中的各个元素，而剩余语法则是将多个元素收集起来并“凝聚”为单个元素。（来源于MDN） 运用于数组 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; arr1 = [...arr2, ...arr1]; 一般展开运算符只能展开可迭代对象，对于对象，但是可以 使用 let person1 = {...person2}进行展开 参数默认值可以给函数附上默认的参数值，在调用时没有给到的形参会用默认值代替 一般具有默认值的参数都靠后（潜规则） function add(a, b ,c=10){ return a + b + c; } console.log(add(1, 2)); //13 3.ES6内置对象的扩展array的扩展 ...ary 扩展运算符是和剩余参数相反的原理，它可以将数组或者对象转为用逗号分隔的参数序列 ...ary let ary = [1, 2, 3]; console.log(...ary); // 1, 2, 3 //相当于 console.log('1', '2', '3'); 扩展运算符应用：数组合并 //方法一： let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; //方法二 ary1.push(...ary2); ...ary扩展运算符还能把伪数组转换成真正的数组，然后可以使用数组的方法 Array.from() 同样的，构造函数方法Array.from() 也可以将类数组或可遍历对象转换成真正的数组（如果是对象必须要有length属性） （浅拷贝的数组实例） let arraylike = { 0: 'a', 1; 'b', length: 2 }; let arr2 = Array.from(arraylike); //[a, b] 但是Array.from还可以接收一个函数，用来对每个元素进行处理，将处理后的值放入返回的数组 Array.from(数组, 形参item =&gt; {函数体}) let arraylike = { 0: 1, 1; 2, length: 2 }; let arr2 = Array.from(arraylike, item => item * 2); //[2, 4] find() 用于找出第一个符合条件的数组成员，如果没有找到返回undefined let ary = [{ id: 1, name: 'A' },{ id: 2, name: 'B' }]; let arr2 = ary.find((item, index) => item.id == 2); findIndex() 用于找出第一个符合条件数组成为的位置，如果没有返回-1 如let index = ary.findIndex((value, index) =&gt; value &gt; 9); includes() 表示某个数组是否包含给定的值，返回布尔值（之前是使用indexof进行判断，但是表达比较晦涩，这个是新增的） string的拓展ES6新增的创建字符串的方式，使用反引号定义 let name = allen;(模板字符串) 模板字符串的特点： 1.可以解析变量，不用字符串拼接${变量名} 2.可以换行，撰写较为美观 3.可以调用函数，得到的结果为函数返回值${函数名()} const saySomething = () => '我是函数'; let a = `allen`; let = `hello, my name is ${name}`; let html = `&lt;div> &lt;span>${saySomething()}&lt;/span> &lt;/div>`; startsWith() 表示参数字符串是否以原字符串开头，返回布尔值 endsWith()表示参数字符串是否以原字符串结尾，返回布尔值 let str = 'hello world !'; str.startsWith('hello'); //true str.startsWith('!'); //true repeat() repeat方法表示将原字符串重复n次，返回一个新字符串 ，如&#39;x&#39;.repeat(3) 返回 xxx set数据结构ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值（不会存储重复的值）、自动去重 集合实现了 iterator接口，所以可以使用 for of Set本身是一个构造函数，用来生成Set数据结构 const s = new Set([\"a\", \"a\",\"b\"]); console.log(s.size); const ary = [...s]; //数组去重 s.add(value) 添加某个值，返回Set结构本身 s.delete(value) 删除某个值，返回布尔值表示删除成功与否 s.has(value) 返回布尔值，查看是否为Set成员 s.clear() 清空所有成员 s.values()查看所有元素 s[Symbol.iterator] s.size() 返回Set实例的成员总数 Set结构实例与数组一样，也有forEach方法，用于对每个成员执行某种操作，没有返回值 map数据结构 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key），“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键 （Object的键只能为字符串，其实还能为数值或符号，但它们都会转化为字符串）。 Map 的遍历顺序就是插入顺序。 使用对象作为键是 Map 最值得注意和重要的功能之一 let map = new Map(); let john = { name: \"John\" }; map.set('1', 'str1'); // 字符串键 map.set(1, 'num1'); // 数字键 map.set(true, 'bool1'); // 布尔值键 map.set(john, 123)); // 对象键 // 还记得普通的 Object 吗? 它会将键转化为字符串 // Map 则会保留键的类型，所以下面这两个结果不同： alert( map.get(1) ); // 'num1' alert( map.get('1') ); // 'str1' alert( map.size ); // 3 方法 + 属性 new Map() —— 创建 map。 map.set(key, value) —— 根据键存储值。 map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。 map.has(key) —— 如果 key 存在则返回 true，否则返回 false。 map.delete(key) —— 删除指定键的值。 map.clear() —— 清空 map。 map.size —— 返回当前元素个数。 map.keys() —— 遍历并返回所有的键（returns an iterable for keys）， map.values() —— 遍历并返回所有的值（returns an iterable for values） map.entries()—— 遍历并返回所有的键值对，entries实际上是引用了 [Symbol.iterator]这个属性 map.entries === map[Symbol.iterator] //true 只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。 const map = new Map(); map.set(['a'], 555); map.get(['a']) // undefined map和Object对比： 1.内存占用：给固定大小的内存，Map大约可以比Object多存储50%键值对 2.插入性能：Object和Map插入新的键值对消耗大致相当，不过插入Map在所有浏览器中一般会稍微快一点儿 3.查找速度：与插入不同，从大型Object和Map中查找键值对的性能差异极小，如果涉及大量查找工作（对两个类型而言，查找速度不会随着键值对数量增加而增加），某些情况可能Object更好一点 4.删除性能：删除Objcet属性的性能一直以来饱受诟病，而对于大多数浏览器引擎来说，Map的delete()删除操作甚至比插入和查找更快，无疑时Map完胜 弱引用类型（很多属性、迭代方法不能用 + 保存的元素有限制） let s = new WeakSet()保存的元素必须得是引用类型（对象 / 数组）（DOM元素也是对象，所以也能存储） let map = new WeakMap()的key 必须得是引用类型（对象 / 数组）（DOM元素也是对象，所以也能存储） 弱引用不支持遍历方法，只有四个方法可用，get()、set()、has()、delete() 正常引用类型的垃圾回收： 谁引用这个数据，就引用次数 + 1， 原来引用这组数据，后面赋值为null，引用次数 -1 当这组数据引用次数为0，则根据垃圾回收机制会被回收掉 弱引用类型的垃圾回收： 当weak弱引用数据时，引用次数不会 + 1 这样的话优点就是，清除变量的时候，不用再去weak弱引用类型那里进行清除（不用赋值null） obj的拓展利用对象字面量创建对象即直接用{}创建对象而不是new出来，而ES6新增对象字面量的增强写法 const name = 'Allen'; const age = 18; const height = 1.88; // ES5对象字面量各类属性、函数写法 obj = { name: name, age: age, height: height, run: function () { } }; // ES6对象字面量各类属性、函数写法 obj2 = { name, age, height, run() { } //此写法仅支持在字面量/类中 }; 判断一个对象是否为空，可以使用 Object.key(对象名称).length === 0js 判断对象的属性是否存在 in运算符 （属性名 in 对象） 情况1:对象自身属性 var obj={a:1}; \"a\" in obj//true 情况2:对象继承的属性 var objA = {a:1}; var objB = Object.create(A) \"a\" in objB //true 查找符合条件的第一个对象 find(function(currentValue, index, arr),thisValue) 参数 描述 currentValue 必需。当前元素 index 可选。当前元素的索引值 arr 可选。当前元素所属的数组对象 thisValue 可选。 传递给函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值 //实现一步查找符合条件的product let product = state.cartList.find(item => item.id === payload.id); 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined。 对象使用变量名作为键名 let a = 'name'; let obj = {}; //obj.a = 'Allen'错误！ obj[a] = Allen //正确 又或者 let a = 'name'; let obj = { [a]:'Allen' }; 4.Promisecallback hell回调地狱：callback hell，异步里面套着另一个异步 无法保证异步任务执行顺序： var fs = require('fs'); fs.readFile('./index.txt', function (err, data) { if (err) { // throw的作用：抛出异常 //即1.阻止程序的执行， 2.把错误信息打印到控制台 throw err; } console.log(data); }); fs.readFile('./index2.txt', function (err, data) { if (err) throw err; console.log(data); }); fs.readFile('./index3.txt', function (err, data) { if (err) throw err; console.log(data); }); 通过回调嵌套的方式来保证顺序，但由此催生了回调地狱，语法十分丑陋，代码丑陋 fs.readFile('./index.txt', function (err, data) { if (err) { // throw的作用：抛出异常 //即1.阻止程序的执行， 2.把错误信息打印到控制台 throw err; } console.log(data); fs.readFile('./index2.txt', function (err, data) { if (err) throw err; console.log(data); fs.readFile('./index3.txt', function (err, data) { if (err) throw err; console.log(data); }); }); }); Promise为了避免回调地狱嵌套，所以ES6中新增了API：Promise（生产微任务） 应用场景：数据来源于多个接口，出现回调嵌套 Promise本身不是异步的，只是里面的任务往往都是异步的 new Promise(resolve => { resolve(); console.log(\"promise\"); }).then(value => console.log(\"success!\")); console.log(\"end\"); //执行顺序: //promise //end //success! 创建一个promise容器 =&gt; 而这里容器一旦创建，就开始执行里面的代码 =&gt; 容器中存放一个异步任务默认pending状态，表示正准备去做，即将发生的 个人觉得：resolve和reject类似于两个callback，然后再外面进行回调罢了finally()方法用于指定不管Promise对象最后状态如何，都会执行的操作，该方法时ES2018引入的标准 var fs = require('fs'); //封装实例化Promise+读取数据API function ProReadFile(Path) { return new Promise(function (resolve, reject) { fs.readFile(Path, 'utf8', function (err, data) { if (err) { // 失败了，承诺容器中的任务失败 // 把容器的pending状态改为Rejected // 调用reject相当于调用了then方法第二个参数函数 reject(err); } else { // 承诺容器中的任务成功 // 把容器的pending状态改为成功Resolved // 调用resolve相当于调用了then方法第一个参数函数 resolve(data); } }) }); }; 当返回结果成功后，then做指定操作 使用Promise过程中resolve或reject后，后面代码还会执行，除非你直接return then的说明： then(resolve(), reject()) 成功状态Fulfilled时（resolve，成功则进入下一个then），then方法接收两个参数:1.容器中的resolve函数, 2.容器中的reject函数，这里把then看成一个整体，then会默认返回一个fulfilled状态的Promise 失败状态Rejected（自己设置判断失败的条件，然后reject函数），会回调catch 在类里面定义 一个then方法，那么他会包装成一个Promise，但是注意这个Promise 默认没有状态，需要手动去 resolve 或者 reject ProReadFile('./index.txt') .then(function (data) { console.log(data); //当第一个读取成功时，这里返回后面想要继续执行的Promise异步任务，如果没有返回，则后面收到的是undefined //我们真正有用的是return 一个Promise对象 //如果return 123，则接下来的then的function参数接受的data是123，而且并不是前面的异步任务执行完毕才进入下一个then return ProReadFile('./index2.txt'); }, err => { console.log('读取文件失败', err); throw 'error message'; //要调用这个，不然返回undefined，会进入下一个then的resolve的回调 }) .then(function (data) { console.log(data); //第二个读取成功时，这里返回后面想要继续执行的Promise异步任务 return ProReadFile('./index3.txt'); }, err => { console.log('读取文件失败', err); throw 'error message'; }) .then(function (data) { console.log(data); }, err => { console.log('读取文件失败', err); }) catch效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中（推荐把catch放在链式结构的最后，前面无论第几个出错，都会跑到最后执行这个catch（除非你事先在前面用reject的回调函数处理过错误结果了））。请看下面的代码： ProReadFile('./index.txt') .then(function (data) { console.log(data); return ProReadFile('./index2.txt'); }).catch(err => {console.log('文件读取失败', err)}) 特殊情况状态传递 注意：如果resolve或reject中的参数是promise实例对象 var p1 = new Promise(function (resolve, reject) { setTimeout(function () { resolve('1'); }, 3000); }) var p2 = new Promise(function (resolve, reject) { setTimeout(function () { resolve(p1); // resolve的参数是一个promise对象 }, 1000); }); p2 .then(function (data) { console.log('resolve执行') console.log(data) }, function (err) { console.log(err) }) 3s后依次打印 ‘resolve执行’ ‘1’ （时间 = max （p1的定时时长, p2的定时时长）） 这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。（实际上有点像是promise.allSettle的原理？） let p1 = new Promise((resolve, reject) => { reject(\"拒绝\"); }) new Promise((resolve, reject) => { resolve(p1); }).then(res => { console.log(\"res\"); }, err => { console.log(\"err\", err); }) //err 拒绝 上面说到p1的状态会传递，所以这里p1的状态是Rejected，传递给了下面这个Promise，执行的是Rejected的回调 返回值问题 注意 如果返回值为一个普通参数 then方法会返回一个新的promise,这个新promise的value由return的值决定 执行return语句后不是Promise实例，是123，则导致当前then方法返回的promise变为成功状态 pending-&gt;fulfilled(Resolved) 在这里它其实是 return new Promise.resolve(123)的简写 var p2 = p1.then(function (data) { console.log(data); return 123456 }, err => { console.log('读取文件失败', err); }) .then(function (data) { console.log(data); // 这个回调一定会被调用，打印123456 }, err => { console.log('读取文件失败', err); }) 注意 甚至没有返回值时，它还会自动给你 pedding -&gt; fulfilled，（因为会返回默认返回值undefined）然后进入下一个then的第一个成功的回调函数里 而反而如果你 return 了一个promise实例，在这个实例里面没有调用 resolve 或者 reject，就进入不了下一个then里面 所以！！！ 因为异步操作我们才使用Promise，而返回值非Promise的情况会导致未执行完异步操作则直接进入下一步的then里面，这样和原来未使用Promise语句地执行方式相同，和我们想要有序地进行异步操作的初衷背道而驰 所以我们推荐返回值返回一个 new Promise，这样等到Promise实例调用resolve / reject后才会进入下一步then，才符合我们的代码规范和初衷！！ 直接抛出异常问题 注意 如果想要返回后直接跳转到下一个then的reject函数里，可以直接 throw ErrorMessage 执行throw语句后，导致当前then方法返回的promise变为失败状态 pending-&gt;Rejected 因为它其实是 return new Promise.reject(&#39;error message&#39;)的简写 var p2 = p1.then(function (data) { console.log(data); throw 'error message'; }, err => { console.log('读取文件失败', err); }) .then(function (data) { console.log(data); }, err => { console.log('读取文件失败', err); // 这个回调一定会被调用 }) 双重then问题 注意 then方法提供一个供自定义的回调函数，若传入非函数，则会忽略当前then方法。 以下的例子就是忽略了第一个then，因为它未传入函数，传入的是 ‘新的值’ let func = function() { return new Promise((resolve, reject) => { resolve('返回值'); }); }; let cb = function() { return '新的值'; } func().then(cb()).then(resp => { console.warn(resp); console.warn('========='); }); //输出：返回值 ============ 状态问题 注意 在执行promise后，return时都会包装成一个新的Promise实例，但如果then方法还未被调用，则这个实例它的状态还是pedding let p1 = new Promise((resolve, reject) => { resolve(\"fulfilled\"); }) let p2 = p1.then( val => {console.log(val);}, err => {console.log(err)} ) console.log(p1); console.log(p2); setTimeout(()=>{ console.log(p1); console.log(p2); }) //输出 //Promise&lt;resolved> //Promise&lt;pending> //fulfilled //Promise&lt;resolved> //Promise&lt;resolved> Promise的all方法使用应用场景：处理多个相互依赖的异步请求 Promise.all([ new Promise((resolve, reject) => { setTimeout(() => { resolve('hello'); }, 1000); }), new Promise((resolve, reject) => { setTimeout(() => { resolve('world'); }, 2000); }) ]) // 两个网络请求都完成后才会进入then // 如果有一个失败，此回调直接失败，失败原因是那个第一个失败的promise .then(results => { // results是一个数组，它包含以上异步操作的结果 console.log(results[0], results[1]); }) 除了 all之外，还有allSettle、race方法，分别表示 allSettle：只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束，返回一个对象数组，每个对象表示对应的promise结果 race：谁执行的快就取决于谁的状态 any：只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 （感觉race方法可能是封装ajax中设置请求超时时长的原理） 有空还可以看看大佬手写promise.all和promise.race https://blog.csdn.net/qq1498982270/article/details/93922893 async和await语法糖async和await时Promise的语法糖，（个人感觉async没什么作用，因为正常情况下我们封装普通函数也可以在里面 return new Promise，只不过是await必须放到async的函数里才能被使用，汗。。。） （2021.6.27纠正，我在《红宝书的啃读》篇目解释了它们在内存中的差别） 使用 await 异步函数() 相当于 .then(res =&gt; { return 异步函数() })，处理异步任务，有异步任务 -&gt; 同步任务的感觉，记得每次都把异步任务放在await后面，而且每次在await 异步操作之后的同步任务就像被放在另一个then里面，会等待异步任务的完成后再执行 async function pro(delay = 1000) { return new Promise((resolve, reject) => { setTimeout(() => { resolve(\"hello\"); }, delay); }) } async function show() { for (const item of [\"Allen\", \"Bruce\", \"Carry\"]) { let hello = await pro(); console.log(item); console.log(\"hello\"); console.log(\"world\"); } } show(); // //原始方法 // let p = Promise.resolve(); // for (const item of [\"Allen\", \"Bruce\", \"Carry\"]) { // p = p.then((res) => { // return pro(); // }).then(() => { // console.log(item); // console.log(\"hello\"); // console.log(\"world\"); // }) // } 语法糖可以配合 then、 catch一起使用 async function fn() { return await new Promise((resolve, reject) => { setTimeout(() => { console.log(\"nononon\"); resolve(); }, 1000); }) } fn().then(res => { console.log(\"success\"); }).catch((err) => { console.log(err); }) async + await实现并行执行 （配合Promise.all） async function fn(k) { return await new Promise((resolve, reject) => { setTimeout(() => { console.log(k); resolve(k); }, 1000); }) } async function hd() { let res = await Promise.all([fn(\"hello\"), fn(\"world\")]) console.log(res); } hd(); Promise缺点 无法取消Promise,一旦新建它就会立即执行，无法中途取消。（只能抛出错误中断（throw））(JavaScript高级程序设计有提及到) 如果不设置回调函数，promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。(JavaScript高级程序设计有提及到) 可能代码撰写比较繁琐 + 冗长 5.SymbolSymbol表示独一无二的值，是ES6引入的第七种数据类型，是一种类似于字符串的数据类型（永远不会重复的字符串） 特点： Symbol的值是唯一的。解决命名冲突的问题（内部实现唯一性，不可见，也就是打印不出来） Symbol不能与其他数据进行运算（隐式类型转换会报错，但是，Symbol 值可以显式转为字符串、转为布尔值） Symbol定义的对象属性不能使用for in 、for...of 进行循环，但是可以使用 Reflect.ownKeys来获取对象的所有键名 基本创建 let s1 = Symbol(); // let s2 = Symbol('描述字符串');，我们可以通过描述字符串更好的理解这个值的作用 let s2 = Symbol('allen'); let s3 = Symbol('allen'); // 返回false，因为描述字符串类似于身份证上的名字，我们可能同名同姓但是不可能同一身份证 console.log(s2 === s3); //false Symbol.for进行创建，是作为一个函数对象，通过这种方式创建，我们是可以通过描述字符串得到得出唯一的symbol值该方法会根据给定的键 key，来从运行时的全局 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。（用于需要共享和重用符号的实例） let s4 = Symbol.for('bruce'); let s5 = Symbol.for('bruce'); //重用已有符号 console.log(s5 === s4); //true Symbol.keyFor(s4); //\"bruce\" 应用能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 注意： Symbol值作为对象属性名时，不能用点运算符。 在对象中使用变量定义属性时，必须放在方括号内，与普通键值(String)进行区分。 let mySymbol = Symbol(); // 第一种写法 let a = {}; a[mySymbol] = 'Hello!'; // 第二种写法 let a = { [mySymbol]: 'Hello!' }; a[mySymbol] // \"Hello!\" let s = Symbol(); let obj = { [s]: function (arg) { ... } }; obj[s](123); 利用Symbol的特性可定义内部私有属性或方法 function getObj(obj) { let privateKey = Symbol('privateKey'); objCopy = { ...obj } || {}; objCopy[privateKey] = function privateFunc() { console.log('privateFunc ') } return objCopy; } let newObj = getObj(); console.log(newObj[privateKey]); // 报错，外部无法获取到privateKey的值 console.log(newObj[Symbol('privateKey')]); //undefined,此时的symbol已经变成新的symbol值 Symbol的内置属性 Symbol.hasInstance：对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。 class MyClass { [Symbol.hasInstance](foo) { return foo instanceof Array; //如果直接 return false，则调用instanceof的时候无论前面接什么实例，都会返回false } } [1, 2, 3] instanceof new MyClass() // true Symbol.isConcatSpreadable：对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 let arr1 = ['c', 'd']; ['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e'] arr1[Symbol.isConcatSpreadable] // undefined let arr2 = ['c', 'd']; arr2[Symbol.isConcatSpreadable] = false; ['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e'] 还有很多，可以去阮一峰的ES6入门查看 在学习过程踩的坑var name = Symbol(); //Uncaught TypeError: Cannot convert a Symbol value to a string 在网上找的的解释： var 定义的变量会把它提升到当前函数作用域顶部，如果是浏览器全局作用域就会成为window的一个属性。 By the way，let会把变量提升到当前块级作用域顶端，如果在浏览器全局作用域下，不会让变量成为window的属性。 name 是window对象的一个固有属性，对它的赋值，会被强制转为string。 可以打开控制台打印一下window，第二个属性就是name。 给name赋值一个对象，会自动转换为string类型 symbol Symbol的隐式类型转换会报错 使用 var 声明变量 =&gt; 给 window 的变量赋值 =&gt; window.name的赋值必须转换为字符串 =&gt; 对值Symbol()转换为字符串的过程中，触犯了的 “Symbol()隐式类型转换” 6.XX器迭代器迭代器是一种接口，为各种不同数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作 实际上 Iterator接口，就是对象里面的一个属性，而属性的名字就叫做 Symbol.Iterator ES6创造了一种 for of循环，Iterator主要供 for of消费，也就是可以使用for of，就有 Symbol.Iterator属性 定义 Symbol.Iterator则定义它的迭代方式 错误：迭代失败！！！ const banji = { name: \"4399\", status: [ 'Allen', 'Bruce', 'Cat' ] } for (item of banji) { console.log(item); } next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。 正确√，重新定义了迭代器，用来迭代status const banji = { name: \"4399\", status: [ 'Allen', 'Bruce', 'Cat' ], [Symbol.iterator]() { let index = 0; return { next: () => { // 这里的this指向我们的banji // value为迭代的值，done表示是否停止迭代的状态 if (index &lt; this.status.length) { const result = { value: this.status[index], done: false }; // 下标自增，继续迭代 index++; return result; } else { return { value: undefined, done: true } } } } } } //这里的item直接输出value for (item of banji) { console.log(item); } 迭代器中有个 return函数，该方法用于指定在迭代器提前关闭执行的逻辑，必须返回一个IteratorResult对象（通过break、continue、return、throw） class Counter{ constructor(limit){ this.limit = limit; } [Symbol.iterator](){ let count = 1; limit = this.limit; return { next(){ if(count &lt;= limit){ return {done: false, value: count++}; }else { return {done: true}; } } return(){ console.log('Exiting early'); return {done: true} } } } } 不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它们可关闭的 生成器名词解释： Generator 函数是 ES6 提供的一种异步编程解决方案 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 使用方法： Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态（使用yield分割）。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 yield有点像函数的中间返回语句，它生成的值会出现在 next()方法返回的对象里，通过 yield关键字退出的生成器函数会处于 {done: false}状态，直接通过 return 关键字退出的生成器函数会处于 done: true状态 yield语句必须在生成器函数内部使用 // yield用于函数代码的分割，3个分隔符产生4块代码 function* gen() { console.log(\"123\"); yield 'aaaaa'; console.log(\"456\"); yield 'bbbbb'; console.log(\"789\"); yield 'cccc'; } let gen1 = gen(); console.log(gen1); // 生成器执行必须调用迭代器的next()，value的值 = yield后的值 //这里的item是执行相对代码块后，然后输出value for (item of gen1) { console.log(item, \"这是一个片段\"); } //123 //aaaaa 这是一个片段 //456 //bbbbb 这是一个片段 //789 //cccc 这是一个片段 // gen1.next(); ///123 // gen1.next(); ///456 在生成器的next传入实参，传入的参数作为上一个yield语句的整体返回结果 function* gen(arg) { console.log(arg); let one = yield 111; console.log(one); let two = yield 222; console.log(two); let three = yield 333; console.log(three); } let iterator = gen('AAA'); //这里输出的是yield的返回值，而不是输出value，所以你看不到111，222，333的输出 iterator.next(); //AAA； 第一个next虽然没有传值，但是第一次调用next()传入的值不会被使用（来自红宝书 p196），因为这一次调用是为了开始执行生成器函数 iterator.next(); //undefined iterator.next('BBB'); //BBB iterator.next('CCC'); //CCC 生成器应用异步编程 下面使用 setTimeout 模拟异步任务的执行 function getUser() { setTimeout(() => { let data = \"用户信息\" iterator.next(data); }, 1000) } function getGood() { setTimeout(() => { let data = \"商品信息\" }, 1000) } function* gen() { let data = yield getUser(); console.log(data); yield getGood(); } let iterator = gen(); iterator.next(); 个人感觉比promise麻烦很多。。。，代码太长了 使用迭代器构造小型计时器 function* gen() { for (let i = 0; i &lt; 5; i++) { setTimeout(() => { console.log(i); a.next(); }, 1000); yield; } } let a = gen(); a.next(); 7.其他static类（class）通过 static 关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能。（也可以解释为实例上加，要想用必先new , 对象上加，可以 直接用） 执行上下文 &amp; 作用域变量和函数的上下文决定了他们可以访问哪些数据，以及他们的行为，每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象之上。（个人理解，上下文 = 他们的作用域） 全局上下文：全局上下文是最外层的上下文，根据ESMAScript的宿主环境对象可能不一样。但是在浏览器中，全局上下文就是我们常说的window对象。上下文在其所有代码都执行完毕后会被销毁，而全局上下文在应用程序退出前才会被销毁，比如关闭网页、退出浏览器。 函数上下文：每个函数都有自己的上下文，当函数上下文被推到一个上下文栈上，当函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的上下文 内部上下文可以通过作用域链访问外部上下文的一切，但是外部上下文无法访问内部上下文的一切，即每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文去搜索。 注意 除了全局上下文 和 函数上下文，还有eval()第三种上下文 而且还有其他方式来增强作用域，比如某些语句会导致在作用域链前端临时添加一个上下文，比如 try/catch、with 关于块级作用域 + 函数声明的诡异代码先上代码，先上代码 console.log(a) // undefined { a=1 function a() {} } console.log(a) // 1 console.log(a) // undefined { function a() {} a=1 } console.log(a) // func a 我在网上搜到的解释，希望对你们有帮助（请自行脑部理解！！！） s塔塔","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"Nodejs","slug":"Nodejs","date":"2020-12-26T13:25:21.026Z","updated":"2021-08-22T11:45:13.037Z","comments":true,"path":"2020/12/26/nodejs/","link":"","permalink":"https://taylor12138.github.io/2020/12/26/nodejs/","excerpt":"","text":"1.Node概述Node.js是一个能够在服务器上运行JavaScript的环境 为什么选择node： 1.node使用JavaScript语法开发后端应用 2.一些公司要求前端人员掌握Node开发 3.生态系统活跃，有大量开源库 4.现有前端开发工具大多居于node开发 node是基于chrome V8引擎的JavaScript代码运行环境（浏览器也是JavaScript代码运行环境），源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码) 在命令行工具中输入 node -v 即可查看nodejs是否安装成功 node.js和JavaScript的对比JavaScript由3部分组成，ECMAScript+DOM+BOM Node.js由ECMAScript及Node环境提供的一些附加API组成的 ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象) os(操作系统) file(文件系统) net(网络系统) database(数据库) 他们都使用了ECMAScript语法，只是分别向前后端的方向拓展了 使用在cmd命令符窗口中使用 node xx.js 即可完成（在执行文件的目录下按住shift+鼠标右键可快速进入当前目录的命令符窗口，然后配合tab键位快速打开） 也可以直接使用 node进行回车，可以直接供测试使用（核心模块可以直接用，不用require），类似于浏览器的console控制台 2.Node.js模块化开发JavaScript弊端：文件依赖（a.js-&gt;b.js-&gt;c.js，相互依赖，但是很难直接看出来，分析完后才知道要一个一个引入）和命名冲突（在相互依赖的js中声明同样的变量名导致的错误） 模块化开发：一个功能一个模块，多模块组合完整应用，抽离一个模块不会影响其他功能的运行，降低程序的耦合性，方便代码复用（虽然开发效率低一点） commonJS的提出为了弥补JavaScript没有标准的缺陷，希望JS’能在任何和地方运行，CommonJS对模块的定义十分简单 模块化node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到（除了console.log的输出内容），因为在node的定义中，每个js文件的js代码都是独立运行在一个函数中，而不是全局作用域。 当node执行模块中代码，它首先在代码顶部添加： function(exports, require, module, __filename, __dirname){} 将代码包含进去 模块内部使用exports 对象进行成员导出，使用require方法导入其他模块（注意ES6不使用require而是使用import） exports //a.js let version = 1.0; const sayHi = name => `你好, ${name}`; //向模块外导出数据 exports.version = version; exports.sayHi = sayHi; require,如果直接使用模块名来引入，没有添加路径，它会首先在当前目录的node_modules中寻找是否含有该模块，没有则一直往上一级寻找var math = require(&quot;math&quot;) （require加载规则：优先从缓存加载，即之前加载过的模块，不再加载） 模块中的路径标识是相对于当前文件模块，不受到node命令所处路径影响，想查看路径影响可跳转阅读 10. Path //b.js //b.js导入a.js, ./b.js是b.js的路径，路径模块必须加'./', 如果只加了'/'，就当作此盘根目录下路径，也就是绝对路径处理 let a = require('./a.js'); console.log(a.version); console.log(a.sayHi('xx')); //使用a.js的方法 模块导出的另一种方式(和exports差不多)： //a.js module.exports.version = version; module.exports.sayHi = sayHi; //b.js let a = require('./a.js'); //b.js导入a.js, ./b.js是b.js的目录 console.log(a.version); console.log(a.sayHi('xx')); //使用a.js的方法 module代表当前模块本身 exports是module.exports的别名（地址引用关系），它们俩指向同一块内存空间，导出对象（当exports和module.exports对象指向的不是同一个对象时）最终以module.exports为准，即想要直接以对象的方式进行全部修改，只能以module.exports进行声明，比如 module.exports = { name: &#39;allen&#39;,} 用module.exports来改动的话，是改对象，更改对象里的值 用exports以对象方式来改动的话，是改变量，更改了地址 最后return的是 module.exports ，所以给exports重新赋值不管用 __filename 当前模块的完整路径 __dirname 当前模块所在文件夹完整路径（所属目录的绝对路径） 注意：如果a加载了b ，b又加载了a，（即a require b，b require a）说明思路有问题 模块分类核心模块 由node引擎提供 核心模块的标识就是模块的名字（如node提供的文件模块fs） 文件模块 由用户自己定义 第三方模块（可以通过npm下载，它的查找方式是先找到当前目录下node_modules/xx/package.json文件，查看其中main属性，记录了js文件的入口，当main没有指定，默认执行node_modules/xx/目录下的index.js）（模块查找机制：如果以上任何条件不成立，则会进入上一级目录中的node_modules） globalnodejs的全局变量保存在global里面 global.a get在地址栏输入网址永远是get、get在回退时是无害的 get注重url获得的参数，且只产生一个TCP数据包 get长度有限制，其实是特定的浏览器及服务器对它的限制（不同浏览器对其限制不同，网络上一直信奉的1024Get请求长度，是错误的） 获得get请求的内容，它的内容是在url的? 之后的部分 url 是nodeJs的url模块 url.parse 解析url请求 (url.parse(req.url, true) 对 url的信息进行解析，得到一个对象，使用true的话，能把里面的重要属性query（查询字符串），也转换成对象) 比如创建端口号为5208的服务器，在网址末尾写上?a=1&amp;b=2&amp;c=3之类 http://localhost:5208/?a=1&amp;b=2&amp;c=3 （查询Content-type网址：http://tool.oschina.net/） var http = require('http'); var url = require('url'); http.createServer(function (req, res) { res.writeHead(200, { 'Content-Type':'text/plain;charset=utf-8' }); // req.url是：/?a=1&amp;b=2&amp;c=3 //url.parse(req.url, true)是： 转对象 //有用的信息保存于query属性中 [a: 1,b: 2,c: 3] var _param = url.parse(req.url, true).query; console.log(_param.a); console.log(_param.b); console.log(_param.c); res.end(); }).listen(5208) console.log(\"5208服务器已经启动。。。。\"); postpost请求，要么是表单post请求，要么是api的post请求，只要记得一般情况下，私密数据传输用POST + body就好。 理论上讲，post是没有大小限制的 post的信息放在Request body中，且产生TCP两个数据包（firefox浏览器除外） 多数浏览器对于POST采用两阶段发送数据的，先发送请求头，再发送请求体，即使参数再少再短，也会被分成两个步骤来发送（相对于GET）,也就是第一步发送header数据，第二部再发送body部分。 post回退时会再次提交请求 querystring 模块从字面上意思就是查询字符串，一般是对http请求所带的数据进行解析 querystring.parse(str[, sep[, eq[, options]]]) 将一个字符串反序列化为对象 var http = require('http'); var querystring = require('querystring'); var _formHtml = '&lt;form method=post>' + '网站名：&lt;input name=\"name\">&lt;br>' + '年龄：&lt;input name=\"age\">&lt;br>' + '&lt;input type=\"submit\">' + '&lt;/form>'; http.createServer(function (req, res) { var body = ''; //当服务端接收到数据时触发data req.on('data', function (_d) { body += _d; }) req.on('end', function () { // 转换成一个对象 body = querystring.parse(body); console.log(body); res.writeHead(200, { 'Content-Type': 'text/html;charset=utf-8' }) if (body.name) { res.write(\"姓名：\" + body.name); res.write('&lt;br>'); res.write(\"年龄：\" + body.age); } else { res.write(_formHtml); } res.end(); }) }).listen(5208); console.log(\"5208服务器已启动！！\"); 3.Nodejs的包通俗来说，单个js文件算一个模块，放在一个文件夹里就是一个包了 CommonJS 的包规范由包结构和包描述两个部分组成 包结构：用于组织包中的各种文件 ​ -package.json 描述文件 （important） ​ -bin 可执行二进制文件 ​ -lib js代码 ​ -doc 文档 ​ -test 单元测试 包描述文件（上面的那个-package.json 描述文件）：描述包的相关信息，以供外部读取分析。它用于表达非代码相关信息，是一个json格式的文件，实际上加载包时使用的原则是：node_modules/express/package.json main, 而且它其中保存着十分重要的第三方包依赖项信息（dependencies） 并且建议每个项目里带一个（有且只有一个）package.json文件npm init npm init -y 里面的-y就是yes的意思，在init的时候省去了敲回车的步骤，生成的默认的package.json package.json和package-lock.jsonnpm 5以前是不会有package-lock.json这个文件的 npm 5 以后才加入 从安装上看，npm都会生成或更新package-lock.json这个文件 npm 5 版本以后的安装包，不用加–save添加依赖，它会自动保存依赖 它会自动创建或者更新package-lock.json package-lock.json里面保存的是node_modules所有包的依赖，包括依赖的包里package.json所依赖的包名（套娃） 因此重新npm install时速度会有所提升 从文件上看 lock是用来锁定版本的，如果当前项目依赖了1.1版本，但是重新npm install 其实会给你下载最新版本，而不是1.1 而package-lock.json的另一个作用就是锁定版本号，防止自动升级最新版 NPM（Node Package Manager） CommonJS包规范时理论，NPM是其中一种实践，是Node包管理器 对于Node而言，NPM帮助其完成第三方模块的发布，安装和依赖（A-&gt;B-&gt;C，下载C直接A, B也下），借助NPM，Node与第三方模块之间形成良好的一个生态系统（安装了node以后，自带安装npm） 在cmd命令行窗口： npm -v 查看版本 （或者包名 --version） npm 帮助说明 npm search 包名 搜索包 安装 npm install 下载当前项目所依赖的包（根据package.json配置里的依赖下载） npm install 包名 / npm i 包名 当前目录安装包（可以先创建一个文件夹）（尾部加--save，则添加到当前package.json的依赖里） 如果尾部加 --save-dev则为开发时依赖 npm install 包名 -g 全局模式安装包（一般都是计算机里的工具） 删除 npm remove 包名 / npm r 包名 删除包 （这个好像是旧版的） npm uninstall 模块：删除模块，但不删除模块留在package.json中的对应信息 npm uninstall 模块 --save 删除模块，同时删除模块留在package.json中dependencies下的对应信息 npm uninstall 模块 --save-dev 删除模块，同时删除模块留在package.json中devDependencies下的对应信息 国内使用npm/npx连接国外的npm服务器是，遇到卡顿问题可以试一试国内淘宝的镜像npm进行配置（此时指令nmp-&gt;cnmp）(但是听说cnmp会有诡异的bug，因为cnpm安装模块路径比较奇怪，packager不能正常识别) 可以使用nrm切换淘宝源 # 使用nrm工具切换淘宝源 npx nrm use taobao # 如果之后需要切换回官方源 npx nrm use npm NPXnpx是一个工具，npm v5.2.0引入的一条命令（npx），一个npm包执行器，指在提高从npm注册表使用软件包时的体验 ，npm使得它非常容易地安装和管理托管在注册表上的依赖项，npx使得使用CLI工具和其他托管在注册表。它大大简化了一些事情。 主要特点： 临时安装可执行依赖包，不用全局安装，不用担心长期的污染。 可以执行依赖包中的命令，安装完成自动运行。 （比如使用React时，我们使用npm） npm i -g create-react-app create-react-app 项目名称 使用npx npx create-react-app 项目名称 自动加载node_modules中依赖包，不用指定$PATH。 可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。 npx -p node@8 npm run build 4.Buffer缓冲区数组不能存储二进制文件，而buffer就是专门来存储二进制数据 从结构上buffer非常像一个数组，他的元素为16进制的两位数 var str = \"hello, 艾伦\"; var buf = Buffer.from(str); console.log(buf.length); //占用内存大小 console.log(str.length); //字符串长度 var s = buf.toString(); //将缓冲区的数据转换回字符串 var j = buf.toJSON(); //将缓冲区的数据转换回json对象 buffer存储的数据都是二进制数据，但是显示的时候都是以16进制显示，范围是00 - ff（00000000 - 11111111），所以是8 bit （位），8 bit = 1 byte （字节）（一个英文占一个字节，一个汉字占3个字节） buffer 构造函数（new Buffer）不推荐使用 但是可以：使用Buffer.alloc(size)分配一个大小为size的新建Buffer 还有：Buffer.allocUnsafe(size) 创建一个指定大小的buffer，但是buffer可能含有敏感数据（分配时未清空上一次使用内存存放的数据，但是性能够好） Buffer的大小一旦确定，则不能修改，Buffer实际上是对底层内存的直接操作 可以通过索引操作buffer中的元素 buf[0] = 88 这里的88是16进制，然后再控制台console.log进行输出时，显示的是10进制（只要数字在控制台输出一定是10进制） 5.文件系统fs通过node操作系统中的文件，在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地文件发送给远程客户端，该模块提供了一些标准文件访问api来打开，读取，写入文件，以及与其交互 引入fs模块，fs是核心模块，直接引用不用下载 fs模块中所有的操作都有两种形式可供选择：同步和异步 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码（顺序执行） 异步文件系统不会阻塞程序的执行，而是在操作完成时（异步都有callback）（异步方法不可能有返回值）通过回调函数结果返回 fs中带Sync的的方法是同步方法，不带Sync的方法是异步方法 文件打开同步文件打开 fs.openSync(path, flags[, mode]) ​ -path 打开的文件路径 ​ flags 打开文件操作类型 比如 r 只读的、 w 可写的 ​ mode 操作权限 ，一般省略 该方法会返回一个文件描述符作为结果，我们可以通过该描述符来对文件进行各种操作 异步文件打开 fs.open(path, flags[, mode], callback) ​ callback不能省略 ​ 回调函数中有两个参数 ​ err 错误对象 没有错误则为null ​ fd 文件描述符 无返回值 文件写入同步文件写入 fs.writeSync(fd, string[, position[, encoding]]) ​ fd文件描述符，需要传递要写入的文件的描述符 ​ string写入内容 ​ position起始位置，一般省略 ​ encoding 默认utf-8 异步文件写入（写在fs.open的回调函数里） fs.write(fd, string[, position[, encoding]], callback) ​ 当前回调有三个参数 ​ err ​ written ​ string 关闭文件服务器是持续运行的，不想我们平时运行的文件，结束后自动释放空间 fs.closeSync(fd) ​ fd文件描述符，需要传递要写入的文件的描述符 fs.close(fd, callback) ​ 异步，完成回调只有一个可能的异常参数 简单文件写入（常用）一步搞定，省略打开，关闭 fs.writeFile(file, data[, options], callback) fs.writeFileSync(file, data[, options]) ​ file 要操作文件的路径 ​ data 要写入的数据 ​ option 选项，可选，对写入进行配置：有encoding（默认utf-8）、mode（权限）、flag（文件操作形式，默认w，如果内容不存在则创建，存在则截断） ​ callback 当写入完成以后执行的函数 var fs = require(\"fs\"); fs.writeFile(\"index.txt\", \"aaa\", function (err) { if (!err) { console.log(\"写入成功！\"); } else { console.log(\"error!\"); } }); 流式文件写入同步、异步、简单文件的写入，都不大适合大文件的写入（都是一次写入），性能较差，容易导致内存溢出 而流式文件的传输相当于两个水池之间插入一条管道，持续的多次的写入 它本质上也是一个异步 创建一个可写流，参数功能和之前的文件读写相同 var ws = fs.createWriteStream(path [, option]) var fs = require(\"fs\"); var ws = fs.createWriteStream(\"index.txt\"); // 监听文件的打开和关闭 ws.once(\"open\", function () { //once为对象绑定一个一次性的事件，jQuery也有出现过类似的one console.log(\"流打开了\"); }); ws.once(\"close\", function () { console.log(\"流关闭了\"); }); ws.write(\"通过可写流写入文件的内容\"); ws.write(\"啊大苏打\"); ws.write(\"大撒大撒\"); // 关闭流，关闭流入口 // ws.close(); 当前版本也可以了（关闭流出口） ws.end(); 文件读取（all kinds）这里只讲讲简单文件读取和流式文件读取 简单文件读取（参数功能同上） fs.readFileSync(path [, options]) fs.readFile(path [, options], callback) ​ callback回调函数参数 （err, data） ​ err 错误对象 ​ data 读取到的数据，会返回一个Buffer 流式文件读取 它也适合一些比较大的文件，可以分多次将文件读取到内存中 创建一个可读流： fs.createReadStream(path) 如果要读取一个可读流的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，然后读取到的数据存放在参数中返回（它的参数没有err，因为事件触发后就意味着不会再出错了） var fs = require(\"fs\"); var rs = fs.createReadStream(\"cool.jpg\"); var ws = fs.createWriteStream(\"copy.jpg\") // 监听 rs.once(\"open\", function () { console.log(\"可读流打开了\"); }); rs.once(\"close\", function () { console.log(\"可读流关闭了\"); // 数据读取完毕，关闭可写流 ws.end(); }); ws.once(\"open\", function () { console.log(\"可写流打开了\"); }); ws.once(\"close\", function () { console.log(\"可写流关闭了\"); }); // 开始读取 rs.on(\"data\", function (data) { //将数据读到data中 // 将读取的数据写入可写流中 ws.write(data); }) 流式文件原本需要data方法进行读取，但是有个更方便的方法： 将可读流和可写流管道相通，形成管道流，用了 pipe() 的方法 改： // 开始读取 /* rs.on(\"data\", function (data) { //将数据读到data中 // 将读取的数据写入可写流中 ws.write(data); })*/ // 开始读取 rs.pipe(ws); 文件读取配合文件写入，可完成文件的传输 服务器就是接收用户的请求，并返回响应，而请求和响应就是数据流 fs其他方法fs.existsSync(path) 是否存在 fs.stat(path, callback) 文件状态（里面包含文件大小等信息） fs.readdir(path, [, option], callback) 读取文件目录列表 fs.readdir(path, [, option])读取一个目录的目录结构 fs.truncateSync(path, size) 截断文件，将文件修改为指定大小 Stream流Stream流是一个抽象的接口，在nodejs当中，很多方法，对象，他们都实现了这个接口，例如之前创建一个服务，向服务器发送一个请求，request对象，他其实就是一个流（流简单粗暴的理解就是在线看电视） 在nodeJS中，Stream有四种流类型： ​ Readable -可读操作 ​ Writable -可写操作 ​ Duple -可读可写操作 ​ Transform -操作被写入数据，然后读出结果 所有的Stream对象都是EventEmitte（events模块）r的实例 常用事件： ​ -data 当有数据可读取时触发 ​ -end 没有更多数据可读取时触发 ​ -error 在接收和写入过程中，发生错误时触发 ​ -finish 所有数据已经被写入之后触发 流式读取文件的方法在 5.文件系统fs中 链式流就是从一个输出流当中，读取数据，创建多个流来操作这个输出流数据的机制 链式流一般来操作管道流 常见的例子就是压缩和解压缩的例子 // 链式流 var fs = require('fs'); var zlib = require('zlib'); // 压缩文件 fs.createReadStream('cool.jpg') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('cool.jpg.gz')); console.log(\"解压完毕！！！\"); // 链式流 var fs = require('fs'); var zlib = require('zlib'); // 解压缩 fs.createReadStream('cool.jpg.gz') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('copy2.jpg')); console.log(\"解压缩完毕！！！\"); 6.创建服务1.先引入模块(Nodejs本身提供了http模块) var _http = require(&#39;http&#39;); 创建服务器http.createServer([options][, requestListener]) request监听事件需要接收两个参数，Request请求对象（获取客户端请求信息），Response响应对象（用来给客户端发送响应消息） 再创建服务器的回调函数里添加http头部信息，然后向客户端发送数据 响应对象1.响应对象response添加信息：response.writeHead(statusCode[, statusMessage][, headers]) ​ statusCode 为状态码 ​ headers为响应头 text/plain:纯文本 text/html: 可识别为html标签的文本 ​ charset=utf-8:防止中文乱码（服务器默认发送数据时utf8，但是浏览器不知道你是utf8，它会默认按照当前操作系统的编码去解析） response.setHeader(name, value)也可以写响应头 （writeHeader可以设置http返回状态码，多个http响应头。但是setHeader只针对单一属性的设置。） 2.响应对象response发送数据，并且结束响应（end）： response.end(&quot;第一个http服务&quot;); （当然也可以response.write(&quot;xxx&quot;); response.end()） 注意：响应内容只能是二进制数据或字符串（Buffer或String） var _http = require('http'); // 创建服务器 _http.createServer(function (request, response) { // http头部信息 response.writeHead(200, { 'Content-type': 'text/plain;charset=utf-8' }); // 向客户端发送数据，并且结束响应（end） response.end(\"第一个http服务\"); }).listen(5205); //自己设置监听的端口号最好不要用8888，8080，可能会被电脑其他应用占用，容易报错 console.log(\"5205已经创建!\"); 绑定端口号也可以直接给实例绑定： ​ var server = http.createServer(){} ​ server.listen(端口号, callback) 此时打开本地浏览器，local:host5205即可查看访问 response的重定向通过服务器让客户端重定向 状态码设置302临时重定向 statusCode 在响应头通过location告诉客户往哪重定向 setHeader 客户端发现收到服务器的响应状态码为302，就会自动去响应头找location，然后对该地址发起新的请求 所以你就能看到客户端自动跳转（这里是跳转至首页） //接收表单数据后（get），进行跳转，跳转至首页 var comment = url.parse(req.url, true).query; comments.unshift(comment); //从头部增加数组元素，comments为数组变量 res.statusCode = 302; res.setHeader('Location', '/'); //响应头的Loacation路径设置为 '/' 即首页 res.end(); 请求对象1.请求路径为： request.url, url：统一资源定位符 路径优化问题： var http = require('http'); var fs = require('fs'); var wwwDir = 'C:/Users/ok-pc/blog/source/_posts'; //文件路径 http.createServer(function (req, res) { var url = req.url; var filePath = '/index.html'; if (url !== '/') { filePath = url; } fs.readFile(wwwDir + filePath, function (err, data) { if (err) { return res.end('404'); } else { res.end(data); } }) }) ip地址与端口所有联网的程序都需要网络通信，计算机只有一个物理网卡，网卡的地址是唯一的（ip地址） 端口号用来定位具体应用程序（类似银行窗口号，服务器类似于银行） 一切需要联网通信的软件都会占用一个端口号 端口号在 0 - 65536 之间 在计算机中有一些默认端口号，最好不要去使用 例如http服务的80 可以同时开启多个服务，但是一定要确保不同服务占用端口号不一致（在一台计算机中，同一端口号同一时间只能被一个程序占用） 处理静态资源浏览器收到html响应内容之后，就要开始从上到下进行解析，当在解析过程中，如果发现： link script img iframe video audio 等带有src 或者 href（link）属性标签的时候（具有外链资源的时候），浏览器会自动对这些资源发起新的请求 我们为了方便统一处理这些静态资源，所以约定把所有静态资源存放在public目录中，即如果请求路径以 /public/开头，则认为你是要获取public的某个资源，所以我们这时可以直接把请求路径当作文件路径进行读取 这时哪些资源能否被用户访问可以达到一个可控的状态 （注意：在服务端中，文件的路径就要要写相对路径了，因为这个时候所有资源都是通过url标识来获取，这里服务器开放了/public/目录，所以这里请求路径写成 /public/xxx） html中的link ：&lt;link rel=&quot;stylesheet&quot; href=&quot;/public/lib/bootstrap/dist/css/bootstrap.css&quot;&gt; nodeJs代码： var http = require('http'); var fs = require('fs'); var rg = /^\\/public\\//; http.createServer(function (req, res) { var url = req.url; if (url === '/') { fs.readFile('./views/index.html', function (err, data) { if (err) { return res.end('404 Not Found.'); } res.end(data); }) } else if (rg.test(url)) { // 如 ：/public/lib/bootstrap/dist/css/bootstrap.css // url.indexOf('/public/') === 0也可以 fs.readFile('.' + url, function (err, data) { if (err) { return res.end('404 Not Found.'); } res.end(data); }); } }).listen(5208, function () { console.log('running!!...'); }); 7.事件nodeJs它基本上，所有事件机制，都是基于设计模式种“观察者模式”来实现的 简单来说，nodejs使用事件驱动的模型，每当接收到一个请求，就把他关掉进行处理，当这个请求完成，就把它放到处理队列当中，最后把结果返回给用户 因为它的服务一直是处理接收请求，但不等待任何读写操作，所以性能很高，这也叫做“非阻塞式IO或是事件驱动IO” nodeJS事件使用events模块，通过实例化它里面的EventEmitter类来绑定和监听事件 使用事件模块：var eve = require(&#39;events&#39;) 实例化EventEmitter类：var event = new eve.EventEmitter() ​ 实例化对象里有个_eventsCount属性，显示绑定事件数量 （也可以： var eventEmitter = require(&#39;events&#39;).EventEmitter; ​ var event = new eventEmitter(); ） 绑定事件：event.on(事件名, callback)（jquery也用on绑定事件） ​ 事件名可以自定义，因为这里的事件名完全不同于浏览器上的各种事件，这里的事件名就是一个“标识”，实际上绑定了一个回调函数 监听事件的触发：event.emit(事件名) // 绑定一个事件 event.on('one', function () { console.log(\"no.1事件被触发了\"); }); // 触发一个事件 event.emit('one'); 所有nodejs里面的异步io操作，都会在完成时，发送一个事件到事件队列 8.模板引擎最早诞生于服务器领域，后来发展到前端 官方文档：https://aui.github.io/art-template/ 安装npm install art-template 浏览器应用引入 &lt;script src=&quot;./node_modules/art-template/lib/template-web.js&quot;&gt;&lt;/script&gt; 类型改为 type = &quot;text/template&quot; 模板引擎不关心字符串内容，只关心自己能认识的模板标记语法，例如(包含if语句判断) {{ 变量名 }} {{ if user }} {{ else }} {{ /if }}{{ each 遍历数组 }} &lt;li&gt;{{ $index + 1 }}&lt;/li&gt; &lt;li&gt;{{ $value }}&lt;/li&gt; {{/each}}该语法被称之为mustache语法，八字胡 template(&#39;script 标签 id&#39;, {对象}) &lt;script src=\"./node_modules/art-template/lib/template-web.js\">&lt;/script> &lt;script type=\"text/template\" id=\"tql\"> hello{{ name }} 今年 {{ age }} 岁了 &lt;/script> &lt;script> var ret = template('tql', { name: 'jack', age: 18 }) console.log(ret); document.querySelector('#表单id号').innerHTML = ret; &lt;/script> nodejs应用核心方法 引入： var template = require(&#39;art-template&#39;); 基于模板名渲染模板template(filename, data); 将模板源代码编译成函数template.compile(source, options); 将模板源代码编译成函数并立刻执行template.render(source, data, options); var ret = template.render('hello {{ name }}', { name: 'Jack' }) 服务端和客户端渲染客户端渲染 服务端渲染 服务端渲染更快，但是会增大服务端的压力（右键查看网页源代码可以看得到具体内容就是服务端渲染），可以被爬虫抓取到 客户端渲染有利于用户体验，但是不利于SEO搜索引擎优化 很多网站是结合两者进行渲染的 SSR渲染SSR：server side render 当前端为vue、react这种spa应用时，非常不利于SEO，各种路由的跳转也变得复杂，并且在首屏渲染时间上也花费了大量时间。在整体架构部署上，还需要利用各种web服务（如ngxin），这点很麻烦 SSR就是类似于老的node ejs或者java jsp方式的web技术。使用后端将html全部准备好，直接抛给前端。 SSR优势 更利于SEO。 更利于首屏渲染 服务端在内网进行请求，数据响应速度快 我们可以看见中间少了两个步骤 SSR劣势 服务端压力较大 开发条件受限，在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制； 学习成本相对较高。除了对webpack、React要熟悉，还需要掌握node、Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。 以前 &amp; now服务端渲染现在的服务端渲染和过去的服务端渲染完全是两码事 以前的服务器渲染，是以“文档”为核心思想。服务器端的逻辑是把HTML, CSS, Javascript当作一个静态文件，对“文档”而言不存在“指令”和“数据”的区别，一切都是数据。所以我们可以看到服务器渲染，GET就是请求一个文件，而web 1.0时代的诸多服务端框架最基础的组件之一就是文档模版，比如asp, JSP之类，核心设计理念就是HTML文件里放占位符然后由服务端逻辑替换成实际数据后一股脑返回。 Web 2.0时代最大的思想革命本质不是前后端分离，而是把网页当作独立的应用程序（app）。前后端分离只是实现这一新架构的必然结果。对程序而言指令和数据是分离的。HTTP GET拿到的不是渲染后的网页，而是一个由html和Javascript组成的app, 这个app以浏览器为虚拟机。装载和显示数据是app启动之后的运行逻辑。传统上app叫什么？叫Client，也就是前端。于是前后端就这么分离了，浏览器变成了app的运行环境，后端蜕化成了单纯的业务逻辑和数据接口。写Javascript不再是给网页添特效的小伎俩，而是正经的和写桌面应用程序一样的工程。于是我们看到了前端工程化，编译（转译），各种MVC/MVVM框架，依赖工具，等等。很新鲜吗？不新鲜，都是传统桌面开发玩剩下的。我很早就说过，前端NodeJS的那堆东西，什么npm，Babel，Webpack，gulp，各个框架的cli… 本质上就是开源社区东拼西凑做一个Visual Studio。 来源于https://www.zhihu.com/question/59578433/answer/332545815 知乎某作者 其实也可以看作加入了nodejs中间件，这个中间件作为伪“服务端”，由它来发送网页html等资源。 9.PathPath是一个核心模块 var path = require(&#39;path&#39;) path.basename(path[,ext]) 获取给定路径当中文件名部分，第二个参数可以用来去除指定的后缀名 console.log(path.basename('c:/a/b/c/index.js')); //index.js console.log(path.basename('c:/a/b/c/index.js', '.js')); //index console.log(path.basename('c:/a/b/c/index.js', '.html')); //index.js path.dirname(path) 方法会返回 path 的目录名 path.extname(path) 返回 path 的扩展名 console.log(path.extname('c:/a/b/c/index.html');); //.html path.isAbsolute(path) 检测 path 是否为绝对路径。(‘./c/index.js’是相对路径， ‘/c/index.js’是绝对路径) path.join([...paths]) 方法会将所有给定的 path 片段连接到一起，生成规范化路径 path.join('/目录1', '目录2', '目录3/目录4', '目录5'); // \\\\目录1\\\\目录2\\\\目录3\\\\目录4\\\\目录5' path.resolve([from...],to) 把一个路径或路径片段的序列解析为一个绝对路径，有点像join，但是解析结果一定是绝对路径 更多知识点可查看nodejs官方文档的Path部分 在文件操作路径中，使用相对路径是不可靠的，因为相对路径设计就是相对于执行node 命令所处的路径， 所以我们要利用好（以下在node中为全局变量，直接用） __filename 当前模块的完整路径 __dirname 当前模块所在文件夹完整路径（所属目录的绝对路径） 配合Path进行操作（比如拼接路径过程中，防止手动拼接带来低级错误，可以使用path.join），把相对路劲变成绝对路径（注意是动态绝对路径）就好了 //express框架公开指定目录 app.use('/node_modules/', express.static(path.join(__dirname, './node_modules/'))); 特殊 ：模块中的路径标识（比如：require(&#39;./a.js&#39;)）是相对于当前文件模块，不受到node命令所处路径影响 10.其他进程为我们程序的运行提供一个必备的环境（进程是资源分配的最小单位） 线程是计算机中最小的计算单位，线程负责执行保存到进程中的程序（线程是CPU调度的最小单位） JS、浏览器、nodejs是单线程 修改完自动重启服务器我们这里可以使用一个第三方工具：nodemon来帮我们解决修改代码重启服务器问题 #--global 来安装则可以在任意目录执行 npm install --global nodemon 原来我们在命令行输入：node xxx.js 现在：nodemon xxx.js， 他会监视你的文件变化，当文件变化时，会自动帮你重启服务器 使用node.js进行爬虫原理：当网页时后端渲染时，对网页源代码进行爬取，得到其html源码 第一步： 使用 npm init --yes初始化创建的文件夹 下载依赖包 npm i superagent cheerio superagent: 是一个轻量的Ajax API，和axios差不多，只不过 cheerio：为服务器特别定制的快速灵活jQuery，它并不会产生视觉呈现，应用CSS，加载外部资源，或者执行JavaScript，可以用来从网页css selector取数据，使用方法和jQuery一样 第二步： 通过 superagent &amp; cheerio获取网页数据（后端渲染） 数据处理，可以使用正则表达式，字符串切割，或者eval() 函数（可计算某个字符串，并执行其中的的 JavaScript 代码。） 第三步： 写入本地 superagent.get('https://ncov.dxy.cn/ncovh5/view/pneumonia').then(res => { // 浏览器可以解析代码，node端直接返回源码,而res.text是我们需要的响应数据 const $ = cheerio.load(res.text); const $getAreaStat = $('#getAreaStat').html(); // 加入全国疫情数据 let data = {}; eval($getAreaStat.replace(/window/g, 'data')); //执行里面的语句，使得data成功被赋值 console.log(data); // 字符串转换json fs.writeFile(path.join(__dirname, './data.json'), JSON.stringify(data), err => { if (err) throw err; console.log(\"写入成功！！！\"); }) }).catch(err => { throw err; })","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript进阶ES5+面向对象","slug":"JavaScript进阶ES5+面向对象","date":"2020-12-08T09:52:15.778Z","updated":"2021-08-22T11:39:53.294Z","comments":true,"path":"2020/12/08/javascript-jin-jie-es5-mian-xiang-dui-xiang/","link":"","permalink":"https://taylor12138.github.io/2020/12/08/javascript-jin-jie-es5-mian-xiang-dui-xiang/","excerpt":"","text":"1.编程思想介绍面向过程（POP）：分析解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一步一步调用就行了 面向对象（OOP）：把事物分解成一个个对象，然后由对象之间分工合作（找出对象出来，然后写出这些对象的功能） 面向过程的性能比较高，适合和硬件联系很紧密的东西，如单片机，缺点是难维护、难拓展、难复用 面向对象的代码灵活，代码可复用性高，容易维护和开发，更适合多人合作的大型软件项目 面向对象：封装性（直接使用，不需要了解内部）、继承性、多态性（多功能） 2.面向对象1.抽取对象公共属性和行为组织封装成一个类（class） class name { class body } 2.对象实例化，获取类的对象（对象是特指某一个，实例化的具体对象） var xx = new name() 利用类创建对象 对象由属性和方法构成 tip： （1）class关键字创建类，类名习惯定义首字母大写 （2）constructor()是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有明显定义，类内部会自动给我们创建一个constructor()（最好自己写上constructor） class Star { constructor(uname, age) { this.name = uname; this.age = age; } } var xxx = new Star('xxx', 20); 类里添加方法1.在类里面构造函数，不需要加function 2.多个方法、函数之间不需要添加逗号进行分割 class Star { constructor(uname) { this.name = uname; } init() { //xxxx } } 类里添加实例对象的默认属性在React，我还学到了往类里添加默认属性的骚操作，直接写入赋值语句 写入赋值语句后，实际上就是往实例自身追加一个属性，属性名为a，值为1，适用于一个不需要根据传参改变的写死的值 class Star { a = 1; } 类的继承使用extends进行继承 super关键字用于访问和调用对象父类上的函数，可以调用父类的构造函数，也可以调用父类的普通函数 在constructor中，super必须在字类this的之前进行调用，即必须先调用父类的构造函数，再使用子类的构造函数 super只能在派生类（子类）的构造函数和静态方法中使用 不过要注意的是：（错误示范❌） class Father { constructor(x, y){ this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } class Son extends Father { constructor(x, y) { this.x = x; //会报错 this.y = y; //会报错 } } var son = new Son(1, 2); son.sum(); //会报错 以上有两个错误： 类里面的语法中，只要符合类继承 + 子类有个构造函数(constructor)则一定要调用super，否则也会报错 如果只需要继承到x、y的属性，自身不需要新的属性，类似于下方的id属性，则甚至可以不用写构造函数 此时参数传递给子类的constructor的x和y，而父类的sum函数用的是父类的constructor的x和y class Father { constructor(x, y){ this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } class Son extends Father { constructor(x, y, id) { //调用父类的构造函数 super(x, y); //并且一定要放在最开头，不能把this.id = id 放在它前面 this.id = id; } } var son = new Son(1, 2, 123); son.sum(); //success 继承中属性或者方法的查找原则：就近原则 在继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就执行子类的 如果没有，就去查找父类有没有此方法，如果有就执行父类的 如果子类想要直接调用父类的方法，则： class Father { say() { //xxx } } class Son extends Father { say() { //调用父类的普通函数 super.say(); } } var son = new Son(); son.say(); 如果在子类中添加了和父类相同的方法，则子类的方法会覆盖掉父类的方法（在当前屏蔽掉父类的方法），此举动可以称为方法的重写 需要注意的三点1.ES6中类没有变量提升，所以必须先定义类，才能通过实例化对象 2.类里的共有属性和方法一定要加this进行使用 （this指向我们创立的·实例化对象） var that; class Father { constructor(uname, age) { //that = this; this.uname = uname; this.age = age; //this.sing(); 加小括号会立即调用 this.btn = document.querySelector('button'); this.btn.onclick = this.sing; this.init(); } init() {} sing() { //这里的this指向的是调用者，所以btn点击事件发生时，this.uname指向的是btn的uname console.log(this.uname); //所以可以外面定义变量，然后让btn固定打印的是该对象的uname //console.log(that.uname) } } 3.类构造函数和构造函数最主要的区别是，类构造函数必须使用new，不然会报错，而构造函数不用new会被当作普通函数去使用 3.构造函数和原型在ES6（ECMAScript6.0）之前，JavaScript没有类的概念，在ES6之前，对象不是基于类创建的，而是用一种称为构造函数的特殊函数来定义对象和他们的特征的。 创建对象：(JavaScript基础也有做过笔记) 1.对象字面量 var obj = {} 2.new Object() var obj = new Object() 3. 自定义构造函数function 构造函数名(){ this.属性=值; this.方法=function (){} } 1.使用构造函数，构造函数名字首字母最好大写如 function Star()2.构造函数不需要return3.使用函数new 构造函数名();即构造一个对象，如new Array()，创建一个数组对象4.属性方法前必须加this如this.name=传参name this.song = function（传参）{} 但毕竟终究是函数，如果在全局下直接调用该构造函数（并非使用new 创建），则会将this的属性添加到window对象上 当然也可以使用call调用，将属性添加到已将创建好的对象上 构造函数中属性和方法我们称之为成员，成员可以添加 实例成员：实例成员就是构造函数内部通过 this 添加的成员 ，实例成员只能通过实例化的对象来访问，不可以通过构造函数访问实例成员，如 function Star(uname){ this.uname = uname; } let star = new Star('xxx'); console.log(star.uname); 静态成员：在构造函数本身上添加的成员，静态成员只能通过构造函数来访问，不能通过对象来访问，如 function Star() {}; Star.sex = 'male'; console.log(Star.sex); 构造函数虽然好用，但是存在浪费内存的问题 构造函数原型对象prototype构造函数通过原型分配的函数是所有对象所共享的 JavaScript规定，每个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype（原型）就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有 因此，我们把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这个方法 使用方法： function Star(uname){ this.uname = uname; } //第一种写法： Star.prototype.sing = function() {} // Star.prototype.sex = 'male'; //第二种写法：（但这种方法不能适用于Array、Object等，会覆盖原来的定型的方法） Star.prototype = { constructor: Star, //不可省略，因为这种写法覆盖掉原来的constructor方法 sing: function() {}, movie: function() {} } 所以一般情况，我们的公共属性定义到构造函数里面，公共的方法我们放到原型对象的身上 注意：虽然随时能给圆形添加属性和方法，并能立即反应在所有对象实例上，但这和重写整个原型是两回事，如果原型的修改是在创建实例之前，则实例引用的仍是最初的原型 let friend1 = new Person(); Person.prototype = { constructor:Person, saySomething(){ console.log(\"yes!\"); } } let friend2 = new Person(); friend1.saySomething() //错误 friend2.saySomething() //通过 原型对象的this指向谁调用，指向谁 1.在构造函数中，this指向的是对象实例 2.原型对象里面的this指向的也是调用它的实例对象 对象原型: __proto__对象都会有一个属性 __proto__ 指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为 __proto__ 的存在 实例化的对象.__proto__ === 构造函数名.prototype 返回true constructor构造函数对象原型（__proto__）和构造函数原型对象（prototype）里面都有一个constructor属性，constructor我们称为构造函数，因为它指回构造函数本身 主要目的：用于记录该对象引用于哪个构造函数（很多情况下我们需要用它来指回原来的构造函数） 原型链任何构造函数原型对象prototype，它作为一个对象，也有它自己的对象原型 __proto__ ，而此时原型对象的 __proto__ 指向的是Object.prototype， 即某构造函数名.prototype.__proto__ === Object.prototype 而我们Object也有prototype原型对象，而它作为一个对象，也有它自己的对象原型 __proto__ ，而此时指向null（到达了终点） 即Object.prototype.__proto__ === null JavaScript成员查找机制： 所以在成员查找时，先查找最底层，没有则根据它 的__proto__查找至他的原型对象，看看有没有该成员，没有的话继续一层一层往上查找，如果找不到该成员 ，最后返回undefined (undefined是由null派生而来的) 而根据查找规则，使用就近原则来处理重复成员定义问题（即先找到，先使用） （这里未标出实例对象 constructor 指向 构造函数） 同时要注意的是： console.log(Object.__proto__); //Function.prototype console.log(Object.__proto__.__proto__); //Object.prototype console.log(Object.__proto__.__proto__.__proto__); //null 拓展内置对象可以通过原型对象，对原来的内置对象进行拓展自定义的方法，比如给数组增加自定义求偶数和的功能 //在Array原型对象上追加函数，不能采取Array.prototype = {}形式 Array.prototype.sum = function() { let sum = 0; for(let i = 0; i &lt; this.length; i++){ sum+=this[i]; } return sum; } 4.继承在ES6之前没有给我们提供extends，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承 call()fun.call(thisArg, arg1, arg2....) （arg n那些指的是传递的其他参数） 功能：调用这个函数，并且修改函数运行时this的指向 thisArg: 当前调用函数的this的指向对象（一般在JavaScript中直接调用函数时，函数的this指向window） ES5继承的两大步借用构造函数继承父类型的属性 核心原理：通过call() 把父类型的this指向子类型的this，这样就实现了子类型继承父类型的属性 利用原型对象继承父类型的方法 实现如下： function Father(uname, age) { this.uname = uname; this.age = age; } Father.prototype.teach = function () { console('father') } //借用父构造函数继承属性 function Son(uname, age) { Father.call(this, uname, age); } // 这样直接赋值会出问题，因为是赋值父原型对象的地址，如果修改了子原型对象，父原型对象也会随之改变 // Son.prototype = Father.prototype; × // 正确方法： // 借用父构造函数继承方法 Son.prototype = new Father(); // 如果利用了对象形式修改了原型对象，别忘了利用constructor指回原来的构造函数 Son.prototype.constructor = Son; Son.prototype.exam = function () { console('son') } let son = new Son('xxx', 18); console.log(son); 原型继承方式的缺点是：原型中包含的引用值会在所有实例中共享，而使用 Son.prototype = new Father();的方式继承时，Son.prototype 是Father类的一个实例，Father的所有属性都会被继承下来，而这些属性都会被当成共享属性 构造函数继承的缺点是：必须在构造函数中定义方法，因此函数不能重用；此外，子类也不能访问父类原型上定义的方法 组合继承=原型继承+构造函数继承（结合两者的优点） 类的本质class本质还是function（用 typeof 查看），所以我们可以认为类就是构造函数的另一种写法 但是新的class写法只是让对象原型的写法更加清晰，更像面向对象编程的语法 和构造函数相同点： 1.类也有原型对象prototype，而prototype里的constructor也是指回类的本身 2.类也可以利用原型对象添加方法 3.类创建的实例对象中的 __proto__ 原型指向类的原型对象 5.ES5新增的方法数组方法1.forEach() ： arr.forEach(function(vlaue, index, [array])) 分别对应数组的value（值）、index（索引号）、数组本身 （遍历数组的全部元素，即使return true也不会终止迭代） （因为forEach本质是一个函数，参数是一个回调函数，回调函数的return只是终止了回调函数而已，不是终止forEach，而forEach内部应该是多次调用了那个函数） 在 forEach遍历中，无法改变item（原数组里的元素，如果元素是数组 or 对象，那另当别论 0.0 ） // 数组改值 let arr = [1,3,5,7,9]; arr.forEach(function(item){ item = 30; }) console.log(arr); //输出 [1, 3, 5, 7, 9] let arr = [{ a: 1 }, { a: 2 }, { a: 3 }]; let arr2 = [[1], [1], [1]]; arr.forEach(function (item) { item.a = 2; }) arr2.forEach(item => { item.push(2) }) console.log(arr); //[ { a: 2 }, { a: 2 }, { a: 2 } ] console.log(arr2); //[ [ 1, 2 ], [ 1, 2 ], [ 1, 2 ] ] 如果你硬要改变item，也不是不可以，只是方法要稍稍改动，使用引用的方式进行修改 // 数组改值 let arr = [1,3,5,7,9]; arr.forEach(function(item,index,arr){ arr[index] = 30; }) console.log(arr); //输出 (5) [30, 30, 30, 30, 30] 2.filter(): filter() 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组 （注意它直接返回一个新数组） array.filter(function(currentValue, index, [arr])) 分别对应currentValue（数组当前项的值），index（索引号），arr（数组本身），它的回调函数返回的必须是一个Boolean值，返回true自动将value加入新数组中，false则过滤掉，最后整体返回一个新数组 var newArr = arr.filter(function(value, index) { return value >= 20; }) find()方法有点类似filter，只不过返回的不是新数组，而是返回符合测试条件的第一个数组元素值 而对应的findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。 3.some() ：some()方法用于检测数组中的元素是否 存在 满足指定条件，通俗点就是查找数组中是否有满足条件的元素，找到第一个满足条件的元素则停止 （注意它返回的是布尔值）在some里设置return true 以终止遍历 array.some(function(currentValue, index, [arr])) 分别对应currentValue（数组当前项的值），index（索引号），arr（数组本身） 4.map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。和forEach相似，不同在于： ​ 如果更改数组内的值，forEach 不能确保数组的不变性。这个方法只有在你不接触里面的任何值时，才能保证不变性。 ​ 由于它们之间的主要区别在于是否有返回值，所以你会希望使用 map 来制作一个新的数组，而使用 forEach 只是为了映射到数组上(修改原来的数组) 返回值加入新数组中 let newarr = arr.map(function(value, index) { return value * 2; }) map的不变性：当数组为基础类型时原数组不变 let array=[1,2,3,4,5] let newArray=array.map((item) => item*2) console.log(array); // [1,2,3,4,5] console.log(newArray);//[2, 4, 6, 8, 10] 当数组为引用类型时原数组发生改变： let array = [{ name: 'Anna', age: 16 }, { name: 'James', age: 18 }] let newArray=array.map((item) => { item.like='eat'; return item; }) console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}] console.log(newArray);//[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}] 5.every() 方法用于检测数组所有元素是否都符合指定条件 6.arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 参数分别对应回调函数和初始值 对数组中所有内容进行汇总，点像递归 let total = a.reduce(function (preValue, currValue) { return preValue + currValue; }, 0); // 遍历到第一次时，preValue为初始值，currValue为数组里的第一个值 // 遍历到第二次时，preValue为第一次返回的值，currValue为数组里第二个数 以上ES5数组方法有助于链式编程（函数式编程），比如： //this.$store.state.cartList 是一个数组 this.$store.state.cartList .filter((item) => item.checked === true) .reduce((preValue, item) => { return preValue + item.count * item.price; }, 0) .toFixed(2); 数组扁平化方法apply（仅限双层） function Flat1(arr){ return [].concat.apply([],arr); } var arr1 = [[1, 2],[3, 4, 5], [6, 7, 8, 9]]; console.log(Flat1(arr1)); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 展开运算符（仅限双层） function Flat1(arr){ return [].concat(...arr); } 多层需要递归 function Flat5(arr){ var newArr =[]; for(var i= 0; i &lt; arr.length; i++){ if(arr[i] instanceof Array){ newArr = newArr.concat(Flat5(arr[i])); // newArr.push.apply(newArr, Flat5(arr[i])); }else{ newArr.push(arr[i]); } } return newArr; } es6方法 const Flat6 = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? Flat6(b) : b), []); 如果数组的元素都是数字，那么我们可以考虑使用 toString 方法 function flatten(arr) { return arr.toString().split(',').map(function(item){ return +item }) } 对象方法Object.defineProperty() 定义对象中新属性或修改原有的属性（应用于vue响应式双向绑定，还有es5实现const的原理） Object.defineProperty(obj, prop,desciptor) obj：必须，目标对象 prop： 必需，需定义或修改的属性名 descriptor： 必须，目标属性所拥有的特性，一对象的形式{ }进行书写， value设置属性的值，默认undefined； writable值能否重写（修改），默认为false； enumerable：目标属性是否可以被枚举(是否可以被遍历，显示出来)，默认false； configurable目标属性是否可以被删除，或者再次修改特性（是否可以再次更改这个descriptor），默认false； 除此外还具有以下可选键值： get：当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。 set：当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象(修改后的值)。 var obj = { id: 1, pname: '小米', price: 1999 } //以前的对象添加修改方式 //obj.num = 1000; //obj.price = 99; Object.defineProperty(obj, 'num', { value = 999, enumerable = true }) Object.keys(obj) 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。 Object.keys(obj1).length得到当前对象属性个数 Object.getOwnPropertyNames(obj1)返回对象实例的常规属性数组 Object.getOwnPropertySymbols(obj1)返回对象实例的符号属性数组 这两种方法互斥 6.函数定义和调用函数定义： 1.自定义函数：function fn() {}; 2.匿名函数： var fun = function() {}; 3.new Function(&#39;参数1&#39;, &#39;参数2&#39;, &#39;函数体&#39;)形式调用 像构造函数, Function里面的参数都必须是字符串格式 var f = new Function('a', 'b', 'console.log(a + b)'); 实际上所有的函数都是Function的实例 函数也属于对象 函数调用： 1.普通函数调用 function fn() { //something } fn(); 2.对象方法 var o = { say: function() { //something } } o.say(); 3.构造函数 function Star() {}; new Star(); 4.绑定事件函数btn.onclick = function() {} 5.定时器函数 setInterval(function() {}, 1000); 6.立即执行函数（自动调用） (function() {} )(); 7.this的指向函数内this的指向是当我们调用函数时确定的，调用方式不同导致this指向不同 1.普通函数调用：window 2.构造函数调用：实例对象，原型对象也是指向实例对象（同样的，类中this也是指向实例对象） 3.对象方法：该方法所属对象 4.事件绑定：绑定事件对象（当前情况指的是位于回调函数的内部中this指向） 5.定时器函数：window 6.立即执行函数：window 但是立即执行函数还得看这时this是否在对象方法或者构造函数中，第二个虽然是立即执行函数，但是此时它的this和foo绑定了，所以还是输出foo的a 而赋值操作，因为赋值表达式是函数本身，this值不再与任何对象绑定，所以this指向window var a = 1; var foo = { a: 2, bar: function () { return this.a; } }; console.log(foo.bar()); //2 console.log((foo.bar)()); //2 console.log((foo.bar=foo.bar)()); //1 “匿名函数的执行环境具有全局性”，所以最里层那个函数中this指向全局环境，全局环境没有定义foo变量所以输出undefined。在匿名函数外部将this保存到一个内部函数可以访问的变量self中，可以通过self访问这个对象，所以self.foo为bar var myobject = { foo: \"bar\", func: function () { var self = this; console.log(this.foo); console.log(self.foo); (function () { console.log(this.foo);//undefined console.log(self.foo);//bar })(); } }; myobject.func(); 类的this指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 class Logger { printName(name = 'there') { this.print(`Hello ${name}`); } print(text) { console.log(text); } } const logger = new Logger(); const { printName } = logger; printName(); // TypeError: Cannot read property 'print' of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错。 （1）一个比较简单的解决方法是，在构造方法（constructor）中绑定this，这样就不会找不到print方法了。 class Logger { constructor() { this.printName = this.printName.bind(this); } // ... } （2）另一种解决方法是使用箭头函数。 class Obj { constructor() { this.getThis = () => this; } } const myObj = new Obj(); myObj.getThis() === myObj // true 改变this指向JavaScript为我们专门提供了一些函数方法来帮助我们处理函数内部this指向问题，常用的有bind()、call()、apply()三种方法 1.call()前面讲过，call的主要作用可以实现继承 2.apply()方法调用一个函数，简单理解为调用函数的方式，但是它可以改变this的指向 fun.apply(thisArg, [argsArray]) thisArg：在函数执行时指定的this对象 argsArray: 传递的值，必须包含在数组（伪数组）里面（这个是和call的不同点） 返回值为函数的返回值，因为它就是调用函数 应用方面：apply传递数组参数，所以可以借助数学内置对象求最大值 Math.max.apply(Math,arr) （es6拓展运算符…Math.max(...arr)也可以，但是不能 Math.max(arr)，因为max不接受数组，只接受一个一个的参数） 3.bind()方法不会调用函数，但是能改变函数内部this指向 fun.bind(thisArg, arg1, arg2....) 返回指定this值和初始化参数改造的原函数拷贝（即创造新的函数 var f = fn.bind(xx)） 应用方面：定时器等不想立即调用的函数（或者处理其他只能用that来暂时储存对象的情况） btn.onclick = function() { this.disabled = true; //var that = this; //old way: /*setTimeout(function() { //that.disabled = false; }, 3000)*/ //new way: setTimeout(function() { this.disabled = false; }.bind(this), 3000) //这个this指向btn } 巧妙运用： 传参的时候可以传递其他对象过来 class Tab { constructor(id) { this.main = document.querySelector(id); //tabsbox this.lis = this.main.querySelectorAll('li'); } // 初始化 init() { for (let i = 0; i &lt; this.lis.length; i++) { this.lis[i].onclick = this.toggleTab.bind(this.lis[i], this); } } // 切换功能 toggleTab(that) { that.clearTab(); this.className = 'liactive' that.sections[this.index].className = 'conactive'; } } 8.严格模式ie10以上版本才支持 它是让JavaScript以严格的条件下运行代码 1.消除了JavaScript一些语法不严谨的地方，减少怪异行为 2.消除代码一些不安全之处，保证代码运行的安全 3.提高编译器效率，增加运行速度 4.禁用了ECMAscript在未来版本中可能会定义的一些语法，为未来JavaScript做好铺垫，比如class、enum、super等 开启严格模式应用到整个到整个脚本或个别函数中，因此，我们可以讲严格模式分为脚本开启严格模式和为函数开启严格模式两种情况 为脚本开启严格模式： &lt;script> \"use strict\"; //xxxx &lt;/script> 方法二：（写在立即执行函数里的都要按照严格模式） &lt;script> (function() { \"use strict\"; /xxxx })(); &lt;/script> 为函数开启严格模式：(只在此函数内部有严格模式) &lt;script> function fn(){ \"use strict\"; /xxxx } &lt;/script> 变化1.严格模式禁止变量为声明就赋值 2.严禁删除已声明的变量，比如delete x; 是错误的 3.在严格模式下，全局作用域中函数中的this不再是window，而是undefined（但是定时器之类的还是指向window） 4.严格模式下，如果构造函数不配合new来使用，this就会报错 5.函数不能有重名参数 6.函数必须声明在顶层，因为新版本的JavaScript引入了块级作用域，所以不允许在非函数代码块内声明函数 9.变量的作用域Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量。 另一方面，在函数外部自然无法读取函数内的局部变量。 var n=999; function f1(){ alert(n); } f1(); // 999 function f1(){ var n=999; } alert(n); // error 一定要使用var命令，如果不用的话，你实际上声明了一个全局变量 function f1(){ n=999; } f1(); alert(n); // 999 如果想要从外部读取内部的局部变量，则需要使用到：闭包！ 10.闭包闭包指有权访问另外一个函数作用域中变量的函数，简单理解就是一个作用域可以访问另外一个函数内部的局部变量 （被访问作用域的函数就是闭包函数） //在此处fun函数作用域访问了另外一个函数fn里面的局部变量num，形成了闭包，此时fun就是闭包 //fun被赋予了一个全局变量，所以fun始终保存在内存中，而fun依赖fn的num，因此num也始终在内存中 function fn() { var num = 10; function fun() { console.log(num); } fun(); } fn(); 在fn外部作用域访问fn内部局部变量（它返回了当时的作用域）： //所以闭包就是典型的高阶函数 function fn() { var num = 10; return function() { console.log(num) } } var f = fn(); f(); 闭包的主要作用： 延伸了变量的作用范围（读取函数内部的变量） 让这些变量的值始终保持在内存中 闭包缺点： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 利用闭包解决异步问题：（因为函数是一个作用域） //立即执行函数也成为了小闭包，因为立即执行函数里面任何一个函数都可以使用它的i变量，此时里面使用外层i的函数，都是闭包 for (var i = 0; i &lt; lis.length; i++) { (function (i) { lis[i].onclick = function () { console.log(i) } })(i); } 回调函数：获取异步操作的结果 一般情况下，把函数作为参数的目的就是为了获取函数内部的异步操作的结果 //如果需要获取一个函数中异步操作的结果，则必须通过回调函数来获取 function fn(callback) { setTimeout(function () { var data = 'hello'; callback(data); }, 1000) } fn(function (data) { console.log(data); }) 高阶函数如果一个函数符合下面两个规范的任何一个，那该函数就是高阶函数 若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数（比如Promise、setTimout） 若A函数，调用的返回值仍然是一个函数，那么A就可以称之为高阶函数（比如防抖，React实现传参的回调函数） 函数的柯里化 通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式（比如React实现传参的回调函数） function sum(a){ return (b) => { return (c)=> { return a+b+c; } } } sum(1)(2)(3) 纯函数一类特别的函数，只要是同样的输入（实参），必定得到同样的输出（返回） 必须遵守以下约束： 不得改写参数数据（如果传入数组、对象，则不能让他们发生改动） 不会产生任何副作用（例如网络请求，输入和输出设备） 不能调用Date.now()或者Math.random()等不纯方法 redux的reducer必须是一个纯函数 11.递归如果一个函数在内部可以调用其本身，则这个函数是递归（俄罗斯套娃） 但是容易发生“栈溢出”错误，所以必须加退出条件“return” 浅拷贝和深拷贝（jQuery篇目有提及到（$.extend([deep], target, object1, [objectN])）） 1.浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用 2.深拷贝拷贝多层，每一级别的数据都会拷贝 ES6中浅拷贝的语法糖：Object.assign(target, ...source)（把source拷贝给target，它将返回目标对象。） const target = { a: 1, b: 2 }; const source = { b: 4, c: 5 }; const returnedTarget = Object.assign(target, source); console.log(target); // expected output: Object { a: 1, b: 4, c: 5 }，按顺序覆盖掉原来的属性 利用循环写浅拷贝 var obj = { id: 1, name: 'andy', msg: { age: 18 } }; var o = {}; for (var k in obj) { // k是属性名， obj[k]是属性值 o[k] = obj[k]; } 利用递归写深拷贝 var obj = { id: 1, name: 'andy', msg: { age: 18 } }; var o = {}; function deepcopy(newobj, oldobj) { for(var k in oldobj) { // 获取属性值 var item = oldobj[k]; // 判断该值是否属于数组(数组也属于object，所以要先写) if(item instanceof Array) { newobj[k] = []; deepcopy(newobj[k], item); } else if(item instanceof Object) { // 判断该值是否为对象 newobj[k] = {}; deepcopy(newobj[k], item); } else { // 所以剩下的属于简单数据类型 newobj[k] = item; } } } deepcopy(o, obj); console.log(o); 12.正则表达式概述正则表达式（regular expression）是用于匹配字符串中字符组合的模式，再JavaScript，正则表达式也是对象 正则表达式通常用来做检索，替换那些符合某个模式（规则）的文本，例如昵称输入框里的对中文的匹配；此外，正则表达式还常用于过滤掉页面一些敏感（替换），或者从字符串获取我们想要的特定部分（提取）等 特点：1.灵活性、逻辑性、功能性非常强 2.可以迅速用极简的形式达到对字符串复杂的控制 3.对刚接触的人来说，比较晦涩难懂 4.一般实际开发，都是直接复制写好的正则表达式，但是要求会使用正则表达式且根据实际情况修改正则表达式 应用1.通过调用RegExp对象的构造函数创建 var 变量名 = new RegExp(/表达式/修饰符) var 变量名 = new RegExp(&#39;表达式&#39;, &#39;修饰符&#39;) 2.通过字面量创建 var 变量名 = /表达式/修饰符（正则表达式不需要加引号，不管是数字型还是字符串型） 测试正则表达式是否符合语法规范：test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数是测试字符串 regexObj.test(str) （只要包含有str这个字符串，返回的都是true） var rg = /123/; var rg2 = /123/g; console.log(rg.test(123)); //true console.log(rg.test(12123)); //true g：全局模式，查找字符串全部内容，再次匹配时会向前搜索下一个匹配项 i：不区分大小写 m：多行模式，表示查找到一行末尾会继续查找 y：粘附模式，每次调用exec()就只会在lastIndex的位置上寻找匹配字段 u：Unicode模式 s：dotAll模式，表示元字符 . 可以匹配任何字符 let a = \"address_address\"; let rg = /a/g; let reg = new RegExp(a, \"g\") //在正则中使用变量 rg.test(\"字符串\"); //是否包含该字符串，返回布尔值 eval(`/a${a}/`).test(\"字符串\") //在正则中使用变量 + 其他字符 a.match(rg); //返回匹配的字符串 + 具体信息，若正则启用全局模式，则返回一个数组，包含所有匹配的字符串 rg.exec(a); //和match差不多，只不过不受全局模式的影响，如果开全局模式，下次再匹配一次，则从lastIndex //开始匹配，在这里也就是从 下标为1的d 开始匹配 特殊字符一个正则表达式可以由简单的字符构成，比如/abc/， 也可以是简单和特殊字符串的组合，比如/ab*c/。其中特殊字符也被称为元字符，在正则表达式中具有特殊意义的专用符号，如^ 、$ 、+ 等 （匹配特殊字符前面增加 \\就可以了） 正则表达式速查表：https://www.runoob.com/regexp/regexp-metachar.html 边界符：^ 表示匹配行首的文本（以谁开始） $ 表示匹配行尾的文本（以谁结束） var rg = /^abc/; console.log(rg.test('abcd')); //true console.log(rg.test('babc')); //false //必须是abc,类似全等 var rg2 = /^abc$/; console.log(rg.test('abcd')); //false console.log(rg.test('abcabc')); //false 字符类：[]表示有一系列字符可供选择，只要匹配到其中一个就可以了 var rg = /[abc]/; //只要包含有a或者b或者c就返回true console.log(rg.test('andy')); //返回true //var rg = /^[abc]$/ 是三选一，只有是单个a或者b或者c才返回true []使用范围符号 - var rg = /^[a-z]$/; //26个英文小写字母任何一个字母都返回true var rg1 = /^[a-zA-Z]$/; //26个英文字母任何一个字母都返回true var rg2 = /^[a-z0-9_-]$/; //任何单个26小写字母，0-9数字，_, -,都返回true []里使用^：如果中括号里有^表示取反的意思，千万别和边界符^混淆，要区分开来 var rg = /^[^a-z]$/; //26个英文小写字母任何一个字母都返回false 量词符：用来设定某个模式出现的次数，有*、 +、 ？、 {}，{}的量词间不要有空格，可以用test来检测下方正则表达式 var rg = /^a*$/; //a可以出现0-n次，n>=0 var rg1 = /^a+$/; //a可以出现1-n次，n>=1 var rg2 = /^a?$/; //a可以出现1或0次 (?也可以表示禁止贪婪，往最少的匹配方式去选择) var rg3 = /^a{3}$/; //a只能可以出现3次 var rg4 = /^a{3,}$/; //a只可以出现3-n次 n>=3 var rg5 = /^a{3,16}$/; //a只可以出现3-16次 //普遍的用户名规定： var name = /^[a-zA-Z0-9_-]{6,16}$/ 括号总结 []中括号：字符集合，匹配方括号中的任意字符 {} 大括号：量词符，里面表示重复次数，但只让大括号前面一个字符重复 （注意：/^abc{3}$/，只让c重复三次，即abccc） () 小括号：表示优先级 可以用来：/^(abc){3}$/，表示让abc重复三次，即abcabc 预定义类\\d 匹配到0-9任意一数字，相当于[0-9] (var rg = /\\d/; 或者 let reg = new RegExp(&quot;\\\\d&quot;)) \\D 匹配到0-9以外的数字，相当于[^0-9] \\w 匹配任意字母、数字、下划线，相当于[A-Za-z0-9_] \\W匹配除字母数字下划线以外的字符，相当于[^A-Za-z0-9_] \\s 匹配空格（包括换行符、制表符、空格符等），相当于[\\t\\r\\n\\v\\f] \\S匹配非空格字符，相当于[^\\t\\r\\n\\v\\f] 正则里的 “或者符号”：| (var rg = /^\\d{3}-\\d{8}|\\d{4}-\\d{7}$/;) . 除了换行外的任何字符 正则替换replace()方法可以实现替换字符串的操作，用来替换的参数可以是一个字符串或者是一个字符表达式 stringObject.replace(regexp/substr, replacement) var str = 'red and blue and red'; var newstr = str.replace('red', 'yellow'); //结果为yellow and blue and red //var newstr = str.replace(/red/, 'yellow'); 同理 但是replace只能替换掉第一个匹配的字符/正则表达式，无法满足替换掉多个敏感词 可以使用: /表达式/[switch] swtich也成为修饰符，即按照什么样的模式来匹配 var str = 'red and blue and red'; var newstr = str.replace(/red/g, 'yellow'); //结果为yellow and blue and yellow","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JQuery","slug":"JQuery","date":"2020-11-29T16:15:30.028Z","updated":"2020-12-23T16:36:12.611Z","comments":true,"path":"2020/11/30/jquery/","link":"","permalink":"https://taylor12138.github.io/2020/11/30/jquery/","excerpt":"","text":"1.JQuery概述JavaScript库：即library，是一个封装好的特定集合（方法和函数），使得我们可以快速高效的使用这些封装好的功能，而jQuery 就是一个 JavaScript函数库 其他常见地js库还有Prototype、YUI、Dojo、ExtJS和移动端的zepto 优点： 1.轻量级，文件够小 2.跨浏览器兼容，基本兼容主流浏览器 3.链式编程、隐式迭代 4.对事件、样式、动画支持，极大地简化了dom的操作，支持插件扩展开发，有丰富的第三方插件 4.免费、开源 官网下载：https://jquery.com/ 最新版本早已不兼容ie6、7、8 等页面dom加载完毕再去执行代码（类似于DOMContentLoaded） //入口函数 $(function() { xxxx }) 要在页面引入官网下载的jQuery的js文件才能使用 2.jQuery的基本使用$是jquery的简称，一般在代码中用$替代jQuery $(function() { $(&#39;div&#39;).hide() }) 相当于 jQuery(function( jQuery(&#39;div&#39;).hide() ) {}) $是jQuery的顶级对象，相当于JavaScript的window，把元素$包装成jQuery对象，就可以调用jQuery方法 jQuery和dom用原生js获取的对象就是dom对象 用jQuery方式获取的对象就是jQuery对象 这两个对象是不一样的 jQuery对象的本质就是利用$对DOM对象包装后产生的对象（伪数组的形式储存） jQuery对象只能用jQuery方法，DOM对象则只能使用原生的JavaScript属性和方法 但是DOM对象和jQuery对象可以相互转换，因为原生js比jQuery更大，原生的一些属性和方法jQuery没有为我们进行封装，想要使用这些属性和方法需要把jQuery转换成DOM对象才能使用 //DOM转jQuery let myvideo = document.querySelector('video'); $(myvideo); //jQuery转DOM $('video')[index]或者$('video').get(index) $('video'); //获取元素 $('video')[0].play(); //将只有一个元素的视频过来并且使用DOM功能 3.jQuery的APIjQuery选择器$(&quot;选择器&quot;) 语法和CSS选择器一样即可 子代选择器 $(&quot;ul&gt;li&quot;) 后代选择器$(&quot;ul li&quot;) jQuery修改样式：$(&quot;div&quot;).css(&quot;属性&quot;, &quot;值&quot;) jQuery有隐式迭代，它会给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再循环，简化我们的操作 //一次性将所有选中的div元素背景颜色改为pink，不再需要for循环一个一个遍历更改 $(\"div\").css(\"background\", \"pink\"); jQuery筛选选择器 $(&quot;li:first&quot;) 选中第一个 $(&quot;li:last&quot;) 选中最后一个 $(&quot;li:eq(x)&quot;) 选中索引号为x的元素 $(&quot;li:odd&quot;) 选中索引号为奇数的元素 $(&quot;li:even&quot;) 选中索引号为偶数的元素 $(&quot;div&quot;).parent(); 返回的是最近一级的父元素 $(&quot;div&quot;).parents(); 返回的是所有祖先元素的数组，可以制定”()”里的类名单独指定是哪个祖先 $(&quot;div&quot;).children(&quot;ul&quot;); 返回指定的亲儿子，类似于子代选择器div&gt;ul $(&quot;div&quot;).find(&quot;li&quot;); 可以选定指定的所有孩子，类似于后代选择器 div li $(&quot;.item&quot;).sibling(&quot;li&quot;); 可以选定除本身外所有亲兄弟元素 $(&quot;li&quot;).eq(x); 选中索引号为x的元素, 类似$(&quot;li:eq(x)&quot;) ，但是此方法更推荐 $(&quot;li&quot;).hasCLass(&quot;类名&quot;); 查看是否有该类名，返回true或false jquery中的快速实现排他思想： $(function() { $(\"button\").click(function() { $(this).css(\"background\",\"pink\"); $(this).siblings(\"button\").css(\"background\", \"\") }) }) jQuery可以快速得到当前元素索引号，不再需要自己添加自定义属性index $(this).index() $(&quot;xxx:checked&quot;) 选择复选框中被选择的元素（$(&quot;xxx:checked&quot;).length为被选中复选框个数） jquery样式操作使用css方法： 1.参数只写属性名，返回属性值 $(this).css(&quot;color&quot;) 2.设置样式，属性名必须加引号，如果属性值值如果是数字可以不用跟单位和引号 $(this).css(&quot;color&quot;, &quot;red&quot;) 3.参数可以用对象的形式(里面的属性名不用加引号，如果如果属性值值如果是数字可以不用跟单位和引号) 如果是复合属性必须采取驼峰命名法（和DOM一样） $(this).css({ width: 400, height: 400, backgroundColor: \"green\" }) 直接设置类方式： 再写一个类，里面包含了所有你想要改变的样式，然后利用jQuery添加类功能，将其添加进去（注意直接添加类名，不需要 “.类名”） (原生js的className进行更改会覆盖原先的类名) // 1. 添加类 addClass() $(\"div\").click(function() { $(this).addClass(\"current\"); }); // 2. 删除类 removeClass() $(\"div\").click(function() { $(this).removeClass(\"current\"); }); // 3. 切换类 toggleClass() $(\"div\").click(function() { $(this).toggleClass(\"current\"); }); jQuery效果显示和隐藏效果 show([speed, [easing], [fn]]) 显示功能，参数可以省略， speed：三种预定字符串（”speed”,”normal”,”fast”）、或者使用毫秒数表示 easing：swing（在开头/结尾移动慢，在中间移动快）、linear（匀速） fn：回调函数 hide([speed, [easing], [fn]]) 隐藏功能，同上 toggle([speed, [easing], [fn]]) 切换（原本显示则隐藏，原本隐藏则显示） 滑动 slideDown([speed, [easing], [fn]]) 下拉显示，类似于手机官网那些下拉菜单，参数功能同上 slideUp([speed, [easing], [fn]]) 上拉隐藏，参数同上 slideToggle([speed, [easing], [fn]]) 拉动切换，参数同上 事件切换 hover([over],out) over: 鼠标移到元素上触发的函数（相当于mouseenter） out：鼠标移出元素触发的函数（类似于mouseleave） 简洁下拉菜单 $(\".nav>li\").hover(function() { $(this).children(\"ul\").slideDown(200); }, function() { $(this).children(\"ul\").slideUp(200); }); 或者 $(\".nav>li\").hover(function() { $(this).children(\"ul\").slideToggle(); }); 动画队列和其停止方法 上述下拉菜单代码有一个问题 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果的排队执行（即鼠标一次性经过多个选项，导致鼠标在一边停下来了之后，动画还在执行（因为还没执行完毕）） 停止排队： stop() stop()用于停止动画或者效果，将其写在动画或者效果的前面，相当于停止结束上一次的动画 //上述示例改进： $(\".nav>li\").hover(function() { $(this).children(\"ul\").stop().slideToggle(); }); 淡入淡出 fadeIn([speed, [easing], [fn]]) 淡入功能，参数可以省略， speed：三种预定字符串（”speed”,”normal”,”fast”）、或者使用毫秒数表示 easing：swing（在开头/结尾移动慢，在中间移动快）、linear（匀速） fn：回调函数 fadeOut([speed, [easing], [fn]]) 淡出 fadeToggle([speed, [easing], [fn]]) 淡入淡出切换 fadeTo([speed, opacity, [easing], [fn]]) 以渐进的方法修改透明度，opacity为透明度，必须写，取值范围0~1，speed也必须写 自定义动画animate animate(params, [speed], [easing], [fn]) params：想要更改的样式属性，以对象的形式传递，必须写，属性名可以不带引号，如果是复合属性需要采取驼峰命名法 其他的speed、easing、fn和之前相同 $(&quot;div&quot;).animate({ left: 500, top: 300, opacity: .4, width: 500 }, 500);4.jQuery属性操作element.prop(&quot;属性名&quot;) 获取属性值（固有的属性值） element.prop(&quot;属性名&quot;, &quot;属性值&quot;) 设置属性值 element.attr(&quot;属性名&quot;) 获取属性值（自定义属性），类似原生的getArribute element.attr(&quot;属性名&quot;, &quot;属性值&quot;) 设置属性值（自定义属性），类似原生的setArribute element.data(&quot;属性名&quot;, &quot;属性值&quot;) 设置数据缓存，data里的数据是存放在元素的内存中，而不是作为属性（这个方法可以获取data-index 即h5自带的自定义属性，不用写data-，写成$(“div”).data(“index”)） 5.jQuery内容文本值element.html() 获取元素内容（包含标签） 相当于原生的innerHTML element.html(&quot;内容&quot;) 设置元素内容 element.text() 获取元素内容（不包含标签） 相当于原生的innerText element.text(&quot;内容&quot;) 设置元素内容 element.val() 获取表单值 element.val(&quot;表单值&quot;) 设置表单值 6.jQuery的元素操作虽然jquery有隐式迭代，但是只是对同类元素做相同操作，如果想要给不同元素进行不同的操作，就需要使用到遍历 jQuery的遍历$(&quot;div&quot;).each(function (index, domEle) { xxxx; }) index（第一个参数）是每个元素的索引号，domELe（第二个参数）是遍历后的每个DOM元素对象，不是jQuery对象，如果想使用jQuery方法，需要给这个dom元素转换为jQuery对象（$(domEle)） $.each(object, function(index, element) { xxx; }) $.each() 方法可以用于遍历任何对象，主要用于数据处理，如数组、对象，index（第一个参数）为索引号（如果是对象，则为属性名），element（第二个参数）为遍历内容（如果是对象，则为属性值） 创建元素 $(&quot;&lt;li&gt;&lt;/li&gt;&quot;) 动态创建一个li标签 添加元素（创建完之后需要添加元素） 内部添加：（生成后它们是父子关系） element.append(&quot;内容&quot;) 放到匹配元素的最后面，类似于原生的appendChild element.prepend(&quot;内容&quot;) 放到匹配元素的最前，类似于原生的ul.insertBefore(xx, ul.children[0])(指定元素的前面) 外部添加：（生成后它们是兄弟关系） 外部添加：element.after(&quot;内容&quot;) 把内容放入目标元素的后面 element.before(&quot;内容&quot;) 把内容放入目标元素前面 删除元素element.remove() 删除匹配元素 element.empty() 删除匹配元素的所有子节点 element.html(&quot;&quot;) 清空匹配元素的内容（孩子） 7.jQuery事件事件注册element.事件(function() {}) 单个事件注册 如 $(&quot;div&quot;).click(function() {事件处理}) 其他事件和原生基本一致 事件处理on(可以绑定多个事件)on() 方法在匹配元素上绑定一个或多个事件的事件处理函数 element.on(events, [selector], fn) 1.events: 一个或多个用空格的事件类型，如”click” 2.selector: 元素的子元素选择器 3.fn：回调函数，即绑定在元素身上得到侦听函数 如 $(\"div\").on({ mouseenter: function() { //xxxxx }, click: function() { //xxxxx }, mouseleave: function() { //xxxx } }) 不同事件类型触发同一处理函数： $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() {}) on的优势2：可以进行事件委托如 //传统，但是给每个li都添加了一个事件，比较麻烦 $(\"ul li\").click(); //事件是绑定在ul身上，但是触发对象时li，li事件冒泡，冒泡到父级的点击事件然后执行程序 $(\"ul\").on(\"click\", \"li\", function() { }) 此前有blind()、live()等方法处理事件绑定或事件委托，但是我们最新版本用on就行了 on的优势3：动态创建元素，on可以给未来动态创建的元素绑定事件//传统，前面绑定事件，后面创建的标签没有绑定该事件 $(\"ol li\").click(function() {}) let li = $(\"&lt;li>xxx&lt;/li>\"); $(\"ol\").append(li); //使用on,之后创建的也能被给予绑定效果 $(\"ol\").on(\"click\", \"li\", function() {}) let li = $(\"&lt;li>xxx&lt;/li>\"); $(\"ol\").append(li); 事件off解绑off()方法可以移除通过on()方法添加的事件处理程序 element.off() 解绑该元素上所有事件 element.off(&quot;click&quot;) 解绑该元素上点击事件 $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() {}) $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;) 解除事件委托 只使用一次: 用one()来绑定有的事件只想触发一次，可以使用one来绑定 element.one(event, fn) 自动触发事件trigger比如click事件： 1.element.click() 2.element.trigger(&quot;click&quot;) 和上面的差不多 3.element.triggerHandler(&quot;click&quot;) triggerHandler不会触发元素默认行为（包括该元素绑定的其他行为），只触发”click” 事件对象element.on(events, [selector], function(event) {}) 中的event为事件对象 event.preventDefault() 或者return false 用于阻止默认行为 event.stopPropagation() 将其写于事件函数中，可以用于阻止冒泡 8.jQuery的其他方法jQuery拷贝对象$.extend([deep], target, object1, [objectN])（如果有冲突的，会覆盖掉targetObj 里面原来的数据） 1.deep: 如果为true为深拷贝，默认false为浅拷贝 （注意是复杂数据类型）浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝的对象，如果该复杂数据类型对象有冲突，直接覆盖掉 深拷贝，完全克隆，对于复杂数据类型拷贝的是对象，不是地址，修改目标对象不会影响被拷贝的对象（如果该复杂数据类型对象有冲突，但是里面的属性不冲突，则属性会合并在一起） //深拷贝时targetObject的msg会与obj的msg合并 //此时都有id，obj的id会覆盖掉targetObject的id var targetObject = { id: 0, msg: { sex: '男' //对象复杂数据类型 } }; var obj = { id: 1, name: 'andy', msg: { age: 18 } } $.extend(targetObject,obj); 2.target：要拷贝的目标对象 3.object1：待被拷贝到第一个对象的对象 （object拷贝给target） jQuery·多库共存随着jquery的流行，其他js库也会使用$作为标识符，这样一起使用会起冲突 需要一个解决方案，让jQuery和其他js库不存在冲突，可以同时存在，这就叫做多库共存 jquery解决方案： 1.把里面的$符号统一改为jQuery ，比如jQuery(“div”) 2.自定义，释放对$对控制权 var suibian = $.noConflict(); //var suibian = jQuery.noConflict(); suibian(\"span\") //原本是$(\"span\") jQuery插件jQuery功能比较有限，想要更加复杂的效果，可以借助jQuery插件（注：这些插件是依赖于jQuery，所以必须先引入jQuery文件，因此也成为jQuery插件） jquery常用网站： 1.jQuery插件库：http://www.jq22.com/ 2.jQuery之家：http://www.htmleaf.com/ (推荐) jQuery插件使用步骤：1.引入相关文件（jQuery、插件文件） 2.赋值相关html、css、js 图片懒加载: 在jQuery·插件可以找到，图片只加载到可视区域，减缓服务器压力 全屏滚动：jQuery的fullPage.js也十分好用 bootstrap也是依赖于jQuery开发的，因此里面的js插件使用，也必须引入jQuery文件 jQuery的位置位置主要有三个：offset()可设置、 position()只读、 scrollTop()/scollLeft()可设置 element.offset() 返回一个对象，里面包含left和top，用于设置或获取相对于文档document的偏移坐标 但是和原生不同的是，它可以设置偏移：element.offset({top: 10, left: 30})，且原生js的offset返回的是相对于父元素的偏移量 element.position() 获取带有相对于父级的偏移距离，如果没有定义父级，则以文档为准，但是此方法只能获取不能设置 element.scrollTop()/element.scrollLeft()设置或获取被卷去的头部和左侧，类似于原生js自带的元素滚动scroll","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"前端关于存储","slug":"前端关于存储","date":"2020-11-27T16:00:00.000Z","updated":"2021-08-22T12:18:59.160Z","comments":true,"path":"2020/11/28/qian-duan-guan-yu-cun-chu/","link":"","permalink":"https://taylor12138.github.io/2020/11/28/qian-duan-guan-yu-cun-chu/","excerpt":"","text":"本地存储使用HTML5可以在本地存储用户的浏览数据：local Storage、session Storage 1.数据存储于自己的浏览器当中 2.设置、读取十分方便，页面刷新数据不丢失 3.容量较大，sessionStorage约5M，localStorage约20M（可是我测试得到我chrome浏览器localStorage才5M） 4.只能存储字符串，可以将对象JSON.stringify() 编码后存储 cookie是网站为了标示用户身份而储存在用户本地终端上的数据；cookie数据始终在同源的http请求中携带（即使不需要），也会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存； 5.此外，User Data 是微软专门为IE在系统中开辟的一块存储空间，单个文件限制大小128kb，一个域名下可保存1M window.sessionStorage1.生命周期为关闭浏览器窗口 2.同一个窗口下数据可以共享 3.以键值对的形式存储使用 window.sessionStorage.setItem(key, value) 分别对应键和值，设置（添加或更改） window.sessionStorage.getItem(&#39;key&#39;) 获取 window.sessionStorage.removeItem(&#39;key&#39;) 删除 window.sessionStorage.clear() 删除所有数据(慎用) window.localStorage1.生命周期永久生效，除非手动删除，不然关闭页面仍然存在 2.多窗口共享（同一浏览器才能共享） 3.以键值对的形式存储使用 window.localStorage.setItem(key, value) 分别对应键和值，设置（添加或更改）（值是以字符串的形式进行存储的） window.localStorage.getItem(&#39;key&#39;) 获取 window.localStorage.removeItem(&#39;key&#39;) 删除 window.localStorage.clear() 删除所有数据(慎用) cookieCookie是一种在客户端保持HTTP状态信息的技术：http协议是无状态的，但是在实际工作中，一些万维网网站希望能识别用户（给用户推销产品）=&gt;诞生了cookie小饼干（由服务器生成），cookie是存储在用户主机的文本文件，记录一段时间内某用户的访问记录 一旦浏览器保存了某个Cookie，那么以后每次访问服务器时，都会在HTTP请求头中将这个Cookie回传给服务器 cookie数据大小不能超过4k cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 Web服务器怎么给客户端发Cookie的呢？服务器通过在HTTP响应头中增加Set-Cookie:字段，而浏览器则通过HTTP请求头增加Cookie字段回传 工作中识别用户给用户推销产品，用来保存一些不太敏感的数据（但我很纳闷，其实很多用户用cookie来记住密码） tips：一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token Sessioncookie和session都是用来跟踪浏览器用户身份的会话方式，通常使用cookie方式存储session ID到客户端 保持状态：cookie保存在浏览器端，session保存在服务器端 存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。 安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。 应用： cookie判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）；保存上次登录的时间等信息。 Session用于保存每个用户的专用信息，变量的值保存在服务器端，服务端会从请求传回来的 Cookie 中获取 SessionID，通过SessionID来区分不同的客户。 （1）网上商城中的购物车 （2）保存用户登录信息 （3）将某些数据放入session中，供同一用户的不同页面使用 （4）防止用户非法登录 cookie - session认证流程 1、用户向服务器发送用户名和密码。 2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 3、服务器向用户返回一个 session_id，写入用户的 Cookie。 4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 session缺点： Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。 Token上述展示了基于服务器验证的session（sessionID）暴露了一些弊端，当然使用session还有可能引起：跨域共享问题、CSRF攻击问题和可拓展性问题。 基于 Token 的身份验证是无状态的，我们不用将用户信息存在服务器或 Session 中。这种概念解决了在服务端存储信息时的许多问题。没有 session 信息意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录和已经登录到了哪里。 大多的token验证流程如下： 用户通过用户名和密码发送请求。 程序验证。 程序返回一个签名的 token 给客户端（令牌）。 客户端储存 token, 并且每次请求都会附带它。 服务端验证 token 并返回数据。（服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码） token优势 无状态（实际上是来自于JWT），无需存储session信息，负载均衡服务器，能够将用户请求传递到任何一台服务器上 可拓展，token保存在客户端本地，使用token可以和其他应用共享权限，比如将博客账号和qq账号进行关联，当通过第三方平台登录qq时，我们可以把博客发到qq平台中 安全性，防止CSRF攻击，请求中发送的是token而不是cookie，浏览器会将接收到的token值存储在Local Storage、sessionStorage或者cookie中 在信任网站的HTML或js中，会向服务器传递参数token，不是通过Cookie传递的，若恶意网站要伪造用户的请求，也必须伪造这个token，否则用户身份验证不通过。但是，同源策略限制了恶意网站不能拿到信任网站的Cookie内容（而正常的session + cookie组合不受同源策略的限制），只能使用，所以就算是token是存放在Cookie中的，恶意网站也无法提取出Cookie中的token数据进行伪造。也就无法传递正确的token给服务器，进而无法成功伪装成用户了。 移动端上不支持 cookie，而 token 只要客户端能够进行存储就能够使用，因此 token 在移动端上也具有优势。 不过，token有过期时间，超过事件后要重新获取token Token 的种类一般来说 token 主要三种： 自定义的 token：开发者根据业务逻辑自定义的 token JWT：JSON Web Token，定义在 RFC 7519 中的一种 token 规范 Oauth2.0：定义在 RFC 6750 中的一种授权规范，但这其实并不是一种 token，只是其中也有用到 token 附上登录认证的进化路程参考网址https://www.cnblogs.com/fengzheng/p/8416393.html （传统cookie-Session -&gt; 改造版cookie-session -&gt; 基于JWT的Token认证 -&gt; OAuth认证） JWT 的组成和优势JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。 一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。中间用 . 分隔，例如：xxxxx.yyyyy.zzzzz 头部（Header）头部用于描述关于该JWT的最基本的信息 { &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot; }说明了这是一个JWT，并且我们所用的签名算法（后面会提到）是HS256算法 载荷（Payload）载荷中放置了 token 的一些基本信息，以帮助接受它的服务器来理解这个 token。同时还可以包含一些自定义的信息，用户信息交换。 Payload 部分也是一个 JSON 对象，JWT 规定了7个官方字段，供选用。 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 { \"iss\": \"John Wu JWT\", //签发者 \"iat\": 1441593502, //签发时间 \"exp\": 1441594722, //过期时间 \"aud\": \"www.example.com\", //受众 \"sub\": \"jrocket@example.com\", //主题 \"from_user\": \"B\", //自定义私有字段 \"target_user\": \"A\" //自定义私有字段 } 通过Node.js的包base64url来得到一个很长的字符串（ console.log(base64url(JSON.stringify(header))) ），如下图 签名（Signature）为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名 签名时需要用到前面编码过的两个字符串，使用 Header 里面指定的签名算法（默认是 HMAC SHA256） 加密算法对于不同的输入（头部和载荷）产生的输出总是不一样的，如果数据被修改，得到的签名总会是不一样的，而且，如果不知道服务器加密的时候使用密钥，得到的签名也会是不一样的。 如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token，返回一个HTTP 401 Unauthorized响应。 三者组合就形成了一个完整的JWT 建议 在JWT中，不应该在载荷里面加入任何敏感的数据（比如密码），怀有恶意的第三方通过Base64解码可以获取到JWT里的信息 虽说JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。（此时才可以写入秘密数据） 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 使用场景 完成加好友的操作，还有诸如下订单的操作 设计用户认证和授权系统，甚至实现Web应用的单点登录。 JWT和token的不同点Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。 JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。 JWT参考文章：http://blog.leapoahead.com/2015/09/06/understanding-jwt/ 阮一峰老师的介绍 http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html JWT详解攻略：https://learnku.com/articles/17883?order_by=vote_count&amp; JWT实战演练先进行安装 npm i jsonwebtoken npm i express-jwt jsonwebtoken: 用于生成 Token 。它也有解析 Token 的功能 express-jwt: 用于解析 Token（比 jsonwebtoken 解决方便） , 它把解析之后的数据，存放到 requset.user 中 jsonwebtoken 提供了sign(payload, secretOrPrivateKey, [options, callback])的方法。 sign ：对应的其实就是 JWT 签名(Signature)的动作 payload：对应的是传入的载荷，可以省略官方提供七个字段，额外添加自定义私有字段，比如用户信息userId等等 secretOrPrivateKey：自定义的密钥，属于敏感信息 options：可以配置 header 、荷载、指定算法类型（常用的只有 exp(expiresIn)有效时间 和 algorithm 算法类型这两个字段） 参考文章https://juejin.cn/post/6932374305758167054","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"PC&移动端网页特效(JS)","slug":"PC&移动端网页特效(JS)","date":"2020-11-17T16:00:00.000Z","updated":"2021-08-22T11:48:27.866Z","comments":true,"path":"2020/11/18/pc-yi-dong-duan-wang-ye-te-xiao-js/","link":"","permalink":"https://taylor12138.github.io/2020/11/18/pc-yi-dong-duan-wang-ye-te-xiao-js/","excerpt":"","text":"PC端1.offset元素偏移量我们使用offset系列相关属性可以动态获取元素的位置（大小）（父亲要定位此功能才有用 element.offsetTop 返回元素相对带有定位父元素上方的偏移，不带单位，如果没有定位或者没有父元素则以body为准 element.offsetLeft 返回元素相对带有定位父元素左方的偏移，情况同上 element.offsetWidth 返回自身宽度大小，自身宽度+padding+border element.offsetHeight 返回自身高度大小，同上 element.offsetParent 返回带有定位的父亲，否则返回body（element.parentNode 直接返回最近一级的父节点，不管父节点是否有定位） offset和style的区别：offset可以得到任意样式表的样式值 style只能得到行内样式表的样式值 offset系列获得的数值没有带单位 style.width获得的是带单位的字符串 offsetWidth等是包含padding+border style.width获得不包含padding和border的值 offsetWidth等属性是只读属性，只能获取不能赋值 style.width是可读写属性，可以赋值 所以offset适合读值，style适合赋值改值 2.元素可视区client通过client系列的相关属性可以动态得到该元素的边框大小、元素大小等（与offset不同点是边框是否囊括其中） element.clientTop 返回元素上边框的大小 element.clientLeft 返回元素左边框的大小 element.clientWidth 返回自身包括padding、内容区的宽度，不包含border，返回数值不带单位 element.clientHeight 同上，返回高度 （番外）立即执行函数立即执行函数，不需要调用，直接执行 传统： function fn() {} fn(); 立执： (function(a, b) {}(1, 2)) //第一种 (function(a, b) {})(参数1, 参数2) //第二种 立即执行函数最大的优点就是独立创建了一个作用域 3.元素滚动scroll获取或设置一个元素的内容垂直滚动的像素数 有点像client，但是client是盒子的大小宽高，即使内容溢出后保持不变，但是scroll面对溢出状态的盒子，它提供的宽高与内容溢出的宽高相互关联。 以下的element，都是针对父盒子的，无论是事件监听or属性(记得父盒子小，子盒子要大于父盒子的大小，并且设置父盒子的css样式overflow: scroll 或者 overflow: auto) father.addEventListener('scroll', () => { console.log(father.scrollTop); }) element.scrollHeigh 返回自身高度，不含边框，不带单位，像clientHeight + 超出文字部分高度 element.scrollWidth 返回自身宽度，不含边框，不带单位，像clientWidth + 超出文字部分宽度 element.scrollTop 返回被滚动条卷上去的上方距离，返回数值不带单位（要有滚动条，且内容大于盒子，往下拉的时候才会有） element.scrollLeft 返回被滚动条卷左的左侧距离，同上 (window的scroll没有scrollTop、scrollLeft，但是有个api可以获取当前网页的scrollTop： var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;) 滚动条在滚动时发生的事件：onscroll事件 检测整个页面的滚动属性： window.pageYOffset window.pageXOffset等 (ie9以上才支持) 让窗口滚动事件：window.scroll(x, y) 三大系列总结offset常用于获取元素位置 element.offsetTop element.offsetLeft 只读的 client常用于获取元素大小 element.clientWidth element.clientHeight 只读的 scroll常用于获取滚动距离 element.scrollTop element.scrollLeft 可设置 判断图片是否滚动到浏览器的可视区域方法一：图片/元素的offsetTop &lt; 当前的元素父亲的scrollTop 图片/元素 offsetTop +图片/元素 clientHeight &gt; 当前元素父亲的 scrollTop 方法二：window.scrollY &gt; 图片/元素的offsetTop 方法三：element.getBoundingClientRect(),返回的结果是包含完整元素的最小矩形，并且拥有left, top, right, bottom, x, y, width, 和 height这几个以像素为单位的只读属性用于描述整个边框。除了width 和 height 以外的属性是相对于视图窗口的左上角来计算的。 图片/元素的getBoundingClientRect().top &lt; document.clientHeight 且 图片/元素的getBoundingClientRect().bottom &gt; 0 4.动画函数封装原理：获取盒子当前位置（position），通过定时器setinterval()不断移动盒子位置，利用定时器不断让盒子当前位置加上一个移动距离，最后加一个结束定时器条件（其实也可以用CSS animation 定义动画） &lt;div>&lt;/div> &lt;script> //简单动画函数封装obj目标函数，target目标位置 //给不同的元素制定了不同的定时器 //不过再js中尽量避免这一种“先创建再补充”的动态属性赋值 function animate(obj, target) { obj.timer = setInterval(function () { if (obj.offsetLeft >= target) { clearInterval(obj.timer); } else { obj.style.left = obj.offsetLeft + 5 + 'px'; } }, 30); } // 调用函数 let div = document.querySelector('div'); animate(div, 300); &lt;/script> 缓动动画：让元素运动速度有所变化 ，即让它每次移动的距离有所变化（如慢慢变小）就可以达到效果 比如可以：（目标值-现在位置）/10 作为每次移动的步长 停止条件：让盒子位置等于目标位置 动画函数添加回调函数：回调函数原理为函数作为一个参数，即将这个函数作为参数传到另一个函数里，当那个函数执行完毕之后，再执行传进去的这个函数，这个过程叫做回调 添加了一点细节和回调函数后的改进代码 //简单动画函数封装obj目标函数，target目标位置 //给不同的元素制定了不同的定时器 //不过再js中尽量避免这一种“先创建再补充”的动态属性赋值 function animate(obj, target, callback) { // 当我们不断点击按钮，元素速度会越来越快，因为开启了太多定时器 // 解决方案就是让我恩的元素只有一个定时器执行,清楚之前的定时器 clearInterval(obj.timer); obj.timer = setInterval(function () { // 把步长值改为整数，不要出现小数的问题 let step = (target - obj.offsetLeft) / 10; // 正值往小的取整，负值往大的取证, 保证数值刚好等于target（） step = step > 0 ? Math.ceil(step) : Math.floor(step); // 可以让800回到500，所以用== 而不是>= if (obj.offsetLeft == target) { clearInterval(obj.timer); // 如果有回调函数，在定时器结束时调用 /*if (callback) { callback(); }*/ //更棒写法 callback &amp;&amp; callback(); } else { obj.style.left = obj.offsetLeft + step + 'px'; } }, 30); } // 调用函数 let div = document.querySelector('div'); let btn500 = document.querySelector('.btn500'); let btn800 = document.querySelector('.btn800'); btn500.addEventListener('click', function () { animate(div, 500, function () { alert('hello') }); }) btn800.addEventListener('click', function () { animate(div, 800); }) 5.节流阀控制速度，用于类似于防止轮播图按钮连续点击，导致播放过快的后果 即当上一个函数动画内容执行完毕再去执行下一个函数动画，让事件无法连续触发 核心思路是：利用回调函数，添加变量进行控制。锁住函数和解锁函数 // 设置节流阀 let flag = true; arrow_r.addEventListener('click', function () { if (flag) { flag = false; fun(x, y, function () { flag = true; }); } }) 移动端移动端兼容性较好，我们不需要考虑以前js的兼容问题，可以放心使用原生的JS书写，但是移动端也有自己独特的地方，如touch事件等 1.touch事件响应用户手指对屏幕的操作 touchstart 手指触摸到一个dom元素 （像mousedown） touchmove 手指在一个dom元素上滑动 （像mousemove） touchend 手指从一个dom元素上移开 （像mouseup） div.addEventListener('touchstart', function() {}) 移动端拖动原理：盒子原来的位置+手指移动的距离 拖动三部曲：（手指移动会触发滚动屏幕，所以要在这里阻止的屏幕滚动e.preventDefault()） 触摸 touchstart 获取初始坐标 移动手指 touchmove 计算手指滑动距离，并且移动盒子 离开手指 touchend //div加了绝对定位 &lt;div>&lt;/div> &lt;script> let startX = 0; let startY = 0; let x = 0; let y = 0; let div = document.querySelector('div'); div.addEventListener('touchstart', function (e) { // 获取第一个触碰的坐标 startX = e.targetTouches[0].pageX; startY = e.targetTouches[0].pageY; // 获取盒子的位置 x = this.offsetLeft; y = this.offsetTop; }) div.addEventListener('touchmove', function (e) { // 计算手指移动的距离，手指移动后坐标-手指初始坐标 let moveX = e.targetTouches[0].pageX - startX; let moveY = e.targetTouches[0].pageY - startY; // 移动盒子 this.style.left = x + moveX + 'px'; this.style.top = y + moveY + 'px'; // 阻止屏幕滚动 e.preventDefault(); }) &lt;/script> 2.移动端常见特效transitionend 事件移动端兼容性较强，在js制作时可以穿插 transform:translate(x, y) 、transition 等， 对于transition ，此时需要用到 transitionend 事件 ，等待过渡完成之后，再去判断是否到达最后一张，监听过渡完成事件 classList 属性它是h5新增的属性，返回元素的类名（返回形式为数组，因为一个元素可能包含多个类），但是ie10以上才支持（移动端也支持） let div = document.querySelector('div'); //返回第一个类的类名 console.log(div.classList[0]); 添加类名, 是追加，不会覆盖以前的类名，注意xx前面不用加 ‘.’ element.classList.add(&#39;xx&#39;) 移除类名 element.classList.remove(&#39;xx&#39;) 切换类名（原来有，就给你删除掉，原来没有，就给你加上） element.classList.toggle(&#39;xx&#39;) 移动端click问题移动端click事件会有300ms的延迟，原因是移动端双击会缩放页面 解决方案1：禁用缩放功能 &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt; 在最顶端的视口标签处写下user-scalable=no 解决方案2：利用touch事件自己封装： 手指触屏记录触摸时间 手指离开屏幕，用离开时间减去触摸的时间，若时间小于150ms则没有缩放屏幕，定义为点击事件 解决方案3：使用fastclick插件 在 vue 中 npm i fastclick -S 在 main.js 中 import fastClick from 'fastclick' fastClick.attach(document.body) 3.插件js插件就是js文件，它遵循一定规范进行编写，方便程序展示效果，拥有特定功能且方便调用，功能单一且文件小 插件的使用： 1.引入js文件 2.按照语法规范进行使用 比较常见的还有swiper插件（轮播图）、supersilide插件（无缝滚动等）、iscroll插件、视频插件等等 4.框架比如bootstrap，同样 来自于twitter，目前最受欢迎的前端框架(拿来主义) 中文官网：https://www.bootcss.com/ 官网：https://getbootstrap.com/ 2.x.x 已经停止维护，功能不够完善 3.x.x 目前使用最多，但已经放弃了ie6，ie7，对ie8支持但是界面效果不好，偏向于开发响应式布局，移动设备优先的web项目 4.x.x 最新版，但是目前不流行 根据官网的介绍引入js和结构即可使用 5.移动端滚动默认的滚动原理，在移动端十分卡顿 可以在github上安装 better-scroll 框架 让你的滚动更加丝滑 原生 JS 实现局部滚动：给定盒子高度，使用 overflow:scroll 使用better-scroll :（老师用的版本1.13.2） 安装 npm i better-scroll 基本使用在滚动内容外面套上一个 div 标签， class=&quot;wrapper&quot; 在js里引入并且使用 import BScroll from 'better-scroll' let wrapper = document.querySelector(\".wrapper\"); //滚动内容部分的元素 let scroll = new BScroll(wrapper, {}); //创建BScroll实例 如果在vue内使用，可以把创建BScroll对象放在 mounted生命周期钩子里 html部分： 注意：wrapper子元素只能有一个，所以不能直接绑定在ul上 注意：wrapper 在CSS里必须要有一个固定的高度 &lt;div class=\"wrapper\"> &lt;ul> &lt;!--许多的li --> &lt;/ul> &lt;/div> 事件监听BScroll创建出来的实例可以使用 on 监听事件 sroll是滚动事件 pullingUp是上拉事件 但是 *默认 *情况下 BScroll是不能实时监听滚动位置的，需要配置probeType better-scroll 管理的标签内部默认会阻止浏览器原生的click事件，需要配置click 必须在实例对象里开启pullUpLoad才能使用pullingUp事件，pullingUp事件只会触发一次，想要在发送网络请求，将新数据展示完毕继续使用该功能的话，需要 scroll.finishPullUp() new BScroll(wrapper, {配置option}) 1.重要配置属性probeType, probe：侦测, 默认值0（用scroll事件监听） 0、1都表示不侦测 1：非实时（屏幕滑动超过一定时间后）派发scroll 事件； 2：手指滑动时侦测，惯性滑动不侦测 3：只要滚动都进行侦测 2.click，默认值false better-scroll管理的标签内部默认会阻止浏览器原生的click事件 当设置为true的时候，better-scroll会派发一个click事件 3.pullUpLoad常用于上拉加载更多 默认值false 用pullingUp进行事件监听，传入boolean / Object ，设置为true或object开启功能 还有很多option配置，详情看官网 let wrapper = document.querySelector(\".wrapper\"); this.scroll = new BScroll(wrapper, { probeType: 2, click: true, pullUpLoad: true, }); //监听滚动事件 this.scroll.on(\"scroll\", (position) => { console.log(position); }); //回拉至x,y位置 //this.scroll.scrollTo(x, y[, time]); //监听上拉事件 this.scroll.on(\"pullingUp\", () => { console.log(\"上拉加载更多\"); }); //监听加载一次上拉事件，需要使用此函数才可以重新开启监听上拉事件 pullingUp this.scroll.finishPullUp(); // 修复better-scroll 因异步的网络请求图片到达，却未计算可滚动高度而无法滑动产生的bug，使用refresh进行刷新 this.scroll.refresh(); //输出滚条当前的x和y console.log(this.scroll.x); console.log(this.scroll.y); 解决better-scroll可滚动区域产生的bugbetter-scroll滚动区域是由 scrollHeight属性决定的，也就是content中子组件的高度 但有时因为异步操作（比如网络请求），导致 scrollHeight未能够计算出正确的组件高度 解决： 监听每一张图片加载完成（每一次的网络请求），只要有一张图片加载完成，就调用 refresh()一次 img.onload() = funciton(){}（vue中，监听加载则 @load=&quot;函数名&quot;） 使用事件总线 eventBus，管理、传递该加载事件到对应的组件，然后进行 refresh() 6.防抖函数有点像节流阀，节流阀：将多次执行变为在规定时间内只执行一次 也就是说，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。 防抖： 在规定的时间内执行多次事件只执行最后一次 （在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms） 上述 “解决better-scroll可滚动区域产生的bug” 操作我们可以看到，每有一张图片加载完成，则发送一次请求，这样会大大降低参加程序效率、性能 为此我们可以封装一个防抖函数 debounce(func, delay) { let timer = null; return function (...args) { if (timer) clearTimeout(timer); timer = setTimeout(() => { // 这里的apply只用一个传入多个参数作用，箭头函数已经指向环境this，不需要用apply绑定 func.apply(this, args); }, delay); }; } 在vue中，我们可以在mounted里调用该函数 mounted() { // 监听goodListItem中图片加载完成 // 修复better-scroll 因异步的网络请求图片到达，却未计算可滚动高度而无法滑动产生的bug，使用refresh进行刷新 // 然后用防抖函数优化,减少函数调用频率 const refresh = this.debounce(this.$refs.scroll.refresh, 50); //得到一个带计时器的函数，里面保存着闭包的timer this.$bus.$on(\"itemImageLoad\", () => { refresh(); //调用refesh进行更新 }); }, 平时开发中常遇到的场景： 搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。 页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况） 这里借用老哥的节流代码 （附上原文https://segmentfault.com/a/1190000018428170/） function throttle(fn,delay){ let valid = true return function() { if(!valid){ //休息时间 暂不接客 return false } // 工作时间，执行函数并且在间隔期内把状态位设为无效 valid = false setTimeout(() => { fn() valid = true; }, delay) } } /* 请注意，节流函数并不止上面这种实现方案, 例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。 也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样 */ // 以下照旧 function showTop () { var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log('滚动条位置：' + scrollTop); } window.onscroll = throttle(showTop,1000)","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"BOM","slug":"BOM","date":"2020-11-13T16:17:20.669Z","updated":"2021-08-22T10:26:41.840Z","comments":true,"path":"2020/11/14/bom/","link":"","permalink":"https://taylor12138.github.io/2020/11/14/bom/","excerpt":"","text":"1.BOM概述BOM是浏览器对象模型，他提供独立于内容而与浏览器窗口进行交互的对象，其核心对象是window BOM缺乏标准，Javascript语法的标准化组织是ECMA，DOM标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分，所以它的兼容性比较的差 BOM比DOM更大，它包含着DOM window对象是浏览器的顶级对象，它是JS浏览器的一个接口，是一个全局对象，定义在全局作用域的变量（var）、函数都会变成window对象的属性和方法（alert()、prompt() ），在调用的时候可以省略window 2.window对象常见事件（1）onload本来我们的内嵌式&lt;script&gt;&lt;/script&gt;只能放在所有标签标签下方 而window.onload可以解决，它是窗口加载事件，当文档内容完全加载以后才会触发该事件（包括图像、脚本、CSS），就调用该函数 &lt;script> window.onload = function() { var btn = document.querySelector('button'); btn.onclick = function() { } } &lt;/script> &lt;button>&lt;/button> 但是window.onlaod传统注册方式只能写一次，如果写多个，只以最后一个onload为准，所以推荐 window.addEventListener('load', function() {}) 所以一般情况下引入js文件，则该js文件都要添加 ↑ pageshow事件下面三种情况会触发load事件： 1.a标签的超链接 2.F5刷新（或者强制刷新） 3.前进或后退 但是在火狐中有个“往返缓存”，它不仅保留着页面数据，还保存着DOM和Javascript的状态，实际上将整个页面保存在内存里，导致后退按钮不能刷新页面（无法触发load事件） 所以此时可以用pageshow事件来触发，它有点像load，但是事件在页面显示时就会触发，无论页面是否来自缓存（注意这个事件是给window添加的） window.addEventListener(&#39;pageshow&#39;, fucntion(e){ //e.persisted返回的是true，就是说如果这个页面是从缓存取过来的页面，也需要重新计算一下rem if(e.persisted) { setRemUnit(); //这个函数是设置rem的 } })new : DOMContentLoaded当DOM加载完毕时触发，不包括样式表，图片，flash等，ie9以上支持，如果页面图片很多，onload的出发会比较久，用户体验不佳 ，此时DOMContentLoaded比较合适，执行顺序DOMContentLoaded &gt; onload document.addEventListener('DOMContentLoaded',function(){ }); load和ready（jQuery） 一般情况下一个页面响应加载的基本顺序是：域名解析 -&gt; 加载html -&gt; 加载js和css -&gt; 加载图片等其他信息 $(document).ready()（在原生的jS中不包括ready()） 从字面的意思上理解，就是文档准备好了。也就是浏览器已经加载并解析完整个html文档，dom树已经建立起来了,然后执行此函数（不包含图片，css等） load 是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数，load方法就是onload事件。 所以对应的缺点是：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响 （2）调整窗口大小只要窗口发生变化，就会触发这个事件 window.onresize = function() {} window.addEventListener(&#39;resize&#39;, function() {}) 响应式布局原理 &lt;div>&lt;/div> &lt;script> var div = document.querySelector('div'); window.addEventListener('resize', function() { if (window.innerWidth &lt;= 800) { div.stye.display = 'none'; } else { div.style.display = 'block'; } }) &lt;/script> （3）定时器window.setTimeout(调用函数, 延时时间) 这个window在调用时可以省略，延时时间单位是毫秒，默认省略为0 延时xx毫秒后，执行该函数，写函数名不加括号、不带参数 var a = setTimeout(function() {}, 1000); var b = setTimeout(callback, 1000); //callback为一个函数 页面中时常有很多定时器，我们经常给定时器加标识符（名字） setTimeout() 这个调用函数我们也称之为回调函数（需要等待时间，时间到了才去调用该函数） callback ，以前onclick之类的函数也是回调函数 停止定时器window.clearTimeout (timeoutID) timeID为定时器的名字（所以我们上方说明了经常要给定时器加名字），这里的window也可以省略，调用该停止定时器方法后，定时器的调用函数不执行，时间被停止了 setInterval() 定时器window.setInterval(回调函数, [间隔毫秒数]) 重复调用一个函数，每隔这个时间就去调用一次，写函数名函数不加括号、不带参数；window也可以省略，默认省略的话为0，同样我们也经常给该定时器加标识符（名字） 这里的关键点是第二个参数，间隔时间，指的是向队列添加新任务之前等待的时间， 比如调用setTimeout的时间为01:00:00，间隔时间为300毫秒，这意味着 01:00:03时，浏览器才会把任务添加到执行队列里，浏览器不关心这个任务什么时候执行，或者执行要花多长时间 因此到了 01:00:06，它会在想队列中添加一个任务 停止setInterval定时器window.clearInterval(intervalID) 同停止定时器 利用定时器自动调用事件例如调用在js中的某点击事件 // 自动播放轮播图 let timer = setInterval(function () { arrow_r.click(); }, 2000); }) 关于定时器延时比设定更久的原因：最小延时 &gt;=4ms（也就是说有4ms的延时） 在浏览器中，setTimeout()/setInterval() 的每调用一次定时器的最小间隔是4ms（不过，Chrome 已将其更改为 2 毫秒，并且显然存在一些问题。），这通常是由于函数嵌套导致（嵌套层级达到一定深度），或者是由于已经执行的setInterval的回调函数阻塞导致的。例如： function cb() { f(); setTimeout(cb, 0); } setTimeout(cb, 0); setInterval(f, 0); 如果想在浏览器中实现0ms延时的定时器，你可以参考（使用postMessage自己写一个定时器函数加载window对象上） https://dbaron.org/log/20100309-faster-timeouts requestAnimationFrame（IE9-浏览器不支持该方法）官方解释：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame() 有点像setInterval，默认每秒60帧，也就是 1000 / 60，采用系统时间间隔，保持最佳绘制效率 对比起 setInterval和 setTimeout的优势 requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。 (function animloop() { render(); window.requestAnimationFrame(animloop); })(); 当然，requestAnimationFrame也有自己的消除定时器，需要传入requestAnimationFrame的id，而id来自于requestAnimationFrame的返回。 let rafId = null; (function animloop(time) { console.log(time,Date.now()) render(); rafId = requestAnimationFrame(animloop); //如果left等于50 停止动画 if(left == 50){ cancelAnimationFrame(rafId) } })(); （4）thisthis的指向在函数定义的时候是确定不了的，只有函数执行的时候才能知道this的指向，一般this最终指向调用它的对象 全局作用域或者普通函数中this指向window, 如 function Fn() { console(this); } Fn(); 方法调用中，谁调用this指向谁（xx = function() {}, 此时function中的this指向xx） 构造函数中this指向的是构造函数的实例对象，如 function Fun() { console.log(this); } var fun = new Fun(); （5）dpr 物理像素比pc端一般都是1，移动端比如iPhone6/7/8都是2，移动端不尽相同 var dpr = window.devicePixelRatio || 1 3.JS执行队列JS原先是单线程，也就是说同一时间只能做一件事，但是单线程就意味着，所有任务需要排队，钱一个任务结束后，才能执行下一个任务，如果JS执行时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞 多线程十分强大，但是多线程同步比较复杂，并且危险，稍有不慎就会崩溃死锁 &amp; 造成大量并发问题 而传统上，JS旨在用于简短，快速运行的代码片段，作为浏览器脚本语言，主要用途是与用户互动，以及操作DOM，所以JS比较适合单线程 为了解决这个问题，H5提出Web Worker标准，允许JS创建多个线程（实际上是“假”并发），于是JS出现了同步（单线程）和异步（现在的JS可以同时多个任务） 他们本质的区别是，这条流水线上各个流程执行的顺序不同 （1）同步和异步同步任务都放在一个主线程上执行，形成一个执行栈，按顺序执行 异步任务：JS的异步是通过回调函数实现的，一般而言，异步任务有以下三种类型 1.普通事件，如click、resize等 2.资源加载，如load、error等 3.定时器，如setTimeout、setInterval等 （2）宏任务和微任务这里需要注意的是new Promise是会进入到主线程中立刻执行（promise本身不是异步，只是里面的任务是异步的罢了），而promise.then则属于微任务 宏任务(macro-task)：是由宿主（Node、浏览器）发起的，比如整体代码script、setTimeOut、setInterval、postMessage 微任务(mincro-task)：由JavaScript自身发起，比如promise.then、process.nextTick(node) 微任务先执行，宏任务后执行 同步代码执行完成后，会先执行微任务队列。注意：此时会把所有微任务队列全部执行完。再去宏队列macrotask取出一个执行，如果宏任务执行过程中产生新的微任务，会跳过微任务继续执行并立即把微任务放到异步任务队列大池子中。当前条宏任务执行完后，又去检查待执行的任务队列大池子，如果有微任务，就优先执行微任务，如果没有就继续执行宏任务队列 （3）执行机制1.先执行执行栈中的同步任务 2.异步任务（回调函数）放入任务队列中 3.一旦执行栈所有同步任务执行完毕，系统就会按次序读取任务队列的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 有异步任务交给异步进程处理（新开一个线程用来执行那些异步任务，我们暂且称为工作线程），异步任务执行完毕后推入任务队列 当主线程执行完毕就来查询任务队列，取排在第一位的事件推入主线程处理，执行完再来取，不断循环，这个过程叫作事件循环 （实际上细分异步事件的优先级有宏任务和微任务，优先级：微任务&gt;宏任务） 异步任务执行顺序不一定按照原来顺序，要取决于文件大小、操作系统调度机制等多方面原因 （4）node的执行机制node的事件循环包括六大阶段 timers阶段（setTimeout、setInterval的事件回调） I/O callbacks 阶段：处理上一轮循环中少数未执行的I/O回调 idle，prepare阶段：仅node内部使用 poll阶段：获取新的I/o事件，适当条件下node阻塞在这里 check阶段：执行setImmediate回调 close callbacks 阶段：执行socket的close回调 这导致了node和浏览器端执行宏任务和微任务的顺序不一样！！ 不过！！在node新的版本逐步完善了，也就是node新版本标准和浏览器趋于相同 （V12.7以上） process.nextTick 这个函数其实是独立于node的 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。 4.location对象location是window对象提供给我们的一个属性，用于获取或设置窗体的URL，并且可以用于解析URL，返回的是一个对象 URL：统一资源定位符是互联网上标准资源的地址，互联网上每个文件都有唯一的URL，它包含的信息支持文件的位置以及浏览器该如何使用它（URL也就是我们的网址） 组成： protocol://host[:port]/path/[?query]#fragment protocol：通信协议，即http、ftp等 host：主机（域名） port：端口号，可选 path：路径，用 / 分隔 query：参数，以键对的形式，通过 &amp; 分隔 fragment：片段， # 后面内容，常见于链接锚点 location对象属性： location.href 获取或设置（实现页面跳转） 整个URL（最常见） location.hash URL散列值，Vue-Router、的hash模式、React路由的HashRouter 跳转原理 location.host 服务器名和端口号 location.search 返回参数（即query部分 ）（这不就是React的search传参吗？） location.assign() 跟href一样，可以跳转页面，但是可以后退 location.replace() 同上，但是不能记录历史，不能实现后退功能 location.reload() 类似于F5刷新 （location.reload(true)为强制刷新，缓存一起没了） 等等 5.navigator对象navigator对象包含浏览器的信息，它可以知道你是用的是pc端浏览器还是移动端浏览器，有很多属性，最常用的是userAgent，该属性值返回又客户机发送服务器user-agent头部的值 &lt;script> if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href = \"../H5/index.html\"; //手机 } &lt;/script> 引入以上代码可以自动判断是进入了pc端浏览器还是移动端浏览器 此外，navigator还暴露了一些API，可提供浏览器和操作系统的状态信息 Geolocation API navigator.geolocation属性暴露了Geolocation API，可以让浏览器脚本感知当前设备的地理位置。这个API只在安全执行环境（HTTPS）中可用 手机GPS的坐标系统可能具有极高的精度，而IP地址的精度就要差的很多 不过浏览器也有可能会利用 Google Location Service（Chrome和Firefox）等服务确定位置。有时候，你可能发现自己并没有GPS，但浏览器给出的坐标却十分精确，是因为浏览器会收集所有可用的无线网络，包括Wifi和蜂窝信号，拿到这些信息后，再去查询网络数据库。 navigator.geolocation.getCurrentPosition((position) => console.log(position), (err) => console.log(err)) 第一个是回调成功的函数，传入的 postion参数，有众多属性， 比如其中 postion.coordinates对象有 latitude 经度， longitude维度、alititude海拔、speed设备移动速度 第二个接收失败回调函数 Connection State任何时候，都可以通过 navigator.onLine属性来确定浏览器的联网状态，该属性返回一个布尔值，表示浏览器是否联网。 const connectionStateChange = () => console.log(navigator.onLine); window.addEventListener('onLine', connectionStateChange) window.addEventListener('offLine', connectionStateChange) //设备联网 //true //断网 //false 6.history对象用于与浏览器历史记录进行交互（实际上和浏览器自带的页面后退，前进功能一样） 实际开发用的少，但是一些OA办公系统会用到 history.back() 后退功能 history.forward() 前进功能 history.go(参数) 前进后退功能，参数是1前进一个页面，-1后退一个页面 history.pushState 历史记录管理 hashchange 会在页面URL的散列变化时被触发，开发者可以在此时执行某些操作，而状态管理API则可以让开发者改变浏览器URL而不会重新加载页面。为此 可以使用history.pushState()方法 接收三个参数 一个state对象 一个新的状态标题 一个可选的 相对URL history.pushState(stateObj, &quot;my title&quot;, &quot;baz.html&quot;) 执行后，状态信息会被推送到历史记录中，浏览器地址栏也会改变以反映新的相对URL，即使location.href返回的是地址栏中的内容，浏览器不会向服务器发送请求。 可以通过 history.state来获取当前的状态对象，也可以使用 replaceState()并传入与 pushState()同样的前两个参数来更新状态（覆盖状态） 注意：使用HTML5状态管理时，要确保通过 pushState()创造的每个“假”的URL背后都对应着服务器上一个真实的的URL，否则单击“刷新”按钮会导致404.所有单页面应用程序（SPA）框架都必须通过服务器或客户端的某些配置解决这个问题。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"DOM","slug":"DOM","date":"2020-11-08T08:47:54.905Z","updated":"2021-08-22T10:35:19.044Z","comments":true,"path":"2020/11/08/dom/","link":"","permalink":"https://taylor12138.github.io/2020/11/08/dom/","excerpt":"","text":"DOM基础DOM：文档对象模型，是一个应用编程接口API W3C已经定义了一系列的dom接口，可以改变网页内容、结构、样式 文档：一个页面就是一个文档，用document表示 元素：页面内的所有标签都是元素，用element表示 节点：网页中所有内容都是一个节点（注释，文本，属性等），用node表示 顶级对象是document 注意：因为文档是从上往下加载，所以script要写到文档标签的下面 （1）获取页面元素id获取（id是大小写敏感的字符串组成） &lt;div id=\"time\">2019&lt;/div> &lt;script> var timer = document.getElementById('time'); /*返回的是一个元素对象*/ console.dir(timer); /*dir是打印返回的元素对象，更好的查看里面的属性方法*/ &lt;/script> &lt;/body> 根据标签名获取 &lt;script> // 返回的是获取过来的元素对象的集合，（无论多少个）以伪数组的形式储存 var lis = document.getElementsByTagName('li'); console.log(lis); console.log(lis[0]); // 可以使用element.getElementsByTagName('标签名')获取，但是父元素必须是单个对象，不能是伪数组之类的 var oll = document.getElementsByTagName('ol'); console.log(oll[0].getElementsByTagName('li')); &lt;/script> H5新增获取元素方法，根据类名获取 document.getElementsByClassName(&#39;类名&#39;); H5新增的万能选择器，querySelector返回选择器的第一个元素对象，切记里面选择器需要加符号 querySelectorAll 返回指定选择器的所有对象集合（伪数组），但是通过querySelectorAll获取的是返回的是NodeListOf&lt;HTMLElementTagNameMap[K]&gt;，经过了一次包装（有了一个包装对象！），保存的是当时状态的快照，所以是静态的，是死的，不会随着数据更新而改变，最好使用 getElementsByTagName （返回的是HTMLCollection）这些进行替代 里面的原理我们可以从typescript角度来观看 https://blog.csdn.net/HermitSun/article/details/95780715 伪数组可以使用es6的扩展运算符转化为数组：let lis2 = [...lis] // 选择类名 var firstbox = document.querySelector('.box'); // 选择id var secondbox = document.querySelector('#nav'); // 选择标签名 var thirdbox = document.querySelector('li'); //选择全部 var fourth = document.querySelectorAll('li'); 多重嵌套进行选择 var firstbox = document.querySelector('.box').document.quertSelector(li); 获取body标签和html标签比较简单特殊 //获取html var htmlEle = document.documentElement; // 获取body元素 var bodyEle = document.body; 注意：获取到的每个DOM元素都作为一个对象来使用！ （2）事件基础事件是可以被js侦测到的行为，触发–响应机制 事件由三部分组成：事件源（被触发对象） 事件类型（触发类型） 事件处理程序 一个简单的事件例子： &lt;button id=\"btn\">哈哈哈&lt;/button> &lt;script> var btn = document.getElementById('btn'); btn.onclick = function() { alert('哈哈哈'); } &lt;/script> （3）操作元素我们可以利用dom操作元素来改变元素里面的内容 element.innerText 从起始位置到终止位置的内容，但它除去html标签，空格换行也会去掉（非标准） element.innerHTML 从起始位置到终止位置的内容，保留（识别）html标签和空格，换行（W3C标准） （element.textContent 相当于innerText，只不过 textContent 会获取style= “display:none” 中的文本，而innerText不会 textContent 会获取style标签里面的文本、script标签里的文本，而innerText 不会 ） 同时，这两个标签是可读写的，可以获取元素里面的内容 btn.onclick = function() { div.innerText = '2020'; /*点击后修改它的文字*/ img.src = 'xxxx'; /*改变图片的src*/ img.title = 'xxxx'; /*改变图片的文字提示*/ input.value = 'xxx' /*改变表单的值*/ this.disabled = true; /*点击后此按钮后，此按钮被禁用，this指向的是事件函数的调用者*/ } p.innerText = 'pp'; /*刷新页面直接修改它的文字*/ console.log(p.innerText); 修改样式（通过JS修改后，变成行内样式，权重比较高） div.onclick = function() { //1.样式比较少的话使用此方法 //采用驼峰命名，原来的 background-color -> backgroundColor this.style.backgroundColor = 'purple'; //2.另一个方法就是再写一个类，里面包含了所有你想要改变的样式，但是注意，它会覆盖原先的类名 this.className = '样式名'; //3.保留原先得类 this.className = '原先样式名 新样式名' } 表单的获取焦点 var text = document.querySelector('input'); text.onfocus = function () { //获得焦点 if (this.value) { this.value = ''; } this.style.color = '#333' } text.onblur = function () { //失去焦点 if (this.value === '') { this.value = '手机'; } this.style.color = '#999' } 表单经过事件（类似于“ :hover ”） // 1.获取元素 获取的是 tbody 里面所有的行 var trs = document.querySelector('tbody').querySelectorAll('tr'); // 2. 利用循环绑定注册事件 for (var i = 0; i &lt; trs.length; i++) { // 3. 鼠标经过事件 onmouseover trs[i].onmouseover = function() { this.className = 'bg'; } // 4. 鼠标离开事件 onmouseout trs[i].onmouseout = function() { this.className = ''; } } 全选框小案例： // 获取元素 var Btn_All = document.getElementById('Btn_All'); // 全选按钮 var Btns = document.getElementById('Btns').getElementsByTagName('input'); // 下面所有的复选框 //1.让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可 Btn_All.onclick = function () { for (var i = 0; i &lt; Btns.length; i++) { Btns[i].checked = this.checked; } } // 2. 每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。 for (var i = 0; i &lt; Btns.length; i++) { Btns[i].onclick = function () { var flag = true; for (var i = 0; i &lt; Btns.length; i++) { if (!Btns[i].checked) { flag = false; break; } } Btn_All.checked = flag; } } （4）自定义属性js的两种元素属性获取方法： element.属性获取属性 element.getArribute(&#39;属性&#39;)也是获取属性，不过这个可以获取自定义属性 自定义属性：&lt;div id=&quot;demo&quot; index=&quot;1&quot;&gt;&lt;/div&gt; 中的index 设定属性值： element.属性 = 值 设置内置属性 element.setArribute(&#39;属性&#39;,&#39;值&#39;) 同上，主要设置自定义属性，它的class比较特殊，不使用className，使用class，如 div.setAttribute(‘class’, ‘footer’); 移除属性：element.removeAttribute(&#39;属性名&#39;) Hs规范：H5规定自定义属性以“data-”作为开头，并且赋值，比如 &lt;div data-index=&quot;1&quot;&gt;&lt;/div&gt; H5新增获取自定义属性的方法：div.dataset.index（属性名为data-index）， div.dataset.listName(属性名为data-list-name) ，dataset是一个集合里面存放了所有以data开头的自定义属性 （5）节点操作dom提供的获取元素方法比较繁琐，利用节点父子兄弟关系获取元素比较方便，但是兼容性差 一般的，节点至少拥有节点类型（nodeType）、节点名称（nodeName）、节点值（nodeValue） 元素节点 nodeType = 1 节点操作一般都是操作元素节点 属性节点 nodeType = 2 文本节点 nodeType = 3 父亲节点： node.parentNode (得到的是离元素最近的父节点，找不到父节点返回空值) 孩子节点： parentNode.childNodes 返回包含节点的子节点的集合，包含元素节点，文本节点等等，该集合为及时更新的集合，若只想获取元素节点：(因为繁琐，所以实际开发不提倡使用childNodes) var ul = document.querySelect(&#39;ul&#39;); for (var i = 0; i &lt; ul.childNodes.length; i++) { if(ul.childNodes[i].nodeType == 1) { console.log(lu.childNodes[i]); } }(new) 孩子节点： parentNode.children 返回所有子元素节点 （常用） parentNode.firsElementtChild 返回第一个元素子节点，找不到返回null parentNode.firstChild 返回第一个元素子节点，找不到返回null parentNode.lastChild 返回最后一个元素子节点，找不到返回null 这两个方法有兼容问题ie9以上才能使用 所以推荐写法： parentNode.children[0] parentNode.children[parentNode.children.lenth-1] 下一个兄弟元素节点：node.nextElementSibling 找不到返回null 上一个兄弟元素节点：node.previousElementSibling 找不到返回null 这两个方法有兼容问题ie9以上才能使用 创建节点 document.createElement(&#39;targetName&#39;) 动态创建节点 添加节点 node.appendChild(child) 创建完后需要添加节点，此方法是将一个节点添加到指定父节点的子节点列表末尾，类似于CSS中的after伪元素 ,child写名称不用加 ‘ ’（不支持追加字符串子元素） or： node.insertBefore(child, 指定元素（子节点）) 将一个节点添加到父节点指定的子节点前面 var li = document.createElement('li'); var ul = document.querySelector('ul'); ul.appendChild(li); var li_2 = document.createElement('li'); ul.insertBefore(li_2, ul.children[0]); /*添加至开头*/ 发表评论案例： &lt;textarea name=\"\" id=\"\">&lt;/textarea> &lt;button>发布&lt;/button> &lt;ul>&lt;/ul> &lt;script> var btn = document.querySelector('button'); var text = document.querySelector('textarea'); var ul = document.querySelector('ul'); btn.onclick = function() { if (text.value == '') { alert('您没有输入内容'); return false; } else { var li = document.createElement('li'); //并且添加删除功能 li.innerHTML = text.value + \"&lt;a href='javascript:;'>删除&lt;/a>\"; //javascript:;意思是页面不发生跳转 ul.insertBefore(li, ul.children[0]); //删除元素 var as = document.querySelectorAll('a'); for(var i = 0; i &lt; as.length; i++) { as[i].onclick = funciton() { ul.removeChild(this.parentNode) } } } } &lt;/script> 删除节点：node.removeChild(child) 返回删除的节点 node.remove() 返回删除的节点（）删除本身 复制节点： node.cloneNode() 克隆完节点之后，和创建节点一样也必须要添加节点才能显示出来 1.如果括号参数为空，是浅拷贝，只克隆该节点本身，不克隆其子节点，即没有任何内容 node.cloneNode(true) 深拷贝 复制标签并且复制里面的内容 （6）创建标签的四种方法：1.element.write() 写入内容（标签），但是页面文档流加载完毕，再调用会导致页面重绘，不好用 2.element.innerHTML 从起始位置到终止位置的内容，保留（识别）html标签和空格，换行（W3C标准） 同时，这两个标签是可读写的，可以获取元素里面的内容 3.document.createElement(&#39;targetName&#39;) 动态创建节点 document.createElement(&#39;targetName&#39;)对比使用element.innerHTML 写多个标签会更省时，省空间，因为他创建多个标签时不用开辟新的空间，而innerHTML使用拼接的原理，所以每次都要要开辟新的空间 但是，如果element.innerHTML 不用拼接字符串的方法来实现创建多个标签，而是采用数组的形式拼接，结构写麻烦一点： var arr[]; for(var i = 0; i &lt; 100; i++) { arr.push('&lt;a href=\"#\">百度&lt;/a>'); } //以''进行拼接，并且转化为字符串 xx.innerHTML = arr.join(''); 执行起来会比 document.createElement(&#39;targetName&#39;) 更快，但是结构不太清晰 element.insertAdjacentHTML(插入的位置, 插入的字符串)可以直接把字符串格式元素添加到父元素中 (如：&quot;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&quot;) 插入位置：beforebegin 元素自身前面 afterbegin 插入元素内部第一个子节点之前 ​ beforeend 插入元素内部的最后一个子节点之后 afterend 元素自身的后面 （注意：appendChild不支持追加字符串子元素，insertAdjacentHTML支持追加字符串子元素） document.createDocumentFragment() 有点类似 document.createElement(&#39;targetName&#39;) ，区别在于： （1）需要很多的插入操作和改动，使用createElement效率是比较低的，而innerHTML拼接方法灵活性比较差，利用DocumentFragment，可以弥补这两个方法的不足 （2）createDocumentFragment创建的元素使用innerHTML并不能达到预期修改文档内容的效果 （3）createDocumentFragment创建的元素是一次性的，添加之后再就不能操作了 （4） 通过createElement新建元素必须指定元素tagName,因为其可用innerHTML添加子元素。通过createDocumentFragment则不必。 （5）通过createElement创建的元素插入文档后，还可以取到创建时的返回值 事件部分1.注册事件传统方式： btn.onclick = function() {} 注册事件唯一性，最后注册处理的函数会覆盖掉前面注册处理的函数，即一个元素只能设置一个处理函数 w3c标准的推荐方式：（ie9以前不支持此方法，即ie8等不支持） eventTarget.addEventListener(type, listerner[, useCapture]) （ie9以前使用的是eventTarget.attachEvent(type, listener[, useCapture]);） type：事件类型，如click，mouseover，不带on listener：事件处理，事件发生时会调用其监听函数 useCapture：可选参数，默认false btn.addEventListener('click', function() { //必须要字符串 alert(xxx); }) btn.addEventListener('click', function() { //必须要字符串 alert(yyy); }) 同一个元素同一个事件可以添加多个监听器，不会覆盖掉 2.解绑事件传统方式： eventTarget.onclick = null 如 div.onclick = function() {alert(); div.onclick = null;} 在点击一次之后删除该事件 方法监听方式：eventTarget.removeEventListener(type, listener[, useCapture]); （ie9以前使用的是eventTarget.detach(type, listener[, useCapture]);） 方法监听方式来解绑事件不能用匿名函数的方法，即 var fun=function(){} 所以使用以下策略 div.addEventListener('click', fn); function fn() { alert(xx); div.removeEventListener('click', fn); } 使得目标div在点击一次之后解绑事件 3.dom事件流事件发生时会在元素节点之间按照特定的顺序传播（document-&gt;Element gtml-&gt;Element body-&gt;Element div），这个传播过程即DOM事件流 DOM事件流分为三个阶段 ：（执行顺序也是如此 捕获 - &gt; 当前 -&gt; 冒泡）(记住是三个，还有一个目标阶段！！！) 1.捕获阶段（从大往小传播，从最顶层开始，然后逐级向下传播到具体元素接收的过程） 2.当前目标阶段 3.冒泡阶段（从小到大，从里到外的传播，由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程） 注意： JS代码只能执行捕获或者冒泡其中一个阶段（除非你设置两个监听函数，一个执行捕获，一个执行冒泡）； 传统注册事件方式（onclick、attachEvent）只能得到冒泡阶段，eventTarget.addEventListener(type, listerner[, useCapture])第三个参数如果是true，则在事件捕获阶段调用程序，如果是false（默认），则在冒泡阶段调用事件 如果事件触发在“当前目标阶段”，则当前目标会根据事件注册的先后顺序执行，而不是上面提及到的 捕获 - &gt; 当前 -&gt; 冒泡，比如：爷节点，父节点，子节点都绑定了 捕获事件和监听事件，而触发子节点的事件，执行爷、父的事件执行顺序一定是 捕获 - &gt; 当前 -&gt; 冒泡；而子节点是根据事件注册的先后顺序来执行捕获 or 冒泡事件，说白了就是无关了。 以下代码，son包含于father内，使用捕获阶段（true），则点击son后先执行father再执行son，冒泡阶段则相反 &lt;div class=\"father\"> &lt;div class=\"son\">son盒子&lt;/div> &lt;/div> &lt;script> var son = document.querySelector('.son'); son.addEventListener('click', function() { alert('son'); }, true); var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, true); &lt;/script> 但是实际开发中我们更关注的是冒泡，且有些事件是没有冒泡的，如onblur，onfocus，onmouseenter，onmouseleave 事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件：比如通过冒泡父元素管理多个子元素的事件 4.事件对象div.addEventListener(&#39;click&#39;, funciton(event){} ) 中的event为事件对象，写到我们监听函数的小括号里，当形参看 事件对象只有有了事件才会存在，它是系统自动为我们创建的，不需要我们传递参数 事件对象是我们事件一些列相关数据的集合 事件对象也有兼容性问题，比如ie6、7、8，通过window.event获取 常见事件对象属性（对低版本浏览器有兼容性问题）： div.addEventListener('click', function(e) { console.log(e.target); console.log(this); /*两者有些许相似，但是e.target返回的是触发事件的元素，this返回的是绑定事件的对象（元素）*/ console.log(e.type); //返回事件类型 e.preventDefault(); //阻止默认事件，让它成为一个普通盒子，比如让链接不跳转，让input不提交等 e.stopPropagation(); //阻止事件冒泡，使得触发子事件后，不会相应触发父事件，不会向外传播 }) ie6\\7\\8 div.onclick = function() { console.log(e.srcElement); //返回的是触发事件得元素 e.returnValue; // 阻止默认事件 /*我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式*/ return false; window.e.cancelBubble = true; //阻止冒泡 } 5.事件委托事件委托也称为事件代理，在JQuery称为事件委派，它提高了程序性能 若多个子节点同时有事件，不需要将每个子结点单独设置事件监听器，而是将事件监听器设置在父节点上，然后利用冒泡原理影响每个子节点，使得每个子节点反馈到父节点，触发父节点的事件 6.常用的鼠标事件鼠标右键菜单： contextmenu 鼠标选中：selectstart dblclick 鼠标双击事件 mousedown 鼠标按下 mousemove 鼠标移动 ，mousemove是鼠标指针在元素内部移动式重复触发的事件，可用于鼠标指针定位实时变化的案例 mouseup 鼠标松开 mouseover 鼠标经过， 类似于“ :hover ” 它不仅经过自身盒子会触发，经过子盒子还会再触发一次 mouseout 鼠标离开元素，和mouseover相互搭配 mouseenter 鼠标移动到元素上，只会经过自身盒子才触发一次，之所以会这样，是因为mouseenter不会冒泡 mouseleave 鼠标离开元素，和mouseenter相互搭配，同样不会冒泡 focus 获得焦点 blur失去焦点 //禁用鼠标右键 document.addEventListener('contextmenu', function(e) { e.preventDefault(); }) //禁止选中文字 document.addEventListener('selectstart', function(e) { e.preventDefault(); }) （e代表事件对象） e.clientX 返回鼠标对于浏览器窗口可视区域的X坐标 e.clientY 返回鼠标对于浏览器窗口可视区域的Y坐标 e.pageX 返回鼠标相对于文档页面的X坐标，ie9+支持 e.pageY 返回鼠标相对于文档页面的Y坐标，ie9+支持 e.screenX 返回鼠标相对于电脑屏幕的X轴坐标 e.screenY 返回鼠标相对于电脑屏幕的Y轴坐标 pink老师天使跟随鼠标案例 &lt;style> img { position: absolute; } &lt;/style> &lt;body> &lt;img src=\"images/angel.gif\" alt=\"\"> &lt;script> var pic = document.querySelector('img'); document.addEventListener('mousemove', function(e) { /*核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的top和left 值就可以移动图片*/ var x = e.pageX; var y = e.pageY; //千万不要忘记给left 和top 添加px 单位 pic.style.left = x - 50 + 'px'; pic.style.top = y - 40 + 'px'; }); &lt;/script> &lt;/body> 7.常用键盘事件onkeyup 某个按键松开时被触发 （松开瞬间） onkeydown 某个按键被按下时被触发 （按下瞬间） onkeypress 同onkeydown 但是它不识别功能键如ctrl shift等 执行顺序down&gt;press&gt;up 使用addEventListener不需要加on keyon和keydown不能区分大小写 keyon和keydown不能区分大小写 （a和A得到的ASCII码值得到的都是65） 键盘事件 （e代表事件对象） e.keyCode 返回该键ASCII码值 e.key返回按下的键位值（字符串） 注意：keydown 和 keypress 在文本框（input）比较特殊，当它们两个事件触发的时候，文字还没落入文本框中 而keyup事件触发的时候，文字已经落入文本框， 8.input事件onchange 当input失去焦点并且它的value值发生变化时触发，它也可用于单选框与复选框改变后触发的事件。 比如复选框发生改变（单击鼠标切换“打勾”/“不打勾”状态） oninput 当input的value值发生变化时就会触发，（与onchange的区别是不用等到失去焦点就可以触发了） 此时通过 event.target.value;事件对象中的target的value可以获取input输入的值 onfocus 获得焦点事件 onblur 失去焦点事件 input.select() 让文本框里的文字处于选定状态 remember.addEventListener('change', function () { // 勾选上 if (this.checked) { localStorage.setItem('username', username.value); } else { localStorage.removeItem('username') } })","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"移动&Web开发的常见布局(CSS)","slug":"移动&Web开发的常见布局(CSS)","date":"2020-10-01T16:00:00.000Z","updated":"2021-06-06T12:30:58.032Z","comments":true,"path":"2020/10/02/yi-dong-web-kai-fa-de-chang-jian-bu-ju-css/","link":"","permalink":"https://taylor12138.github.io/2020/10/02/yi-dong-web-kai-fa-de-chang-jian-bu-ju-css/","excerpt":"","text":"兼容移动端主流浏览器，处理Webkit内核浏览器即可 1.视口视口分类视口可以分为布局视口，视觉视口和理想视口 布局视口：一般移动设备浏览器都默认设置一个布局视口（980px），用于早期PC端页面在手机上显示的问题 缺点：使得元素看上去很小，字体小 视觉视口：用户正在看的网站区域，我们可以通过缩放操作视觉视口，但是不影响布局视口 理想视口：设定最理想的浏览和阅读宽度，与要手动添加meta视口标签通知浏览器（乔布斯发明） &lt;meta name=\"viewport\" content=\"width-device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"> content=”width-device-width 适应窗口大小 user-scalable=no 不允许用户缩放 maximum-scale=1.0 初始的最小缩放比 minimum-scale=1.0 初始的最大缩放比 2.二倍图在移动端，1px=一个物理像素，但是移动端不尽相同 移动端有物理像素比，可从px转化移动端时，（开发尺寸）px × 物理像素比 = 移动端显示的像素 此做法可以使得在移动端上显示更加高清 背景缩放background-size注意：background-size一定要放在background属性后设置 background-size用于规定背景尺寸 /*现有background: 才能设置*/ background-size: 图片宽度,图片高度; /*可以px，可以百分比（相对于父盒子）*/ background-size: cover; /*完全盖住盒子，可能图片显示不全*/ background-size: contain; /*宽高完全适应父盒子，父盒子可能有空白区域*/ 切图时可以用ps里的cutterman多倍切图 精灵图缩放1.使用工具（如firework）把精灵图缩放为原来的一半 2.根据大小测量坐标 3.注意代码里面的background-size也要写：精灵图原来的一半 （原图进行修改查看， 但是不要保存） （或者直接上，用chrome调试就行了） background-size: 宽度（原来的大小/倍数） 高度auto 3.移动端开发的选择1.单独移动端页面（主流）：京东、淘宝 pc和手机打开后显示的网页布局不同 2.响应式页面兼容移动端：三星官网 响应屏幕宽度，制作麻烦，需要大量调整兼容性 CSS的初始化推荐使用 normalize.css CSS3盒子模型传统盒子计算方式：CSS设置的width+border+padding CSS3盒子模型：盒子宽度=CSS设置的宽度width包含了border+padding 设置方式：(CSS高级部分讲过，但是使用此方法后文字使用line-heigh居中会有所影响,原因是我们要对其的是盒子内部中间的位置，即去除掉边框的高度的中间位置，但是line-heigh会把所有方框所有高度算进去) box-sizing:border-box; 移动端链接清除高亮移动端点击完链接 &lt;a&gt; 会出现高亮 ，清除高亮可用 -webkit-tap-highlight-color:transparent; 移动端链接清除外观效果在移动端浏览器默认的外观上在ios上加上这个属性才能给按钮和输入框自定义样式（清除原来的样式） -webkit-appearance: none; 禁用长安页面弹出菜单img, a {-webkit-touch-callout: none; } 4.移动端常见布局不需要像pc端一样排列版心 单独移动端页面（主流）：流式布局（百分比布局）（京东）、flex弹性布局（新闻网，强烈推荐）、less+rem+媒体查询布局（苏宁）、混合布局 流式布局也就是百分比布局，非固定像素布局，可自由伸缩 为了保护屏幕不被拉过宽（缩过窄），导致里面的元素显示出现问题，设置最大最小宽度 max-width: xxpx; min-width: xxpx; flex布局传统布局：兼容性好，布局繁琐，有一定局限 flex布局：操作方便，pc端浏览器支持差，IE11或者更低版本不支持或仅部分支持 flex可以让原本span（无法设置宽高）成功使用宽高属性，即不需要浮动，更不用清除浮动 （1）flex原理flex是flexible box的缩写，意为弹性布局，任何一个容器都可以指定为flex布局（谁都可以用，除了IE） 父盒子设置为flex后，子元素的float、clear、vertical属性都失效 采用flex布局的元素称为flex容器，他的所有子元素自动成为容器成员，称为flex项目，即它是通过给父盒子添加flex属性，来控制子盒子的位置和排列 （2）flex常见父项属性默认主轴方向是x轴，水平向右 侧轴方向是y轴 水平向下，我们的元素是跟着主轴排列地 flex-direction 设置主轴方向，剩下那个就自动变成侧轴 1.默认值row从左到右 2.row-reverse从右到左 3.column从上到下 4.column-reverse从下到上 justify-content 设置主轴上子元素的排列方式 1.flex-start默认 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.space-around平分剩余空间 5.space-between先两边贴边，再平分剩余空间 flex-wrap 设置子元素是否换行 默认不换行，装不开会缩小子元素的宽度，自动适应 wrap：换行 align-content 设置侧轴上的子元素的排列方式（多行）（即有换行情况）（单行情况下没用） 1.flex-start 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.stretch拉伸，默认 5.space-around平分剩余空间 6.space-between先两边贴边，再平分剩余空间 align-items 设置侧轴上的子元素的排列方式（单行） 1.flex-start 2.flex-end从尾部开始排列 3.center在主轴居中对齐 4.stretch拉伸，默认，但是子盒子不要带高度 flex-flow 复合属性，相当于同时设置flex-direction和flex-wrap flex-flow: column wrap; （3）flex常见子项属性flex属性，定义子项目分配剩余空间，用flex表示占有份数 flex: number;/*默认为0*/ 如果是flex：1的话，则将改行剩余空间全部划分给该子元素，不用设置宽高，且类似于百分比流式布局，可以根据窗口大小调节剩余空间大小 如果该行没有设置任何子元素在该行（假设当前主轴为x轴），然后将三个子元素设置flex：1，则每个盒子占33.33%的宽度（即设置该盒子的主轴长度） A设置flex:2 ， B设置flex:1 则A占比2/3，B占比1/3 (其实可以写百分比 即flex: 20%, 相对父级来说) align-self，控制子项自己在侧轴上的排列方式。 它允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items属性，默认值为auto，表示继承align-items的属性 span:nth-child(3) { align-self: flex-end; /*只让第三个盒子在侧轴上从尾部开始排列*/ } oder定义项目的排列顺序，数值越小，排名越靠前，注意，和z-index不一样（定位属性） span:nth-child(2) { order:-1; /*让2号盒子跑到1号盒子前面，因为默认是0，0&lt;1*/ } Rem适配布局（1）rem基础rem是一个单位（root em），是一个相对单位，类似于em，em是父元素的字体大小，如父元素的font-size为12px，子元素设置宽高为10em，则大小实际为10*12=120px；而不同的地方在于rem是相对于html元素的字体大小，rem的优点是可以通过修改html的文字大小来改变页面中的元素大小 （2）媒体查询媒体查询是CSS3的新语法，使用@media可以针对不同屏幕尺寸设置不同的屏幕样式 /*用@media开头，mediatype是媒体类型，关键字and、not、only，media feature是媒体特性，要用小括号包含*/ @media mediatype and|not|only (media feature) { CSS-Code; } mediatype查询类型： all 用于所有设备 print 用于打印机和打印预览 screen用于电脑屏幕，智能手机 媒体特性：暂且先了解三个 1.width 定义输出设备页面可见区域的宽度 2.min-width 定义输出设备页面最小可见区域宽度 3.max-width 定义输出设备页面最大可见区域宽度 @media screen and (max-width: 800px) and (min-width: 540px) { /*在屏幕上且最大宽度为800px且最小宽度为540px则设置该样式*/ body { background-color: pink; } } 当样式改变比较多的时候（如三星官网首页根据页面不同大小的变化样式的改变），可以针对不同的媒体使用不同的stylesheets（样式表）原理，直接在link中判断设备的尺寸，引用不同的CSS文件 &lt;link rel=\"stylesheet\" href=\"style320.css\" media=\"screen and (min-width: 320px)\"> 媒体查询最好的方法是从小到大 less基础CSS的冗余度比较高，需要书写大量看似没有逻辑的代码，不方便维护，且无计算能力 而Less是CSS的拓展语言，也成为CSS预处理器（常见的CSS预处理器：Less、Sass、Stylus），可以计算（运算符的左右两侧必须加一个空格， 两个数参与运算，如果只有一个数有单位，最后结果以这个单位为准 两个数参与运算，如果两个数都有单位，以前面那个数字单位为准） Less的文件后缀名：.less （1）less变量@color: pink; /*@变量名:值;*/ @font: 14px; 使用： background-color: @color ; （2）less的编译需要把less编译成CSS才能放入H5使用 在VScode中安装easy-less插件，less文件保存后一键生成CSS文件 （3）less镶套在less不需要再 .header a {} 去选择后代选择器(再见) 可以直接： .header { width: 100px; a { color: red; } } 伪类选择器： .nav { &amp;:hover { color: blue; } &amp;::before { content: \"\"; } } 在一个less中可以引入另外一个less（套娃） @import \"common\"; /*导入conmon.less*/ 在Vue脚手架里使用less时，只需要用npm安装 less 和 less-loader即可 npm i less --save npm i less-loader --save 但在实践过程中报错了，原因竟然是是less-loader安装的版本太高，卸载重新安装7.0版本即可 npm uninstall --save less-loader npm install -D less-loader@7.x rem的实际适配1.按照设计稿与设备宽度比例，动态计算并设置html根标签font-size大小（屏幕宽度/划分的份数=font-size的大小）（划分份数有15、20、10都有可能，苏宁移动端网页是15） 2.CSS中，设计稿元素宽、高、相对位置等取值，按照同等比例换算为rem rem适配方案一：less 媒体查询 rem 适配方案二：flexible.js rem (推荐) 适配方案二：rem适配之flexible.js再也不用太过繁琐的写下多个媒体查询，使用js做了处理 它的原理是把当前设备自动划分为10等份 会根据屏幕自动修改文字大小 github下载地址：https://github.com/amfe/lib-flexible 但是需要加一个限定弥补不足： /* 如果屏幕超过了750px, 那么我们按照750的设计稿走，不让我们的页面超过750px*/ @media screen and (min-width: 750px) { html { font-size: 75px!important; /*提权重*/ } } 适配方案（add）：Vscode px转换rem插件cssrem（堪称外挂），及其好用 可以使得px直接转换rem 该插件默认的html字体大小为16px（根据当前页面大小（正常大小状态）/划分份数=得到我们应该设置的字体大小）,需要在设置里更改setting.json里的&quot;cssrem.rootFontSize&quot;: 16才可以 响应式布局其原理就是根据媒体查询对不同宽度设备进行布局和样式设置，从而适配不同设备的目的 小屏幕（手机）&lt;768px 小屏设备（平板） &gt;=768px~&lt;992px 中等屏幕（桌面显示器）&gt;=992px~&lt;1200px 宽屏设备（大桌面显示器）&gt;=1200px @media screen and (max-width: 767px) { .container { width: 100%; } } @media screen and (min-width: 768px) { .container { width: 750px; } } @media screen and (min-width: 992x) { .container { width: 970px; } } @media screen and (min-width: 1200px) { .container { width: 1170px; } } (1)Bootstrap前端开发框架来自于twitter，目前最受欢迎的前端框架(拿来主义) 中文官网：https://www.bootcss.com/ 官网：https://getbootstrap.com/ 2.x.x 已经停止维护，功能不够完善 3.x.x 目前使用最多，但已经放弃了ie6，ie7，对ie8支持但是界面效果不好，偏向于开发响应式布局，移动设备优先的web项目 4.x.x 最新版，但是目前不流行 样式库的使用：1.创建文件夹结构（复制bootstrap的文件夹）-&gt; 2.创建html骨架结构（在bootstrap中文文档官网中找到bootstrap入门-基础模板）-&gt; 3. 引入相关样式文件 -&gt; 使用 (2)Bootstrap的布局容器bootstrap需要为页面内容和栅格系统包裹一个.container容器，Bootstrap预先定义好了这个类 .container已经定义好了响应式布局，如@media screen and (max-width: 767px)之类的 而.container-fluid类定义了流式布局（百分比布局） (3）Bootstrap的栅格系统亦称为网络系统，它指页面布局划分为等宽的列，通过样式定义来模块化页面布局（rem是把整个屏幕划分多个等份，这个是页面内容），bootstrap自动拓展到最多12等份 bootstrap里面的CSS已经包含了normalize.css即关于网页初始化的内容，所以不用再引入normalize.css进行初始化 栅格系统用于通过一系列的行row和列coloum的组合来创建页面布局 （行缩小到一定程度，模块进入下一个列）,实现列的平均划分，需要给列添加类前缀（添加类名），分别对应着响应式布局上面定义的四种媒体查询代码 超小屏幕列前缀.col-xs-小屏设备列前缀.col-sm-中等屏幕列前缀.col-md-宽屏幕列前缀.col-lg-有12份，让其占4分之一，即3份,所有盒子总和没达到12，则占不满，超过12，则另起一行（像浮动）.col-lg-3 大屏幕占4分之一，即3份，中等屏幕占3分之一，即4份，小屏幕占2分之一，即6份 .col-lg-3 col-md-4 col-sm-6 每一列的盒子里有默认左右15px的padding Bootstrap的列嵌套：父盒子会产生一个padding值，使得子盒子划分的时候没有按照父盒子的宽高划分，而是按照父盒子的宽高-padding值划分，所以在嵌套的时候最好加多一个盒子进行包装，并且此时子盒子和父级一样高： &lt;div class=\"col-md-4\"> &lt;div> &lt;div class=\"col-md-6\">&lt;/div> &lt;div class=\"col-md-6\">&lt;/div> &lt;/div> &lt;/div> &lt;div class=\"col-md-4\">&lt;/div> &lt;div class=\"col-md-4\">&lt;/div> &lt;div class=&quot;col-mid-4 col-md-offset-4&quot;&gt;&lt;/div&gt;的offset功能，在中间增加了4份的空格（1/3），实现每个盒子不必紧密相连的模型格式，其实可以把offset当成空盒子来看待 &lt;div class=&quot;col-md-4 colmd-push-8&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;col-md-4 colmd-pull-4&quot;&gt;右侧&lt;/div&gt;可以实现左右盒子颠倒的状态（做盒子推，右盒子拉） (4）响应式工具利用媒体查询功能，使用工具类可以方便针对不同设备展示或者隐藏页面内容（类似淘宝首页某类商品的隐藏） hidden-xs 超小屏：隐藏 小屏：可见 中屏：可见 大屏：可见 hidden-sm 超小屏：可见 小屏：隐藏 中屏：可见 大屏：可见 hidden-md 超小屏：可见 小屏：可见 中屏：隐藏 大屏：可见 hidden-lg 超小屏：可见 小屏：可见 中屏：可见 大屏：隐藏 &lt;div class=\"col-md-3 hidden-xs\">&lt;/div> 与之相反的是visible-xs，visible-sm等，可以实现广东财经大学首页的搜索栏隐藏模块功能 bootstrap官网里还有字体图标供给使用 bootstrap已经帮你写好清除浮动，只需添加类名clearfix 5.线性渐变颜色（针对于移动端）pc端需要很多私有前缀，特别麻烦，但是移动端只需要添加webkit就可以了 background: linear-gradient(起始方向,颜色1,颜色2); /*起始方向默认top*/ background: -webkit-linear-gradient(left,red,blue); /*一般都要添加-webkit-私有前缀*/ background: -webkit-linear-gradient(left top,red,blue); 6.CSS变量除了less可以声明变量，其实css自身也可以声明变量 CSS全局变量的声明是在变量名称前加两个中横线--，通常用于设置全局的主题颜色，主题背景颜色，字体大小等 :root { /* css定义变量的方式 */ /* 使用：var(变量名) */ --color-text: #666; --color-high-text: #ff5777; --color-tint: #fd5d7b; --color-background: #fff; --font-size: 20px; --line-height: 1.5; } /*使用*/ div { background-color: var(--color-tint); }","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"matlab期末知识点汇总","slug":"matlab期末知识点汇总","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-06T09:30:41.436Z","comments":true,"path":"2020/08/06/matlab-qi-mo-zhi-shi-dian-hui-zong/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/matlab-qi-mo-zhi-shi-dian-hui-zong/","excerpt":"","text":"regress命令 用于一元及多元线性回归 B = regress(Y,X)[B,BINT] = regress(Y,X)[B,BINT,R] = regress(Y,X)[B,BINT,R,RINT] = regress(Y,X)B,BINT,R,RINT,STATS] = regress(Y,X)[…] = regress(Y,X,ALPHA) B：回归系数，类似于斜率，是个向量（“the vector B of regression coefficients in the linear model Y = X*B”）。BINT：回归系数的区间估计（“a matrix BINT of 95% confidence intervals for B”）。R：残差（ “a vector R of residuals”）。RINT：置信区间（“a matrix RINT of intervals that can be used to diagnose outliers”）。STATS：用于检验回归模型的统计量。有4个数值：判定系数R^2，接近1，回归方程越显著，F统计量观测值，F越大，回归方程越显著，检验的p的值，误差方差的估计。ALPHA：显著性水平（缺少时为默认值0.05）。 %导入数据 y=[7613.51 7850.91 8381.86 9142.81 10813.6 8631.43 8124.94 9429.79 10230.81 ... 10163.61 9737.56 8561.06 7781.82 7110.97]&#39;; x1=[7666 7704 8148 8571 8679 7704 6471 5870 5289 3815 3335 2927 2758 2591]&#39;; x2=[16.22 16.85 17.93 17.28 17.23 17 19 18.22 16.3 13.37 11.62 10.36 9.83 9.25]&#39;; X=[ones(size(y)) x1.^2 x2.^2 x1 x2 x1.*x2]; % size（）：获取矩阵的行数和列数 % s=size(A), 当只有一个输出参数时，返回一个行向量，该行向量的第一个元素时矩阵的行数，第二个元素是矩阵的列数。 % ones(M,N)产生一个M*N的矩阵 %开始分析 [b,bint,r,rint,stats] = regress(y,X);创建残差的置信区间图用regress返回的值r，rint：rcoplot（r，rint） 线性回归模型类线性回归模型类 wlb=LinearModel; %创建线性回归类对象，对象名wlb wlb=LinearModel.fit(x,y); %创建线性回归类对象，并对观测 数据做多元线性回归 wlb.plot %绘制wlb的效果图 wlb.anova %给出方差分析表 [y,ly]=wlb.predict(x) %给出x预测和置信区间 wlb.plotResiduals %绘制残差图 wlb. plotDiagnoisetics(method) %绘制不同统计量的残差图分 析 properties(wlb) %显示所有统计量属性t值和显著性水平有什么样的对应关系t-检验：可以用于比较两组数据是否来自同一分布。（可以用于比较两组数据的区分度） 在统计检验中，统计量t值和显著性水平具有什么样的对应关系？一般来说，大样本和正态分布情况下的数据，当1.65&lt;|t|&lt;1.96时,p&lt;0.10;当1.96&lt;|t|&lt;2.58时，p&lt;0.05；|t|大于2.58时，p&lt;0.01。 但是要注意的是，当样本量很小（小于30），数据分布形态不明或明显不服从正态分布（一座山一样的分布）时，t值和显著性水平不一定完全对应，例如t值绝对值大于2时，p值有可能大于0.05，也就是不显著。这种情况一般要采用非参数检验的方法，而不是t检验。 1、t值，指的是T检验，主要用于样本含量较小（例如n&lt;30），总体标准差σ未知的正态分布资料。T检验是用t分布理论来推论差异发生的概率，从而比较两个平均数的差异是否显著。 2、P值，就是当原假设为真时，所得到的样本观察结果或更极端结果出现的概率。如果P值很小，说明原假设情况的发生的概率很小，而如果出现了，根据小概率原理，我们就有理由拒绝原假设，P值越小，我们拒绝原假设的理由越充分。 p值代表的是不接受原假设的最小的显著性水平，可以与选定的显著性水平直接比较。例如取5%的显著性水平，如果P值大于5%，就接受原假设，否则不接受原假设。这样不用计算t值，不用查表。 3、P值能直接跟显著性水平比较；而t值想要跟显著性水平比较，就得换算成P值，或者将显著性水平换算成t值。在相同自由度下，查t表所得t统计量值越大，其尾端概率P越小，两者是此消彼长的关系，但不是直线型负相关 怎么得到检验回归系数显著性的T值对于X、Y两个正态总体的样本，其t检验应使用ttest2()函数来检验假设。[H,P,CI]=ttest2(X,Y) ttest2（）函数是用来检验具有相同方差的两个正态总体均值差的假设检验（即两正态总体的检验法）。 基本调用格式： h=ttest2（x，y）判断来自不同正态总体的样本数据x与y是否有相同的均值。当h=0表示接受原假设，当h=1表示拒绝原假设。 h=ttest2（x，y，alpha）调用格式表示执行显著性水平为（100*alpha）%的假设检验。没有给出alpha值，默认alpha=0.05。 h=ttest2（x，y，alpha，tail）调用格式表示执行以tail指定的备择假设作假设检验，原假设为均值等于m，当tail=‘both’时表明备择假设为“x与y均值不相等”，当tail=‘right’时表明备择假设为“x的均值大于y的均值”，当tail=‘left’时表明备择假设为“x的均值小于y的均值”。regstats函数（回归系数显著性检测？）MATLAB统计工具箱中提供了regstats函数，也可用来作多重线性或广义线性回归分析，它的调用方式如下：regstats(y,X,model)stats = regstats(…)stats = regstats(y,X,model,whichstats) 非线性用nlinfit函数或者开启cftool工具箱 eye函数该函数返回单位矩阵。 Y = eye(n)：返回n*n单位矩阵； Y = eye(m,n)：返回m*n单位矩阵；","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"模拟退火算法","slug":"模拟退火算法","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-07T03:16:44.061Z","comments":true,"path":"2020/08/06/mo-ni-tui-huo-suan-fa/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/mo-ni-tui-huo-suan-fa/","excerpt":"","text":"1.模拟退火算法可能的情况很多，数据量太大，用模拟退火搜索出需要的解（求最值）（最大值问题可以添加负号转换成求最小值问题） 启发式搜索：利用搜索过程中获取的信息改进搜索策略。启发式搜索有利于找到问题最优解，且有助于加速求解过程。 模拟退火可以说是最简单（应用）的启发式搜索之一 相比起爬山法（找到局部最优解），模拟退火算法有一定概率能接受比当前还要差的解，概率p位于[0,1]，旧解和新解的函数值越接近，p值就越大（概率为0对应爬山法，概率为1对应蒙特卡洛算法）；时间越长，p值越小；搜索前期p大，后期p小 2.搜索过程1.随机生成一个解A，计算F(A) 2.在A附近随机生成一个解B，计算F(B) 3.对比F(A)和F(B)，进行对比，若F(B)&gt;F(A)（求最大值）,B赋值A，F(B)&lt;F(A)，计算接受B的概率，接受则B赋值A，且重复以上操作，否则返回第2步，在原来A附近再生成一个B继续下去 如果优化问题有约束条件： 1.生成B是查看是否符合要求 2.使用罚函数 与时间相关的系数Ct如何设置：Ct是温度t的倒数（模拟退火） 如何再A附近随机生成一个解B：没有统一规定，需要具体问题具体分析 停止搜索1.达到迭代次数 2.达到指定温度 3.找到连续最优解，M（如30次）次迭代还未改变 3.实现产生新解： 1.matlab内置工具 根据温度不同，新解距离旧解的步长改变，温度高步长高，温度低步长短，由全局缩短为 x_new=x_i+T×z_i 然后检查x_new是否位于上下界 2.旅行商问题 交换法，位移法，倒置法","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"数学建模国赛matlab知识点","slug":"数学建模国赛matlab知识点","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-22T07:55:04.587Z","comments":true,"path":"2020/08/06/shu-xue-jian-mo-guo-sai-matlab-zhi-shi-dian/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/shu-xue-jian-mo-guo-sai-matlab-zhi-shi-dian/","excerpt":"","text":"1.基础命令行太长，可加上三个小数点：“…” 进行分割（续行符），如 s=1-1/2+1/3-1/4... +1/5-1/6+1/7数值数据默认双精度double clear命令，清除工作区的所有变量 class(变量)得到变量类型 复型数据，虚数部分用i或j表示，如6+5i ，real函数求复数实部，imag函数求复数的虚部 以角度为单位的函数，在函数名后加“d”，如sin(pi/2)=sind(90) abs(xx)可求实数绝对值，复数的模，字符串的ascii码 rem(m,10)求m/10的余数 isprime(n)求n是否为素数，是返回1，否返回0 exp(pi/2)为e的2/Π次方 整形转换x=int8(129) //转有符号的int，最大127，即这里x=127 x=uint(129) //转无符号uint，即x=129 取整函数round()函数按照四舍五入 ceil()向上取整 floor()向下取整 fix()取靠近0的整数矩阵的建立//no.1 A=[1,2,3;4,5,6;7,8,9] //第一行1，2，3，第二行4，5，6冒号表达式e1:e2:e3 //分别为初始值，步长（两两之间间隔的大小，如果省略步长，则步长为1），终止值 inspace(a,b,n)//分别对应第一个元素，最后一个元素，元素总数（省略时为100）结构矩阵&amp;单位矩阵//结构矩阵 结构矩阵元素.成员名=表达式 a(1).x1=10; a(1).x2=&#39;liu&#39;; a(1).x3=[11,21;34,78]; //单元矩阵，用大括号 b={10,&#39;liu&#39;,[11,21;34,78]}2.矩阵引用矩阵元素A(3,2)表示A矩阵第三行，第二列元素 可用序号引用，如在A=[1,2,3;4,5,6;7,8,9]中，A(3)=7 (矩阵元素按列储存) D=sub2ind(S,I,J),分别为行数和列数组成的向量，转换矩阵元素的行下标，转换矩阵元素的列下标，D为序号（下标转序号） size(A)求矩阵A的行列数 [I,J]=ind2sub(S,D),分别为行数和列数组成的向量，序号（序号转下标） k=find(ch&gt;=&#39;a&#39;&amp;ch&lt;&#39;z&#39;) 找到符合条件的元素的序号 利用冒号获得子矩阵A(i,:) 第i行的所有元素 A(:,j) 第j列的所有元素 A(i:i+m,k:k+m) 第i~i+m行且在第k~k+m行的所有元素end运算符：表示某一维末尾下标 如：A(end,:)，是指A矩阵最后一行所有元素 利用空矩阵删除矩阵的元素将想要的元素范围赋值空矩阵[]即可，如A(:,[2,4])=[]，删除第二列，第四列元素 改变矩阵形状reshape(A,m,n)：在矩阵综援素不变的情况下，将A重新排列成m×n的二维矩阵 注意：并不改变元素个数及其储存顺序 A(:)：将矩阵A每一列元素堆叠起来成为一个列向量 3.算术运算&amp;字符串须知：加减运算两矩阵必须同型，乘法运算要求A行数和B的列数相同 点运算：两矩阵进行点运算是指它们对应元素进行运算，要求两矩阵同型 逻辑运算符：&amp;，|，~ 字符串和数值之间的转换：数值（ASCII码）=abs(字符串) 字符串=char(ASCII码) strncmp(s1,s2)：用于比较字符串s1，s2是否相等 strncmp(s1,s2,n)：用于比较字符串s1，s2前n个字符是否相等 strcmpi(s1,s2)：忽略大小写 4.特殊矩阵zeros函数：产生全零矩阵 ones函数：产生全1矩阵 eye函数：产生对角线为1的函数 rand函数：产生（0,1）区间均匀分布的随机矩阵 randn函数：产生均值为0，方差为1的标准正态分布随机矩阵 inv(矩阵)：求其逆矩阵 zeros(m):产生m×m零矩阵 zeros(m,n):产生m×n零矩阵特殊矩阵介绍： 魔方矩阵M=magic(8) (8行8列) 范德蒙矩阵vander(1:5) 希尔伯特矩阵：H=hilb(4) 伴随矩阵：A=compan(P) 帕斯卡矩阵：P=pascal(5) 对角阵对角矩阵：对角线上元素非零 数量矩阵：对角线上元素相等 对角矩阵：对角线上元素为1 diag(A)：提取矩阵A对角线元素，产生一个列向量 diag(A,k)：提取矩阵A第k条对角线元素，产生一个列向量 构造对角矩阵：diag(V)：以向量V为主对角线元素，产生对角矩阵 三角阵triu(A)：提取矩阵A的主对角线及以上的元素 tril(A)：提取矩阵A的主对角线及以下的元素 triu(A,k)：提取矩阵A的第k条主对角线及以上的元素 矩阵的转置A=[1,3;3+4i,1-2i] 转置：A.’ 共轭转置：A’ 若矩阵为实数，转置和共轭转置是一样的 矩阵旋转：rot90(A,k)，将矩阵A逆时针旋转90°的k倍，k为1可省略 矩阵左右翻转：fliplr(A) 矩阵上下翻转：flipud(A) 矩阵其他功能把一个方阵看作一行列式，并对其按行列式的规则求值：det(A) 求矩阵的秩：rank(A) 求矩阵的迹，即对角线元素之和：trace(A) 求矩阵A全部特征值，构成向量E：E=eig(A) 或者 [X,D]=eig(A) A的全部特征值构成对角阵D，X的各列是对应的特征向量 5.subplot画图subplot（m,n,p）或者subplot（mnp）此函数最常用：subplot是将多个图画到一个平面上的工具。其中，m表示是图排成m行，n表示图排成n列，也就是整个figure中有n个图是排成一行的，一共m行，如果第一个数字是2就是表示2行图。p是指你现在要把曲线画到figure中哪个图上，最后一个如果是1表示是从左到右第一个位置。 ） 6.MatLab中关于程序的操作建立函数，新建脚本，开头为： function C = 函数名( 参数A,参数B)，并且通过C返回（当有多个形参时，可用逗号分隔，而C为输出形参表，多个输出形参需要用方括号[] 括起来） 数据的输入：A=input(‘请输入A的值：’); 数据的输出：disp(输出项) 程序暂停：pause(延迟数秒),如果省略参数，则一直暂停，除非用户按任意键就可以继续执行 x^(1/3)=power(x,1/3) matlab中的switch case相对于C，java不需要break，且最后一个的default改成otherwise 匿名函数：简化了函数的过程：如f=@(x,y)x^2+y^2，f(3,4)进行调用，但是不适用于复杂函数 7.Plot函数plot(x,y)，x，y分别存储x，y坐标的数据 最简单的plot调用格式：plot(x)，下标为横坐标，值为纵坐标 x,y为同型矩阵，则分别对应x，y坐标绘画出曲线图 多条曲线可以plot(x1,y1,x2,y2,x3,y3……) x=linspace(0,2*pi,100) ,位置0到2pi的100个元素存于x plot（x,y,选项）选项有线性，颜色，数据点标记 线型：“ - ” 实线, “ : ”虚线, “ -. ”点画线, “ – ” 双画线 颜色：“ r ”红，“ g ”绿，“ b ”蓝。。。。。。 数据点标记：“ * ”星号，“ o ”圆圈，” s “方块。。。。 8.fplot函数fplot（f,lim,选项），f是函数，lim是x的取值范围，用二元向量[xmin,xmax]表示，默认[-5,5]，选项和plot相同 自变量无法间隔采样时使用fplot（函数变化趋势未知，或者在不同区间函数变化频率过大，如sin（x/1）） 9.曲线拟合polyfit（）进行拟合，找一个函数去逼近数据，再根据找到的函数预测下一个点的值（如 人口预测问题）（它实际上是求得最小二乘法拟合的多项式系数） p=ployfit（x,y,3）生成三次多项式函数，调用ployval（p,2020）进行计算（求2020年的人口）","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"CSS渲染深究","slug":"CSS渲染深究","date":"2020-07-30T16:00:00.000Z","updated":"2021-08-22T10:33:17.577Z","comments":true,"path":"2020/07/31/css-xuan-ran-shen-jiu/","link":"","permalink":"https://taylor12138.github.io/2020/07/31/css-xuan-ran-shen-jiu/","excerpt":"","text":"CSS动画和JS动画的对比CSS动画优点： 动画流畅 性能较优 动画效果对帧速不好的低版本浏览器 代码简单，调优方向固定 缺点： 运行过程控制较弱,无法附加事件绑定回调函数 代码冗长 JS动画优点： JavaScript动画控制能力很强，动画能力强 兼容性好 CSS的repaint和reflow 以上为浏览器解析流程图(WebKit 主流程) 1、解析HTML以构建DOM树：渲染引擎开始解析HTML文档，转换树中的html标签或js生成的标签到DOM节点，它被称为 – 内容树；此外，CSS下载完之后对CSS进行解析，解析成CSS对象，然后把CSS对象组装起来，构建CSSOM树。 2、构建渲染树：解析CSS（包括外部CSS文件和样式元素以及js生成的样式），根据CSS选择器计算出节点的样式，在解析步骤中创建的CSSOM树和DOM树组合成一个Render树。（display: none;不会出现在render树上，visibility: hidden会出现在render树上，因为它们会占用空间）3、布局渲染树: 也就是layout，从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。4、绘制渲染树: 也就是paint，遍历渲染树，每个节点将使用UI后端层来绘制。 在 Chrome、Opera、Safari 和 Internet Explorer 中称为布局 (Layout)。 在 Firefox 中称为自动重排 (Reflow)，但实际上其过程是一样的。 reflow对节点大小和位置的重新计算称为回流reflow/ layout，每个页面至少需要一次回流（reflow/ layout），就是页面第一次加载的时候。 对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算并根据计算结果将元素放到它该出现的位置，过程称为reflow 它一般在DOM元素位置发生改变后触发，比如JS添加 DOM元素，CSS width的改变、CSS3的animation、Scroll页面 repaint当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，过程称为repaint 它一般在改变 DOM 元素的视觉效果时触发，即不涉及任何排版布局的问题时触发，比如color、text-align、 注意：回流reflow一定会触发重绘repaint，而重绘不一定会回流 我们应该减少reflow和repaint的操作，提高渲染速度 reflow的成本比repaint高很多 下面操作可能导致高成本的消耗： 当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint。 当你移动 DOM 的位置，或是搞个动画的时候。 当你修改 CSS 样式的时候。 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。 当你修改网页的默认字体时。 display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint 优化方式 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className（或者使用的是vue、react等框架，虚拟dom会帮助你完成一次性的dom操作） 可以先把父元素隐藏起来，添加完子元素后，在把父元素显示出来；亦或者使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档 减少使用table布局 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量 使用transform、opacity、filters这些动画不会引起回流重绘，因为他们是在paint之后的 比如我在使用了transform:translate()后，无法获取正确的offsetTop、offsetLeft，由于他们未进行回流重绘，虽然视觉上确实是移动了，但是div在文档流中的位置是不变的 实质上Layout -&gt; Paint -&gt; 还有一个Composite(渲染层合并) 具体有关于会影响Layout的CSS属性可以在CSS Triggers网站中查阅。（可以方便我们优化） 浏览器对于回流重绘的优化现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程 但是：当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect 所以我们要有可能造成回流重绘时，要避免使用以上方法，导致队列进行刷新 关于特殊CSS属性的优化如果你修改一个非样式且非绘制的CSS属性，那么浏览器会在完成样式计算之后，跳过布局和绘制的过程，直接做渲染层合并。这种方式在性能上是最理想的。 不是所有属性动画消耗的性能都一样，其中消耗最低的是transform和opacity两个属性（当然还有会触发Composite的其他CSS属性），其次是Paint相关属性。所以在制作动画时，建议使用transform的translate替代margin或position中的top、right、bottom和left，同时使用transform中的scaleX或者scaleY来替代width和height。 transform在没有重绘的情况下，变换究竟是如何渲染动画的呢？基本答案是 CSS 转换直接发生在利用硬件加速的GPU内存中，从而避免了软件渲染。 渲染优化与此同时，我们通过CSS的属性来触发 GPU加速 浏览器会为此元素单独创建一个“层”,是一个新的复合层。有了这一层，就有点React的PureComponent、usecallback内味了，进行局部更新，不影响他人。 为什么开启硬件加速动画就会变得流畅，那是因为每个页面元素都有一个独立的Render进程。 首先理解三个概念： CPU即中央处理器，它的功能主要是解释计算机指令以及处理计算机软件中的数据,也被称为主板。 GPU即图形处理器，是与处理和绘制图形相关的硬件。GPU是专为执行复杂的数学和几何计算而设计的，有了它，CPU就从图形处理的任务中解放出来，可以执行其他更多的系统任务。 硬件加速是指在计算机中透过把计算量非常大的工作分配给专门的硬件来处理来减轻CPU的工作量的技术。在CSS transition, transform和animation的世界里，他暗示我们应该卸载进程到GPU，因此加快速度。这种情况通过向它自己的层叠加元素，当加载动画的时候可以加速渲染。 有了新的“层”，就有了新的“Render进程”。Render进程中包含了主线程和合成线程，主线程负责： JavaScript的执行 CSS样式计算 计算Layout 将页面元素绘制成位图(Paint) 发送位图给合成线程 合成线程则主要负责： 将位图发送给GPU 计算页面的可见部分和即将可见部分(滚动) 通知GPU绘制位图到屏幕上(Draw) 我们可以得到一个大概的浏览器线程模型： 而在什么情况下我们可以单独创建出这样一个复合层？ 它在以下情况下这样做： 对于 3D 或透视 CSS 转换（在我们的示例中） 对于&lt;video&gt;或&lt;canvas&gt;元素 使用 CSS 过滤器时 对于与提取到复合层的另一个元素重叠的元素（例如，使用z-index） 所以这时我们会想到：transfrom: translate(x, y)这种2D岂不是也不可以实现？ 雀食，所以我们可以看到两个额外的重绘操作在动画时间轴的开始和结束 3D 和 2D 变换之间的区别在于 3D 变换使浏览器预先创建一个单独的复合层，而 2D 变换则是即时完成的。在动画开始时，会创建一个新的复合层并将纹理加载到 GPU，从而启动重绘。然后动画由 GPU 中的合成器执行。当动画完成时，附加的复合层将被移除，这将导致另一个重绘操作。 如何开启GPU加速？并非元素上的所有 CSS 属性更改都可以直接在 GPU 中处理。仅支持以下属性： transform opacity filter 因此，为了确保获得流畅、高质量动画的最佳机会，我们应该始终尝试使用这些 GPU 友好的属性。 或者尝试一下强制在GPU中渲染元素的方法：！ .example1 { transform: translateZ(0); } .example2 { transform: rotateZ(360deg); } 缺点： 没有什么是免费的！（英文直译hhh） 内存问题：最重要的问题与内存有关。向 GPU 加载过多纹理可能会导致内存问题 字体渲染：GPU 中的渲染会影响字体抗锯齿。这是因为 GPU 和 CPU 具有不同的渲染机制 will-change使用“transform hack”来创建单独的复合层的必要性很麻烦。浏览器绝对应该提供一种直接的方法来做到这一点。这就是为什么引入了will-change 属性。这个功能可以让你通知浏览器哪个属性会发生变化，以便浏览器提前做相应的优化。这是一个通知浏览器transform属性将被更改的示例： .element { transition: opacity .3s linear; } /* declare changes on the element when the mouse enters / hovers its ancestor */ .ancestor:hover .element { will-change: opacity; } /* apply change when element is hovered */ .element:hover { opacity: .5; } 是不是有点缓存内味了？ 可惜并非所有浏览器都支持will-change 不能过度使用 + 要节制使用 + 不能过早使用will-change（因为会消耗内存） 渲染优化的文章参考链接 参考链接https://github.com/amfe/article/issues/47 参考链接:https://www.w3cplus.com/css3/introduction-css-will-change-property.html 参考链接https://www.sitepoint.com/introduction-to-hardware-acceleration-css-animations/","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"JavaScript基础","slug":"JavaScript基础","date":"2020-07-21T14:14:19.766Z","updated":"2021-08-22T11:38:34.536Z","comments":true,"path":"2020/07/21/javascript-ji-chu/","link":"","permalink":"https://taylor12138.github.io/2020/07/21/javascript-ji-chu/","excerpt":"","text":"1.JS的介绍JS是脚本语言，不需要编译，直接由js解释器逐行进行解释并执行（编译一行，执行一行），（解释型的编程语言）现在也可以基于node.js技术（后台）进行服务器编程 实现业务逻辑和页面控制功能，浏览器的JS引擎，也就是JS解释器，用来读取JS代码 JS执行 JS本身是没有预编译的 编译器编译（important）： 将所有声明语句，包括变量声明（以var开头）和函数声明（以function开头）里面的标识符（即变量名a和函数名foo）添加到当前作用域中（添加规则是：对var声明的变量来说，如a已存在则忽略该声明，继续编译后面语句;否则就要求在当前作用域声明一个新的变量命名为a，此时a的值是undefined；对于function开头声明的函数来说，函数名foo的声明过程与变量声明一样，不过如果遇到有function声明 2个以上同名函数foo,则后面的函数体会覆盖前面的 ） 一切声明的全局变量和未经声明的变量，全归window所有。 预解析 js引擎运行js，分为两步：1.预解析 2.代码执行 预解析：js会把里面所有var还有function提升到当前作用域的最前面（分别为变量提升和函数提升） 变量提升：把所有变量声明提升至当前作用域于最前，但是不提升赋值操作 函数提升：把所有函数提升至当前作用域最前 原理： 声明 + 赋值操作是LHS查找，LHS找不到引擎会帮你在顶层作用域声明一个具有该名称的变量（严格模式除外） 从变量获取空间里的数据是RHS查找，RHS找不到会抛出错误RefrenceError var a //LHS 寻找a,未找到，通知作用域声明一个新变量，命名为a a=2; //LHS 找到a并给其赋值2 console.log(a);//RHS找到a的值2，并将其输出 JS的组成JavaScript语法：ECMAScript 页面文档对象模型：DOM 浏览器对象模型：BOM ECMAScript它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和拓展 DOM它是标准编程接口，通过DOM提供的接口可以对页面上各种元素进行操作（大小位置颜色） BOM它提供了独立于内容，可以与浏览器窗口进行互动的对象，操作浏览器窗口比如弹出窗，控制浏览器跳转，获取分辨率等 JS的插入方式 类似于CSS，有行内式，内嵌式&lt;script&gt;xxxx&lt;/script&gt; 还有从外部引入：(script标签中间别写代码) &lt;script src=\"xx.js\">&lt;/script> 2.JS基本功能介绍输入输出alert(msg); //弹出警示框 console.log(msg) //打印输出信息，是控制台输出，给程序猿测试用的 prompt(info) //弹出输入框，提供用户输入 但是都是以字符的形式输入console.log()会在浏览器控制台打印出信息 console.dir()可以显示一个对象的所有属性和方法 定义使用var，自动确定类型（JS拥有动态类型） var 如果没有事先声明var，直接使用，会创建一个全局变量 var存在声明提升 功能isNaN() 判断是否非数字 typeof 变量名 查看数据类型 转换转字符串： ​ 变量名.toString() number类型时，变量名.toString(16) 转换成16进制字符串 ​ 强制转换：String(变量名) ​ 隐式转换：变量名+”xxxx”(拼接字符串) String转数字类型： （1）String-&gt;int： parseInt(String)； （2） String-&gt;float: parseFloat(String)； （3）Number强制转换（String转数值）：Number(String) 但是Number转换字符串是相对复杂且有点反常规，建议使用parseInt （4）利用减乘除（没有+）：String-String或String-int之类的 String转ascii码 var str = \"A\"; str.charCodeAt(); // 65 var str1 = 'a'; str1.charCodeAt(); // 97 Ascii码转String //将对应的编码值转为字符 var charValue = String.fromCharCode(codeValue); 运算符18==‘18’ 成立true，默认转换数据类型 ===为全等需要完全一致， 18===‘18’为false 逻辑与短路运算：123&amp;&amp;456，返回456，左式为真返回右式子，为假返回左式 逻辑或短路运算：123||456，返回123，左式为真返回左式子，为假返回右式 三元表达式： 条件表达式？表达式1：表达式2，条件为真返回表达式1，为假返回表达式2 数组数组名.length为数组的长度 数组增加元素 （1）直接设定数组长度arr.length=xx,多出来的变成空 （2）arr数组有三个元素，直接arr[3]=xx，进行新增元素 数据类型：基本数据类型（简单数据类型） Boolean Null Undefined Number BigInt：BigInt数据类型的目的是比Number数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用BigInt，整数溢出将不再是问题。 String Symbol 收录于 https://tc39.es/ecma262/#sec-primitive-value A primitive value is a member of one of the following built-in types: Undefined, Null, Boolean, Number, BigInt, String, and Symbol; 复杂数据类型 Object 总结：USONB （you are so niubi） u：undefined s：string、symbol o：object n：null、number b：boolean，bigint 3.判断JS数据类型的四种方法typeoftypeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。 返回值是一个字符串，该字符串说明运算数的类型。 所以经常搭配使用：if(typeof target === &#39;object&#39; &amp;&amp; target !== null){} 注意： typeof null 返回 object typeof 函数 返回 function 以创建对象的方式（显示创建原始值包装类型实例），用typeof判断是否为object都会为true，它不能精确到具体的object let s = new String('abc'); typeof s === 'object'// true s instanceof String // true js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 null：所有机器码均为0（这就是type null 返回 object的原因） undefined：用 −2^30 整数来表示 红宝书阐述：typeof虽然对原始值很有用，但是对引用值用处不大。。 instanceof instanceof 用于判断一个变量是否某个对象的实例，如 var a=new Array();alert(a instanceof Array); 会返回 true 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。 官方解释：instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 注意： 数组可以被 instanceof 判断为 Object 只能判断对象，对原始类型(简单数据类型)不能判断 对于 value instanceof Array，我们还可以使用 Array.isArray(value)，后者是ECMAScript提供为了解决多框架涉及多版本Array的instancof升级版方法 constructor constructor [].constructor.name; //Array ''.constructor.name; //String alert(c.constructor === Array) ----------> true alert(d.constructor === Date) -----------> true alert(e.constructor === Function) -------> true 注意： constructor 在类继承时会出错， null 和 undefined 是无效的对象，因此是不会有 constructor 存在的 toString toString，利用toString打印出原型对象 Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ;// [object Boolean] //使用Reflect更棒！ console.log(Reflect.toString.call('')); // [object String] console.log(Reflect.toString.call(1)); // [object Number] console.log(Reflect.toString.call(true));// [object Boolean] 4..函数//1.利用函数关键字自定义函数 function 函数名(参数) { 函数体 } //如下： function sort(arr){ } //2.匿名函数 var fun=function(){ } //调用 fun(); 函数没有return，则返回的是undefined 注意在函数内部没有声明直接赋值的变量，也属于全局变量 5..对象对象一定是一个具体的对象，而不是泛指的东西 属性：事物的特征，用对象的属性表示 方法：事物的行为，在对象中方法来表示 利用对象字面量创建对象var obj ={ uname:'xx', age:18, sex:'man', say:function(){ console.log('good'); } } //调用对象属性(2种) obj.uname obj['uname'] (1)键 属性名: 值 属性值 (2)用逗号隔开 (3)方法冒号后面跟的一个匿名函数 利用new Object创建对象再赋值的时候创建属性，因此此方法效率不高 var obj = new Object obj.uname='xx'; obj.age=18; obj.say=funciton(){} （1）利用等号赋值添加对象的属性和方法 （2）每个属性和方法用分号 利用构造函数创建对象其过程也称为对象的实例化,构造函数是泛指的某一大类，对象是具体的事物 function 构造函数名(){ this.属性=值; this.方法=function（）{} } 1.使用构造函数，构造函数名字首字母最好大写如 function Star()2.构造函数不需要return3.使用函数new 构造函数名();即构造一个对象，如new Array()，创建一个数组对象4.属性方法前必须加this如this.name=传参name this.song = function（传参）{} 遍历对象for (const k in obj){ //obj为对象 console.log(k); //k输出的是属性名 console.log(obj[k]);//得到的是属性值 } //我们使用for in 喜欢var k或者key //或者使用 for (const item of obj) { console.log(item); //每个属性的属性值，不过仅适用于可遍历对象 } 对象删除键值对var json = { name:'张三', age:'23' }; delete json.age; 6.内置对象JavaScript中对象分为自定义对象，内置对象，浏览器对象，前两种属于ECMAScript；第三个浏览器对象是js特有的 Javascript提供了多个和内置对象：Math、Date、Array、String 可以通过MDN/W3C来查询内置对象的使用 MDN的网址：https://developer.mozilla.org/zh-CN/ （1）Math对象//绝对值方法： Math.abs(-1) //1 Math.abs('-1') //1,隐式转换 Math.abs('pink') //NAN Math.PI //圆周率 Math.floor(x) //向下取整 Math.ceil(x) //向上取整 Math.round(x) //四舍五入 Math.max(x) //最大值, x为0或多个值。在 ECMASCript v3 之前，该方法只有两个参数。 Math.min(x) //最小值 Math.random() //随机 0&lt;=x&lt;1 Math.floor(Math.random()*(x_max-x_min+1))+x_min//得到两个数之间的随机整数 Math.sqrt(x) //返回一个数的平方根 Math.pow(3, 2) //3^2次方，当然也可以使用 3 ** 2来表示 函数 toFixed(n) 将数字舍入（四舍五入）到小数点后 n 位，并以字符串形式返回结果。如果后续还想再用该数字，记得转回number let num = 12.34; alert( num.toFixed(1) ); // \"12.3\" （2）Date对象是一个构造函数，必须使用new调用 var date = new Date(); //无参数，返回当前系统的时间,复杂的字符串结构 //常用的两种时间写法 var date = new Date(2020, 10, 1); //指定固定日期 var date = new Date('2020-10-1 8:8:8'); //返回年份，月份，日期，时，分，秒 date.getFullYear(); date.getMonth()+1; //0-11 + 1 = 1-12 date.getDate(); date.getHours(); date.getMinutes(); date.getSeconds(); //距离1970年 1.1经历的毫秒数，用来：d=parsent（总秒数/60/60/24）得到天数等单位 date.valueOf() date.getTime() var date1= +new Date(); //最常用,返回执行时日期和时间的毫秒数 Date.now() //H5新增，返回执行时日期和时间的毫秒数 var d=new Date().toLocaleTimeString() //本地时间把 Date 对象的时间部分转换为字符串 由于开发中时间戳转换为日期太过于常见，所以网上有直接封装好的（使用的是正则表达式）的函数，直接格式化即可 日期类转换到原始值能使用 toString() 注意：const date = new Date(&#39;2020-10-1 8:8:8&#39;);这种写法，会导致安卓端和ios端的时间上有所不同，并且有明显的差异！！最好以 const birthday = new Date(1995, 11, 17, 3, 24, 0);的形式进行命名 const date = new Date(&#39;2020/10/1 8:8:8&#39;);也可以，但是兼容性好象不如逗号分隔的形式 （3）数组对象填充数组数组的每个槽位可以储存任意类型数据 var arr1 = new Array(2,3); //相当于[2,3]的数组 var arr = new Array(5).fill(); //创造一个数组长度为5的数组，但是此方法会自动往里面填undefined值，让数组最起码有值了！ var arr = new Array(5).fill(0);//也可以填写你想要的值，比如0 但是如果想创建一个用空对象填充的数组话，实际上我们在使用同一个 空对象 / 空数组进行提埃填充，这样会造成他们都是联动的，牵一发而动全身 let a = new Array(5).fill({}); console.log(a); // [{}, {}, {}, {}, {}] a[0].name = '张三'; console.log(a); // [{name: \"张三\"}, {name: \"张三\"}, {name: \"张三\"}, {name: \"张三\"}, {name: \"张三\"}] 但是可以使用这个方法创建二维数组 const arr = Array.from(Array(n), () => Array(m).fill(0)); //from的使用 console.log(Array.from([1, 2, 3], x => x + x)); // expected output: Array [2, 4, 6] 排序arr1.sort(function(a,b) { return a-b; //从小到大 }); //该排序可能是快排等结合的很优算法。升序 如果不加function则为按照字符串排序 arr.sort([compareFunction]) compareFunction 可选 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 firstEl 第一个用于比较的元素。 secondEl 第二个用于比较的元素。 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 其他arr1 instanceof Array //检验是否为数组，是返回true，否则false Array.isArray(arr1); //同上,H5新增,但这个效果好，防止多个不同版本的Array构造函数 arr1.push(xx); //在数组末尾增加数组元素，push完毕之后，返回结果是新数组的长度,push实际上可以接收多个参数一次增加 arr1.unshift(xx); //在数组开头增加数组元素，unshift完毕之后，返回结果是新数组的长度 arr1.pop(); //删除数组的最后一个元素 返回值为被删除的元素值 arr1.shift(); //删除数组的第一个元素 返回值为被删除的元素值 arr1.reverse(); //翻转数组 arr1.indexOf(xx); //返回该数组元素的索引号（只返回第一个满足条件的索引号），找不到返回-1 //indexOf还可以用于判断对象是否存在 arr1.includes(xx); //是否含有该元素，判断对象是否存在 arr1.lastindexOf(xx);//同上，只返回倒数第一个满足条件的索引号 arr1.toString(); //转换成字符串，逗号分隔 arr1.join('你想要的分隔符'); //用指定分隔符分割不同的数组元素，并转换成字符串 array.splice(开始的指针下标,删除的个数[, item1[, item2[, ...]]]); //用于删除多组元素并且添加新元素 arr.splice(2,1,\"William\"); //从index序号为2地开始，删除掉一个，并添加william元素 arr.slice(start,end) //slice() 方法可从已有的数组中返回选定的元素。 //这里是指从start到end-1，不包含end arr.concat(arrayX, arrayX, arryX) //concat() 方法用于连接两个或多个数组。 //该方法不会改变现有的数组，而仅仅会返回被连接数组的一 //个副本。 Array.from(obj); //() 方法用于通过拥有 length 属性的对象或可迭代的对象来返回一个数组(浅拷贝的数组实例); //对于字符串有点类似于 Array.from(str) = str.spilt(\"\"); //案例，数组去重 //利用indexoOf，返回-1则添加入新数组 function unique(arr) { var newArr = []; //另一种创建数组方式 for(int i = 0; i &lt; arr.length; i++){ if(newArr.indexOf(arr[i]) == -1) { newArr.push(arr[i]); } } } 7.基本包装类型基本数据类型是没有属性和方法的，而对象才有属性和方法 //String var str = 'andy'; //但是str可以使用str.length,因为jshui把基本数据类型包装成复杂数据类型，操作如下 var temp = new String('andy'); str = temp; temp = null; //因为字符串不可变，所以每次str += i ，拼接字符串会开辟另外一个内存空间，字符串赋值同理 //String 同样有很多很多数组对象的属性功能 str.indexOf('xx'); str.indexOf('查找的字符',[起始的位置]); //这个也可以 str.lastindexOf('查找的字符',[起始的位置]); //从后面开始查找字符串，当然也可以指定位置 str.charAt(位置); //根据位置返回字符 str.charCodeAt(位置); //根据位置返回字符的ASCII码 str[index]; //同str.charAt，H5新增 str.replace(被替换的字符,替换的字符); //只替换掉里面第一个字符， 原字符串不会改变。 str.includes(xx); //是否含有该子字符串，返回布尔值 str.trim() //方法会从一个字符串的两端删除空白字符，它并不影响本身的字符串，它返回的是一个新的字符串 判断一个对象是否有该属性 可使用对象[‘属性名’], 返回true则有，反则返回false 截取字符串（和concat一样，他们不会影响原来的字符串，只会返回提取到的原始新字符串值） 这三个方法在面对负值参数时又有三个不同的效果 str.substr(start,length); //start位置开始，length取的个数，省略length则默认取到最后 str.slice(start,end); //start开始，截取到end，但是end截取不到 str.substring(start,end); //start开始，截取到end，end可以截取到 数组对象转字符用join()，字符转数组用split var str = 'red, pink, blue'; console.log(str.spilt(',')); //用逗号分隔 var arr = [1, 2, 3]; console.log(arr.join(' ')); //用' '分隔 str.toUpperCase() 转换大写， str.toLowerCase() 转换小写 ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 8.简单类型和复杂类型如果有个数据类型打算作为存储对象，暂时没想好放什么，可以先放null 简单数据类型（值类型）：string（但是string数值不可变）、number、boolean、undefined、null、symbol、bigint 简单数据类型放入栈里面（操作系统），栈里开辟的空间存放的是值 （用函数传参是不会影响变量的值） 复杂数据类型（引用类型）：Object、 Array、 Date 复杂数据类型放入堆里面（操作系统），于栈里存放地址，十六进制表示，然后这个地址指向堆里的数值；一般由程序员分配释放，若程序员不释放，由垃圾回收机制释放 （用函数传参是会影响对象的值） 但是复杂数据类型null赋值时断了地址联系 var obj = new Object(); obj.name = 'allen'; var obj2 = obj; console.log(obj2.name); //allen obj.name = 'bllen'; //改对象 console.log(obj2.name); //bllen obj = null; //改变量 console.log(obj2.name); //bllen 但是JS里没有堆栈的概念，只是通过堆栈的方式理解代码的执行方式 9.其他swiper插件的使用官网地址：https://www.swiper.com.cn （1）下载并解压包后，把其中的swiper.min.js和swiper.min.css放入网页文件夹的js和css中 （2）官网找到类似的案例，复制html，css和js（进入官网swiper演示中，然后新窗口打开，查看网页源代码） （3）根据需求修改模块 模块JavaScript天生不支持模块化，node.js中才有 但是在浏览器中也可以像在node.js中模块进行编程，如果 &lt;scirpt&gt;标签进行引用加载，还得考虑加载顺序问题，这时需要第三方库： require.js（AMD）或sea.js（CMD） 为了上述方法都是民间自主创造出来的，为了解决模块化问题，官方自己发布了ES6标准，其中包含了官方对JavaScript模块化的支持，虽然标准已经发布，但是JavaScript运行环境还不支持 目前很多前端都是使用很多新技术，然后利用编译器工具打包，可以在低版本浏览器中运行，类似于less =&gt; css 浅拷贝和深拷贝深拷贝和浅拷贝是只针对object和Array这样的引用数据类型的 1.赋值当我们把一个对象赋值给一个新的变量时，赋的其实是该对象在栈中的地址，而不是堆中的数据，只要修改了里面的的值，原来都都会受到影响 2.浅拷贝他会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性基本类型，拷贝的基本类型的值（修改后原来的变量的值不会受到影响）；如果属性是内存地址（引用类型，比如数组、对象），拷贝的就是内存地址，即其中一个变量修改了这个地址存放的对象，则另外一个会受到影响 数组的浅拷贝可以使用：Array.prototype.concat()、Array.prototype.slice()、Array.from(arr)，他们不会修改原数组，只是返回了一个浅拷贝的新数组 对象可以使用 ：Object.assgin()或者 let obj2 = {...obj1} (（ECMAScript 2018规范新增特性）) 3.深拷贝所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝，使得两个对象不会相互影响 具体深拷贝的手写我在 “JavaScript进阶ES5+面向对象”篇章中写过 10.JS数值精度JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数 而位操作并不直接应用到64位，而是先把值转换为32位整数，在进行位操作，最后再把32位转换为34位存储起来 NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 typeof NaN // 'number' NaN === NaN // false，NaN不等于任何值 Boolean(NaN) // false JavaScript 内所有数字都是浮点数，若遇到需要整数才能运算的情况，JavaScript 会自行将64位浮点数转成32位整数，再进行运算，而这个转换过程，便导致了精度丢失。 比如： 0.1 + 0.2 // 0.30000000000000004 0.1 + 0.7 // 0.7999999999999999 0.3 / 0.1 // 2.9999999999999996 (0.3 - 0.2) === (0.2 - 0.1) // false 为什么0.1+0.2===0.3 //false ？？？？ 在计算机里的数表示方式都是二进制，so 0.01 = 1/4 = 0.25 ,太大 0.001 =1/8 = 0.125 , 又太小 0.0011 = 1/8 + 1/16 = 0.1875 , 逼近0.2了 0.00111 = 1/8 + 1/16 + 1/32 = 0.21875 , 又大了 0.001101 = 1/8+ 1/16 + 1/64 = 0.203125 还是大 0.0011001 = 1/8 + 1/16 + 1/128 = 0.1953125 这结果不错 0.00110011 = 1/8+1/16+1/128+1/256 = 0.19921875 整数精度而整数的精度最多只能到53个二进制位，这意味着，绝对值 小于 2^53 的整数，即 (-2^53, 2^53) Math.pow(2, 53) // 9007199254740992【未丢失】 Math.pow(2, 53) + 1 // 9007199254740992【丢失】 Math.pow(2, 53) + 2 // 9007199254740994【未丢失】 Math.pow(2, 53) + 3 // 9007199254740996【丢失】 Math.pow(2, 53) + 4 // 9007199254740996【未丢失】 可以使用Number.isSafeInteger(变量) 方法来判断一个值是否为安全整数，即该整数是否在 (-2^53, 2^53) 范围内 指数范围根据 IEEE 754 标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（211-1 = 2047）。分出一半表示正数，一半表示负数，则 JavaScript 能够表示的数值范围为 (2^1024, 2^-1023) 【开区间】，超出这个范围的数无法表示。 正向溢出与负向溢出 【正向溢出】如果一个数大于等于 2^1024，那么就会发生 “正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity 【负向溢出】如果一个数小于等于 2^-1075（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为 “负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 // 正向溢出 Math.pow(2, 1024) // Infinity【正数数值非常大，无法表示，正向溢出，只能返回正无穷】 // 负向溢出 Math.pow(2, -1075) // 0【正数数值非常小，无法表示，负向溢出，返回 0】 所以无穷大、无穷小由此得来 无穷大：Number.MAX_VALUE，JavaScript里最接近infinity的正值 无穷小：Number.MIN_VALUE，JavaScript 里最接近 0 的正值，而不是最小的负值。 浮点数精度修复为了避免此类事情的发生 (0.3 - 0.2) === (0.2 - 0.1) // false ECMA 给出的解决方法是：将浮点数分别乘 10n 转为整数，再除以 10n。((0.01 * 100) + (0.02 * 100)) / 100 === 0.03; // 来源：https://www.iteye.com/blog/talentluke-1767138 // 两个浮点数求和 function accAdd(num1, num2) { var r1, r2, m; try { r1 = num1.toString().split('.')[1].length; } catch(e) { r1 = 0; } try { r2 = num2.toString().split(\".\")[1].length; } catch(e) { r2 = 0; } m = Math.pow(10,Math.max(r1,r2)); // return (num1*m+num2*m)/m; return Math.round(num1*m+num2*m)/m; } 还有一个办法就是，把小数部分逐个转换成字符，然后一个一个作为单个数字去做加减乘除，实现大数加减乘除，实现方法可能比较繁琐。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"CSS高级","slug":"CSS高级","date":"2020-05-30T16:00:00.000Z","updated":"2021-08-22T10:27:59.065Z","comments":true,"path":"2020/05/31/css-gao-ji/","link":"","permalink":"https://taylor12138.github.io/2020/05/31/css-gao-ji/","excerpt":"","text":"1.图形精灵图为了有效减少服务器接收和发射请求次数，提高速度出现的CSS技术。即将网页小背景图合成一张大图。 主要针对于背景图片（非产品类等更新换代图片） 主要使用background-position+x和y轴配合使用，x轴向右，y轴向下 background: url()no-repeat -182px 0; //分别对应x轴，y轴,基本都是负值缺点：文件大，放大缩小会失真，更换复杂 svg + canvasSVG 指可伸缩矢量图形 (Scalable Vector Graphics)，基于可扩展标记语言XML（老），SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失。SVG是通过DOM操作来显示的。 canvas：canvas 是H5新出来的标签(技术比较新)。画布是一个矩形区域，您可以控制其每一像素，Canvas是逐像素进行渲染的，一旦图形绘制完成，就不会继续被浏览器关注。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法 SVG &amp; canvas的区别： SVG不依赖分辨率 SVG支持事件处理器 SVG适合带有大型渲染区域的应用程序（地图） SVG复杂度高会减慢渲染速度（可能会reflow） SVG不适合游戏应用 canvas依赖分辨率 canvas不支持事件处理器 canvas文本渲染能力较弱 canvas能够以png、jpg格式保存结果图像 canvas适合图像密集型游戏（他不会relfow） 2.字体图标iconfont常用于一些小图标（样式简单），展示状态时图标，实际上是字体 优点1.轻量级，够小 2.灵活性，可改多种效果 3.几乎支持所有浏览器 下载：相应网站（如https://icomoon.io/）下载后得到压缩包，解压后，把下载包里的fonts放入页面根目录下 使用：在CSS中根据说明引用全局声明，然后再在个体css中再次引用你想要的声明，同时可以自己调色和字体大小（font-size） 这里以阿里的图标为例子，把项目添加好之后，根据操作https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.16&amp;helptype=code一步一步来（这里是unicode引用），注意：**复制代码的时候，一定要在url的值中补充 “http:”** （使用bootstrap框架，可以直接使用其官网给的图标） 3.三角形若盒子设置宽高为0；此时又设置边框，则会形成组成一个正方形的4个三角形，实际上我们写三角形可以利用这个原理，把其他三个三角形隐藏起来则就只有一个三角形了 width: 0; height: 0; /*line-height: 0; font-size: 0; 有时需要添加，看浏览器*/ /*先设置一个边框，尽量大，以边框概括盒子大小*/ border: 50px solid #ccc; border-color: transparent red transparent transparent //上右下左的颜色 4.用户界面鼠标样式 cursorcursor: defalut 默认无样式 cursor: pointer 小手 cursor: move 移动 cursor: text 文本 cursor: not-allowed 禁止 轮廓线给表单（input）添加 outline: 0;，点击表单时，会去掉默认的l蓝色光标 防止拖拽文本域textarea{ resize: none }可以使文本框没有拖拽选项 5.Vertical-align(图片)css常用vertical-align让图片和文字对齐（但是只能针对行内元素或者行内块元素） vertical-align: middle; 中线对齐（一般使用这个来对齐） 图片底侧放置于盒子内时，时常有一个空白缝隙，可以使用vertical-align: middle||top||bottom;将其解决 （其实还可以直接转成块元素，但是此方法不提倡） 其实也可以将该盒子转化成 display: table-cell，然后同样可以使用vertical-align属性 常用的压缩图片地址（png）https://tinypng.com/ 6.文字溢出变省略号（推荐让后端写）单行文本：white-space: nowrap //强制一行内显示 ​ overflow: hidden; //溢出隐藏 ​ text-overflow: ellipsis ///变成省略号 多行文本：（有较大兼容性问题，适用于移动端或者webkit浏览器） ​ overflow: hidden; + text-overflow: ellipsis display: -webkit-box; /*单行伸缩盒子*/ -webkit-line-clamp: 2; /*限制其文本行数*/ -webkit-box-orient: vertical; /*设置盒子的子元素排列方式，（垂直居中）*/ 7.常见布局技巧可以使用margin的负值来消除浮动边框的重合（消除产生的巨大影子）如： margin-left: -Xpx; 想要移动到某个边框内自动变色可以使用hover，但是当排列方式为每个盒子的右边框被另外一个盒子的左边框压住时，变色效果会出bug，正确做法是：xx:hover{ position: relative; }添加相对定位使其马上覆盖当前所有单位 如果失败，有可能是因为当前已经添加了绝对定位了，此时只需要提高层级：z-index: 1; 8.CSS初始化为了照顾浏览器兼容，必须首先进行CSS初始化，即重新设定CSS个标签的初始默认值 9.CSS3新特性ie9+才支持 属性选择器可以不借助类选择器 input[att] {} 带有att属性值的被选中input[att=&quot;value&quot;] {} 带有att属性并且属性值等于value被选中 input[class^=icon]{} 选择类属性以icon开头的所有标签 input[class$=icon]{} 选择类属性以icon结尾的所有标签 input[class*=icon]{} 选择类属性含有icon的所有标签 如 .local-nav li [class^=\"local-nav-icon\"] { } 类选择器，伪类选择器，属性选择器（伪类选择器、属性选择器一般是11，因为包含标签名+/伪类名属性名=1+10=11）它们权重都为10 结构伪类选择器first和last等可以来了解一下，实际开发不太建议使用，也比较少使用。 值得注意的是 nth-child(n)比较重要 n可以是数字，可以是关键字（even偶数，odd奇数），甚至公式 ul li:nth-child(even){ } //选择所有的偶数孩子 ul li:nth-child(n){ } //选择所有孩子,因为n是公式类似n++，依次施加CSS效果 ul li:nth-child(2n){ } //选择所有的偶数孩子 ul li:nth-child(-n+5){ } //选择前5个孩子 nth-of-type和nth-child的不同： section div:nth-child(1){ } //先排序，再看是否符合div，如果是div就渲染 section div:nth-type(1){ } //先看是否符合div，如果是就在div里排序，选择第一个就渲染 伪元素选择器通过CSS创建新的子标签（比较简单的），从而简化html结构，（还与之前清除浮动使用的伪元素方法有关） element::before{ content：'XX'; /*必须要有content属性，为内容*/ } /*在元素内部前面（左）插入内容*/ element::after{ content: 'XX'; } /*在元素内部后面（右）插入内容*/ 它和标签选择器一样，权重=1，且为行内元素，想要设置大小必须转行内块 （还可以有element:hover::before{}的操作） 伪类和伪元素单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素 双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法; 所以我们最好养成习惯，伪元素写 :: 伪类写 : CSS3盒子模型只需增加如下代码 box-sizing: content-box; /*默认*/ box-sizing: border-box; /*只看盒子大小，不考虑border和padding因素*/ 即可不用考虑border和padding因素是否会将盒子本身撑大。 标准盒模型：box-sizing：content-box 怪异盒模型：box-sizing：border-box 这里提及到盒子模型就讲一讲标准盒模型和怪异盒模型 W3C盒子模型(标准盒模型)和IE盒子模型(怪异盒模型)标准盒模型： 盒子实际内容（content）的width/height=我们设置的width/height; 盒子总宽度/高度=width/height+padding+border+margin。 怪异盒模型： 盒子的（content）宽度+内边距padding+边框border宽度=我们设置的width/heigh 盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin。 总结： 总大小其实是一样的，只是我们设置标准盒子宽高是设置内容宽高，设置怪异盒子宽高是内容 + padding + border 宽高 CSS3滤镜filter用于模糊图形效果，filter: 函数(); 如：filter:blur(5px); //模糊处理，数值越大越模糊 …… CSS3calc函数(计算函数)width: calc(100% - 80px); //宽度永远比父盒子宽度小30px CSS过渡（重点）一些变化的动画效果（时间缓滞），经常和 :hover 一起搭配 transition: 要过渡的属性 花费的时间（单位为s） 运动曲线（默认ease，可以省略） 何时开始（默认0s，可省略）; transition: width 0.5s,heigh 0.5s; /*多个属性\",\"分割，想要更多属性，直接属性值写all*/ xx:hover{width:100px;heigh:100px;} transition: all 0.xs; 使用的比较多 10.CSS的morecss的2D转换transform可以理解为变形 移动：translate 旋转：rotate 缩放：scale 2d为二维坐标，x轴向右，y轴向下 translate类似于定位transform:translate(x,y); transform:translateX(n); transform:translateY(n); /*单位是px，如果是百分号，则它的距离是盒子自身高宽对比出来的*/ translate最大的优点：不会影响其他元素的位置，绝对定位会脱标，margin会影响，（有点像相对定位，但是更方便，可以加过渡效果） 可用于定位父盒子的中间位置 使用： position: absolute; top: 50%; left: 50%; transform:translate(-50%,-50%);但是它对行内标签没有效果 rotate旋转transform:rotate(度数deg); transform-origin:x y; /*设置元素旋转依靠的中心点*/ x，y默认为50%，50%，设置x，y可以可是bottom，left等，如transform-origin:left bottom;为设置左下角为中心点 scale之缩放transform:scale(x,y);/*里面的数字不跟单位，是倍数，x，y分别是宽，高*/ transform-origin:x y; /*设置元素旋转依靠的中心点*/ 若只有一个参数，则同比放大 使用scale的优点：变大时不会影响其他盒子的位置，且放大是以中心向外扩张的放大，直接修改width和heigh放大是直接往下放大 动画用keyframes定义动画 @keyframes 动画名称 { 0%{ width:100px.... } 100%{ width:200px.... } }//可以设置25%，75%等多个状态，习惯上把0%也写了 //以下也可以 @keyframes 动画名称 { from{ width:100px.... } to{ width:200px.... } } 0%动画的开始 100%动画的结束 1.可以做多个状态变化 keyframe关键帧 2.里面的数字为整数 3.百分比为时间的划分 使用动画： div { animation-name:动画名称; animation-duration:持续时间; animation-iteration-count:播放次数，可以为infinite; animation-direction:xx; //默认normal，alternate为设置逆向播放 animation-fill-mode:xx; //默认backwards，动画结束后返回原来位置，forwards可取消该功能 animation-play-state:xx; //running/paused 是动画运行或者暂停 animation-timing-fuction: ease; //默认ease加速度，linear匀速，step分步。。。 } 使用多个动画用“，”分隔，如animation: bear 0.7s steps(8) infinite, move 0.7s ……（animation: name duration timing-function delay iteration-count direction fill-mode play-state;） 3D转换x轴向右，y轴向下，z轴向外，最常用的是3d位移和3d旋转,以下许多功能与2d十分相似 设置为3d模式(变形效果) transform-style: preserve-3d 3d移动transform: translate3d(x,y,z); transform:translateZ(n); /*translateZ一般采用px，3d的z轴显现出来需要透视功能*/ 透视透视我们也成为视距，即眼睛到屏幕的距离，透视的单位是像素，透视越小，盒子越大 透视写在被观察元素的父盒子上 perspective: xxpx;3d旋转一般加上透视效果会比较明显，3d旋转方向遵循左手定则： 左手大拇指指向x轴正方向，手指弯曲的方向则为旋转的方向 transform: rotateX(度数); /*沿着X轴旋转*/ transform: rotateY(度数); transform: rotateZ(度数); /*z轴旋转和2d普通rotate有点像*/ transform: rotate3d(x,y,z,度数); /*自定义轴旋转*/ 自定义旋转只对x轴选取为transform: rotate3d(1,0,0,度数); 对角线旋转为transform: rotate3d(1,1,0,度数) transform要看情况选择：先写旋转rotate再写移动translate或者相反情况 3d呈现transform-style控制子元素是否开启三维立体环境，代码要写给父级（一定是父级，不能爷爷级别，亲测过），此属性很重要 transform-style: preserve-3d /*此为开启立体空间，但是默认值为flat，不开启立体空间*/","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"基数排序","slug":"基数排序","date":"2020-05-17T12:55:49.418Z","updated":"2021-04-04T15:14:40.894Z","comments":true,"path":"2020/05/17/ji-shu-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/ji-shu-pai-xu/","excerpt":"","text":"基数排序使用的大致思路是：根据关键字进行分类，再次排序，在分类，在排序，以此类推直至完成结果 如扑克牌中根据分13类，排序，再根据花色分类，再排序； 对百位数排序，先根据个位分类，排，再根据十位分类，排，再根据百位分类，排 //算法8.12 基数排序 #include using namespace std; #include #include #include #define MAXNUM_KEY 8 //关键字项数的最大值 #define RADIX 10 //关键字基数，此时是十进制整数的基数 #define MAX_SPACE 10000 typedef char KeysType; //定义关键字类型为字符型 typedef int InfoType; //定义其它数据项的类型 typedef struct { KeysType keys[MAXNUM_KEY]; //关键字 InfoType otheritems; //其他数据项 int next; }SLCell; //静态链表的结点类型 typedef struct { SLCell r[MAX_SPACE]; //静态链表的可利用空间，r[0]为头结点 int keynum; //记录的当前关键字个数 int recnum; //静态链表的当前长度 }SLList; //静态链表类型 typedef int ArrType[RADIX]; //指针数组类型 void InitList(SLList *L) { //初始化静态链表L（把数组D中的数据存于L中） char c[MAXNUM_KEY],c1[MAXNUM_KEY]; int i,j,n,max; //max为关键字的最大值 max=-10000; cout","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"归并排序","slug":"归并排序","date":"2020-05-17T11:52:57.097Z","updated":"2021-04-04T15:14:46.724Z","comments":true,"path":"2020/05/17/gui-bing-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/gui-bing-pai-xu/","excerpt":"","text":"归并排序将相邻的两个记录（序列）排序，并成一个有序序列，并继续上述操作 //算法8.11 归并排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }RedType; typedef struct { RedType *r; int length; }SqList; void Create_Sq(SqList &L) { int i,n; cout","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"简单选择排序","slug":"简单选择排序","date":"2020-05-17T11:35:13.462Z","updated":"2021-07-22T14:20:59.515Z","comments":true,"path":"2020/05/17/jian-dan-xuan-ze-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/jian-dan-xuan-ze-pai-xu/","excerpt":"","text":"简单选择排序选择关键字储存最小的记录：和表中的记录进行一一对比，选出最小记录放在开头，接着从第二个记录继续开始 //算法8.6 简单选择排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void SelectSort(SqList &amp;L) { //对顺序表L做简单选择排序 int i,j,k; ElemType t; for(i=1;i&lt;L.length;++i) { //在L.r[i..L.length] 中选择关键字最小的记录 k=i; for(j=i+1;j&lt;=L.length;++j) if(L.r[j].key&lt;L.r[k].key) k=j; //k指向此趟排序中关键字最小的记录 if(k!=i) {t=L.r[i];L.r[i]=L.r[k];L.r[k]=t;} //交换r[i]与r[k] } //for } // SelectSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); SelectSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序，但如果是采用“交换记录”，则会导致不稳定现象 2.顺序，链式皆可以使用 3.时间复杂度O( n^2 ),比直接插入快。 空间复杂度为O(l1).","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"快速排序","slug":"快速排序","date":"2020-05-17T10:28:42.342Z","updated":"2021-04-04T15:14:31.261Z","comments":true,"path":"2020/05/17/kuai-su-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/kuai-su-pai-xu/","excerpt":"","text":"快速排序设置个关键字，将大的放在它后面，小的放在前面，分成两个子表，并且重复上述过程，直到每一个子表只有一个记录为止 //算法8.5 快速排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 int Partition(SqList &L,int low,int high) { //对顺序表L中的子表r[low..high]进行一趟排序，返回枢轴位置 int pivotkey; L.r[0]=L.r[low]; //用子表的第一个记录做枢轴记录 pivotkey=L.r[low].key; //枢轴记录关键字保存在pivotkey中 while(low","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-05-17T10:25:30.973Z","updated":"2021-04-04T15:14:25.034Z","comments":true,"path":"2020/05/17/mou-pao-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/mou-pao-pai-xu/","excerpt":"","text":"冒泡排序将关键字大的记录“下沉”,与小的记录进行交换 //算法8.4 冒泡排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void BubbleSort(SqList &L) { //对顺序表L做冒泡排序 int m,j,flag; ElemType t; m=L.length-1; flag=1; //flag用来标记某一趟排序是否发生交换 while((m>0)&&(flag==1)) { flag=0; //flag置为0，如果本趟排序没有发生交换，则不会执行下一趟排序 for(j=1;jL.r[j+1].key) { flag=1; //flag置为1，表示本趟排序发生了交换 t=L.r[j];L.r[j]=L.r[j+1];L.r[j+1]=t; //交换前后两个记录 } //if --m; } //while } //BubbleSort void Create_Sq(SqList &L) { int i,n; cout","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"希尔排序","slug":"希尔排序","date":"2020-05-17T09:07:40.698Z","updated":"2021-04-08T00:15:33.296Z","comments":true,"path":"2020/05/17/xi-er-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/xi-er-pai-xu/","excerpt":"","text":"希尔排序通过分组进行大浮动跳跃性排序，并且分组的形式是以设定的增量为基准 //算法8.3 希尔排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void ShellInsert(SqList &L,int dk) { //对顺序表L做一趟增量是dk的希尔插入排序 int i,j; for(i=dk+1;i","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"折半插入排序","slug":"折半插入排序","date":"2020-05-17T08:36:10.446Z","updated":"2021-04-04T15:13:59.648Z","comments":true,"path":"2020/05/17/zhe-ban-cha-ru-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/zhe-ban-cha-ru-pai-xu/","excerpt":"","text":"折半插入排序其实就是直接插入排序引入了折半的思想 //算法8.2 折半插入排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表 void BInsertSort(SqList &amp;L){ //对顺序表L做折半插入排序 int i,j,low,high,m; for(i=2;i&lt;=L.length;++i) { L.r[0]=L.r[i]; //将待插入的记录暂存到监视哨中 low=1; high=i-1; //置查找区间初值 while(low&lt;=high) { //在r[low..high]中折半查找插入的位置 m=(low+high)/2; //折半 if(L.r[0].key&lt;L.r[m].key) high=m-1; //插入点在前一子表 else low=m+1; //插入点在后一子表 }//while for(j=i-1;j&gt;=high+1;--j) L.r[j+1]=L.r[j]; //记录后移 L.r[high+1]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //for } //BInsertSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); BInsertSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.仅适用于顺序表 3.时间复杂度为O(n^2)，但是平均性能&gt;直接插入。 空间复杂度为O(1),只需要一个r[0]","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"直接插入排序","slug":"直接插入排序","date":"2020-05-17T08:26:32.728Z","updated":"2021-04-08T00:24:33.907Z","comments":true,"path":"2020/05/17/zhi-jie-cha-ru-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/zhi-jie-cha-ru-pai-xu/","excerpt":"","text":"直接插入排序这里采用的是从后向前的比较方式，（从前向后其实也可以） 有点像打牌，抽牌，然后选择地方放好 //算法8.1 直接插入排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void InsertSort(SqList &L) { //对顺序表L做直接插入排序 int i,j; for(i=2;i","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"CSS浮动+定位","slug":"CSS浮动+定位","date":"2020-05-16T16:00:00.000Z","updated":"2021-08-22T07:59:00.230Z","comments":true,"path":"2020/05/17/css-fu-dong-ding-wei/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/css-fu-dong-ding-wei/","excerpt":"","text":"1.浮动CSS三种传统布局：普通流 浮动 定位 标准流：标签按照默认排序 多个块级元素纵向排列用标准流，横向排列用浮动 选择器{ float: 属性值; //none不浮动 left向左浮动 right向右浮动 }//创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘 1.浮动元素会脱离标准流原来（排在浮动后面的）标准流的标签会顶上你原来的位置（但标准流之后的浮动挤不上去） （但是！！不会覆盖掉你的文字！，因为本身浮动是为环绕图片而设计的） 2.浮动元素会一行内显示并且元素顶部对齐紧贴在一起，不会有缝隙，装不开会另起一行 3.浮动元素具有行内块元素的特性添加浮动后自动附带行内块元素的特性 4.浮动自带文字环绕效果浮动的使用：一般采取先用标准流父元素排列上下位置，之后在子元素采取浮动，使得浮动在网页中间而不是左右侧 一般一个元素浮动了，他的兄弟标签最好也使用浮动 2.清除浮动布局1.父盒子不给高度，子盒子会自动撑开 2.父盒子不给高度的话，子盒子如果是浮动，父盒子会发生高度塌陷，导致高度变成0 所以总结：需要清除浮动！！！ clear: 属性值 一般属性值取both（常用）清楚两侧浮动，也有left，right 1.额外标签法，隔墙法，W3C推荐做法在浮动标签最后加多个一子标签（必须是块级元素），如： .clear{ clear: both; } &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;优点：通俗易懂，书写方便 缺点：结构化差 2.父级添加overflow（生成BFC元素） //父级盒子 .box{ overflow: hidden; //或者auto } 优点：代码简洁 缺点：无法显示出溢出部分 3.：after伪元素法额外标签的升级版，给父元素添加 .clearfix::after { content: \"\"; display: block; //伪元素默认是行内元素，所以得转 height: 0; clear: both; visibility: hidden; } .clearfix { *zoom: 1; //兼容ie6，ie7 } /*一般类名定义为clearfix*/ 优点：结构简单 缺点：需要照顾低版本浏览器 代表网站：百度，淘宝，网易 4.双伪元素清除浮动.clearfix::before, .clearfix::after { content: &quot;&quot;; display: table; //转化为块级，并且一行显示 } .clear::after { clear: both; } .clearfix { *zoom: 1; //兼容ie6，ie7 }优缺点同上，代表网站：小米，腾讯 3.CSS定位1.某个元素可以在盒子内移动位置，并且压住其他盒子。 2.滚动窗口时，盒子固定于屏幕某个位置。 定位=定位模式+边偏移量 定位选择器{ position: static; position: relative; position: absolute; position: fixed; position: sticky; top: 100px; //必备的指定位置，可以为left，right，bottom } position: static; //默认，无定位,标准流特性 position: relative; //相对定位，参照点是自己，移动位置后，原来的位置继续占有（没有脱标） position: absolute; //绝对定位，是相对于他的祖先元素。 1.没有祖先元素或者，祖先元素没有使用定位，则以浏览器为准直接偏移 2.如果祖先元素有定位（相对，绝对，固定），则以最近一级定位的祖先元素为参考点 3.绝对定位不再占有原来的位置（脱标） 4.加了绝对定位的盒子不能通过 margin: 0 auto; 来居中，让它居中的原理和fixed设置版心的原理差不多，都是left：50%+margin组合 position: fixed; //固定于浏览器可视区位置，不占有原先位置 1.还可以设置于版心附近，方法：让那个固定定位的盒子 left: 50%,然后让固定定位的盒子margin-left：版心的一半距离 position: sticky; //粘性定位，被认为相对定位和固定定位的混合体 relative -&gt; fixed 1.以浏览器可视窗口为参照移动的元素（固定特点） 2.粘性定位占有原先的位置 3.必须添加top，left等，不然相当于相对定位 4.常用于导航栏的滚动 缺点：很多比较老的浏览器都不支持（移动端不考虑） (子绝父相—–出自pink老师) -&gt;&gt;&gt;&gt;&gt;&gt;&gt; —–&gt; 子级使用绝对定位，父亲则需要使用相对定位 位置如果一个定位既设置了left，也设置了right，它默认会执行left。若及设置了top，也设置了bottom，会默认执行top（无关权重的事情） 定位叠放次序通过控制z-index来控制盒子的前后次序（叠放次序）z-index： 1; 1.数值越大盒子越靠上 2.如果值相同，按照书写顺序，后来居上 3.数字不能加单位 4.只有定位盒子才有z-index属性（还有flex） 定位的特殊性质1.行内元素添加绝对或固定定位，可以直接设置高度和宽度 2.块级元素添加绝对或固定定位，未设置宽高，会脱标，默认内容大小（类似浮动）（不会发生外边距合并） 3.和浮动不同，绝对或固定定位会压住你标准流文字等内容 4.元素的显示和隐藏1.displaydisplay: none; 隐藏对象（不再占有原来的位置，可以用于js的下拉菜单等功能） display: block; 显示对象（也可以是转换块元素） 2.visiblevisibility: visible; 元素可视 visibility: hidden; 元素隐藏（仍然占有原来位置） 3.overflowoverflow: visible; 超出你的标签部分（固定大小）可见 overflow: hidden; 超出你的标签部分（固定大小）隐藏，如果有定位的盒子慎用，他会切掉你溢出布局标签的部分 overflow: scroll; 可添加滚动条 overflow: auto; 需要的时候添加滚动条 5.文档流浮动和定位一些属性会脱离文档流 其实还有一个文本流，它其实就是一系列字符，是文档的读取和输出顺序，也就是我们通常看到的由左到右、由上而下的读取和输出形式。 只有postion一些属性可以从文本流脱离出来 文档流是相对于盒子模型讲的文本流是相对于文字段落讲的 所以我们可以看到浮动的时候文字环绕的形式，说明浮动并没有脱离文本流；但是position中的absolute和fixed全部脱离。 mdn: 下列元素会脱离常规流: floated items。浮动的元素 items with position: absolute (including position: fixed which acts in the same way)。通过设置position属性为absolute或者fixed的元素 the root element (html)根元素","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"字典排序","slug":"字典排序","date":"2020-05-14T11:30:26.797Z","updated":"2021-04-04T15:13:43.323Z","comments":true,"path":"2020/05/14/zi-dian-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/zi-dian-pai-xu/","excerpt":"","text":"字典排序实现“ 1 2 3 ， 1 3 2 ， 2 1 3 ， 2 3 1 ， 3 1 2 ， 3 2 1 ”的序列排序方法 代码实现如下 #include #define swap(a,b) {int temp=a;a=b;b=temp;} //交换a，b值 void sort(int arr[],int start,int end)//冒泡排序，从start到end的排序，使用时注意是数组的下标，如数组下标0-3排序，sort（arr,0,3） { int i,j; for(i=0;iarr[a]) //这是字典排序第二步，获取arr[b]的值 { b=j1; break; } } swap(arr[a],arr[b]); //这是第三步 sort(arr,a+1,n-1); //这是第四步 } } int main() { int arr[]={1,2,4,3}; permutation(arr,4); return 0; } 总结得出字典排序算法四步法： 字典排序：第一步：从右至左找第一个左邻小于右邻的数，记下位置i，值list[a]第二部：从右边往左找第一个右边大于list[a]的第一个值，记下位置j，值list[b]第三步：交换list[a]和list[b]的值第四步：将i以后的元素重新按从小到大的顺序排列 举例：125643的下一个字典序列第一步：右边值大于左边的3&lt;4,4&lt;6,6&gt;5,则i=2，list[a]=5第二步：从右往左找出第一个右边大于list[a]=5的值，找到6&gt;5,j=3;list[b]=6;第三步：交换list[a]和list[b]的值，序列125643-&gt;126543第四步：将位置2以后的元素重新排序,126543-&gt;126345;结束： 126345即125643的下一个序列————————————————版权声明：本文为CSDN博主「Hi,Mr.Wang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_34672688/article/details/79557380","categories":[{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Hello"},{"title":"牛客算法课personnel note","slug":"牛客算法课personnel note","date":"2020-05-14T11:30:26.797Z","updated":"2020-10-26T08:59:32.432Z","comments":true,"path":"2020/05/14/niu-ke-suan-fa-ke-personnel-note/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/niu-ke-suan-fa-ke-personnel-note/","excerpt":"","text":"小基础floor(x) 小于等于x的最大值整数（向下取整） ceil(x) 大于等于x的最小整数（向上取整）( #include&lt;math.h&gt; ) int 32位二进制 第一个是符号位正数为0，负数为1，后面是数值位 -2^31——2^31-1 long long 64位二进制 double 64位二进制 （float别用了，太垃圾了） ~ 取反 &gt;&gt;右移 &lt;&lt;左移 pow(a,b) a的b次方 一维前缀和拥有数组x和数组y，满足： y0=x0; y1=x0+x1; y2=x0+x1+x2; 即想要求某区间和，可用y数组来相减得到结果 枚举一一举例，不重复 先列举出（求第x数到第y数的和，先求数组所有和，直接减），（求四个点的位置，并且四个点组成正方形，先求四个点中的两个点，），（求一排树数量，部份树被整段移走（可能重叠），直接标记1，移走的树部分-1） 取尺法分L，R两个指针，求数组区域&lt;=s的连续数组的个数，&lt;s R右移， &gt;=s L右移 使用前提： 1.能够维护一个区间，保证这个区间能够获得答案。 2.维护的具体操作可以左边移动一位、右边移动一位。 3.区间的变化是连续的而不是跳跃的。问题1就是比较跳跃的，双指针比较好，问题2不能跳跃。 贪心算法局部最优解，然后发现局部最优=整体最优解 桶排序列出数组， 将数组分到有限数量的桶里，将数据对比，有则让数组对应的数据+1，每个桶再个别排序 ，然后依次输出 桶越多，时间效率就越高，而桶越多，空间就越大 这里有位大佬我觉得写得很好，外加动漫配图，可以看一下（简单桶排序） https://www.cnblogs.com/bqwzx/p/11029264.html 计数排序基数排序和计数排序都可以看做桶排序，计数排序的思路是开一个长度为 maxValue-minValue+1 的数组，进行分配+收集: 分配。扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1。 收集。扫描一遍计数器数组，按顺序把值收集起来。 计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序 ， 计数排序非常浪费空间 VECTORvector是一个不限制数组长度的数组 top()返回第一个元素 back()返回最后一个元素 erase（int index,int size）删除 vector a; 迭代器Iterator用于访问问一个容器内的数据的指针 vector:: iterator it; C++ STL的二分查找binary search 返回bool，是否存在 low_bound 返回可插入的最小位置的迭代器，即返回第一个符合条件的元素位置，low_bound(a,a+11,55), a[0]到a[10]找55，返回迭代器，可将结果 -a 得到它的下标 第一个&lt;=x的位置 upper_bound 返回可插入的最大位置的迭代器，即返回最后一个符合条件的元素位置 第一个&gt;x的位置","categories":[{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"}],"tags":[],"author":"Hello"},{"title":"C++类型转换&java的一些对象","slug":"C++类型转换&java的一些对象","date":"2020-05-13T09:10:17.923Z","updated":"2020-11-15T05:40:12.960Z","comments":true,"path":"2020/05/13/c-lei-xing-zhuan-huan-java-de-yi-xie-dui-xiang/","link":"","permalink":"https://taylor12138.github.io/2020/05/13/c-lei-xing-zhuan-huan-java-de-yi-xie-dui-xiang/","excerpt":"","text":"头文件#include &quot;iostream&quot; #include &quot;stdlib.h&quot; #include &quot;cstdlib&quot; #include &quot;string&quot;使用cstdlib中c_str()使其转换成char，再转int和float/double C 库函数 int atoi(const char *str) 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。 C 库函数 double atof(const char *str) 把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 double price=atof(new_str[2].c_str()); int count=atoi(new_str[3].c_str());; javaStringBuilder：动态StringStringBuilder str = new StringBuilder(“Hello World!”, 25)//最大长度，可有可无str.append//增加 str.insert(6,”Beautiful”);//在第6个位置插入str.toString转String 自带栈：import java.until.Stack1 boolean empty()测试堆栈是否为空。2 Object peek( )查看堆栈顶部的对象，但不从堆栈中移除它。3 Object pop( )移除堆栈顶部的对象，并作为此函数的值返回该对象。4 Object push(Object element)把项压入堆栈顶部。5 int search(Object element)返回对象在堆栈中的位置，以 1 为基数。 用栈Stack 创建对象（类型不同） Stack&lt;Integer> stack = new Stack&lt;>(); Stack&lt;Character> stack = new Stack&lt;>(); //Stack stack=new Stack()也可 Hashmap的特点： hashmap和hashset的区别：一个是使用键值对存放（快一点），一个是对象存放底层实现是 链表数组，JDK 8 后又加了 红黑树实现了 Map 全部的方法key 用 Set 存放，所以想做到 key 不允许重复，key 对应的类需要重写 hashCode 和 equals 方法map.put(“zhang”, “31”)//存放键值对map.containsKey(“zhang”);//键中是否包含这个数据map.get(“zhang”);//通过键拿值map.isEmpty();//判空map.remove(“zhang”);//从键值中删除 利用set帮List去重复：List list = new ArrayList(); 。。。。。。。List newList = new ArrayList(new HashSet(list)); 或者 Set set = new HashSet(); List newList = new ArrayList(); set.addAll(list); newList.addAll(set); String[] s = {“aa”,”bb”,”cc”}; List ebsCodes = new ArrayList();List strlist = Arrays.asList(s); 等同于 ebsCodes.add(“USERNAME”); 等同于 (Arrays.asList(“USERNAME”,”REAP”,”NLS”)但不支持add，remove ebsCodes.add(“REAP”); ebsCodes.add(“NLS”);","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"CSS样式","slug":"CSS样式","date":"2020-05-09T16:00:00.000Z","updated":"2021-08-07T07:21:36.690Z","comments":true,"path":"2020/05/10/css-yang-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/css-yang-shi/","excerpt":"","text":"声明：可以使用chrome的F12浏览学习别人的样式并且调试你的代码 引入CSS/*1）link的写法：*/ &lt;link rel=\"stylesheet\" href=\"index.css\"> /*2）import的写法：*/ &lt;style type=”text/css”> @import url（“index.css”）； &lt;/style> link和@import的区别： （1）link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 （2）link可以加载CSS，Javascript；@import只能加载CSS。 （3）link加载的内容是与页面同时加载；@import需要页面网页完全载入以后加载。（所以有时候浏览@import加载CSS的页面时会没有样式（就是闪烁），网速慢的时候还挺明显。） 1.主要定义/*是类型选择,标签选择器*/ 元素（标签） { } /*选择所有元素*/ * { } /*的选择 选择多个类可以 &lt;div class=\"类1 类2\">&lt;/div>*/ .class(类名) { } /*id的选择,有点类似class，只能调用一次，别人切勿使用*/ #(id名) { } /*复合，后代选择器*/ 元素1（可以是类名） 元素2（可以是类名） { } /*只选择亲儿子，孙子不选*/ 元素1（可以是类名）>元素2（可以是类名） { } /*并集选择器，多个统一*/ 元素1, 元素2{ } /*选择类名1的下一个兄弟节点元素2*/ 类名1+元素2{ } /*m-small-cont 写成 &amp;-cont的形式， &amp; 表示嵌套的上一级*/ .m-small { &amp;-cont { } } 注意：如果一个元素拥有ID属性,那么ID属性的属性值就会成为window对象的属性名 文字注意：chrome默认最小展现字体为12px，想要查看需要在浏览器设置中设置 font-size: 12px //12像素大小文字 谷歌默认16px font-size: 12px/1.5 //12像素大小文字 行高为12*1.5=18 font-weight: xxx //字体加粗 text-align: center //文字水平居中对齐 text-indent: 10px //文本首行缩进,最好使用em，如text-indent: 2em,em是相对单位，当前1个文字元素的大小 text-decoration: none//取消下划线 line-height: 26px //行间距，用QQ截图可以偷偷测量，等于盒子高度时垂直居中 背景background-color //背景颜色 background: rgba(red（数值）,green(数值),blue（数值），透明度（0-1）) //背景颜色 透明化 background-image: url(地址)//背景图片，常见于标志，logo或者超大背景图片，有点是便于控制位置 baackground-repeat: no-repeat//背景平铺，默认为平铺，可以改成取消平铺 background-position: x y//背景图片的位置 ，可以使用方位名词，前后顺序可可以不一样top，center ，botton，left等（只写一个另外一个默认居中）。也可以使用精确单位x轴长度，y轴长度，（只写一个另外一个默认居中） background-attachment: scroll||fixed//背景图像随对象内容滚动||背景图像固定 复合：background: 颜色 图片地址 平铺 图像滚动 图片位置 列表list-style: none//去掉无序列表里 li 列表前面的小圆点 阴影box-shadow: 10px 10px 5px #888888; 分别对应阴影的水平，垂直和阴影，颜色 text-shadow: 1px 1px rgba(0,0,0,.2); 文字阴影效果 inputoutline: none; 消除输入边框 border: 0; 消除输入框的自带边框 透明opacity: 0.5 半透明 opacity: 1 不透明 box-sizingbox-sizing 属性可以被用来调整这些表现: content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。 border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。 border-box不包含margin 尺寸单位 px单位，像素单位 em单位，em是相对于父元素的字体大小，如父元素的font-size为12px，子元素设置宽高为10em，则大小实际为10*12=120px rem单位，相对于html字体大小 %单位，继承父元素单位 dp单位，屏幕密度 vh单位，viewpoint height，视窗高度，1vh等于视窗高度的1%。 vw单位，viewpoint width，视窗宽度，1vw等于视窗宽度的1%。 2.伪类选择器/*a超链接类 或者写成 a的类名:XXX{}*/ a:link 选择所有未访问的链接 a:visited 选择所有已被访问的链接 a:hover 常用，选择鼠标指向的链接 a:ative 鼠标按下未弹起的链接 /*如果全部都写，请按照LVHA的顺序写*/ /*input类，把获得光标的inut选取出来改写CSS*/ input:focus 3.行块转换display:block /*转块元素*/ display:inline /*转行内元素*/ display: inline-block /*转行内块*/ displat: table /*成为一个块级表格元素*/ display: table-cell /*使子元素成为表格单元格*/ /*使文字垂直居中 让文字行高=盒子的行高 行高>盒子高度偏下，&lt;偏上*/ line-height: 盒子高度 多行文字居中 父元素 display的table + 子元素：table-cell vertical-align: middle 配合可以实现多行文字居中 父元素设置对应的height和line-height 子元素设置display:inline-block + vertical-align:middle() + line-height (缺点：文本的高度不能超过外部盒子的高度。) .parent { height: 300px; line-height: 300px; } .son { display: inline-block; width: 300px; line-height: 20px; vertical-align: middle; } CSS水平垂直居中方式1.绝对定位 position: absolute; top: 50%; left: 50%; transform:translate(-50%,-50%); 2.flex布局 .parent{ display:flex; justify-content:center; align-content:center; } 3.grid布局，比flex的兼容性还低 .parent { display: grid; } .child { align-self: center; justify-self: center; } .parent{ display: grid; place-items: center; } 4.table-cell + vertical + text-align .parent { display: table-cell; vertical-align: middle; text-align: center; } .child { display: inline-block; } 5.table-cell + vertical + margin .parent { display: table-cell; vertical-align: middle; } .child { /*加上 display: table 兼容ie7*/ margin: 0 auto; } 6.行内元素水平垂直居中 text-align: center; line-height: 300px; /*和盒子高度保持一致*/ 关于九宫格样式布局可以参考以下链接博主的讲解，很详细 https://juejin.cn/post/6886770985060532231#heading-2 display和visibilitydisplay: none：该元素以及它的所有后代元素都会隐藏，无法使用屏幕阅读器等辅助设备访问，占据的空间消失 visibility: hidden：也可以隐藏这个元素，但是隐藏元素仍需占用与未隐藏时一样的空间，也就是说虽然元素不可见了，但是仍然会影响页面布局。（也就是仍然占据空间，只是隐藏起来） 除了占据空间这个重大的区别之外，还有2个区别： visibility具有继承性，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别 visibility: hidden不会影响计数器的计数，如图所示，visibility: hidden虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样 解决行内元素造成的间距 给其父元素添加了font-size:0 但是注意：IE6，IE7浏览器当设置font-size：0时，换行符、tab（制表符）、空格始终存在1px的空隙而最新版本的Safari浏览器，Chrome浏览器不支持字体大小为0的浏览器 设置浮动（不过可能会有布局问题） 设置margin为负值（感觉不太好） 将行内标签都放在同一行上 4.CSS的三大特性1.层叠性样式冲突选择就近原则，把前面的覆盖掉，不冲突的不覆盖 2.继承性子标签会继承父标签的属性 3.优先级1.选择器相同，执行层叠性 2.选择器不同，继承/*(0,0,0,0)&lt;元素(0,0,0,1)&lt;类(0,0,1,0)&lt;id(0,1,0,0)&lt;行内样式style(1,0,0,0)&lt;！important无限大 （属性选择器input[class^=icon]{} 是（0,0,0,1）（0,0,1,0） ） （！important加在某属性后面，如color: green!important） 继承的你加了！important，权值还是（0，0，0，0），毕竟是继承过来的 3.复合选择器有权重叠加的问题 ul li{}权重为(0,0,0,1)+(0,0,0,1) li为(0,0,0,1) .nav li为（0，0，1，1） 权重会叠加，但是永不进位，不是二进制 （a:hover为(0,0,1,1)） 5.CSS盒子border（会影响盒子大小） border-style: solid(实线边框，最常用) dashed(虚线) dotted（点线边框） border-width: XXpx border-color: XX 复写： border: 1px solid red 边框分开写法： border-top: 1px solid red border-collapse:collapse /*相邻边框合并*/ border-top-right-radius: 15px; /*右上方改圆角，无top，right则全部都改*/ padding内边距（会影响盒子大小，要设置了盒子宽高才会撑开） 适用于文字大小不一的盒子，不设置宽高，直接设置padding，字少空间小。字多空间大 子容器盒子没设置宽高，父容器盒子padding不会被撑开 padding: 5px; padding: 0 10px; /*分别对应上下和左右*/ padding-top: 5px; /*仅写上方内边距*/ margin外边距，盒子和盒子之间的距离（不会撑开） 使用方法和padding是一致的 margin可以让块级盒子水平居中：1盒子必须有宽度，盒子左右外边距设置为auto margin: 0 auto;(不适用于定位) 行内元素或者行内块元素水平居中只需在其父元素CSS样式中添加：text-align: center; 外边距合并问题1.外边距合并指的是，当两个垂直外边距（2个margin）相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。而左右外边距不合并。2.在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。3.注释：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 4.我们可以在a元素或者b元素再包裹一个容器并触发该容器生成一个BFC，就不会发生margin重叠了 overflow visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 使用了overflow: scroll 或者 overflow: auto 才可以使用scroll事件的那些 scrollTop属性等 6.PSjpg： JPEG对色彩保留好，高清颜色多 gif：常用于小图片动画，可保留透明背景 png：结合jpg和gif，储存形式丰富，支持透明背景 PSD：保存PS设计稿 图层切图： 选定图层，右键，快速导出为png 切片切图： 切片工具—》选中—》左上角文件—》导出—》存储为Web所用格式—》JPEG（png可用于保存透明图）（保存的时候选”选中的切片“） ps插件切图：需要下载Cutterman插件 7.部署网站免费的远程服务器：http://free.3v.do/ 8.vhvh：viewport hetght 指当前可视窗口高度 100vh为100%的可视区域 height: 100vh; 9.BFC我们常说的文档流其实分为定位流、浮动流、普通流三种。而普通流其实就是指BFC中的FC Box 是 CSS 布局的对象和基本单位 Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 BFC：块级格式化上下文，我个人理解的是一种规则 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（margin外边距合并问题） 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算（清除浮动的原理，overflow: hidden） 触发BFC 根元素（CSS 中的根元素是指 :root 选择器匹配到的元素，在 HTML 中是 html 元素） float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible https://segmentfault.com/a/1190000013023485 这个网址里面又生成BFC的小案例，很有趣，可以加深理解","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"前端冗杂知识","slug":"前端冗杂知识","date":"2020-05-09T16:00:00.000Z","updated":"2021-07-25T05:00:18.977Z","comments":true,"path":"2020/05/10/qian-duan-rong-za-zhi-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/qian-duan-rong-za-zhi-shi/","excerpt":"","text":"BFFBack-end for Front-end，服务于前端的后端 BFF就是老生长谈的中间层概念，初衷是在后台服务与前端之前添加一层，比如在中间加上一个node.js，做到请求的转发 和 数据的转换，Nodejs既配合了前端技术栈，也更适应向微服务的并发请求 BFF作为中间层，优点是： 前后端彻底分离，即便是后期有微服务迁移，也不需改动前端代码 业务更向前靠拢，琐碎的api由前端开发自己决定，更适配前端框架 BFF可以自开mock，插件也能生成API文档，相比后端单开这类服务要方便些吧 留给后端更清晰的服务边界，只需要提供粗粒度的接口即可 缺点： 中间层转发会增加请求延迟。 需要保证端到端测试 必须随时准备好后端异常请求 BFF分成会增加开发成本 资料来源：https://www.jianshu.com/p/9cca72f9e93c VSCode编译Emmet语法插件于市面上大多前端编译软件，如VScode所带有的，便于快速写html和CSS 网页移动端适配，开启理想视口，用于做移动端网页的适配 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> h5想要生成多个标签：div*10，再回车（或者tab），即可生成10个div标签。 生成父子关系标签：div&gt;span,再回车（或者tab），即可生成包含span标签的div标签。 生成兄弟关系标签：div+span,再回车（或者tab）。 输入：.nav 直接生成一个class=“nav”的div标签。(默认div) 输入：#nav 直接生成一个id=“nav”的div标签。 输入：p.nav 直接生成一个class=“nav”的p标签。 输入：.nav$*5 直接生成5个class=“nav1”,class=“nav2”…..的div标签。($是自增符号) 输入：div{前端真好玩}*5 直接生成5个&lt;div&gt; 前端真好玩 &lt;/div&gt; CSS样式内输入：tac 直接生成text-align: center; 其他语法缩写同样类似，诸如w100—&gt;width: 100 格式化直接鼠标右键，格式化文档，即可直接让文档变整齐。 （或者想要每次保存后自动格式化，需要在首页—首选项—设置—搜索emmet.include,在setting.json下的用户，添加 “editor.formatOnType”: true, “editor.formatOnSave”: true 即可） 又或者 On Windows Shift + Alt + F On Mac Shift + Option + F On Ubuntu Ctrl + Shift + I RPCRPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。 首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接 第二，要解决寻址的问题，连接到对应的服务器（如主机或IP地址）以及特定的端口 两台服务器之间以 序列化传输数据 + 反序列化得到数据结果 以上是它们连接的建立和数据的传输过程 远程调用的问题 Call ID映射。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。 序列化和反序列化问题 网络传输问题 RPC的大项目适用性： 做一个访问量不大的项目的时候,一台服务器部署上一个应用+数据库也就够了. 访问量稍微大一点之后呢,需要：集群.架设nginx,部署多个服务 再大一点，数据库已经扛不住了,有时候宕机. 那这个时候呢我们需要数据库读写分离,再架设几台数据库服务器,做主从,做分库分表。 再大一点，我们需要拆分模块，拆分项目，比如订单系统分一个项目，但是还是需要切换顶层的nginx.把要重启的服务的流量切到可用服务上. 这个时候就可以使用RPC 所有的服务在启动的时候注册到一个注册机里面,然后顶层处理在接收到nginx的请求时,去注册机找一个可用的服务,并调用接口. 这样子呢,在不加新功能的时候,顶层处理服务我们就不需要动了，那修改了用户信息项目的时候,我们只需要一个个更新用户信息项目的服务群就好了。 部分观点源自https://www.zhihu.com/question/25536695 Native Modules官方解释 有时，React Native 应用程序需要访问 JavaScript 中默认不可用的原生平台 API，例如用于访问 Apple 或 Google Pay 的原生 API。也许你想重用一些现有的 Objective-C、Swift、Java 或 C++ 库，而不必在 JavaScript 中重新实现它，或者为图像处理之类的事情编写一些高性能、多线程的代码。 NativeModule 系统将 Java/Objective-C/C++（本机）类的实例作为 JS 对象公开给 JavaScript（JS），从而允许您从 JS 内执行任意本机代码。虽然我们不希望此功能成为通常开发过程的一部分，但它的存在至关重要。如果 React Native 没有导出你的 JS 应用程序需要的原生 API，你应该能够自己导出它！ 所以我们可以在RN的项目里中看到导入RPC数据使用的是 import {NativeModules} from 'react-native'; const NERCTAppContextModule = NativeModules.NERCTAppContextModule || {}; // iOS审核屏蔽功能 const { source = '' } = NERCTAppContextModule;","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"循环队列","slug":"循环队列","date":"2020-05-09T11:51:20.811Z","updated":"2020-10-26T08:58:48.437Z","comments":true,"path":"2020/05/09/xun-huan-dui-lie/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/xun-huan-dui-lie/","excerpt":"","text":"循环队列顺序定义typedef struct { QElemType *base;//初始化时动态分配存储空间 int front;//头指针 int rear;//尾指针 } SqQueue; 初始化//算法3.11 循环队列的初始化 Status InitQueue(SqQueue &Q) {//构造一个空队列Q Q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间 if (!Q.base) exit(OVERFLOW); //存储分配失败 Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空 return OK; } 求队列长度//算法3.12 求循环队列的长度 int QueueLength(SqQueue Q) {//返回Q的元素个数，即队列的长度 return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE; } 入队和出队（防止假溢出）（出头front，入尾rear）（rear无元素，front有元素）//算法3.13 循环队列的入队 Status EnQueue(SqQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满 return ERROR; Q.base[Q.rear] = e; //新元素插入队尾 Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1 return OK; } //算法3.14 循环队列的出队 Status DeQueue(SqQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 if (Q.front == Q.rear) return ERROR; //队空 e = Q.base[Q.front]; //保存队头元素 Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1 return OK; } 链队定义（还是像极了单链表，可知X链的形式一般都是单链表拓展）typedef struct QNode { QElemType data; struct QNode *next; } QNode, *QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 } LinkQueue; 链队的初始化Status InitQueue(LinkQueue &Q) {//构造一个空队列Q Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点 Q.front->next = NULL; //头结点的指针域置空 return OK; } 入队和出队（队头front无元素）//算法3.17 链队的入队 Status EnQueue(LinkQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 QueuePtr p; p = new QNode; //为入队元素分配结点空间，用指针p指向 p->data = e; //将新结点数据域置为e p->next = NULL; Q.rear->next = p; //将新结点插入到队尾 Q.rear = p; //修改队尾指针 return OK; } //算法3.18 链队的出队 Status DeQueue(LinkQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 QueuePtr p; if (Q.front == Q.rear) return ERROR; //若队列空，则返回ERROR p = Q.front->next; //p指向队头元素 e = p->data; //e保存队头元素的值 Q.front->next = p->next; //修改头指针 if (Q.rear == p) Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点 delete p; //释放原队头元素的空间 return OK; } 取队头元素//算法3.19 取链队的队头元素 SElemType GetHead(LinkQueue Q) {//返回Q的队头元素，不修改队头指针 if (Q.front != Q.rear) //队列非空 return Q.front->next->data; //返回队头元素的值，队头指针不变 }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"栈","slug":"栈","date":"2020-05-09T11:14:09.081Z","updated":"2020-05-17T12:35:55.947Z","comments":true,"path":"2020/05/09/zhan/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/zhan/","excerpt":"","text":"顺序栈定义typedef struct { SElemType *base;//栈底指针 SElemType *top;//栈顶指针 int stacksize;//栈可用的最大容量 } SqStack; 初始化Status InitStack(SqStack &S) { //构造一个空栈S S.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间 if (!S.base) exit(OVERFLOW); //存储分配失败 S.top = S.base; //top初始为base，空栈 S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE return OK; } 入栈和出栈（top无元素）//算法3.2 顺序栈的入栈 Status Push(SqStack &S, SElemType e) { // 插入元素e为新的栈顶元素 if (S.top - S.base == S.stacksize) return ERROR; //栈满 *(S.top++) = e; //元素e压入栈顶，栈顶指针加1 return OK; } //算法3.3 顺序栈的出栈 Status Pop(SqStack &S, SElemType &e) { //删除S的栈顶元素，用e返回其值 if (S.base == S.top) return ERROR;//栈空 e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e return OK; } 链栈定义，有点像链表typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack;初始化，无需链表的”头结点“Status InitStack(LinkStack &amp;S) { // 构造一个空栈 S，栈顶指针置空 S = NULL; return OK; }入栈和出栈//算法3.6 链栈的入栈 Status Push(LinkStack &S, SElemType e) {//在栈顶插入元素e LinkStack p; p = new StackNode; //生成新结点 p->data = e; //将新结点数据域置为e p->next = S; //将新结点插入栈顶 S = p; //修改栈顶指针为p return OK; } //算法3.7 链栈的出栈 Status Pop(LinkStack &S, SElemType &e) {//删除S的栈顶元素，用e返回其值 LinkStack p; if (S == NULL) return ERROR; //栈空 e = S->data; //将栈顶元素赋给e p = S; //用p临时保存栈顶元素空间，以备释放 S = S->next; //修改栈顶指针 delete p; //释放原栈顶元素的空间 return OK; }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"双向链表","slug":"双向链表","date":"2020-05-07T11:15:31.827Z","updated":"2020-05-17T12:35:32.455Z","comments":true,"path":"2020/05/07/shuang-xiang-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shuang-xiang-lian-biao/","excerpt":"","text":"双向链表的定义typedef struct DuLNode{ ElemType data; struct DuLNode *prior; struct DuLNode *next; //前驱和后继 }DuLNode，*DuLinkList 插入顺序 s=data; s->prior=p->prior; p->prior->next=s; s->next=p; p->prior=s;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"单链表","slug":"单链表","date":"2020-05-07T10:10:22.778Z","updated":"2020-05-17T12:35:13.050Z","comments":true,"path":"2020/05/07/dan-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/dan-lian-biao/","excerpt":"","text":"如定义单链表结构体，注意引用单链表元素用” -&gt; “,因为是*LinkList，使用单链表用的是LinkListtypedef struct LNode { ElemType data; //结点的数据域 struct LNode *next; //结点的指针域 }LNode,*LinkList; //LinkList为指向结构体LNode的指针类型 前插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头 } }后插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p,r; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 r=L; //尾指针r指向头结点 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=NULL; r-&gt;next=p; r=p; } }单链表的初始化，它的头节点（为了处理方便，在第一个节点之前增加的结点）没有赋值Status InitList_L(LinkList &L){ //功能1---算法2.5 单链表的初始化 //构造一个空的单链表L L=new LNode; //生成新结点作为头结点，用头指针L指向头结点 L->next=NULL; //头结点的指针域置空 return OK; } 它不能像顺序表一样随机取值，所以需要一一查找ElemType FindList(LinkList &amp;L,int i,ElemType &amp;x){ LinkList p=L; for(int j=0;j&lt;i;j++){ if(!(p-&gt;next))return ERROR; p=p-&gt;next; } x=p-&gt;data; return OK; }查找，按值查找int GetElem(LinkList &L,int &i,ElemType e) { LinkList p=L; int j=1; while(p->next) { p=p->next; if(p->data==e){ //查找成功 i=j; return OK; } j++; } return ERROR; //循环至查找失败 } 单链表的插入Status ListInsert_L(LinkList &amp;L,int i,ElemType &amp;e){ //功能3---算法2.8 单链表的插入 //在带头结点的单链表L中第i个位置之前插入元素e int j; LinkList p,s; p=L;j=0; while(p &amp;&amp; j&lt;i-1){p=p-&gt;next;++j;} //寻找第i-1个结点 if(!p||j&gt;i-1) return ERROR; //i大于表长+1或者小于1 s=new LNode; //生成新结点s s-&gt;data=e; //将结点s的数据域置为e s-&gt;next=p-&gt;next; //将结点s插入L中 p-&gt;next=s; return OK; }删除指定序号数据元素Status ListDelete(LinkList &L,int i){ LinkList p=L; int j=1; while(p->next&&jnext; j++; } if(!(p->next)||j>i)return ERROR; LinkList q=p->next; p->next=q->next; delete q; return OK; }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"顺序表","slug":"顺序表","date":"2020-05-07T09:31:08.736Z","updated":"2020-10-26T08:59:00.549Z","comments":true,"path":"2020/05/07/shun-xu-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shun-xu-biao/","excerpt":"","text":"如定义s顺序表结构体，注意引用顺序表元素用” . “,因为是SqList不是*S’q’Listtypedef struct{ ElemType *elem; //存储空间的基地址 int length; //当前长度 }SqList; 顺序表的初始化Status InitList_Sq(SqList &L){ //功能1--算法2.1 顺序表的初始化 //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) return OVERFLOW; //存储分配失败，overflow为-2 L.length=0; //空表长度为0 return OK; } 查找Status LocateElem(SqList *L, ElemType e) //按元素值查找 { int i=0; while (ilength && L->elem[i]!=e) i++; //查找元素e if (i>=L->length) //未找到时返回0 return 0; else return i+1; //找到后返回其逻辑序号 顺序表的插入Status ListInsert_Sq(SqList &amp;L,int i,ElemType e){ //功能3--算法2.3 顺序表的插入 //在顺序表L中第i个位置之前插入新的元素e //i值的合法范围是1&lt;=i&lt;=L.length+1 if(i&lt;1 || i&gt;L.length+1) return ERROR; //i值不合法,error为0 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length; //表长增1 return OK; }删除数据元素bool ListDelete(SqList &L,int i) //删除数据元素 { int j; if (iL.length) //参数错误时返回false return false; for (j=i-1;j","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"C++结构体初始化","slug":"C++结构体初始化","date":"2020-05-07T09:16:02.980Z","updated":"2020-05-17T12:35:02.720Z","comments":true,"path":"2020/05/07/c-jie-gou-ti-chu-shi-hua/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/c-jie-gou-ti-chu-shi-hua/","excerpt":"","text":"如定义药品结构体 typedef struct node{ //定义结构体 string name; float price; int count; float sale; int next; }Medicine; typedef struct{ //定义顺序表 Medicine r[MAX_Size+1]; int length; }SqList; 使用new的初始化 SqList *list_med=new SqList;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"finished gitee","slug":"finished gitee","date":"2020-05-04T17:01:10.659Z","updated":"2020-07-06T16:11:42.941Z","comments":true,"path":"2020/05/05/finished-gitee/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/finished-gitee/","excerpt":"","text":"原来是个人邮箱的设置必须得是公开的，我一直是设置为private，搞得一直错，终于搞出来了。 但是发现了gitee的一个缺点，每次部署完后都要去码云更新一次。。。","categories":[],"tags":[],"author":"Hello"},{"title":"HTML5的基本属性","slug":"HTML5的基本属性","date":"2020-05-04T16:25:58.368Z","updated":"2021-08-22T07:56:40.144Z","comments":true,"path":"2020/05/05/html5-de-ji-ben-shu-xing/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/html5-de-ji-ben-shu-xing/","excerpt":"","text":"1.基本标签介绍&lt;html&gt;&lt;/html&gt;根标签 &lt;head&gt; &lt;/head&gt; 文档头部 &lt; title&gt; &lt;/title&gt; 文档标题 &lt;body&gt;&lt;/body&gt; 文档主体 页面解析顺序： （1）先解析head标签中的代码，head标签中会包含一些引用外部文件的代码，就会开始下载这些被引用的外部文件 当遇到script标签的时候浏览器暂停解析（相关脚本会立即下载并执行），将控制权交给JavaScript引擎（解释器）如果script标签引用了外部脚本，就下载该脚本，否则就直接执行，执行完毕后将控制权交给浏览器 当遇到一个CSS文件时，解析也可以继续进行 （2）然后解析body中的代码（如果此时head中引用的外部文件没有下载完，将会继续下载） 如果此时遇到body标签中的script，同样会将控制权交给JavaScript引擎来解析JavaScript，解析完毕后将控制权交还给浏览器渲染引擎。 （3）当body中的代码全部执行完毕、并且整个页面的css样式加载完毕后，css会重新渲染整个页面的html元素。reflow 因此，script标签放靠后比较好，此时操作dom元素才能正常操作，还能保证页面正常加载出来，如果你想放在开头，可以配合 window.onload就可以放在任意位置 页面具体渲染过程可以看MDN的官方文档https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work 2.在vscode里使用英文“！”可以直接生成基本结构ctrl+“+”可以放大（写代码）页面 &lt;!DOCTYPE html&gt; （） &lt;html lang=&quot;zh-CN&quot;&gt; (中文) &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;h1&gt;&lt;/h1&gt;---&lt;h6&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; &lt;br /&gt;&lt;strong&gt;&lt;/strong&gt;(字体加粗)&lt;del&gt;&lt;/del&gt;（字体删除线） &lt;em&gt;&lt;/em&gt; 标签告诉浏览器把其中的文本表示为强调的内容 3.盒子类似于微信小程序的view，用于布局 &lt;div&gt;&lt;/div&gt; //大盒子，独占一整行 &lt;span&gt;&lt;/span&gt; //小盒子 无法设置高度和宽度 4.img&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; height=&quot;&quot; width=&quot;&quot;&gt; //微信小程序是image alt为图片无法加载时显示的文字，title为鼠标移到图片上显示的文字提示, 但是对于height和width,一般只修改其中一个，另外一个就会跟着改变 src种绝对路径 \\ 相对路径 / （图片设置宽高一般设置为width：100%，heigh：100%，可以自动适应盒子） 5.超链接&lt; a&gt;&lt;a href=&quot;&quot; target=&quot;&quot; &gt;文本或者图像&lt;/a&gt; 类似于微信小程序中的navigator, href用于指定目标的url，可打开内部，外部链接 target用于来链接打开方式，默认_self _blank为在新窗口打开 锚点链接：设置href=#名字，如&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;可以快速跳转到第二集的页面位置 ​ 在于目标位置标签里添加id=”two” &lt;a href=&quot;&quot; title=&quot;&quot;&gt;移动到链接时会出现提示框 一般情况下，a如果包含有宽度的盒子，a需要转换为块级元素 &lt;a href=&#39;javascript:;&#39;&gt;xx&lt;/a&gt; 直接添加javascript:; 可以阻止链接跳转 6.特殊字符空格：&amp;nbsp (因无法识别大于号和小于号) 小于号：&amp;lt 大于号：&amp;gt 7.表格（用于数据）&lt;table&gt; ​ &lt;tr&gt; ​ &lt;td&gt;单元格文字&lt;/td&gt;或者&lt;th&gt;&lt;/th&gt; ​ &lt;/tr&gt; &lt;/table&gt; table是表格，tr是行，td是单元格（th可充当表头单元格）。还可以加入&lt;thead&gt;和 &lt;tbody&gt;来帮助CSS区分表格结构 单元格合并使用colspan=”（列）想要合并的单元个数”或者rowspan=”（行）想要合并的单元个数”，再删除多余的td（或th） 8.列表（用于布局）无序列表ul里只能放li标签，所以其他容器放li里面就可以 &lt;ul&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ul&gt; 有序列表(规则同无序)&lt;ol&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ol&gt; 自定义列表(同上)&lt;dl&gt; ​ &lt;dt&gt;名词1&lt;/dt&gt; ​ &lt;dd&gt;名词1解释1&lt;/dd ​ &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 注意（li默认本身没有margin） list-style-type 用于设置不同列表列表项的样式。 无序列表常使用： ul { list-style-type:circle; /* 每一项前都是圆圈 */ } ul { list-style-type:square; /* 每一项前都是正方形 */ } 有序列表也可以用 list-style-type 来设置列表项 ol { list-style-type:upper-roman; /* 每一项前面都是大写罗马数字 */ } ol { list-style-type:lower-alpha; /* 每一项前都是小写字母 */ } li标签包含a标签实际开发中导航栏不会直接用a标签，而是用li（列表）包含a标签的做法，1.语义更加清晰 2.故意对其关键字有被搜索引擎降权的风险 导航栏不给宽度是不想定死，让其自动适应 9.表单（用于填写信息，用户注册）&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot; maxlength=&quot;&quot;&gt;&lt;/form&gt;表单域 url地址为处理表单数据的地址，method有get，post 表单具有默认的提交行为，默认是同步的，同步表单提交，浏览器会锁死（转圈儿）等待服务端的响应结果。 表单的同步提交之后，无论服务端响应的是什么，都会直接把响应的结果覆盖掉当前页面。 表单中需要提交的表单控件元素必须有name属性 表单元素&lt;input&gt;&lt;input type=&quot;属性值&quot; name=&quot;&quot; value=&quot;&quot; check=&quot;&quot;&gt;输入 type可以为text，number，password，button，reset（重置）submit（用于提交），radio（单选框，必须添加name才能使用），checkbox（复选框）等 科普：submit是button的一个特例，用于处理大量表单数据，而此时input里的name是表单的名称，需要填写name才能提交表单数据 value为输入框内的提示语||充当提交给后台的数据||显示的文字 placeholder=&quot;Search...&quot; 显示提示的文字 用于单选和复选的默认属性 checked checked=&quot;checked&quot;选中 checked=&quot;真值&quot; maxlength=“最大值” &lt;label for=&quot;sex&quot;&gt;男 &lt;/label&gt; label用于增加用户体验，点击范围内即可选中某input（一般一个label绑定一个input） &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; label中的for对应input里的id 或者把input标签放在label里面也能达到同样的效果，此时不需要for和id（隐式的联系） 其实还有 defaultCheck： defaultCheck 只在初次渲染时生效，更新数据时不受控制，但是允许后续你通过点击手动更改它的选定 checked 始终受到控制，必须通过绑定 onchange 事件来控制选中情况 总结defaultChecked、defaultValue 只在初始渲染时由状态控制，之后更新不再跟状态有关系，而checked、value在全过程中都受状态控制 开发中更多的是使用checked + onchange 组合 表单元素&lt;select&gt; 下拉列表&lt;select&gt; &lt;option value=&quot;1&quot;&gt;选项1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;选项2&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;选项3&lt;/option&gt; //默认选中选项3 ... &lt;select&gt;表单元素&lt;textarea&gt; 文本域textarea 可以写大量文字（个人介绍，评论） 输入的评论作为element.value &lt;textarea> 文字 &lt;/textarea> //如果没文字textarea必须写到同一行 按钮 buttontype属性：button的类型。可选值： submit: 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。 reset: 此按钮重置所有组件为初始值。 button: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。 menu: 此按钮打开一个由指定``元素进行定义的弹出菜单。 10 元素分类块元素，独占一行，是一个容器或者盒子如 &lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &lt;h1&gt; &lt;h2&gt;等 但&lt;p&gt; &lt;h&gt; 不能内置块级元素，只能放文字行元素，不能设置宽高，只能容纳文本或者其他行内元素 &lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;span&gt; 等 但是&lt;a&gt;不能再放&lt;a&gt; 特殊情况&lt;a&gt;可以转块级 &lt;b&gt;是粗文本行内块元素，能在同一行，也能设置宽高，但是行内块之间有缝隙 &lt;input/&gt; &lt;img/&gt; &lt;td&gt; &lt;button&gt;行内元素和块级元素的区别块级元素： 会独占一行,默认情况下,其宽度自动填满其父元素宽度 块级元素可以设置width,height属性. 块级元素即使设置了宽度,仍然是独占一行. 块级元素可以设置margin和padding属性. 块级元素对应于display:block. 行内元素 不会独占一行,相邻的行内元素会排列在同一行里,直到一行排不下,才会换行 行内元素设置width,height属性无效，它的长度高度主要根据内容决定. 行内元素的margin和padding属性,水平方向的padding-left,padding-right,margin-left,margin- right都产生边距效果,但竖直方向的padding-top,padding-bottom,margin-top,margin-bottom却不 会产生边距效果，即水平有效，垂直无效 行块的转换详情请看CSS里的《行块转换》 h5标签推荐网址： http://www.w3school.com.cn/ http://developer.mozilla.org/zh-CN/ 11.HTML5新特性新增标签i9以上版本浏览器才支持 &lt;header>: 头部标签 &lt;nav>: 导航标签 &lt;article>: 内容标签 &lt;section>: 定义文档某个区域 &lt;aside>: 侧边栏标签 &lt;footer>: 尾部标签 &lt;!-- 实质上都和div差不多，只是语义化了而已，主要针对搜索引擎 但是在i9中，需要把这些元素转换成块级元素，所以移动端更喜欢使用这些标签--> 新增&lt;audio&gt;，&lt;video&gt;新增&lt;audio&gt;音频，&lt;video&gt;视频，抛弃flash等插件功能 video尽量使用mp4格式，谷歌把音频，视频自动播放禁止了 &lt;video src=&quot;文件地址&quot; autoplay=&quot;autoplay&quot;自动播放 谷歌需要添加muted=&quot;muted&quot;（静音播放）,才能实现自动播放 controls=&quot;controls&quot;添加播放组件 loop=&quot;loop&quot;循环播放 poster=&quot;图片地址&quot; 视频封面显示图片 &gt;&lt;/video&gt; 遇到不兼容的情况可以写成 &lt;video width=&quot;320&quot; height=&quot;240&quot;&gt; &lt;source src=&quot;&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;&quot; type=&quot;video/ogg&quot;&gt; &lt;/video&gt;兼容问题同上 &lt;audio src=&quot;文件地址&quot;&gt;&lt;/audio&gt; 其功能性同video，如autoplay，loop，controls新增input的类型type=&quot;email&quot; type=&quot;url&quot; type=&quot;date&quot; type=&quot;number&quot; type=&quot;search&quot; type=&quot;tel&quot;(手机号码) 限制用户只能使用&quot;X&quot;类型 /*表单属性*/ &lt;input type=&quot;search&quot; required=&quot;required&quot; 填写字段不能为空 placeholder=&quot;XX&quot; 表单的提示信息 autofocus=&quot;autofocus&quot; 页面完成时自动聚焦到指定表单 autocomplete=&quot;on&quot; 打开历史记录功能，需要加上name属性，放在表单内，成功提交过，可以可选择&quot;off&quot; mutiple=&quot;multiple&quot; 选择多个文件上传 &gt;除此之外还有canvas、SVG、WebSocket，我分别在css高级、计网personnel的篇章中提及到，这里就不一一继续解释了。 12.网站的缩略图标一般使用favicon.ico作为图标，主要的浏览器都支持。 通过第三方网站将png图片转化成ico图标，如http://www.bitbug.net/ 转化成功后，在&lt;head&gt; &lt;/head&gt;之间引入代码： &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico type=&quot;XX&quot;&gt;(网页那里有代码直接copy) 在某网页的页面，在它的网址后输入”/favicon.ico” 可以直接获取它的ico 13.网站TDK三大标签优化SEOSEO是搜索引擎优化，目的为对网站深度优化，使得网站排名位于搜索引擎使用后较前的位置。 1.title网站名-网站介绍（不超过30字） 2.description简要概述网站内容 3.keywords页面关键字，搜索引擎的关注点 logo的SEO优化logo里首先放一个h1标签来提权，h1里再放一个链接，用于返回至首页，为了让搜索引擎收录我们，我们要在链接里放文字（网站名称），但是文字不要显示出来（文字大小设置为0，font-size: 0），最后给链接一个title属性 14.HTML5中的跨文档消息传递跨文档消息传送（cross-document messaging），有时候也简称为XDM，指的是来自不同域的页面间传递消息。 着是一个bom的api， MDN：window.postMessage。 XDM的核心是postMessage()方法，实际上我们可以使用postMessage()方法进行跨域 postMessage两个参数： data:作为postMessage()第一个参数传入的字符串数据。 origin:发送消息的文档所在的域，例如“https://www.w3cmm.com”。 // 跨域发送数据到目标源 window.onload = function () { document.getElementsByTagName(\"iframe\")[0].contentWindow.postMessage({name: 'wujiang'}, \"http://localhost:8090\") } // 监听目标源发送过来的数据 window.addEventListener('message', function (e) { if(event.origin==\"http://localhost:8080\"){//注意origin是发送消息的文档所在的域。 console.log('http://localhost:8090/a.ftl ===> http://localhost:8080/index.jsp') console.log(e) } }) 15.iframe标签iframe 元素会创建包含另外一个文档的内联框架 听说iframe标签能耗高？安全性差？还很low？我看面试有问到，（我还没用过）所以以下是选取网上我个人觉得比较有用的关于 iframe的知识点（不过我主要看的是局限 0.0 ，，毕竟还是少用为妙） 听说你长这样？ &lt;iframe src=\"demo.html\" height=\"300\" width=\"500\" name=\"demo\" scrolling=\"auto\" sandbox=\"allow-same-origin\">&lt;/iframe> &lt;iframe src=\"地址\" frameborder=\"0\">&lt;/iframe> 还可以仿造别人的页面（假装自己做的，手动狗头） 局限1、创建比一般的 DOM 元素慢了 1-2 个数量级 iframe 的创建比其它包括 scripts 和 css 的 DOM 元素的创建慢了 1-2 个数量级，使用 iframe 的页面一般不会包含太多 iframe，所以创建 DOM 节点所花费的时间不会占很大的比重。但带来一些其它的问题：onload 事件以及连接池（connection pool） 2、阻塞页面加载 及时触发 window 的 onload 事件是非常重要的。onload 事件触发使浏览器的 “忙” 指示器停止，告诉用户当前网页已经加载完毕。当 onload 事件加载延迟后，它给用户的感觉就是这个网页非常慢。 window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 SRC 可以避免这种阻塞情况 3、唯一的连接池 浏览器只能开少量的连接到 web 服务器。比较老的浏览器，包含 Internet Explorer 6 &amp; 7 和 Firefox 2，只能对一个域名（hostname）同时打开两个连接。这个数量的限制在新版本的浏览器中有所提高。Safari 3+ 和 Opera 9+ 可同时对一个域名打开 4 个连接，Chrome 1+, IE 8 以及 Firefox 3 可以同时打开 6 个 绝大部分浏览器，主页面和其中的 iframe 是共享这些连接的。这意味着 iframe 在加载资源时可能用光了所有的可用连接，从而阻塞了主页面资源的加载。如果 iframe 中的内容比主页面的内容更重要，这当然是很好的。但通常情况下，iframe 里的内容是没有主页面的内容重要的。这时 iframe 中用光了可用的连接就是不值得的了。一种解决办法是，在主页面上重要的元素加载完毕后，再动态设置 iframe 的 SRC。 4、不利于 SEO 搜索引擎的检索程序无法解读 iframe。另外，iframe 本身不是动态语言，样式和脚本都需要额外导入。 综上，iframe 应谨慎使用。","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"主题与2d人物","slug":"主题与2d人物","date":"2020-05-03T16:50:47.307Z","updated":"2020-05-05T17:03:19.452Z","comments":true,"path":"2020/05/04/zhu-ti-yu-2d-ren-wu/","link":"","permalink":"https://taylor12138.github.io/2020/05/04/zhu-ti-yu-2d-ren-wu/","excerpt":"","text":"Start人物使用命令安装npm：npm uninstall hexo-helper-live2d npm install –save hexo-helper-live2d此时在blog/node_modeles下多出了一个“live2d-widget”下载动画model：这里是套用别人（大佬）的仓库https://github.com/xiazeyu/live2d-widget-models.git下载好后将packages里的所有文件拷贝到blog/node_modeles最后在win使用padnote _config.yml，把以下：live2d: enable: true pluginModelPath: assets/ model: use: live2d-widget-model-epsilon2_1 #模板目录，在node_modules里 display: position: right width: 150 height: 300 mobile: show: false #是否在手机进行显示 复制进去 再使用hexo clean g d进行部署 主题下载好了之后放入blog/themes里面（整个文件）再在win使用padnote _config.yml把theme: xx改成theme: (你要的主题名)最后部署","categories":[],"tags":[],"author":"Hello"},{"title":"Hexo的部分问题","slug":"Hexo的部分问题","date":"2020-05-02T17:33:53.947Z","updated":"2021-08-22T13:00:16.976Z","comments":true,"path":"2020/05/03/hexo-de-bu-fen-wen-ti/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/hexo-de-bu-fen-wen-ti/","excerpt":"","text":"Quick Start打开win+R进入cmd，然后在正确目录下进入：cd source_post(指定blog下) 基本操作用typora修改完毕后，1.使用“hexo clean”进行清理（1.5.若是发生主题等修改后，要接上hexo g 来建立）2.接上“hexo s”即可进入网站查看（退出键位：control+C，y）（本地浏览）3.再次部署到远端：hexo d 关于主题1.可以使用git clone 网址.git themes\\新建目录名（或者使用码云gitee进行下载，然后复制到themes目录下）2.cd.. (回到blog目录下)notepad _config.yml把记事本里面的theme：xx修改成theme：主题目录名3.重新执行”基本操作” 关于图片再_post目录下安装 (必须得是这个) npm i https://github.com/CodeFalling/hexo-asset-image 然后再_post下新建和md文件同名的文件夹，放入图片，再md中引入即可 如果还是出现上传后没有图片，可能是因为图片命为 ‘ httpxxx ‘、甚至是文件名为http也是不能被允许的，这种格式也是不能被允许的！！（因此我不得不把文章名改为超文本传输协议。。。） 参考文献 https://hexo.io/docs/one-command-deployment.html)","categories":[],"tags":[],"author":"Hello"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"算法","slug":"算法","permalink":"https://taylor12138.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"网络","slug":"网络","permalink":"https://taylor12138.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"},{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"},{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[]}