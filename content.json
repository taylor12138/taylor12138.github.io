{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://taylor12138.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-05-03T17:20:07.000Z","updated":"2020-05-04T06:33:11.259Z","comments":true,"path":"categories/index.html","permalink":"https://taylor12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-05-04T06:35:25.450Z","comments":true,"path":"about/index.html","permalink":"https://taylor12138.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-05-03T17:21:52.000Z","updated":"2020-05-04T06:33:52.664Z","comments":true,"path":"contact/index.html","permalink":"https://taylor12138.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-05-03T17:22:42.000Z","updated":"2020-05-04T06:34:25.403Z","comments":true,"path":"friends/index.html","permalink":"https://taylor12138.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-03T17:17:32.000Z","updated":"2020-05-04T06:33:28.454Z","comments":true,"path":"tags/index.html","permalink":"https://taylor12138.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"matlab期末知识点汇总","slug":"matlab期末知识点汇总","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-06T09:30:41.436Z","comments":true,"path":"2020/08/06/matlab-qi-mo-zhi-shi-dian-hui-zong/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/matlab-qi-mo-zhi-shi-dian-hui-zong/","excerpt":"","text":"regress命令 用于一元及多元线性回归 B = regress(Y,X)[B,BINT] = regress(Y,X)[B,BINT,R] = regress(Y,X)[B,BINT,R,RINT] = regress(Y,X)B,BINT,R,RINT,STATS] = regress(Y,X)[…] = regress(Y,X,ALPHA) B：回归系数，类似于斜率，是个向量（“the vector B of regression coefficients in the linear model Y = X*B”）。BINT：回归系数的区间估计（“a matrix BINT of 95% confidence intervals for B”）。R：残差（ “a vector R of residuals”）。RINT：置信区间（“a matrix RINT of intervals that can be used to diagnose outliers”）。STATS：用于检验回归模型的统计量。有4个数值：判定系数R^2，接近1，回归方程越显著，F统计量观测值，F越大，回归方程越显著，检验的p的值，误差方差的估计。ALPHA：显著性水平（缺少时为默认值0.05）。 %导入数据 y=[7613.51 7850.91 8381.86 9142.81 10813.6 8631.43 8124.94 9429.79 10230.81 ... 10163.61 9737.56 8561.06 7781.82 7110.97]&#39;; x1=[7666 7704 8148 8571 8679 7704 6471 5870 5289 3815 3335 2927 2758 2591]&#39;; x2=[16.22 16.85 17.93 17.28 17.23 17 19 18.22 16.3 13.37 11.62 10.36 9.83 9.25]&#39;; X=[ones(size(y)) x1.^2 x2.^2 x1 x2 x1.*x2]; % size（）：获取矩阵的行数和列数 % s=size(A), 当只有一个输出参数时，返回一个行向量，该行向量的第一个元素时矩阵的行数，第二个元素是矩阵的列数。 % ones(M,N)产生一个M*N的矩阵 %开始分析 [b,bint,r,rint,stats] = regress(y,X);创建残差的置信区间图用regress返回的值r，rint：rcoplot（r，rint） 线性回归模型类线性回归模型类 wlb=LinearModel; %创建线性回归类对象，对象名wlb wlb=LinearModel.fit(x,y); %创建线性回归类对象，并对观测 数据做多元线性回归 wlb.plot %绘制wlb的效果图 wlb.anova %给出方差分析表 [y,ly]=wlb.predict(x) %给出x预测和置信区间 wlb.plotResiduals %绘制残差图 wlb. plotDiagnoisetics(method) %绘制不同统计量的残差图分 析 properties(wlb) %显示所有统计量属性t值和显著性水平有什么样的对应关系t-检验：可以用于比较两组数据是否来自同一分布。（可以用于比较两组数据的区分度） 在统计检验中，统计量t值和显著性水平具有什么样的对应关系？一般来说，大样本和正态分布情况下的数据，当1.65&lt;|t|&lt;1.96时,p&lt;0.10;当1.96&lt;|t|&lt;2.58时，p&lt;0.05；|t|大于2.58时，p&lt;0.01。 但是要注意的是，当样本量很小（小于30），数据分布形态不明或明显不服从正态分布（一座山一样的分布）时，t值和显著性水平不一定完全对应，例如t值绝对值大于2时，p值有可能大于0.05，也就是不显著。这种情况一般要采用非参数检验的方法，而不是t检验。 1、t值，指的是T检验，主要用于样本含量较小（例如n&lt;30），总体标准差σ未知的正态分布资料。T检验是用t分布理论来推论差异发生的概率，从而比较两个平均数的差异是否显著。 2、P值，就是当原假设为真时，所得到的样本观察结果或更极端结果出现的概率。如果P值很小，说明原假设情况的发生的概率很小，而如果出现了，根据小概率原理，我们就有理由拒绝原假设，P值越小，我们拒绝原假设的理由越充分。 p值代表的是不接受原假设的最小的显著性水平，可以与选定的显著性水平直接比较。例如取5%的显著性水平，如果P值大于5%，就接受原假设，否则不接受原假设。这样不用计算t值，不用查表。 3、P值能直接跟显著性水平比较；而t值想要跟显著性水平比较，就得换算成P值，或者将显著性水平换算成t值。在相同自由度下，查t表所得t统计量值越大，其尾端概率P越小，两者是此消彼长的关系，但不是直线型负相关 怎么得到检验回归系数显著性的T值对于X、Y两个正态总体的样本，其t检验应使用ttest2()函数来检验假设。[H,P,CI]=ttest2(X,Y) ttest2（）函数是用来检验具有相同方差的两个正态总体均值差的假设检验（即两正态总体的检验法）。 基本调用格式： h=ttest2（x，y）判断来自不同正态总体的样本数据x与y是否有相同的均值。当h=0表示接受原假设，当h=1表示拒绝原假设。 h=ttest2（x，y，alpha）调用格式表示执行显著性水平为（100*alpha）%的假设检验。没有给出alpha值，默认alpha=0.05。 h=ttest2（x，y，alpha，tail）调用格式表示执行以tail指定的备择假设作假设检验，原假设为均值等于m，当tail=‘both’时表明备择假设为“x与y均值不相等”，当tail=‘right’时表明备择假设为“x的均值大于y的均值”，当tail=‘left’时表明备择假设为“x的均值小于y的均值”。regstats函数（回归系数显著性检测？）MATLAB统计工具箱中提供了regstats函数，也可用来作多重线性或广义线性回归分析，它的调用方式如下：regstats(y,X,model)stats = regstats(…)stats = regstats(y,X,model,whichstats) 非线性用nlinfit函数或者开启cftool工具箱 eye函数该函数返回单位矩阵。 Y = eye(n)：返回n*n单位矩阵； Y = eye(m,n)：返回m*n单位矩阵；","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"模拟退火算法","slug":"模拟退火算法","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-07T03:16:44.061Z","comments":true,"path":"2020/08/06/mo-ni-tui-huo-suan-fa/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/mo-ni-tui-huo-suan-fa/","excerpt":"","text":"1.模拟退火算法可能的情况很多，数据量太大，用模拟退火搜索出需要的解（求最值）（最大值问题可以添加负号转换成求最小值问题） 启发式搜索：利用搜索过程中获取的信息改进搜索策略。启发式搜索有利于找到问题最优解，且有助于加速求解过程。 模拟退火可以说是最简单（应用）的启发式搜索之一 相比起爬山法（找到局部最优解），模拟退火算法有一定概率能接受比当前还要差的解，概率p位于[0,1]，旧解和新解的函数值越接近，p值就越大（概率为0对应爬山法，概率为1对应蒙特卡洛算法）；时间越长，p值越小；搜索前期p大，后期p小 2.搜索过程1.随机生成一个解A，计算F(A) 2.在A附近随机生成一个解B，计算F(B) 3.对比F(A)和F(B)，进行对比，若F(B)&gt;F(A)（求最大值）,B赋值A，F(B)&lt;F(A)，计算接受B的概率，接受则B赋值A，且重复以上操作，否则返回第2步，在原来A附近再生成一个B继续下去 如果优化问题有约束条件： 1.生成B是查看是否符合要求 2.使用罚函数 与时间相关的系数Ct如何设置：Ct是温度t的倒数（模拟退火） 如何再A附近随机生成一个解B：没有统一规定，需要具体问题具体分析 停止搜索1.达到迭代次数 2.达到指定温度 3.找到连续最优解，M（如30次）次迭代还未改变 3.实现产生新解： 1.matlab内置工具 根据温度不同，新解距离旧解的步长改变，温度高步长高，温度低步长短，由全局缩短为 x_new=x_i+T×z_i 然后检查x_new是否位于上下界 2.旅行商问题 交换法，位移法，倒置法","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"数学建模国赛matlab知识点","slug":"数学建模国赛matlab知识点","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-22T07:55:04.587Z","comments":true,"path":"2020/08/06/shu-xue-jian-mo-guo-sai-matlab-zhi-shi-dian/","link":"","permalink":"https://taylor12138.github.io/2020/08/06/shu-xue-jian-mo-guo-sai-matlab-zhi-shi-dian/","excerpt":"","text":"1.基础命令行太长，可加上三个小数点：“…” 进行分割（续行符），如 s=1-1/2+1/3-1/4... +1/5-1/6+1/7数值数据默认双精度double clear命令，清除工作区的所有变量 class(变量)得到变量类型 复型数据，虚数部分用i或j表示，如6+5i ，real函数求复数实部，imag函数求复数的虚部 以角度为单位的函数，在函数名后加“d”，如sin(pi/2)=sind(90) abs(xx)可求实数绝对值，复数的模，字符串的ascii码 rem(m,10)求m/10的余数 isprime(n)求n是否为素数，是返回1，否返回0 exp(pi/2)为e的2/Π次方 整形转换x=int8(129) //转有符号的int，最大127，即这里x=127 x=uint(129) //转无符号uint，即x=129 取整函数round()函数按照四舍五入 ceil()向上取整 floor()向下取整 fix()取靠近0的整数矩阵的建立//no.1 A=[1,2,3;4,5,6;7,8,9] //第一行1，2，3，第二行4，5，6冒号表达式e1:e2:e3 //分别为初始值，步长（两两之间间隔的大小，如果省略步长，则步长为1），终止值 inspace(a,b,n)//分别对应第一个元素，最后一个元素，元素总数（省略时为100）结构矩阵&amp;单位矩阵//结构矩阵 结构矩阵元素.成员名=表达式 a(1).x1=10; a(1).x2=&#39;liu&#39;; a(1).x3=[11,21;34,78]; //单元矩阵，用大括号 b={10,&#39;liu&#39;,[11,21;34,78]}2.矩阵引用矩阵元素A(3,2)表示A矩阵第三行，第二列元素 可用序号引用，如在A=[1,2,3;4,5,6;7,8,9]中，A(3)=7 (矩阵元素按列储存) D=sub2ind(S,I,J),分别为行数和列数组成的向量，转换矩阵元素的行下标，转换矩阵元素的列下标，D为序号（下标转序号） size(A)求矩阵A的行列数 [I,J]=ind2sub(S,D),分别为行数和列数组成的向量，序号（序号转下标） k=find(ch&gt;=&#39;a&#39;&amp;ch&lt;&#39;z&#39;) 找到符合条件的元素的序号 利用冒号获得子矩阵A(i,:) 第i行的所有元素 A(:,j) 第j列的所有元素 A(i:i+m,k:k+m) 第i~i+m行且在第k~k+m行的所有元素end运算符：表示某一维末尾下标 如：A(end,:)，是指A矩阵最后一行所有元素 利用空矩阵删除矩阵的元素将想要的元素范围赋值空矩阵[]即可，如A(:,[2,4])=[]，删除第二列，第四列元素 改变矩阵形状reshape(A,m,n)：在矩阵综援素不变的情况下，将A重新排列成m×n的二维矩阵 注意：并不改变元素个数及其储存顺序 A(:)：将矩阵A每一列元素堆叠起来成为一个列向量 3.算术运算&amp;字符串须知：加减运算两矩阵必须同型，乘法运算要求A行数和B的列数相同 点运算：两矩阵进行点运算是指它们对应元素进行运算，要求两矩阵同型 逻辑运算符：&amp;，|，~ 字符串和数值之间的转换：数值（ASCII码）=abs(字符串) 字符串=char(ASCII码) strncmp(s1,s2)：用于比较字符串s1，s2是否相等 strncmp(s1,s2,n)：用于比较字符串s1，s2前n个字符是否相等 strcmpi(s1,s2)：忽略大小写 4.特殊矩阵zeros函数：产生全零矩阵 ones函数：产生全1矩阵 eye函数：产生对角线为1的函数 rand函数：产生（0,1）区间均匀分布的随机矩阵 randn函数：产生均值为0，方差为1的标准正态分布随机矩阵 inv(矩阵)：求其逆矩阵 zeros(m):产生m×m零矩阵 zeros(m,n):产生m×n零矩阵特殊矩阵介绍： 魔方矩阵M=magic(8) (8行8列) 范德蒙矩阵vander(1:5) 希尔伯特矩阵：H=hilb(4) 伴随矩阵：A=compan(P) 帕斯卡矩阵：P=pascal(5) 对角阵对角矩阵：对角线上元素非零 数量矩阵：对角线上元素相等 对角矩阵：对角线上元素为1 diag(A)：提取矩阵A对角线元素，产生一个列向量 diag(A,k)：提取矩阵A第k条对角线元素，产生一个列向量 构造对角矩阵：diag(V)：以向量V为主对角线元素，产生对角矩阵 三角阵triu(A)：提取矩阵A的主对角线及以上的元素 tril(A)：提取矩阵A的主对角线及以下的元素 triu(A,k)：提取矩阵A的第k条主对角线及以上的元素 矩阵的转置A=[1,3;3+4i,1-2i] 转置：A.’ 共轭转置：A’ 若矩阵为实数，转置和共轭转置是一样的 矩阵旋转：rot90(A,k)，将矩阵A逆时针旋转90°的k倍，k为1可省略 矩阵左右翻转：fliplr(A) 矩阵上下翻转：flipud(A) 矩阵其他功能把一个方阵看作一行列式，并对其按行列式的规则求值：det(A) 求矩阵的秩：rank(A) 求矩阵的迹，即对角线元素之和：trace(A) 求矩阵A全部特征值，构成向量E：E=eig(A) 或者 [X,D]=eig(A) A的全部特征值构成对角阵D，X的各列是对应的特征向量 5.subplot画图subplot（m,n,p）或者subplot（mnp）此函数最常用：subplot是将多个图画到一个平面上的工具。其中，m表示是图排成m行，n表示图排成n列，也就是整个figure中有n个图是排成一行的，一共m行，如果第一个数字是2就是表示2行图。p是指你现在要把曲线画到figure中哪个图上，最后一个如果是1表示是从左到右第一个位置。 ） 6.MatLab中关于程序的操作建立函数，新建脚本，开头为： function C = 函数名( 参数A,参数B)，并且通过C返回（当有多个形参时，可用逗号分隔，而C为输出形参表，多个输出形参需要用方括号[] 括起来） 数据的输入：A=input(‘请输入A的值：’); 数据的输出：disp(输出项) 程序暂停：pause(延迟数秒),如果省略参数，则一直暂停，除非用户按任意键就可以继续执行 x^(1/3)=power(x,1/3) matlab中的switch case相对于C，java不需要break，且最后一个的default改成otherwise 匿名函数：简化了函数的过程：如f=@(x,y)x^2+y^2，f(3,4)进行调用，但是不适用于复杂函数 7.Plot函数plot(x,y)，x，y分别存储x，y坐标的数据 最简单的plot调用格式：plot(x)，下标为横坐标，值为纵坐标 x,y为同型矩阵，则分别对应x，y坐标绘画出曲线图 多条曲线可以plot(x1,y1,x2,y2,x3,y3……) x=linspace(0,2*pi,100) ,位置0到2pi的100个元素存于x plot（x,y,选项）选项有线性，颜色，数据点标记 线型：“ - ” 实线, “ : ”虚线, “ -. ”点画线, “ – ” 双画线 颜色：“ r ”红，“ g ”绿，“ b ”蓝。。。。。。 数据点标记：“ * ”星号，“ o ”圆圈，” s “方块。。。。 8.fplot函数fplot（f,lim,选项），f是函数，lim是x的取值范围，用二元向量[xmin,xmax]表示，默认[-5,5]，选项和plot相同 自变量无法间隔采样时使用fplot（函数变化趋势未知，或者在不同区间函数变化频率过大，如sin（x/1）） 9.曲线拟合polyfit（）进行拟合，找一个函数去逼近数据，再根据找到的函数预测下一个点的值（如 人口预测问题）（它实际上是求得最小二乘法拟合的多项式系数） p=ployfit（x,y,3）生成三次多项式函数，调用ployval（p,2020）进行计算（求2020年的人口）","categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"}],"tags":[],"author":"Hello"},{"title":"JavaSript","slug":"JavaSript","date":"2020-07-21T14:14:19.766Z","updated":"2020-07-27T16:41:42.129Z","comments":true,"path":"2020/07/21/javasript/","link":"","permalink":"https://taylor12138.github.io/2020/07/21/javasript/","excerpt":"","text":"1.JS的介绍JS是脚本语言，不需要编译，直接由js解释器逐行进行解释并执行，现在也可以基于node.js技术（后台）进行服务器编程 实现业务逻辑和页面控制功能，浏览器的JS引擎，也就是JS解释器，用来读取JS代码 JS的组成JavaScript语法：ECMAScript 页面文档对象模型：DOM 浏览器对象模型：BOM ECMAScript它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和拓展 DOM它是标准编程接口，通过DOM提供的接口可以对页面上各种元素进行操作（大小位置颜色） BOM它提供了独立于内容，可以与浏览器窗口进行互动的对象，操作浏览器窗口比如弹出窗，控制浏览器跳转，获取分辨率等 JS的三种书写 类似于CSS，有行内式，内嵌式&lt;script&gt;xxxx&lt;/script&gt; 还有从外部引入：(script标签中间别写代码) &lt;script src=\"xx.js\">&lt;/script> 2.JS基本功能介绍输入输出alert(msg); //弹出警示框 console.log(msg) //打印输出信息，是控制台输出，给程序猿测试用的 prompt(info) //弹出输入框，提供用户输入 但是都是以字符的形式输入定义使用var，自动确定类型（JS拥有动态类型） 功能isNaN() 判断是否非数字 typeof 变量名 查看数据类型 转换转字符串： 变量名.toString() 强制转换：String(变量名) 隐式转换：变量名+”xxxx”(拼接字符串) String转数字类型：（1）String-&gt;int： parseInt(String)； （2） String-&gt;float: parseInt(String)； ​ （3）Number强制转换（String转数值）：Number(String) （4）利用加减乘除：String-String或String-int之类的 运算符18==‘18’ 成立true，默认转换数据类型 ===为全等需要完全一致， 18===‘18’为false 逻辑与短路运算：123&amp;&amp;456，返回456，左式为真返回右式子，为假返回左式 逻辑或短路运算：123||456，返回123，左式为真返回左式子，为假返回右式 三元表达式：条件表达式？表达式1：表达式2，条件为真返回表达式1，为假返回表达式2 数组数组名.length为数组的长度 数组增加元素 （1）直接设定数组长度arr.length=xx,多出来的变成空 （2）arr数组有三个元素，直接arr[3]=xx，进行新增元素 3.函数//1.利用函数关键字自定义函数 function 函数名(参数) { 函数体 } //如下： function sort(arr){ } //2.匿名函数 var fun=function(){ } //调用 fun(); 函数没有return，则返回的是undefined 注意在函数内部没有声明直接赋值的变量，也属于全局变量 arguments的使用当我们不确定函数用多少个参数来传递的时候，arguments实际上是当前函数的一个内置对象（函数才拥有），arguments储存了传递的所有实参,它展示的方式是伪数组，因此可以进行遍历（使用for等） function fn(){ console.log(agruments); console.log(agruments.length); } fn(1,2,3); //则输出1，2，3 伪数组：1.具有length属性 2.按索引凡是储存数据 3.不具有push，pop功能 预解析js引擎运行js，分为两步：1.预解析 2.代码执行 预解析：js会把里面所有var还有function提升到当前作用域的最前面（分别为变量提升和函数提升） 变量提升：把所有变量声明提升至当前作用于最前，但是不提升赋值操作 4.对象对象一定是一个具体的对象，而不是泛指的东西 属性：事物的特征，用对象的属性表示 方法：事物的行为，在对象中方法来表示 //利用对象字面量创建对象， var obj ={ uname:'xx', age:18, sex:'man', say:function(){ console.log('good'); } } //调用对象属性(2种) obj.uname obj['uname'] (1)键 属性名: 值 属性值 (2)用逗号隔开 (3)方法冒号后面跟的一个匿名函数 //利用new Object创建对象 var obj = new Object obj.uname=&#39;xx&#39;; obj.age=18; obj.say=funciton(){}（1）利用等号赋值添加对象的属性和方法 （2）每个属性和方法用分号 //利用构造函数创建对象，即用函数来创建对象","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"CSS高级","slug":"CSS高级","date":"2020-05-30T16:00:00.000Z","updated":"2020-07-21T14:13:38.670Z","comments":true,"path":"2020/05/31/css-gao-ji/","link":"","permalink":"https://taylor12138.github.io/2020/05/31/css-gao-ji/","excerpt":"","text":"1.精灵图为了有效减少服务器接收和发射请求次数，提高速度出现的CSS技术。即将网页小背景图合成一张大图。 主要针对于背景图片（非产品类等更新换代图片） 主要使用background-position+x和y轴配合使用，x轴向右，y轴向下 background: url()no-repeat -182px 0; //分别对应x轴，y轴,基本都是负值缺点：文件大，放大缩小会失真，更换复杂 2.字体图标iconfont常用于一些小图标（样式简单），展示状态时图标，实际上是字体 优点1.轻量级，够小 2.灵活性，可改多种效果 3.几乎支持所有浏览器 下载：相应网站（如https://icomoon.io/）下载后得到压缩包，解压后，把下载包里的fonts放入页面根目录下 使用：在CSS中根据说明引用全局声明，然后再在个体css中再次引用你想要的声明，同时可以自己调色和字体大小（font-size） 这里以阿里的图标为例子，把项目添加好之后，根据操作https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.16&amp;helptype=code一步一步来（这里是unicode引用），注意：**复制代码的时候，一定要在url的值中补充 “http:”** 3.三角形若盒子设置宽高为0；此时又设置边框，则会形成组成一个正方形的4个三角形，实际上我们写三角形可以利用这个原理，把其他三个三角形隐藏起来则就只有一个三角形了 width: 0; height: 0; /*line-height: 0; font-size: 0; 有时需要添加，看浏览器*/ border: 50px solid tranparent; //先全部设置为透明 border-bottom-color: red; /*或者*/ border-color: transparent red transparent transparent //上右下左的颜色 4.用户界面鼠标样式 cursorcursor: defalut 默认无样式 cursor: pointer 小手 cursor: move 移动 cursor: text 文本 cursor: not-allowed 禁止 轮廓线给表单（input）添加 outline: 0;，点击表单时，会去掉默认的l蓝色光标 防止拖拽文本域textarea{ resize: none }可以使文本框没有拖拽选项 5.Vertical-aligncss常用vertical-align让图片和文字对齐（但是只能针对行内元素或者行内块元素） vertical-align: middle; 中线对齐（一般使用这个来对齐） 图片底侧放置于盒子内时，时常有一个空白缝隙，可以使用vertical-align: middle||top||bottom;将其解决 （其实还可以直接转成块元素，但是此方法不提倡） 6.文字溢出变省略号（推荐让后端写）单行文本：white-space: nowrap //强制一行内显示 ​ overflow: hidden; //溢出隐藏 ​ text-overflow: ellipsis ///变成省略号 多行文本：（有较大兼容性问题，适用于移动端或者webkit浏览器） ​ overflow: hidden; + text-overflow: ellipsis display: -webkit-box; //单行伸缩盒子 -webkit-line-clamp: 2; //限制其文本行数 -webkit-box-orient: vertical; //设置盒子的子元素排列方式，（垂直居中） 7.常见布局技巧可以使用margin的负值来消除浮动边框的重合（消除产生的巨大影子）如： margin-left: -Xpx; 想要移动到某个边框内自动变色可以使用hover，但是当排列方式为每个盒子的右边框被另外一个盒子的左边框压住时，变色效果会出bug，正确做法是：xx:hover{ position: relative; }添加相对定位使其马上覆盖当前所有单位 如果失败，有可能是因为当前已经添加了绝对定位了，此时只需要提高层级：z-index: 1; 8.CSS初始化为了照顾浏览器兼容，必须首先进行CSS初始化，即重新设定CSS个标签的初始默认值 9.CSS3新特性ie9+才支持 属性选择器可以不借助类选择器 input[att] {} 带有att属性值的被选中input[att=&quot;value&quot;] {} 带有att属性并且属性值等于value被选中 input[class^=icon]{} 选择类属性以icon开头的所有标签 input[class$=icon]{} 选择类属性以icon结尾的所有标签 input[class*=icon]{} 选择类属性含有icon的所有标签 类选择器，伪类选择器，属性选择器（这个一般是11，因为包含标签名+属性名=1+10=11）它们权重都为10 结构伪类选择器first和last等可以来了解一下，实际开发不太建议使用，也比较少使用。 值得注意的是 nth-child(n)比较重要 n可以是数字，可以是关键字（even偶数，odd奇数），甚至公式 ul li:nth-child(even){ } //选择所有的偶数孩子 ul li:nth-child(n){ } //选择所有孩子,因为n是公式类似n++，依次施加CSS效果 ul li:nth-child(2n){ } //选择所有的偶数孩子 ul li:nth-child(-n+5){ } //选择前5个孩子 nth-of-type和nth-child的不同： section div:nth-child(1){ } //先排序，再看是否符合div，如果是div就渲染 section div:nth-type(1){ } //先看是否符合div，如果是就在div里排序，选择第一个就渲染 伪元素选择器通过CSS创建新的子标签（比较简单的），从而简化html结构，（还与之前清除浮动使用的伪元素方法有关） element::before{ content：&#39;XX&#39;; //必须要有content属性，为内容 样式 } //在元素内部前面（左）插入内容 element::after{ content: &#39;XX&#39;; 样式 } //在元素内部后面（右）插入内容它和标签选择器一样，权重=1，且为行内元素，想要设置大小必须转行内块 （还可以有element:hover::before{}的操作） CSS3盒子模型只需增加如下代码 box-sizing: border-box; //只看盒子大小，不考虑border和padding因素即可不用考虑border和padding因素是否会将盒子本身撑大。 CSS3滤镜filter用于模糊图形效果，filter: 函数(); 如：filter:blur(5px); //模糊处理，数值越大越模糊 …… CSS3calc函数(计算函数)width: calc(100% - 80px); //宽度永远比父盒子宽度小30px CSS过渡（重点）一些变化的动画效果（时间缓滞），经常和 :hover 一起搭配 transition: 要过渡的属性 花费的时间（单位为s） 运动曲线（默认ease，可以省略） 何时开始（默认0s，可省略）; transition: width 0.5s,heigh 0.5s; //多个属性&quot;,&quot;分割，想要更多属性，直接属性值写all xx:hover{width:100px;heigh:100px;}transition: all 0.xs; 使用的比较多 10.CSS的morecss的2D转换transform可以理解为变形 移动：translate 旋转：rotate 缩放：scale 2d为二维坐标，x轴向右，y轴向下 translate类似于定位transform:translate(x,y); transform:translateX(n); transform:translateY(n); //单位是px，如果是百分号，则它的距离是盒子自身高宽对比出来的translate最大的优点：不会影响其他元素的位置，绝对定位会脱标，margin会影响，（有点像相对定位，但是更方便，可以加过渡效果） 可用于定位父盒子的中间位置 使用： position: absolute; top: 50%; left: 50%; transform:translate(-50%,-50%);但是它对行内标签没有效果 rotate旋转transform:rotate(度数deg); transform-origin:x y; //设置元素旋转依靠的中心点 x，y默认为50%，50%，设置x，y可以可是bottom，left等，如transform-origin:left bottom;为设置左下角为中心点 scale之缩放transform:scale(x,y);//里面的数字不跟单位，是倍数，x，y分别是宽，高 transform-origin:x y; //设置元素旋转依靠的中心点 若只有一个参数，则同比放大 使用scale的优点：变大时不会影响其他盒子的位置，且放大是以中心向外扩张的放大，直接修改width和heigh放大是直接往下放大 动画用keyframes定义动画 @keyframes 动画名称 { 0%{ width:100px.... } 100%{ width:200px.... } }//可以设置25%，75%等多个状态，习惯上把0%也写了 //以下也可以 @keyframes 动画名称 { form{ width:100px.... } to{ width:200px.... } } 0%动画的开始 100%动画的结束 1.可以做多个状态变化 keyframe关键帧 2.里面的数字为整数 3.百分比为时间的划分 使用动画： div { animation-name:动画名称; animation-duration:持续时间; animation-iteration-count:播放次数，可以为infinite; animation-direction:xx; //默认normal，alternate为设置逆向播放 animation-fill-mode:xx; //默认backwards，动画结束后返回原来位置，forwards可取消该功能 animation-play-state:xx; //running/paused 是动画运行或者暂停 animation-timing-fuction: ease; //默认ease加速度，linear匀速，step分步。。。 }使用多个动画用“，”分隔，如animation: bear 0.7s steps(8) infinite, move 0.7s …… 3D转换x轴向右，y轴向下，z轴向外，最常用的是3d位移和3d旋转,以下许多功能与2d十分相似 3d移动transform: translate3d(x,y,z); transform:translateZ(n); //translateZ一般采用px，3d的z轴显现出来需要透视功能 透视透视我们也成为视距，即眼睛到屏幕的距离，透视的单位是像素，透视越小，盒子越大 透视写在被观察元素的父盒子上 perspective: xxpx;3d旋转一般加上透视效果会比较明显，3d旋转方向遵循左手定则： 左手大拇指指向x轴正方向，手指弯曲的方向则为旋转的方向 transform: rotateX(度数); //沿着X轴旋转 transform: rotateY(度数); transform: rotateZ(度数); //z轴旋转和2d普通rotate有点像 transform: rotate3d(x,y,z,度数); //自定义轴旋转自定义旋转只对x轴选取为transform: rotate3d(1,0,0,度数); 对角线旋转为transform: rotate3d(1,1,0,度数) transform要看情况选择：先写旋转rotate再写移动translate或者相反情况 3d呈现transform-style控制子元素是否开启三维立体环境，代码要写给父级（一定是父级，不能爷爷级别，亲测过），此属性很重要 transform-style: preserve-3d //此为开启立体空间，但是默认值为flat，不开启立体空间","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"CSS定位&显示","slug":"CSS定位&显示","date":"2020-05-27T16:00:00.000Z","updated":"2020-07-20T15:38:02.268Z","comments":true,"path":"2020/05/28/css-ding-wei-xian-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/28/css-ding-wei-xian-shi/","excerpt":"","text":"CSS定位1.某个元素可以在盒子内移动位置，并且压住其他盒子。 2.滚动窗口时，盒子固定于屏幕某个位置。 定位=定位模式+边偏移量 定位选择器{ position: static; position: relative; position: absolute; position: fixed; position: sticky; top: 100px; //必备的指定位置，可以为left，right，bottom } position: static; //默认，无定位,标准流特性 position: relative; //相对定位，参照点是自己，移动位置后，原来的位置继续占有 position: absolute; //绝对定位，是相对于他的祖先元素。 1.没有祖先元素或者，祖先元素没有使用定位，则以浏览器为准直接偏移 2.如果祖先元素有定位（相对，绝对，固定），则以最近一级定位的祖先元素为参考点 3.绝对定位不再占有原来的位置（脱标） 4.加了绝对定位的盒子不能通过 margin: 0 auto; 来居中，让它居中的原理和fixed设置版心的原理差不多，都是left：50%+margin组合 position: fixed; //固定于浏览器可视区位置，不占有原先位置 1.还可以设置于版心附近，方法：让那个固定定位的盒子 left: 50%,然后让固定定位的盒子margin-left：版心的一半距离 position: sticky; //粘性定位，被认为相对定位和固定定位的混合体 1.以浏览器可视窗口为参照移动的元素（固定特点） 2.粘性定位占有原先的位置 3.必须添加top，left等，不然相当于相对定位 缺点：ie不支持 (子绝父相—–出自pink老师) -&gt;&gt;&gt;&gt;&gt;&gt;&gt; —–&gt; 子级使用绝对定位，父亲则需要使用相对定位 位置如果一个定位既设置了left，也设置了right，它默认会执行left。若及设置了top，也设置了bottom，会默认执行top（无关权重的事情） 定位叠放次序通过控制z-index来控制盒子的前后次序（叠放次序） z-index： 1; 1.数值越大盒子越靠上，2.如果值相同，按照书写顺序，后来居上 3.数字不能加单位 4.只有定位盒子才有z-index属性 定位的特殊性质1.行内元素添加绝对或固定定位，可以直接设置高度和宽度 2.块级元素添加绝对或固定定位，未设置宽高，会脱标，默认内容大小（类似浮动）（不会发生外边距合并） 3.和浮动不同，绝对或固定定位会压住你标准流文字等内容 元素的显示和隐藏1.（用的更多） display: none; 隐藏对象（不再占有原来的位置，可以用于js的下拉菜单等功能） display: block; 显示对象（也可以是转换块元素） 2. visibility: visible; 元素可视 visibility: hidden; 元素隐藏（仍然占有原来位置） 3. overflow: visible; 超出你的标签部分（固定大小）可见 overflow: hidden; 超出你的标签部分（固定大小）隐藏，如果有定位的盒子慎用，他会切掉你溢出布局标签的部分 overflow: scroll; 可添加滚动条 overflow: auto; 需要的时候添加滚动条","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"基数排序","slug":"基数排序","date":"2020-05-17T12:55:49.418Z","updated":"2020-05-18T13:03:45.898Z","comments":true,"path":"2020/05/17/ji-shu-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/ji-shu-pai-xu/","excerpt":"","text":"基数排序使用的大致思路是：根据关键字进行分类，再次排序，在分类，在排序，以此类推直至完成结果 如扑克牌中根据分13类，排序，再根据花色分类，再排序； 对百位数排序，先根据个位分类，排，再根据十位分类，排，再根据百位分类，排 //算法8.12 基数排序 #include &lt;iostream&gt; using namespace std; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #define MAXNUM_KEY 8 //关键字项数的最大值 #define RADIX 10 //关键字基数，此时是十进制整数的基数 #define MAX_SPACE 10000 typedef char KeysType; //定义关键字类型为字符型 typedef int InfoType; //定义其它数据项的类型 typedef struct { KeysType keys[MAXNUM_KEY]; //关键字 InfoType otheritems; //其他数据项 int next; }SLCell; //静态链表的结点类型 typedef struct { SLCell r[MAX_SPACE]; //静态链表的可利用空间，r[0]为头结点 int keynum; //记录的当前关键字个数 int recnum; //静态链表的当前长度 }SLList; //静态链表类型 typedef int ArrType[RADIX]; //指针数组类型 void InitList(SLList *L) { //初始化静态链表L（把数组D中的数据存于L中） char c[MAXNUM_KEY],c1[MAXNUM_KEY]; int i,j,n,max; //max为关键字的最大值 max=-10000; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAX_SPACE&lt;&lt;&quot;个。\\n&quot;; cin&gt;&gt;n; while(n&gt;MAX_SPACE) { cout&lt;&lt;&quot;您输入的个数超过上限，请重新输入，不超过&quot;&lt;&lt;MAX_SPACE&lt;&lt;&quot;个。\\n&quot;; cin&gt;&gt;n; } int *D=new int[n]; cout&lt;&lt;&quot;请输入&quot;&lt;&lt;n&lt;&lt;&quot;个排排序的数据：\\n&quot;; for(i=0;i&lt;n;i++) { cin&gt;&gt;D[i]; if(max&lt;D[i]) max=D[i]; } (*L).keynum=(int)(ceil(log10(max))); //存放十进制的位数 (*L).recnum=n; for(i=1;i&lt;=n;i++) { itoa(D[i-1],c,10); //将10进制整型转化为字符型,存入c for(j=strlen(c);j&lt;(*L).keynum;j++) //若c的长度&lt;max的位数,在c前补&#39;0&#39; { strcpy(c1,&quot;0&quot;); strcat(c1,c); strcpy(c,c1); } for(j=0;j&lt;(*L).keynum;j++) (*L).r[i].keys[j]=c[(*L).keynum-1-j]; } } int ord(char c) { //返回k的映射(个位整数) return c-&#39;0&#39;; } void Distribute(SLCell *r,int i,ArrType &amp;f,ArrType &amp;e) { //静态链表L的r域中记录已按（keys[0], …, keys[i-1]）有序 //本算法按第i个关键字keys[i]建立RADIX个子表，使同一子表中记录的keys[i]相同。 //f[0..RADIX-1]和e[0..RADIX-1]分别指向各子表中第一个和最后一个记录（很重要！！！！） int j,p; for(j=0;j&lt;RADIX;++j) f[j]=0; //各子表初始化为空表 for(p=r[0].next;p;p=r[p].next) { j=ord(r[p].keys[i]); //ord将记录中第i个关键字映射到[0..RADIX-1] if(!f[j]) f[j]=p; //f[j]为空，则直接赋值 else r[e[j]].next=p; //若不为空，则将其排在之前已有被赋值相同映射关键字的r的next的next里 e[j]=p; //将p所指的结点插入第j个子表中 }//for }//Distribute int succ(int i) { //求后继函数 return ++i; } void Collect (SLCell *r,int i,ArrType &amp;f,ArrType &amp;e) { //本算法按keys[i]自小至大地将f[0..RADIX-1]所指各子表依次链接成一个链表 //e[0..RADIX-1]为各子表的尾指针 int j,t; for(j=0;!f[j];j=succ(j)); //找第一个非空子表，succ为求后继函数 r[0].next=f[j];t=e[j]; //r[0].next指向第一个非空子表中第一个结点 while(j&lt;RADIX-1) { for(j=succ(j);j&lt;RADIX-1&amp;&amp;!f[j];j=succ(j)) ; //找下一个非空子表 if(f[j]) {r[t].next=f[j];t=e[j];} //链接两个非空子表 }//while r[t].next=0; //t指向最后一个非空子表中的最后一个结点 }//Collect void RadixSort(SLList &amp;L) { //L是采用静态链表表示的顺序表 //对L做基数排序，使得L成为按关键字自小到大的有序静态链表，L.r[0]为头结点 int i; ArrType f,e; for(i=0;i&lt;L.recnum;++i) L.r[i].next=i+1; //next指向i+1，即下一个记录 L.r[L.recnum].next = 0; //将L改造为静态链表 最尾部的next为0 for(i=0;i&lt;L.keynum;++i) { //按最低位优先依次对各关键字进行分配和收集 Distribute(L.r,i,f,e); //第i趟分配 Collect(L.r,i,f,e); //第i趟收集 }//for } // RadixSort void print(SLList L) { //按数组序号输出静态链表 int i,j; for(i=1;i&lt;=L.recnum;i++) { for(j=L.keynum-1;j&gt;=0;j--) cout&lt;&lt;L.r[i].keys[j]; cout&lt;&lt;endl; } } void Sort(SLList L,int adr[]) { //求得adr[1..L.length]，adr[i]为静态链表L的第i个最小记录的序号 int i=1,p=L.r[0].next; while(p) { adr[i++]=p; p=L.r[p].next; } } void Rearrange(SLList *L,int adr[]) { //adr给出静态链表L的有序次序，即L.r[adr[i]]是第i小的记录。 //本算法按adr重排L.r，使其有序。算法10.18(L的类型有变) int i,j,k; for(i=1;i&lt;=(*L).recnum;i++){ if(adr[i]!=i) { j=i; (*L).r[0]=(*L).r[i]; //r[0]用于暂存记录(*L).r[i] while(adr[j]!=i) { //调整(*L).r[adr[j]]的记录到位直到adr[j]=i为止 k=adr[j]; (*L).r[j]=(*L).r[k]; adr[j]=j; j=k; //记录按序到位 } (*L).r[j]=(*L).r[0]; //将原来最初始的记录置于链表到达的最后一个点 adr[j]=j; } } } int main() { SLList l; int *adr; InitList(&amp;l); RadixSort(l); adr=new int[l.recnum]; Sort(l,adr); Rearrange(&amp;l,adr); cout&lt;&lt;&quot;排序后(重排记录):\\n&quot;; print(l); } 1.稳定排序 2.适用于顺序表和链表,一般采用静态链式 3.时间复杂度为O(d(n+rd))/O(n) 空间复杂度为O(n+rd) 4.但是它的使用有严格要求，必须知道各级关键字的主次关系和各级关键字的取值范围","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"归并排序","slug":"归并排序","date":"2020-05-17T11:52:57.097Z","updated":"2020-05-17T12:32:39.626Z","comments":true,"path":"2020/05/17/gui-bing-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/gui-bing-pai-xu/","excerpt":"","text":"归并排序将相邻的两个记录（序列）排序，并成一个有序序列，并继续上述操作 //算法8.11 归并排序 #include using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }RedType; typedef struct { RedType *r; int length; }SqList; void Create_Sq(SqList &L) { int i,n; cout","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"简单选择排序","slug":"简单选择排序","date":"2020-05-17T11:35:13.462Z","updated":"2020-05-17T11:52:49.562Z","comments":true,"path":"2020/05/17/jian-dan-xuan-ze-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/jian-dan-xuan-ze-pai-xu/","excerpt":"","text":"简单选择排序选择关键字储存最小的记录：和表中的记录进行一一对比，选出最小记录放在开头，接着从第二个记录继续开始 //算法8.6 简单选择排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void SelectSort(SqList &amp;L) { //对顺序表L做简单选择排序 int i,j,k; ElemType t; for(i=1;i&lt;L.length;++i) { //在L.r[i..L.length] 中选择关键字最小的记录 k=i; for(j=i+1;j&lt;=L.length;++j) if(L.r[j].key&lt;L.r[k].key) k=j; //k指向此趟排序中关键字最小的记录 if(k!=i) {t=L.r[i];L.r[i]=L.r[k];L.r[k]=t;} //交换r[i]与r[k] } //for } // SelectSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); SelectSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序，但如果是采用“交换记录”，则会导致不稳定现象 2.顺序，链式皆可以使用 3.时间复杂度O( n^2 ),比直接插入快。 空间复杂度为O(l1).","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"快速排序","slug":"快速排序","date":"2020-05-17T10:28:42.342Z","updated":"2020-05-17T11:35:10.593Z","comments":true,"path":"2020/05/17/kuai-su-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/kuai-su-pai-xu/","excerpt":"","text":"快速排序设置个关键字，将大的放在它后面，小的放在前面，分成两个子表，并且重复上述过程，直到每一个子表只有一个记录为止 //算法8.5 快速排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 int Partition(SqList &amp;L,int low,int high) { //对顺序表L中的子表r[low..high]进行一趟排序，返回枢轴位置 int pivotkey; L.r[0]=L.r[low]; //用子表的第一个记录做枢轴记录 pivotkey=L.r[low].key; //枢轴记录关键字保存在pivotkey中 while(low&lt;high) { //从表的两端交替地向中间扫描 while(low&lt;high&amp;&amp;L.r[high].key&gt;=pivotkey) --high; L.r[low]=L.r[high]; //将比枢轴记录小的记录移到低端 while(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey) ++low; L.r[high]=L.r[low]; //将比枢轴记录大的记录移到高端 }//while L.r[low]=L.r[0]; //枢轴记录到位 return low; //返回枢轴位置 }//Partition void QSort(SqList &amp;L,int low,int high) { //调用前置初值：low=1; high=L.length; //对顺序表L中的子序列L.r[low..high]做快速排序 int pivotloc; if(low&lt;high) { //长度大于1 pivotloc=Partition(L,low,high); //将L.r[low..high]一分为二，pivotloc是枢轴位置 QSort(L,low,pivotloc-1); //对左子表递归排序 QSort(L,pivotloc+1,high); //对右子表递归排序 } } //QSort void QuickSort(SqList &amp;L) { //对顺序表L做快速排序 QSort(L,1,L.length); } //QuickSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); QuickSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.不稳定排序 2.多用于顺序结构 3.时间复杂度O(log2 n)。 空间复杂度为O(log2 n), 最坏O(n). 最坏情况是逆序，或基本有序（顺序）","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-05-17T10:25:30.973Z","updated":"2020-05-17T10:28:31.636Z","comments":true,"path":"2020/05/17/mou-pao-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/mou-pao-pai-xu/","excerpt":"","text":"冒泡排序将关键字大的记录“下沉”,与小的记录进行交换 //算法8.4 冒泡排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void BubbleSort(SqList &amp;L) { //对顺序表L做冒泡排序 int m,j,flag; ElemType t; m=L.length-1; flag=1; //flag用来标记某一趟排序是否发生交换 while((m&gt;0)&amp;&amp;(flag==1)) { flag=0; //flag置为0，如果本趟排序没有发生交换，则不会执行下一趟排序 for(j=1;j&lt;=m;j++) if(L.r[j].key&gt;L.r[j+1].key) { flag=1; //flag置为1，表示本趟排序发生了交换 t=L.r[j];L.r[j]=L.r[j+1];L.r[j+1]=t; //交换前后两个记录 } //if --m; } //while } //BubbleSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); BubbleSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.顺序链式都适用 3.时间复杂度O(n^2)。 空间复杂度为O(1).","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"希尔排序","slug":"希尔排序","date":"2020-05-17T09:07:40.698Z","updated":"2020-05-17T10:07:52.937Z","comments":true,"path":"2020/05/17/xi-er-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/xi-er-pai-xu/","excerpt":"","text":"希尔排序通过分组进行大浮动跳跃性排序，并且分组的形式是以设定的增量为基准 //算法8.3 希尔排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void ShellInsert(SqList &amp;L,int dk) { //对顺序表L做一趟增量是dk的希尔插入排序 int i,j; for(i=dk+1;i&lt;=L.length;++i) if(L.r[i].key&lt;L.r[i-dk].key) { //需将L.r[i]插入有序增量子表 L.r[0]=L.r[i]; //暂存在L.r[0] for(j=i-dk;j&gt;0&amp;&amp; L.r[0].key&lt;L.r[j].key;j-=dk) L.r[j+dk]=L.r[j]; //记录后移，直到找到插入位置 L.r[j+dk]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //for } //ShellInsert void ShellSort(SqList &amp;L,int dt[ ],int t){ //按增量序列dt[0..t-1]对顺序表L作t趟希尔排序 int k; for(k=0;k&lt;t;++k) ShellInsert(L,dt[k]); //一趟增量为dt[t]的希尔插入排序 } //ShellSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); int i,t;//增量数组的长度 int *dt=new int[MAXSIZE];//增量数组 cout&lt;&lt;&quot;请输入增量个数：\\n&quot;; cin&gt;&gt;t; for(i=0;i&lt;t;i++) { cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;个增量:\\n&quot;; cin&gt;&gt;dt[i]; } ShellSort(L,dt,t); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.不稳定排序 2.仅适用于顺序表 3.时间复杂度取决于增量的决定，最少可以减少到n(log2 n)^2, n^3/2等。 空间复杂度为O(1),只需要一个r[0] 对于增量的选取很重要，希尔自带的增量设定为 {N/2, (N / 2)/2, …, 1} ，叫做希尔增量，常用但是效果并不拔群，其余的有 Hibbard：{1, 3, …, 2^k-1}，Sedgewick：{1, 5, 19, 41, 109…} 等","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"折半插入排序","slug":"折半插入排序","date":"2020-05-17T08:36:10.446Z","updated":"2020-05-17T10:07:34.883Z","comments":true,"path":"2020/05/17/zhe-ban-cha-ru-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/zhe-ban-cha-ru-pai-xu/","excerpt":"","text":"折半插入排序其实就是直接插入排序引入了折半的思想 //算法8.2 折半插入排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表 void BInsertSort(SqList &amp;L){ //对顺序表L做折半插入排序 int i,j,low,high,m; for(i=2;i&lt;=L.length;++i) { L.r[0]=L.r[i]; //将待插入的记录暂存到监视哨中 low=1; high=i-1; //置查找区间初值 while(low&lt;=high) { //在r[low..high]中折半查找插入的位置 m=(low+high)/2; //折半 if(L.r[0].key&lt;L.r[m].key) high=m-1; //插入点在前一子表 else low=m+1; //插入点在后一子表 }//while for(j=i-1;j&gt;=high+1;--j) L.r[j+1]=L.r[j]; //记录后移 L.r[high+1]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //for } //BInsertSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); BInsertSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.仅适用于顺序表 3.时间复杂度为O(n^2)，但是平均性能&gt;直接插入。 空间复杂度为O(1),只需要一个r[0]","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"直接插入排序","slug":"直接插入排序","date":"2020-05-17T08:26:32.728Z","updated":"2020-05-18T12:29:18.950Z","comments":true,"path":"2020/05/17/zhi-jie-cha-ru-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/zhi-jie-cha-ru-pai-xu/","excerpt":"","text":"直接插入排序这里采用的是从后向前的比较方式，（从前向后其实也可以） 有点像打牌，抽牌，然后选择地方放好 //算法8.1 直接插入排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 20 //顺序表的最大长度 typedef struct { int key; char *otherinfo; }ElemType; //顺序表的存储结构 typedef struct { ElemType *r; //存储空间的基地址 int length; //顺序表长度 }SqList; //顺序表类型 void InsertSort(SqList &amp;L) { //对顺序表L做直接插入排序 int i,j; for(i=2;i&lt;=L.length;++i) if(L.r[i].key&lt;L.r[i-1].key) { //&quot;&lt;&quot;，需将r[i]插入有序子表 L.r[0]=L.r[i]; //将待插入的记录暂存到监视哨中 L.r[i]=L.r[i-1]; //r[i-1]后移 for(j=i-2; L.r[0].key&lt;L.r[j].key;--j) //从后向前寻找插入位置 L.r[j+1]=L.r[j]; //记录逐个后移，直到找到插入位置 L.r[j+1]=L.r[0]; //将r[0]即原r[i]，插入到正确位置 } //if } //InsertSort void Create_Sq(SqList &amp;L) { int i,n; cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl; cin&gt;&gt;n; //输入个数 cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;; while(n&gt;MAXSIZE) { cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl; cin&gt;&gt;n; } for(i=1;i&lt;=n;i++) { cin&gt;&gt;L.r[i].key; L.length++; } } void show(SqList L) { int i; for(i=1;i&lt;=L.length;i++) cout&lt;&lt;L.r[i].key&lt;&lt;endl; } void main() { SqList L; L.r=new ElemType[MAXSIZE+1]; L.length=0; Create_Sq(L); InsertSort(L); cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl; show(L); }1.稳定排序 2.适用于顺序表和链表 3.时间复杂度为O(n^2) 空间复杂度为O(1),只需要一个r[0]","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"CSS浮动+常见的网页布局","slug":"CSS浮动+常见的网页布局","date":"2020-05-16T16:00:00.000Z","updated":"2020-06-09T16:55:10.348Z","comments":true,"path":"2020/05/17/css-fu-dong-chang-jian-de-wang-ye-bu-ju/","link":"","permalink":"https://taylor12138.github.io/2020/05/17/css-fu-dong-chang-jian-de-wang-ye-bu-ju/","excerpt":"","text":"浮动CSS三种传统布局：普通流 浮动 定位 标准流：标签按照默认排序 多个块级元素纵向排列用标准流，横向排列用浮动 选择器{ float: 属性值; //none不浮动 left向左浮动 right向右浮动 }//创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘 浮动特性：1.浮动元素会脱离标准流原来（排在浮动后面的）标准流的标签会顶上你原来的位置（但标准流之后的浮动挤不上去） （但是！！不会覆盖掉你的文字！，因为本身浮动是为环绕图片而设计的） 2.浮动元素会一行内显示并且元素顶部对齐紧贴在一起，不会有缝隙，装不开会另起一行 3.浮动元素具有行内块元素的特性添加浮动后自动附带行内块元素的特性 4.浮动自带文字环绕效果浮动的使用：一般采取先用标准流父元素排列上下位置，之后在子元素采取浮动，使得浮动在网页中间而不是左右侧 一般一个元素浮动了，他的兄弟标签最好也使用浮动 清除浮动布局1.父盒子不给高度，子盒子会自动撑开 2.父盒子不给高度的话，子盒子如果是浮动，父盒子会发生高度塌陷，导致高度变成0 所以总结：需要清除浮动！！！ clear: 属性值 一般属性值取both（常用）清楚两侧浮动，也有left，right 1.额外标签法，隔墙法，W3C推荐做法在浮动标签最后加多个一子标签（必须是块级元素），如： .clear{ clear: both; } &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;优点：通俗易懂，书写方便 缺点：结构化差 2.父级添加overflow//父级盒子 .box{ overflow: hidden; //或者auto } 优点：代码简洁 缺点：无法显示出溢出部分 3.：after伪元素法额外标签的升级版，给父元素添加 .clearfix:after { content: \"\"; display: block; //伪元素默认是行内元素，所以得转 height: 0; clear: both; visibility: hidden; } .clearfix { *zoom: 1; //兼容ie6，ie7 } //一般类名定义为clearfix 优点：结构简单 缺点：需要照顾低版本浏览器 代表网站：百度，淘宝，网易 4.双伪元素清除浮动.clearfix:before, .clearfix:after { content: &quot;&quot;; display: table; //转化为块级，并且一行显示 } .clear:after { clear: both; } .clearfix { *zoom: 1; //兼容ie6，ie7 }优缺点同上，代表网站：小米，腾讯 学成在线案例实际开发中导航栏不会直接用a标签，而是用li（列表）包含a标签的做法，1.语义更加清晰 2.故意对其关键字有被搜索引擎降权的风险 导航栏不给宽度是不想定死，让其自动适应","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"字典排序","slug":"字典排序","date":"2020-05-14T11:30:26.797Z","updated":"2020-05-17T12:34:15.125Z","comments":true,"path":"2020/05/14/zi-dian-pai-xu/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/zi-dian-pai-xu/","excerpt":"","text":"字典排序实现“ 1 2 3 ， 1 3 2 ， 2 1 3 ， 2 3 1 ， 3 1 2 ， 3 2 1 ”的序列排序方法 代码实现如下 #include #define swap(a,b) {int temp=a;a=b;b=temp;} //交换a，b值 void sort(int arr[],int start,int end)//冒泡排序，从start到end的排序，使用时注意是数组的下标，如数组下标0-3排序，sort（arr,0,3） { int i,j; for(i=0;iarr[a]) //这是字典排序第二步，获取arr[b]的值 { b=j1; break; } } swap(arr[a],arr[b]); //这是第三步 sort(arr,a+1,n-1); //这是第四步 } } int main() { int arr[]={1,2,4,3}; permutation(arr,4); return 0; } 总结得出字典排序算法四步法： 字典排序：第一步：从右至左找第一个左邻小于右邻的数，记下位置i，值list[a]第二部：从右边往左找第一个右边大于list[a]的第一个值，记下位置j，值list[b]第三步：交换list[a]和list[b]的值第四步：将i以后的元素重新按从小到大的顺序排列 举例：125643的下一个字典序列第一步：右边值大于左边的3&lt;4,4&lt;6,6&gt;5,则i=2，list[a]=5第二步：从右往左找出第一个右边大于list[a]=5的值，找到6&gt;5,j=3;list[b]=6;第三步：交换list[a]和list[b]的值，序列125643-&gt;126543第四步：将位置2以后的元素重新排序,126543-&gt;126345;结束： 126345即125643的下一个序列————————————————版权声明：本文为CSDN博主「Hi,Mr.Wang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_34672688/article/details/79557380","categories":[{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[],"author":"Hello"},{"title":"牛客算法课personnel note","slug":"牛客算法课personnel note","date":"2020-05-14T11:30:26.797Z","updated":"2020-05-21T13:49:02.538Z","comments":true,"path":"2020/05/14/niu-ke-suan-fa-ke-personnel-note/","link":"","permalink":"https://taylor12138.github.io/2020/05/14/niu-ke-suan-fa-ke-personnel-note/","excerpt":"","text":"小基础floor(x) 小于等于x的最大值整数（向下取整） ceil(x) 大于等于x的最小整数（向上取整）( #include&lt;math.h&gt; ) int 32位二进制 第一个是符号位正数为0，负数为1，后面是数值位 -2^31——2^31-1 long long 64位二进制 double 64位二进制 （float别用了，太垃圾了） ~ 取反 &gt;&gt;右移 &lt;&lt;左移 pow(a,b) a的b次方 一维前缀和拥有数组x和数组y，满足： y0=x0; y1=x0+x1; y2=x0+x1+x2; 即想要求某区间和，可用y数组来相减得到结果 枚举一一举例，不重复 先列举出（求第x数到第y数的和，先求数组所有和，直接减），（求四个点的位置，并且四个点组成正方形，先求四个点中的两个点，），（求一排树数量，部份树被整段移走（可能重叠），直接标记1，移走的树部分-1） 取尺法分L，R两个指针，求数组区域&lt;=s的连续数组的个数，&lt;s R右移， &gt;=s L右移 使用前提： 1.能够维护一个区间，保证这个区间能够获得答案。 2.维护的具体操作可以左边移动一位、右边移动一位。 3.区间的变化是连续的而不是跳跃的。问题1就是比较跳跃的，双指针比较好，问题2不能跳跃。 贪心算法局部最优解，然后发现局部最优=整体最优解 桶排序列出数组， 将数组分到有限数量的桶里，将数据对比，有则让数组对应的数据+1，每个桶再个别排序 ，然后依次输出 桶越多，时间效率就越高，而桶越多，空间就越大 这里有位大佬我觉得写得很好，外加动漫配图，可以看一下（简单桶排序） https://www.cnblogs.com/bqwzx/p/11029264.html 计数排序基数排序和计数排序都可以看做桶排序，计数排序的思路是开一个长度为 maxValue-minValue+1 的数组，进行分配+收集: 分配。扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1。 收集。扫描一遍计数器数组，按顺序把值收集起来。 计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序 ， 计数排序非常浪费空间 VECTORvector是一个不限制数组长度的数组 top()返回第一个元素 back()返回最后一个元素 erase（int index,int size）删除 vector a; 迭代器Iterator用于访问问一个容器内的数据的指针 vector:: iterator it; C++ STL的二分查找binary search 返回bool，是否存在 low_bound 返回可插入的最小位置的迭代器，即返回第一个符合条件的元素位置，low_bound(a,a+11,55), a[0]到a[10]找55，返回迭代器，可将结果 -a 得到它的下标 第一个&lt;=x的位置 upper_bound 返回可插入的最大位置的迭代器，即返回最后一个符合条件的元素位置 第一个&gt;x的位置","categories":[{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"}],"tags":[],"author":"Hello"},{"title":"C++string转换int，double","slug":"C++string转换int，double","date":"2020-05-13T09:10:17.923Z","updated":"2020-05-17T12:34:56.111Z","comments":true,"path":"2020/05/13/c-string-zhuan-huan-int-double/","link":"","permalink":"https://taylor12138.github.io/2020/05/13/c-string-zhuan-huan-int-double/","excerpt":"","text":"头文件#include &quot;iostream&quot; #include &quot;stdlib.h&quot; #include &quot;cstdlib&quot; #include &quot;string&quot;使用cstdlib中c_str()使其转换成char，再转int和float/double C 库函数 int atoi(const char *str) 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。 C 库函数 double atof(const char *str) 把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 double price=atof(new_str[2].c_str()); int count=atoi(new_str[3].c_str());;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"CSS样式","slug":"CSS样式","date":"2020-05-09T16:00:00.000Z","updated":"2020-08-06T09:23:04.809Z","comments":true,"path":"2020/05/10/css-yang-shi/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/css-yang-shi/","excerpt":"","text":"声明：可以使用chrome的F12浏览学习别人的样式并且调试你的代码引入CSS&lt;link rel=\"stylesheet\" href=\"css文件路径\"> 1.主要定义//是类型选择,标签选择器 元素（标签） { } //选择所有元素 * { } //类的选择 选择多个类可以 &lt;div class=\"类1 类2\">&lt;/div> .class(类名) { } //id的选择,有点类似class，只能调用一次，别人切勿使用 #(id名) { } //复合，后代选择器 元素1（可以是类名） 元素2（可以是类名） { } //只选择亲儿子，孙子不选 元素1（可以是类名）>元素2（可以是类名） { } //并集选择器，多个统一 元素1, 元素2{ } 文字font-size: 12px //12像素大小文字 谷歌默认16px font-size: 12px/1.5 //12像素大小文字 行高为12*1.5=18 font-weight: xxx //字体加粗 text-align: center //文字水平居中对齐 text-indent: 10px //文本首行缩进,最好使用em，如text-indent: 2em,em是相对单位，当前1个文字元素的大小 text-decoration: none//取消下划线 line-height: 26px //行间距，用QQ截图可以偷偷测量，等于盒子高度时垂直居中 背景background-color //背景颜色 background: rgba(red（数值）,green(数值),blue（数值），透明度（0-1）) //背景颜色 透明化 background-image: url(地址)//背景图片，常见于标志，logo或者超大背景图片，有点是便于控制位置 baackground-repeat: no-repeat//背景平铺，默认为平铺，可以改成取消平铺 background-position: x y//背景图片的位置 ，可以使用方位名词，前后顺序可可以不一样top，center ，botton，left等（只写一个另外一个默认居中）。也可以使用精确单位x轴长度，y轴长度，（只写一个另外一个默认居中） background-attachment: scroll||fixed//背景图像随对象内容滚动||背景图像固定 复合：background: 颜色 图片地址 平铺 图像滚动 图片位置 列表list-style: none//去掉无序列表里 li 列表前面的小圆点 阴影box-shadow: 10px 10px 5px #888888; 分别对应阴影的水平，垂直和阴影，颜色 2.伪类选择器//a超链接类 或者写成 a的类名:XXX{} a:link 选择所有未访问的链接 a:visited 选择所有已被访问的链接 a:hover 常用，选择鼠标指向的链接 a:ative 鼠标按下未弹起的链接 //如果全部都写，请按照LVHA的顺序写 //input类，把获得光标的inut选取出来改写CSS input:focus 3.行块转换（块元素和行元素相互转换）display:block //转块元素 display:inline //转行内元素 display: inline-block //转行内块 //使文字垂直居中 让文字行高=盒子的行高 行高&gt;盒子高度偏下，&lt;偏上 line-height: 盒子高度4.CSS的三大特性1.层叠性样式冲突选择就近原则，把前面的覆盖掉，不冲突的不覆盖 2.继承性子标签会继承父标签的属性 3.优先级1.选择器相同，执行层叠性 2.选择器不同，继承/*(0,0,0,0)&lt;元素(0,0,0,1)&lt;类(0,0,1,0)&lt;id(0,1,0,0)&lt;行内样式style(1,0,0,0)&lt;！important无限大 （属性选择器input[class^=icon]{} 是（0,0,1,0）） （！important加在某属性后面，如color: green!important） 继承的你加了！important，权值还是（0，0，0，0），毕竟是继承过来的 3.复合选择器有权重叠加的问题 ul li{}权重为(0,0,0,1)+(0,0,0,1) li为(0,0,0,1) .nav li为（0，0，1，1） 权重会叠加，但是永不进位，不是二进制 （a:hover为(0,0,1,1)） 5.CSS盒子border（会影响盒子大小）border-style: solid(实线边框，最常用) dashed(虚线) dotted（点线边框） border-width: XXpx border-color: XX 复写： border: 1px solid red 边框分开写法： border-top: 1px solid red border-collapse:collapse //相邻边框合并 border-top-right-radius: 15px; //右上方改圆角，无top，right则全部都改padding，内边距（会影响盒子大小，要设置了盒子宽高才会撑开）适用于文字大小不一的盒子，不设置宽高，直接设置padding，字少空间小。字多空间大 子容器盒子没设置宽高，父容器盒子padding不会被撑开 padding: 5px; padding: 0 10px; //分别对应上下和左右 padding-top: 5px; //仅写上方内边距margin，外边距，盒子和盒子之间的距离（不会撑开）使用方法和padding是一致的 margin可以让块级盒子水平居中：1盒子必须有宽度，盒子左右外边距设置为auto margin: 0 auto; 行内元素或者行内块元素居中只需在其父元素CSS样式中添加：text-align: center; 外边距合并问题1.外边距合并指的是，当两个垂直外边距（2个margin）相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。而左右外边距不合并。2.在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。3.注释：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 6.PSjpg： JPEG对色彩保留好，高清颜色多 gif：常用于小图片动画，可保留透明背景 png：结合jpg和gif，储存形式丰富，支持透明背景 PSD：保存PS设计稿 图层切图： 选定图层，右键，快速导出为png 切片切图： 切片工具—》选中—》左上角文件—》导出—》存储为Web所用格式—》JPEG（png可用于保存透明图）（保存的时候选”选中的切片“） ps插件切图：需要下载Cutterman插件 7.部署网站免费的远程服务器：http://free.3v.do/","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"emmet语法","slug":"emmet语法","date":"2020-05-09T16:00:00.000Z","updated":"2020-08-06T09:24:08.564Z","comments":true,"path":"2020/05/10/emmet-yu-fa/","link":"","permalink":"https://taylor12138.github.io/2020/05/10/emmet-yu-fa/","excerpt":"","text":"Emmet语法插件于市面上大多前端编译软件，如VScode所带有的，便于快速写html和CSSh5想要生成多个标签：div*10，再回车（或者tab），即可生成10个div标签。 生成父子关系标签：div&gt;span,再回车（或者tab），即可生成包含span标签的div标签。 生成兄弟关系标签：div+span,再回车（或者tab）。 输入：.nav 直接生成一个class=“nav”的div标签。(默认div) 输入：#nav 直接生成一个id=“nav”的div标签。 输入：p.nav 直接生成一个class=“nav”的p标签。 输入：.nav$*5 直接生成5个class=“nav1”,class=“nav2”…..的div标签。($是自增符号) 输入：div{前端真好玩}*5 直接生成5个&lt;div&gt; 前端真好玩 &lt;/div&gt; CSS样式内输入：tac 直接生成text-align: center; 其他语法缩写同样类似，诸如w100—&gt;width: 100 格式化直接鼠标右键，格式化文档，即可直接让文档变整齐。 （或者想要每次保存后自动格式化，需要在首页—首选项—设置—搜索emmet.include,在setting.json下的用户，添加 “editor.formatOnType”: true, “editor.formatOnSave”: true 即可）","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"循环队列","slug":"循环队列","date":"2020-05-09T11:51:20.811Z","updated":"2020-05-17T12:35:49.227Z","comments":true,"path":"2020/05/09/xun-huan-dui-lie/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/xun-huan-dui-lie/","excerpt":"","text":"循环队列顺序定义typedef struct { QElemType *base;//初始化时动态分配存储空间 int front;//头指针 int rear;//尾指针 } SqQueue; 初始化//算法3.11 循环队列的初始化 Status InitQueue(SqQueue &Q) {//构造一个空队列Q Q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间 if (!Q.base) exit(OVERFLOW); //存储分配失败 Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空 return OK; } 求队列长度//算法3.12 求循环队列的长度 int QueueLength(SqQueue Q) {//返回Q的元素个数，即队列的长度 return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE; } 入队和出队（防止假溢出）（出头front，入尾rear）（rear无元素，front有元素）//算法3.13 循环队列的入队 Status EnQueue(SqQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满 return ERROR; Q.base[Q.rear] = e; //新元素插入队尾 Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1 return OK; } //算法3.14 循环队列的出队 Status DeQueue(SqQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 if (Q.front == Q.rear) return ERROR; //队空 e = Q.base[Q.front]; //保存队头元素 Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1 return OK; } 链队定义（还是像极了单链表，可知X链的形式一般都是单链表拓展）typedef struct QNode { QElemType data; struct QNode *next; } QNode, *QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 } LinkQueue; 链队的初始化Status InitQueue(LinkQueue &Q) {//构造一个空队列Q Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点 Q.front->next = NULL; //头结点的指针域置空 return OK; } 入队和出队（队头front无元素）//算法3.17 链队的入队 Status EnQueue(LinkQueue &Q, QElemType e) {//插入元素e为Q的新的队尾元素 QueuePtr p; p = new QNode; //为入队元素分配结点空间，用指针p指向 p->data = e; //将新结点数据域置为e p->next = NULL; Q.rear->next = p; //将新结点插入到队尾 Q.rear = p; //修改队尾指针 return OK; } //算法3.18 链队的出队 Status DeQueue(LinkQueue &Q, QElemType &e) {//删除Q的队头元素，用e返回其值 QueuePtr p; if (Q.front == Q.rear) return ERROR; //若队列空，则返回ERROR p = Q.front->next; //p指向队头元素 e = p->data; //e保存队头元素的值 Q.front->next = p->next; //修改头指针 if (Q.rear == p) Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点 delete p; //释放原队头元素的空间 return OK; } 取队头元素//算法3.19 取链队的队头元素 SElemType GetHead(LinkQueue Q) {//返回Q的队头元素，不修改队头指针 if (Q.front != Q.rear) //队列非空 return Q.front->next->data; //返回队头元素的值，队头指针不变 }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"栈","slug":"栈","date":"2020-05-09T11:14:09.081Z","updated":"2020-05-17T12:35:55.947Z","comments":true,"path":"2020/05/09/zhan/","link":"","permalink":"https://taylor12138.github.io/2020/05/09/zhan/","excerpt":"","text":"顺序栈定义typedef struct { SElemType *base;//栈底指针 SElemType *top;//栈顶指针 int stacksize;//栈可用的最大容量 } SqStack; 初始化Status InitStack(SqStack &S) { //构造一个空栈S S.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间 if (!S.base) exit(OVERFLOW); //存储分配失败 S.top = S.base; //top初始为base，空栈 S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE return OK; } 入栈和出栈（top无元素）//算法3.2 顺序栈的入栈 Status Push(SqStack &S, SElemType e) { // 插入元素e为新的栈顶元素 if (S.top - S.base == S.stacksize) return ERROR; //栈满 *(S.top++) = e; //元素e压入栈顶，栈顶指针加1 return OK; } //算法3.3 顺序栈的出栈 Status Pop(SqStack &S, SElemType &e) { //删除S的栈顶元素，用e返回其值 if (S.base == S.top) return ERROR;//栈空 e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e return OK; } 链栈定义，有点像链表typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode, *LinkStack;初始化，无需链表的”头结点“Status InitStack(LinkStack &amp;S) { // 构造一个空栈 S，栈顶指针置空 S = NULL; return OK; }入栈和出栈//算法3.6 链栈的入栈 Status Push(LinkStack &S, SElemType e) {//在栈顶插入元素e LinkStack p; p = new StackNode; //生成新结点 p->data = e; //将新结点数据域置为e p->next = S; //将新结点插入栈顶 S = p; //修改栈顶指针为p return OK; } //算法3.7 链栈的出栈 Status Pop(LinkStack &S, SElemType &e) {//删除S的栈顶元素，用e返回其值 LinkStack p; if (S == NULL) return ERROR; //栈空 e = S->data; //将栈顶元素赋给e p = S; //用p临时保存栈顶元素空间，以备释放 S = S->next; //修改栈顶指针 delete p; //释放原栈顶元素的空间 return OK; }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"双向链表","slug":"双向链表","date":"2020-05-07T11:15:31.827Z","updated":"2020-05-17T12:35:32.455Z","comments":true,"path":"2020/05/07/shuang-xiang-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shuang-xiang-lian-biao/","excerpt":"","text":"双向链表的定义typedef struct DuLNode{ ElemType data; struct DuLNode *prior; struct DuLNode *next; //前驱和后继 }DuLNode，*DuLinkList 插入顺序 s=data; s->prior=p->prior; p->prior->next=s; s->next=p; p->prior=s;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"单链表","slug":"单链表","date":"2020-05-07T10:10:22.778Z","updated":"2020-05-17T12:35:13.050Z","comments":true,"path":"2020/05/07/dan-lian-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/dan-lian-biao/","excerpt":"","text":"如定义单链表结构体，注意引用单链表元素用” -&gt; “,因为是*LinkList，使用单链表用的是LinkListtypedef struct LNode { ElemType data; //结点的数据域 struct LNode *next; //结点的指针域 }LNode,*LinkList; //LinkList为指向结构体LNode的指针类型 前插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头 } }后插法创建单链表void CreateList_F(LinkList &amp;L,int n){ //算法2.10 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p,r; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 r=L; //尾指针r指向头结点 cout&lt;&lt;&quot;请输入 &quot;&lt;&lt;n&lt;&lt;&quot; 个数(以空格隔开，按回车结束)：&quot;; for(int i=n;i&gt;0;--i){ p=new LNode; //生成新结点 cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=NULL; r-&gt;next=p; r=p; } }单链表的初始化，它的头节点（为了处理方便，在第一个节点之前增加的结点）没有赋值Status InitList_L(LinkList &L){ //功能1---算法2.5 单链表的初始化 //构造一个空的单链表L L=new LNode; //生成新结点作为头结点，用头指针L指向头结点 L->next=NULL; //头结点的指针域置空 return OK; } 它不能像顺序表一样随机取值，所以需要一一查找ElemType FindList(LinkList &amp;L,int i,ElemType &amp;x){ LinkList p=L; for(int j=0;j&lt;i;j++){ if(!(p-&gt;next))return ERROR; p=p-&gt;next; } x=p-&gt;data; return OK; }查找，按值查找int GetElem(LinkList &L,int &i,ElemType e) { LinkList p=L; int j=1; while(p->next) { p=p->next; if(p->data==e){ //查找成功 i=j; return OK; } j++; } return ERROR; //循环至查找失败 } 单链表的插入Status ListInsert_L(LinkList &amp;L,int i,ElemType &amp;e){ //功能3---算法2.8 单链表的插入 //在带头结点的单链表L中第i个位置之前插入元素e int j; LinkList p,s; p=L;j=0; while(p &amp;&amp; j&lt;i-1){p=p-&gt;next;++j;} //寻找第i-1个结点 if(!p||j&gt;i-1) return ERROR; //i大于表长+1或者小于1 s=new LNode; //生成新结点s s-&gt;data=e; //将结点s的数据域置为e s-&gt;next=p-&gt;next; //将结点s插入L中 p-&gt;next=s; return OK; }删除指定序号数据元素Status ListDelete(LinkList &L,int i){ LinkList p=L; int j=1; while(p->next&&jnext; j++; } if(!(p->next)||j>i)return ERROR; LinkList q=p->next; p->next=q->next; delete q; return OK; }","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"顺序表","slug":"顺序表","date":"2020-05-07T09:31:08.736Z","updated":"2020-05-17T12:37:04.901Z","comments":true,"path":"2020/05/07/shun-xu-biao/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/shun-xu-biao/","excerpt":"","text":"如定义s顺序表结构体，注意引用顺序表元素用” . “,因为是SqList不是*S’q’Listtypedef struct{ ElemType *elem; //存储空间的基地址 int length; //当前长度 }SqList; 顺序表的初始化Status InitList_Sq(SqList &L){ //功能1--算法2.1 顺序表的初始化 //构造一个空的顺序表L L.elem=new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) return OVERFLOW; //存储分配失败，overflow为-2 L.length=0; //空表长度为0 return OK; } 查找Status LocateElem(SqList *L, ElemType e) //按元素值查找 { int i=0; while (ilength && L->elem[i]!=e) i++; //查找元素e if (i>=L->length) //未找到时返回0 return 0; else return i+1; //找到后返回其逻辑序号 顺序表的插入Status ListInsert_Sq(SqList &amp;L,int i,ElemType e){ //功能3--算法2.3 顺序表的插入 //在顺序表L中第i个位置之前插入新的元素e //i值的合法范围是1&lt;=i&lt;=L.length+1 if(i&lt;1 || i&gt;L.length+1) return ERROR; //i值不合法,error为0 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length; //表长增1 return OK; }删除数据元素bool ListDelete(SqList &L,int i) //删除数据元素 { int j; if (iL.length) //参数错误时返回false return false; for (j=i-1;j","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"C++结构体初始化","slug":"C++结构体初始化","date":"2020-05-07T09:16:02.980Z","updated":"2020-05-17T12:35:02.720Z","comments":true,"path":"2020/05/07/c-jie-gou-ti-chu-shi-hua/","link":"","permalink":"https://taylor12138.github.io/2020/05/07/c-jie-gou-ti-chu-shi-hua/","excerpt":"","text":"如定义药品结构体 typedef struct node{ //定义结构体 string name; float price; int count; float sale; int next; }Medicine; typedef struct{ //定义顺序表 Medicine r[MAX_Size+1]; int length; }SqList; 使用new的初始化 SqList *list_med=new SqList;","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"C++求string数组元素个数","slug":"C++求String数组的元素个数","date":"2020-05-06T11:04:31.177Z","updated":"2020-07-27T13:28:02.604Z","comments":true,"path":"2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","link":"","permalink":"https://taylor12138.github.io/2020/05/06/c-qiu-string-shu-zu-de-yuan-su-ge-shu/","excerpt":"","text":"不能使用str.length(),这个求的是单个字符串的大小，可以使用以下求得到长度 sizeof(str)/sizeof(str[0]) int[] a={1,2,3,4,5}; 数组长度为 a.length","categories":[{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[],"author":"Hello"},{"title":"finished gitee","slug":"finished gitee","date":"2020-05-04T17:01:10.659Z","updated":"2020-07-06T16:11:42.941Z","comments":true,"path":"2020/05/05/finished-gitee/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/finished-gitee/","excerpt":"","text":"原来是个人邮箱的设置必须得是公开的，我一直是设置为private，搞得一直错，终于搞出来了。 但是发现了gitee的一个缺点，每次部署完后都要去码云更新一次。。。","categories":[],"tags":[],"author":"Hello"},{"title":"HTML5的基本属性","slug":"HTML5的基本属性","date":"2020-05-04T16:25:58.368Z","updated":"2020-07-11T12:43:09.676Z","comments":true,"path":"2020/05/05/html5-de-ji-ben-shu-xing/","link":"","permalink":"https://taylor12138.github.io/2020/05/05/html5-de-ji-ben-shu-xing/","excerpt":"","text":"1.基本标签介绍&lt;html&gt;&lt;/html&gt;``根标签 &lt;head&gt; &lt;/head&gt; 文档头部 &lt; title&gt; &lt;/title&gt; 文档标题 &lt;body&gt;&lt;/body&gt; 文档主体 2.在vscode里使用英文“！”可以直接生成基本结构ctrl+“+”可以放大（写代码）页面 &lt;!DOCTYPE html&gt; （） &lt;html lang=&quot;zh-CN&quot;&gt; (中文) &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;h1&gt;&lt;/h1&gt;---&lt;h6&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; &lt;br /&gt;&lt;strong&gt;&lt;/strong&gt;(字体加粗)&lt;del&gt;&lt;/del&gt;（字体删除线） &lt;em&gt;&lt;/em&gt; 标签告诉浏览器把其中的文本表示为强调的内容 3.盒子：类似于view，用于布局&lt;div&gt;&lt;/div&gt; //大盒子，独占一整行 &lt;span&gt;&lt;/span&gt; //小盒子 4.img&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; height=&quot;&quot; width=&quot;&quot;&gt; //微信小程序是image alt为图片无法加载时显示的文字，title为鼠标移到图片上显示的文字提示, 但是对于height和width,一般只修改其中一个，另外一个就会跟着改变 src种绝对路径 \\ 相对路径 / （图片设置宽高一般设置为width：100%，heigh：100%，可以自动适应盒子） 5.超链接&lt; a&gt;&lt;a href=&quot;&quot; target=&quot;&quot; &gt;文本或者图像&lt;/a&gt; 类似于微信小程序中的navigator, href用于指定目标的url，可打开内部，外部链接 target用于来链接打开方式，默认_self _blank为在新窗口打开 锚点链接：设置href=#名字，如&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;可以快速跳转到第二集的页面位置 ​ 在于目标位置标签里添加id=”two” &lt;a href=&quot;&quot; title=&quot;&quot;&gt;移动到链接时会出现提示框 一般情况下，a如果包含有宽度的盒子，a需要转换为块级元素 6.特殊字符空格：&amp;nbsp (因无法识别大于号和小于号) 小于号：&amp;lt 大于号：&amp;gt 7.表格（用于数据）&lt;table&gt; ​ &lt;tr&gt; ​ &lt;td&gt;单元格文字&lt;/td&gt;或者&lt;th&gt;&lt;/th&gt; ​ &lt;/tr&gt; &lt;/table&gt; table是表格，tr是行，td是单元格（th可充当表头单元格）。还可以加入&lt;thead&gt;和 &lt;tbody&gt;来帮助CSS区分表格结构 单元格合并使用colspan=”（列）想要合并的单元个数”或者rowspan=”（行）想要合并的单元个数”，再删除多余的td（或th） 8.列表（用于布局）无序列表（ul里只能放li标签，所以其他容器放li里面就可以）&lt;ul&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ul&gt; 有序列表(规则同无序)&lt;ol&gt; ​ &lt;li&gt;列表项1&lt;/li&gt; ​ &lt;li&gt;列表项2&lt;/li&gt; &lt;/ol&gt; 自定义列表(同上)&lt;dl&gt; ​ &lt;dt&gt;名词1&lt;/dt&gt; ​ &lt;dd&gt;名词1解释1&lt;/dd ​ &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 9.表单（用于填写信息，用户注册）&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot; maxlength=&quot;&quot;&gt;&lt;/form&gt;表单域 url地址为处理表单数据的地址，method有get，post 表单元素&lt;input&gt;&lt;input type=&quot;属性值&quot; name=&quot;&quot; value=&quot;&quot; check=&quot;&quot;&gt;输入 type可以为text，password，button，reset（重置）submit（用于提交），radio（单选框，必须添加name才能使用），checkbox（复选框）等 科普：submit是button的一个特例，用于处理大量表单数据 value为输入框内的提示语||充当提交给后台的数据||显示的文字 check用于单选和复选的默认值 check=”checked” maxlength=“最大值” &lt;label for=&quot;sex&quot;&gt;男 &lt;/label&gt; label用于增加用户体验，点击范围内即可选中某input &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; label中的for对应input里的id 或者把input标签放在label里面也能达到同样的效果，此时不需要for和id 表单元素&lt;select&gt; 下拉列表&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;选项3&lt;/option&gt; //默认选中选项3 ... &lt;select&gt;表单元素&lt;textarea&gt; 文本域，可以写大量文字（个人介绍，评论）&lt;textarea> 文字 &lt;/textarea> //如果没文字textarea必须写到同一行 10 元素分类块元素，独占一行，是一个容器或者盒子如 &lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt;等 但&lt;p&gt; &lt;h&gt; 不能内置块级元素，只能放文字行元素，不能设置宽高，只能容纳文本或者其他行内元素 &lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;span&gt;等 但是&lt;a&gt;不能再放&lt;a&gt; 特殊情况&lt;a&gt;可以转块级行内块元素，能在同一行，也能设置宽高，但是行内块之间有缝隙 &lt;input/&gt; &lt;img/&gt; &lt;td&gt;行块的转换详情请看CSS里的《行块转换》h5标签推荐网址： http://www.w3school.com.cn/ http://developer.mozilla.org/zh-CN/ 11.HTML5新特性i9以上版本浏览器才支持 &lt;header&gt;: 头部标签 &lt;nav&gt;: 导航标签 &lt;article&gt;: 内容标签 &lt;section&gt;: 定义文档某个区域 &lt;aside&gt;: 侧边栏标签 &lt;footer&gt;: 尾部标签 /*实质上都和div差不多，只是语义化了而已，主要针对搜索引擎*/ /*但是在i9中，需要把这些元素转换成块级元素，所以移动端更喜欢使用这些标签*/ 新增：&lt;audio&gt;音频，&lt;video&gt;视频，抛弃flash等插件功能video尽量使用mp4格式，谷歌把音频，视频自动播放禁止了 &lt;video src=&quot;文件地址&quot; autoplay=&quot;autoplay&quot;自动播放 谷歌需要添加muted=&quot;muted&quot;（静音播放） controls=&quot;controls&quot;添加播放组件 loop=&quot;loop&quot;循环播放 poster=&quot;图片地址&quot; 视频封面显示图片 &gt;&lt;/video&gt; 遇到不兼容的情况可以写成 &lt;video width=&quot;320&quot; height=&quot;240&quot;&gt; &lt;source src=&quot;&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;&quot; type=&quot;video/ogg&quot;&gt; &lt;/video&gt;兼容问题同上 &lt;audio src=&quot;文件地址&quot;&gt;&lt;/audio&gt; 其功能性同video，如autoplay，loop，controls新增input的类型type=&quot;email&quot; type=&quot;url&quot; type=&quot;date&quot; type=&quot;number&quot; type=&quot;search&quot; type=&quot;tel&quot;(手机号码) 限制用户只能使用&quot;X&quot;类型 /*表单属性*/ &lt;input type=&quot;search&quot; required=&quot;required&quot; 填写字段不能为空 placeholder=&quot;XX&quot; 表单的提示信息 autofocus=&quot;autofocus&quot; 页面完成时自动聚焦到指定表单 autocomplete=&quot;on&quot; 打开历史记录功能，需要加上name属性，放在表单内，成功提交过，可以可选择&quot;off&quot; mutiple=&quot;multiple&quot; 选择多个文件上传 &gt;12.网站的缩略图标一般使用favicon.ico作为图标，主要的浏览器都支持。 通过第三方网站将png图片转化成ico图标，如http://www.bitbug.net/ 转化成功后，在&lt;head&gt; &lt;/head&gt;之间引入代码： &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico type=&quot;XX&quot;&gt;(网页那里有代码直接copy) 在某网页的页面，在它的网址后输入”/favicon.ico” 可以直接获取它的ico 13.网站TDK三大标签优化SEOSEO是搜索引擎优化，目的为对网站深度优化，使得网站排名位于搜索引擎使用后较前的位置。 1.title网站名-网站介绍（不超过30字） 2.description简要概述网站内容 3.keywords页面关键字，搜索引擎的关注点 logo的SEO优化logo里首先放一个h1标签来提权，h1里再放一个链接，用于返回至首页，为了让搜索引擎收录我们，我们要在链接里放文字（网站名称），但是文字不要显示出来（文字大小设置为0，font-size: 0），最后给链接一个title属性","categories":[{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"Hello"},{"title":"主题与2d人物","slug":"主题与2d人物","date":"2020-05-03T16:50:47.307Z","updated":"2020-05-05T17:03:19.452Z","comments":true,"path":"2020/05/04/zhu-ti-yu-2d-ren-wu/","link":"","permalink":"https://taylor12138.github.io/2020/05/04/zhu-ti-yu-2d-ren-wu/","excerpt":"","text":"Start人物使用命令安装npm：npm uninstall hexo-helper-live2d npm install –save hexo-helper-live2d此时在blog/node_modeles下多出了一个“live2d-widget”下载动画model：这里是套用别人（大佬）的仓库https://github.com/xiazeyu/live2d-widget-models.git下载好后将packages里的所有文件拷贝到blog/node_modeles最后在win使用padnote _config.yml，把以下：live2d: enable: true pluginModelPath: assets/ model: use: live2d-widget-model-epsilon2_1 #模板目录，在node_modules里 display: position: right width: 150 height: 300 mobile: show: false #是否在手机进行显示 复制进去 再使用hexo clean g d进行部署 主题下载好了之后放入blog/themes里面（整个文件）再在win使用padnote _config.yml把theme: xx改成theme: (你要的主题名)最后部署","categories":[],"tags":[],"author":"Hello"},{"title":"My First Blog","slug":"My First Blog","date":"2020-05-02T17:33:53.947Z","updated":"2020-05-05T17:02:29.455Z","comments":true,"path":"2020/05/03/my-first-blog/","link":"","permalink":"https://taylor12138.github.io/2020/05/03/my-first-blog/","excerpt":"","text":"Quick Start打开win+R进入cmd，然后在正确目录下进入：cd source_post(指定blog下) 基本操作用typora修改完毕后，1.使用“hexo clean”进行清理（1.5.若是发生主题等修改后，要接上hexo g 来建立）2.接上“hexo s”即可进入网站查看（退出键位：control+C，y）（本地浏览）3.再次部署到远端：hexo d 关于主题1.可以使用git clone 网址.git themes\\新建目录名（或者使用码云gitee进行下载，然后复制到themes目录下）2.cd.. (回到blog目录下)notepad _config.yml把记事本里面的theme：xx修改成theme：主题目录名3.重新执行”基本操作” 参考文献 https://hexo.io/docs/one-command-deployment.html)","categories":[],"tags":[],"author":"Hello"}],"categories":[{"name":"matlab","slug":"matlab","permalink":"https://taylor12138.github.io/categories/matlab/"},{"name":"前端","slug":"前端","permalink":"https://taylor12138.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"排序","slug":"排序","permalink":"https://taylor12138.github.io/categories/%E6%8E%92%E5%BA%8F/"},{"name":"personnel","slug":"personnel","permalink":"https://taylor12138.github.io/categories/personnel/"},{"name":"C++","slug":"C","permalink":"https://taylor12138.github.io/categories/C/"}],"tags":[]}